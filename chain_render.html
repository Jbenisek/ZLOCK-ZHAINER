<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zcash Chain Render - 0,90,0 Pattern</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            color: #fff;
            overflow: hidden;
        }
        
        #canvas {
            display: block;
            width: 100%;
            height: 100vh;
        }
        
        #controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 8px;
            border: 2px solid #2A9D8F;
            z-index: 100;
        }
        
        #controls h2 {
            margin-bottom: 15px;
            color: #2A9D8F;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #aaa;
        }
        
        button {
            background: linear-gradient(135deg, #2A9D8F, #1B7A6E);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px 5px 5px 0;
            transition: all 0.3s ease;
        }
        
        button:hover {
            background: linear-gradient(135deg, #34B3A3, #2A9D8F);
            transform: translateY(-2px);
        }
        
        input[type="range"] {
            width: 200px;
        }
        
        input[type="number"] {
            width: 80px;
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 5px;
            border-radius: 4px;
        }
        
        .info {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #555;
            font-size: 12px;
            color: #888;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div id="controls">
        <h2>Chain Render Controls</h2>
        
        <div class="control-group">
            <label>Chain Length: <span id="lengthValue">4</span></label>
            <input type="range" id="chainLength" min="1" max="10" value="4">
        </div>
        
        <div class="control-group">
            <label>Link Spacing: <span id="spacingValue">1.0</span></label>
            <input type="range" id="linkSpacing" min="0.5" max="2.0" step="0.1" value="1.0">
        </div>
        
        <div class="control-group">
            <label>Camera Distance: <span id="distanceValue">15</span></label>
            <input type="range" id="cameraDistance" min="5" max="50" value="15">
        </div>
        
        <div class="control-group">
            <label>Background Color:</label>
            <button onclick="setBackground('#000000')">Black</button>
            <button onclick="setBackground('#1a1a1a')">Dark Gray</button>
            <button onclick="setBackground('#ffffff')">White</button>
        </div>
        
        <div class="control-group">
            <label>View Mode:</label>
            <button onclick="setViewMode('chain')">Chain View</button>
            <button onclick="setViewMode('spritesheet')">Sprite Sheet (6x6)</button>
        </div>
        
        <div class="control-group" id="chainTypeControls">
            <label>Chain Type:</label>
            <button onclick="setChainType('A')">Type A (Red)</button>
            <button onclick="setChainType('B')">Type B (Green)</button>
            <button onclick="setChainType('C')">Type C (Blue)</button>
            <button onclick="setChainType('D')">Type D (Yellow)</button>
            <button onclick="setChainType('MULTI')">Multi-Color</button>
        </div>
        
        <div class="control-group">
            <button onclick="toggleGrid()">Toggle Grid</button>
            <button onclick="resetCamera()">Reset Camera</button>
            <button onclick="downloadScreenshot()">Save Screenshot</button>
        </div>
        
        <div class="info">
            <strong>Pattern:</strong> 0°, 90°, 0°, 90°...<br>
            <strong>Controls:</strong><br>
            • Left click + drag to rotate<br>
            • Right click + drag to pan<br>
            • Scroll to zoom
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    
    <script>
        // Link types matching your game
        const LinkType = {
            ZEC_A: { color: 0xff0000, emissive: 0x660000, name: 'ZEC_A' },
            ZEC_B: { color: 0x00ff00, emissive: 0x006600, name: 'ZEC_B' },
            ZEC_C: { color: 0x0000ff, emissive: 0x000066, name: 'ZEC_C' },
            ZEC_D: { color: 0xffff00, emissive: 0x666600, name: 'ZEC_D' }
        };
        
        // Scene setup
        let scene, camera, renderer, controls;
        let chainLinkModel = null;
        let chainMeshes = [];
        let currentChainType = 'MULTI';
        let chainLength = 4;
        let linkSpacing = 1.0;
        let gridHelper = null;
        let viewMode = 'chain'; // 'chain' or 'spritesheet'
        let spriteSheetMeshes = [];
        
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(15, 10, 15);
            camera.lookAt(0, 0, 0);
            
            // Create renderer
            const canvas = document.getElementById('canvas');
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas, 
                antialias: true,
                preserveDrawingBuffer: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const keyLight = new THREE.DirectionalLight(0xffffff, 0.8);
            keyLight.position.set(5, 10, 7.5);
            keyLight.castShadow = true;
            scene.add(keyLight);
            
            const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
            fillLight.position.set(-5, 0, -5);
            scene.add(fillLight);
            
            // Add orbit controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            // Load chain link model
            const loader = new THREE.GLTFLoader();
            loader.load('models/Zcash_Chain_Link_A.glb', (gltf) => {
                chainLinkModel = gltf.scene;
                console.log('Chain link model loaded');
                createChain();
            }, undefined, (error) => {
                console.error('Error loading model:', error);
            });
            
            // Add grid helper
            gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
            scene.add(gridHelper);
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Setup control listeners
            setupControls();
            
            // Start animation
            animate();
        }
        
        function createLinkMesh(linkType) {
            if (!chainLinkModel) return null;
            
            const mesh = chainLinkModel.clone();
            mesh.traverse((child) => {
                if (child.isMesh) {
                    child.material = child.material.clone();
                    child.material.emissive.setHex(linkType.emissive);
                    child.material.emissiveIntensity = 0.6;
                    child.material.shininess = 60;
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });
            return mesh;
        }
        
        function createChain() {
            if (!chainLinkModel) return;
            
            // Clear existing chain
            chainMeshes.forEach(mesh => scene.remove(mesh));
            chainMeshes = [];
            
            // Create new chain with 0,90,0,90 pattern
            const baseTypes = [LinkType.ZEC_A, LinkType.ZEC_B, LinkType.ZEC_C, LinkType.ZEC_D];
            
            for (let i = 0; i < chainLength; i++) {
                let linkType;
                
                if (currentChainType === 'MULTI') {
                    linkType = baseTypes[Math.floor(Math.random() * baseTypes.length)];
                } else {
                    linkType = LinkType['ZEC_' + currentChainType];
                }
                
                const mesh = createLinkMesh(linkType);
                if (!mesh) continue;
                
                // Position vertically with spacing
                mesh.position.y = i * linkSpacing;
                
                // Rotate: 0° for even indices, 90° for odd indices
                mesh.rotation.y = (i % 2 === 1) ? Math.PI / 2 : 0;
                
                scene.add(mesh);
                chainMeshes.push(mesh);
            }
            
            // Center the chain
            const totalHeight = (chainLength - 1) * linkSpacing;
            chainMeshes.forEach(mesh => {
                mesh.position.y -= totalHeight / 2;
            });
        }
        
        function createSpriteSheet() {
            if (!chainLinkModel) return;
            
            // Clear existing meshes
            chainMeshes.forEach(mesh => scene.remove(mesh));
            chainMeshes = [];
            spriteSheetMeshes.forEach(mesh => scene.remove(mesh));
            spriteSheetMeshes = [];
            
            // Define all link types including special ones
            const linkTypes = [
                { type: LinkType.ZEC_A, name: 'A-0°' },
                { type: LinkType.ZEC_A, name: 'A-90°', rotation: Math.PI / 2 },
                { type: LinkType.ZEC_B, name: 'B-0°' },
                { type: LinkType.ZEC_B, name: 'B-90°', rotation: Math.PI / 2 },
                { type: LinkType.ZEC_C, name: 'C-0°' },
                { type: LinkType.ZEC_C, name: 'C-90°', rotation: Math.PI / 2 },
                { type: LinkType.ZEC_D, name: 'D-0°' },
                { type: LinkType.ZEC_D, name: 'D-90°', rotation: Math.PI / 2 },
                // Add more rows for variety
                { type: LinkType.ZEC_A, name: 'A-0°' },
                { type: LinkType.ZEC_A, name: 'A-90°', rotation: Math.PI / 2 },
                { type: LinkType.ZEC_B, name: 'B-0°' },
                { type: LinkType.ZEC_B, name: 'B-90°', rotation: Math.PI / 2 },
                { type: LinkType.ZEC_C, name: 'C-0°' },
                { type: LinkType.ZEC_C, name: 'C-90°', rotation: Math.PI / 2 },
                { type: LinkType.ZEC_D, name: 'D-0°' },
                { type: LinkType.ZEC_D, name: 'D-90°', rotation: Math.PI / 2 },
                { type: LinkType.ZEC_A, name: 'A-0°' },
                { type: LinkType.ZEC_A, name: 'A-90°', rotation: Math.PI / 2 },
                { type: LinkType.ZEC_B, name: 'B-0°' },
                { type: LinkType.ZEC_B, name: 'B-90°', rotation: Math.PI / 2 },
                { type: LinkType.ZEC_C, name: 'C-0°' },
                { type: LinkType.ZEC_C, name: 'C-90°', rotation: Math.PI / 2 },
                { type: LinkType.ZEC_D, name: 'D-0°' },
                { type: LinkType.ZEC_D, name: 'D-90°', rotation: Math.PI / 2 },
                { type: LinkType.ZEC_A, name: 'A-0°' },
                { type: LinkType.ZEC_A, name: 'A-90°', rotation: Math.PI / 2 },
                { type: LinkType.ZEC_B, name: 'B-0°' },
                { type: LinkType.ZEC_B, name: 'B-90°', rotation: Math.PI / 2 },
                { type: LinkType.ZEC_C, name: 'C-0°' },
                { type: LinkType.ZEC_C, name: 'C-90°', rotation: Math.PI / 2 },
                { type: LinkType.ZEC_D, name: 'D-0°' },
                { type: LinkType.ZEC_D, name: 'D-90°', rotation: Math.PI / 2 },
                { type: LinkType.ZEC_A, name: 'A-0°' },
                { type: LinkType.ZEC_A, name: 'A-90°', rotation: Math.PI / 2 },
                { type: LinkType.ZEC_B, name: 'B-0°' },
                { type: LinkType.ZEC_B, name: 'B-90°', rotation: Math.PI / 2 }
            ];
            
            const gridSize = 6;
            const spacing = 3;
            const totalWidth = (gridSize - 1) * spacing;
            const offset = totalWidth / 2;
            
            let index = 0;
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    if (index >= linkTypes.length) break;
                    
                    const config = linkTypes[index];
                    const mesh = createLinkMesh(config.type);
                    if (!mesh) continue;
                    
                    // Position in grid
                    mesh.position.x = col * spacing - offset;
                    mesh.position.y = 0;
                    mesh.position.z = row * spacing - offset;
                    
                    // Rotate to face up (90 degrees on X axis)
                    mesh.rotation.x = Math.PI / 2;
                    
                    // Apply Y rotation (0 or 90 degrees)
                    if (config.rotation !== undefined) {
                        mesh.rotation.y = config.rotation;
                    }
                    
                    scene.add(mesh);
                    spriteSheetMeshes.push(mesh);
                    index++;
                }
            }
            
            // Position camera looking down at sprite sheet
            camera.position.set(0, -25, 0);
            camera.lookAt(0, 0, 0);
            controls.target.set(0, 0, 0);
            controls.update();
        }
        
        function setViewMode(mode) {
            viewMode = mode;
            
            if (mode === 'chain') {
                // Show chain controls, hide sprite sheet
                document.getElementById('chainTypeControls').style.display = 'block';
                document.querySelectorAll('.control-group')[0].style.display = 'block';
                document.querySelectorAll('.control-group')[1].style.display = 'block';
                createChain();
                resetCamera();
            } else if (mode === 'spritesheet') {
                // Hide chain-specific controls
                document.getElementById('chainTypeControls').style.display = 'none';
                document.querySelectorAll('.control-group')[0].style.display = 'none';
                document.querySelectorAll('.control-group')[1].style.display = 'none';
                createSpriteSheet();
            }
        }
        
        function setupControls() {
            const lengthSlider = document.getElementById('chainLength');
            const lengthValue = document.getElementById('lengthValue');
            lengthSlider.addEventListener('input', (e) => {
                chainLength = parseInt(e.target.value);
                lengthValue.textContent = chainLength;
                createChain();
            });
            
            const spacingSlider = document.getElementById('linkSpacing');
            const spacingValue = document.getElementById('spacingValue');
            spacingSlider.addEventListener('input', (e) => {
                linkSpacing = parseFloat(e.target.value);
                spacingValue.textContent = linkSpacing.toFixed(1);
                createChain();
            });
            
            const distanceSlider = document.getElementById('cameraDistance');
            const distanceValue = document.getElementById('distanceValue');
            distanceSlider.addEventListener('input', (e) => {
                const distance = parseInt(e.target.value);
                distanceValue.textContent = distance;
                const angle = camera.position.clone().normalize();
                camera.position.copy(angle.multiplyScalar(distance));
            });
        }
        
        function setBackground(color) {
            scene.background = new THREE.Color(color);
        }
        
        function setChainType(type) {
            currentChainType = type;
            createChain();
        }
        
        function toggleGrid() {
            if (gridHelper) {
                gridHelper.visible = !gridHelper.visible;
            }
        }
        
        function resetCamera() {
            camera.position.set(15, 10, 15);
            camera.lookAt(0, 0, 0);
            controls.reset();
        }
        
        function downloadScreenshot() {
            renderer.render(scene, camera);
            const dataURL = renderer.domElement.toDataURL('image/png');
            const link = document.createElement('a');
            const filename = viewMode === 'spritesheet' 
                ? 'zcash_spritesheet_6x6.png'
                : `zcash_chain_${currentChainType}_${chainLength}links.png`;
            link.download = filename;
            link.href = dataURL;
            link.click();
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        // Initialize
        init();
    </script>
</body>
</html>
