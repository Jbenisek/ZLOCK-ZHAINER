<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ZLOCK ZHAINER - 3D Blockchain Puzzle v0.20.22</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet" media="print" onload="this.media='all'; this.onload=null;">
    <style>
        /* Fallback fonts in case Google Fonts don't load */
        @font-face {
            font-family: 'Inter';
            src: local('Arial'), local('Helvetica');
            font-display: swap;
        }
        @font-face {
            font-family: 'JetBrains Mono';
            src: local('Courier New'), local('monospace');
            font-display: swap;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background: #0A0E12;
            color: #E9F0F7;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            cursor: default;
        }
        
        body.targeting {
            cursor: crosshair;
        }
        
        #gameContainer {
            position: relative;
            width: 100%;
            height: 100%;
        }
        
        #renderCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        /* HUD Overlay */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        #titleScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 14, 18, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            pointer-events: all;
        }
        
        #title {
            font-size: 96px;
            font-weight: 900;
            color: #F2C94C;
            text-shadow: 0 0 40px rgba(242, 201, 76, 0.6);
            margin-bottom: 20px;
            letter-spacing: 8px;
        }
        
        #subtitle {
            font-size: 36px;
            font-weight: 600;
            color: #FFD85A;
            margin-bottom: 60px;
            letter-spacing: 4px;
        }
        
        .button {
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            color: #E9F0F7;
            border: 2px solid #2A9D8F;
            border-radius: 8px;
            padding: 14px 40px;
            font-size: 18px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
            margin: 8px;
            pointer-events: all;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            min-width: 280px;
        }
        
        .button:hover {
            background: linear-gradient(135deg, rgba(20, 27, 34, 0.95), rgba(42, 157, 143, 0.2));
            box-shadow: 0 6px 25px rgba(42, 157, 143, 0.4);
            transform: translateY(-2px);
            border-color: #4ECDC4;
        }
        
        .button:active {
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.98), rgba(15, 19, 24, 0.95));
            transform: translateY(0px);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }
        
        .skipButton {
            position: absolute;
            left: 60px;
            top: 50.5%;
            transform: translateY(-50%);
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            color: #E9F0F7;
            border: 2px solid #2D9CDB;
            border-radius: 8px;
            padding: 12px 24px;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
            pointer-events: all;
            width: 220px;
            text-align: center;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
        }
        
        .skipButton:hover {
            background: linear-gradient(135deg, rgba(20, 27, 34, 0.95), rgba(45, 156, 219, 0.2));
            box-shadow: 0 6px 20px rgba(45, 156, 219, 0.4);
            transform: translateY(-50%) scale(1.02);
            border-color: #4ECDC4;
        }
        
        .skipButton:active {
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.98), rgba(15, 19, 24, 0.95));
            transform: translateY(-50%) scale(0.98);
        }
        
        .preFillButton {
            position: absolute;
            left: 60px;
            top: calc(10% - 0px);
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            color: #E9F0F7;
            border: 2px solid #8B5CF6;
            border-radius: 8px;
            padding: 12px 24px;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
            pointer-events: all;
            width: 220px;
            text-align: center;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
        }
        
        .preFillButton:hover {
            background: linear-gradient(135deg, rgba(20, 27, 34, 0.95), rgba(139, 92, 246, 0.2));
            box-shadow: 0 6px 20px rgba(139, 92, 246, 0.4);
            transform: scale(1.02);
            border-color: #A78BFA;
        }
        
        .preFillButton:active {
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.98), rgba(15, 19, 24, 0.95));
            transform: scale(0.98);
        }
        
        .skipButton50 {
            position: absolute;
            left: 60px;
            top: calc(50% + 55px);
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            color: #E9F0F7;
            border: 2px solid #FF9F1C;
            border-radius: 8px;
            padding: 12px 24px;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
            pointer-events: all;
            width: 220px;
            text-align: center;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
        }
        
        .skipButton50:hover {
            background: linear-gradient(135deg, rgba(20, 27, 34, 0.95), rgba(255, 159, 28, 0.2));
            box-shadow: 0 6px 20px rgba(255, 159, 28, 0.4);
            transform: scale(1.02);
            border-color: #FFBD59;
        }
        
        .skipButton50:active {
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.98), rgba(15, 19, 24, 0.95));
            transform: scale(0.98);
        }
        
        .skipButton100 {
            position: absolute;
            left: 60px;
            top: calc(50% + 145px);
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            color: #E9F0F7;
            border: 2px solid #EB5757;
            border-radius: 8px;
            padding: 12px 24px;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
            pointer-events: all;
            width: 220px;
            text-align: center;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
        }
        
        .skipButton100:hover {
            background: linear-gradient(135deg, rgba(20, 27, 34, 0.95), rgba(235, 87, 87, 0.2));
            box-shadow: 0 6px 20px rgba(235, 87, 87, 0.4);
            transform: scale(1.02);
            border-color: #FF6B6B;
        }
        
        .skipButton100:active {
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.98), rgba(15, 19, 24, 0.95));
            transform: scale(0.98);
        }
        
        .skipButton1000 {
            position: absolute;
            left: 60px;
            top: calc(50% + 232px);
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            color: #E9F0F7;
            border: 2px solid #8B5CF6;
            border-radius: 8px;
            padding: 12px 24px;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
            pointer-events: all;
            width: 220px;
            text-align: center;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
        }
        
        .skipButton1000:hover {
            background: linear-gradient(135deg, rgba(20, 27, 34, 0.95), rgba(139, 92, 246, 0.2));
            box-shadow: 0 6px 20px rgba(139, 92, 246, 0.5);
            transform: scale(1.02);
            border-color: #A78BFA;
        }
        
        .skipButton1000:active {
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.98), rgba(15, 19, 24, 0.95));
            transform: scale(0.98);
        }
        
        .skipButton10000 {
            position: absolute;
            left: 60px;
            top: calc(50% + 315px);
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            color: #E9F0F7;
            border: 2px solid #F012BE;
            border-radius: 8px;
            padding: 12px 24px;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
            pointer-events: all;
            width: 220px;
            text-align: center;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
        }
        
        .skipButton10000:hover {
            background: linear-gradient(135deg, rgba(20, 27, 34, 0.95), rgba(240, 18, 190, 0.2));
            box-shadow: 0 6px 30px rgba(240, 18, 190, 0.6);
            transform: scale(1.02);
            border-color: #FF6FD8;
        }
        
        .skipButton10000:active {
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.98), rgba(15, 19, 24, 0.95));
            transform: scale(0.98);
        }
        
        .aboutButton {
            position: absolute;
            right: 60px;
            bottom: 60px;
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            color: #E9F0F7;
            border: 2px solid #2A9D8F;
            border-radius: 8px;
            padding: 12px 24px;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
            pointer-events: all;
            width: 220px;
            text-align: center;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
        }
        
        .aboutButton:hover {
            background: linear-gradient(135deg, rgba(20, 27, 34, 0.95), rgba(42, 157, 143, 0.2));
            box-shadow: 0 6px 20px rgba(42, 157, 143, 0.4);
            transform: scale(1.02);
            border-color: #4ECDC4;
        }
        
        .aboutButton:active {
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.98), rgba(15, 19, 24, 0.95));
            transform: scale(0.98);
        }
        
        #scoreDisplay {
            position: absolute;
            top: 40px;
            right: 60px;
            text-align: right;
        }
        
        #scoreLabel {
            font-size: 18px;
            color: #BFD1E0;
            margin-bottom: 4px;
        }
        
        #scoreValue {
            font-family: 'JetBrains Mono', monospace;
            font-size: 48px;
            font-weight: 700;
            color: #F2C94C;
            text-shadow: 0 0 10px rgba(242, 201, 76, 0.4);
        }
        
        #levelDisplay {
            position: absolute;
            top: 40px;
            left: 60px;
        }
        
        #levelLabel {
            font-size: 18px;
            color: #BFD1E0;
            margin-bottom: 4px;
        }
        
        #levelValue {
            font-family: 'JetBrains Mono', monospace;
            font-size: 48px;
            font-weight: 700;
            color: #2D9CDB;
        }
        
        #comboDisplay {
            position: absolute;
            top: 140px;
            right: 60px;
            text-align: right;
        }
        
        #comboLabel {
            font-size: 16px;
            color: #BFD1E0;
        }
        
        #comboValue {
            font-family: 'JetBrains Mono', monospace;
            font-size: 32px;
            font-weight: 700;
            color: #27AE60;
        }
        
        #consensusDisplay {
            position: absolute;
            top: 220px;
            right: 60px;
            text-align: right;
        }
        
        #consensusLabel {
            font-size: 16px;
            color: #BFD1E0;
        }
        
        #consensusValue {
            font-family: 'JetBrains Mono', monospace;
            font-size: 32px;
            font-weight: 700;
            color: #4ECDC4;
        }
        
        #spmDisplay {
            position: absolute;
            top: 300px;
            right: 60px;
            text-align: right;
        }
        
        #spmLabel {
            font-size: 16px;
            color: #BFD1E0;
        }
        
        #spmValue {
            font-family: 'JetBrains Mono', monospace;
            font-size: 32px;
            font-weight: 700;
            color: #F2C94C;
        }
        
        #dropSpeedDisplay {
            position: absolute;
            top: 380px;
            right: 60px;
            text-align: right;
        }
        
        #dropSpeedLabel {
            font-size: 16px;
            color: #BFD1E0;
        }
        
        #dropSpeedValue {
            font-family: 'JetBrains Mono', monospace;
            font-size: 32px;
            font-weight: 700;
            color: #FF9F1C;
        }
        
        #instructions {
            position: fixed;
            right: 280px;
            bottom: 60px;
            width: 320px;
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            border: 2px solid #2A9D8F;
            border-radius: 12px;
            padding: 10px 12px;
            backdrop-filter: blur(10px);
            text-align: left;
            font-size: 11px;
            color: #D4E3F0;
            line-height: 1.8;
            z-index: 15;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            display: none;
        }
        
        #instructions.show {
            display: block;
        }
        
        #instructions > div {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        #instructions .controlTitle {
            font-weight: 800;
            font-size: 12px;
            margin-bottom: 6px;
            margin-top: 6px;
            color: #2A9D8F;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid #2A9D8F;
            padding-bottom: 6px;
            width: 100%;
        }
        
        #instructions .controllerGrid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 6px 16px;
            width: 100%;
            margin-top: 4px;
        }
        
        #instructions .controllerGrid > div {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        #instructions .controllerGrid .fullWidth {
            grid-column: 1 / -1;
        }
        
        #instructions .controlSection {
            margin-top: 6px;
            padding-top: 6px;
            border-top: 1px solid #26313B;
        }
        
        #instructions .controlSection > div {
            margin-bottom: 2px;
        }
        
        #chainPreview {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            background: rgba(20, 27, 34, 0.9);
            border: 2px solid #26313B;
            border-radius: 12px;
            padding: 15px 25px;
            backdrop-filter: blur(10px);
        }
        
        .chainPreviewItem {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }
        
        .chainPreviewLabel {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: #89A0B4;
            font-weight: 600;
        }
        
        .chainPreviewChain {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        .chainPreviewLink {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
        }
        
        .key {
            display: inline-block;
            background: #141B22;
            border: 1px solid #26313B;
            border-radius: 4px;
            padding: 4px 8px;
            margin: 0 2px;
            font-family: 'JetBrains Mono', monospace;
            color: #E9F0F7;
        }
        
        .controllerBtn {
            display: inline-block;
            padding: 2px 5px;
            margin: 0 2px;
            border-radius: 3px;
            font-weight: bold;
            color: white;
            font-size: 10px;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .controllerBtn.green {
            background: #27AE60;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            padding: 0;
            text-align: center;
            line-height: 18px;
        }
        
        .controllerBtn.red {
            background: #E74C3C;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            padding: 0;
            text-align: center;
            line-height: 18px;
        }
        
        .controllerBtn.blue {
            background: #3498DB;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            padding: 0;
            text-align: center;
            line-height: 18px;
        }
        
        .controllerBtn.yellow {
            background: #F39C12;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            padding: 0;
            text-align: center;
            line-height: 18px;
        }
        
        .controllerBtn.gray {
            background: #555;
        }
        
        #specialAbilitiesPanel {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            width: 240px;
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            border: 2px solid #2A9D8F;
            border-radius: 12px;
            padding: 15px;
            backdrop-filter: blur(10px);
            pointer-events: all;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
        }
        
        .specialAbility {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
            padding: 8px;
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.5), rgba(20, 27, 34, 0.3));
            border-radius: 8px;
            border: 2px solid;
            transition: all 0.2s;
            position: relative;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .specialAbility:hover {
            background: rgba(20, 27, 34, 0.8);
            transform: translateX(3px);
            filter: brightness(1.2);
        }
        
        .specialAbility:last-child {
            margin-bottom: 0;
        }
        
        .specialIconContainer {
            position: relative;
            flex-shrink: 0;
            display: flex;
            gap: 4px;
            align-items: center;
        }
        
        .specialBarVertical {
            width: 12px;
            height: 80px;
            background: rgba(10, 14, 18, 0.8);
            border-radius: 6px;
            overflow: hidden;
            border: 2px solid #26313B;
            position: relative;
        }
        
        .specialBarFillVertical {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 0%;
            transition: height 0.3s ease;
        }
        
        .specialIcon {
            width: 80px;
            height: 80px;
            border-radius: 6px;
            border: 2px solid #26313B;
            background: #141B22;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            flex-shrink: 0;
            position: relative;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.2s;
        }
        
        .specialIcon:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
        }
        
        .specialIcon:active {
            transform: scale(0.95);
        }
        
        .specialIcon.ready {
            animation: specialReady 1s ease-in-out infinite;
        }
        
        .specialIcon.disabled {
            opacity: 0.3;
            cursor: not-allowed;
            pointer-events: none;
            filter: grayscale(100%);
        }
        
        @keyframes specialReady {
            0%, 100% {
                border-color: #FFD700;
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.8), 0 0 40px rgba(255, 215, 0, 0.4);
            }
            50% {
                border-color: #FFF;
                box-shadow: 0 0 30px rgba(255, 255, 255, 0.9), 0 0 60px rgba(255, 215, 0, 0.6);
            }
        }
        
        @keyframes controlsHint {
            0%, 100% {
                box-shadow: 0 0 15px rgba(42, 157, 143, 0.8), 0 0 30px rgba(42, 157, 143, 0.4);
                transform: scale(1);
            }
            50% {
                box-shadow: 0 0 25px rgba(42, 157, 143, 1), 0 0 50px rgba(42, 157, 143, 0.6);
                transform: scale(1.1);
            }
        }
        
        #controlsBtn.hint {
            animation: controlsHint 1.5s ease-in-out infinite;
        }
        
        @keyframes tooltipFade {
            0%, 100% { opacity: 0; }
            10%, 90% { opacity: 1; }
        }
        
        #controlsHintTooltip.show {
            display: block;
            animation: tooltipFade 10s ease-in-out;
        }
        
        .specialInfo {
            flex: 1;
            min-width: 0;
        }
        
        .specialName {
            font-size: 13px;
            font-weight: 700;
            color: #E9F0F7;
            margin-bottom: 2px;
        }
        
        .specialKey {
            font-size: 10px;
            color: #89A0B4;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .specialTooltip {
            position: absolute;
            left: 100%;
            top: 50%;
            transform: translateY(-50%);
            margin-left: 15px;
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.98), rgba(20, 27, 34, 0.95));
            border: 2px solid;
            border-radius: 12px;
            padding: 14px 16px;
            width: 240px;
            font-size: 13px;
            color: #D4E3F0;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s, transform 0.3s;
            z-index: 1000;
            line-height: 1.5;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
        }
        
        .specialTooltip::before {
            content: '';
            position: absolute;
            left: -10px;
            top: 50%;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-top: 8px solid transparent;
            border-bottom: 8px solid transparent;
            border-right: 10px solid;
            border-right-color: inherit;
        }
        
        .specialAbility:hover .specialTooltip {
            opacity: 1;
            transform: translateY(-50%) translateX(5px);
        }
        
        .tooltipTitle {
            font-weight: 800;
            font-size: 14px;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.8);
        }
        
        #gameControls {
            position: absolute;
            bottom: 20px;
            right: 280px;
            pointer-events: all;
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            border: 2px solid #2A9D8F;
            border-radius: 8px;
            padding: 4px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
        }
        
        #gameControlsButtons {
            display: flex;
            gap: 4px;
            justify-content: center;
            align-items: center;
        }
        
        #gameControlsButtons button {
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            color: #F2C94C;
            border: 2px solid #26313B;
            border-radius: 6px;
            padding: 6px 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 32px;
            min-height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            position: relative;
        }
        
        #gameControlsButtons button:hover {
            background: linear-gradient(135deg, rgba(20, 27, 34, 0.95), rgba(42, 157, 143, 0.2));
            border-color: #4ECDC4;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(42, 157, 143, 0.4);
        }
        
        #gameControlsButtons button:active {
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.98), rgba(15, 19, 24, 0.95));
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }
        
        /* Active state for toggle buttons */
        #gameControlsButtons button.active {
            background: linear-gradient(135deg, rgba(42, 157, 143, 0.4), rgba(42, 157, 143, 0.3));
            border-color: #F2C94C;
            box-shadow: 0 0 15px rgba(242, 201, 76, 0.4);
        }
        
        /* Disabled/unused buttons */
        #gameControlsButtons button:disabled,
        #gameControlsButtons button.unused {
            opacity: 0.3;
            cursor: not-allowed;
            filter: grayscale(100%);
        }
        
        #gameControlsButtons button:disabled:hover,
        #gameControlsButtons button.unused:hover {
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            border-color: #26313B;
            transform: none;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }
        
        @keyframes zookoSpecial {
            0% {
                transform: translate(-50%, -50%) scale(0.5);
                opacity: 0;
            }
            20% {
                transform: translate(-50%, -50%) scale(1.2);
                opacity: 1;
            }
            80% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) scale(0.8);
                opacity: 0;
            }
        }
        
        #settingsPanel, #highScoresPanel, #achievementsPanel, #aboutPanel {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            border: 2px solid #2A9D8F;
            border-radius: 12px;
            padding: 25px;
            max-height: 90vh;
            overflow-y: auto;
            z-index: 200;
            pointer-events: all;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
        }
        
        #highScoresPanel {
            max-width: 1300px;
            width: 85vw;
        }
        
        #achievementsPanel {
            max-width: 1200px;
            width: 85vw;
        }
        
        #settingsPanel, #aboutPanel {
            max-width: 550px;
        }
        
        #overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 14, 18, 0.9);
            z-index: 150;
            pointer-events: all;
        }
        
        .panelTitle {
            font-size: 28px;
            font-weight: 900;
            color: #2A9D8F;
            margin-bottom: 20px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .achievementItem {
            background: rgba(10, 14, 18, 0.5);
            border: 1px solid #26313B;
            border-radius: 6px;
            padding: 6px;
            margin: 4px 0;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s;
        }
        
        .achievementItem.unlocked {
            border-color: #2A9D8F;
            background: linear-gradient(135deg, rgba(42, 157, 143, 0.2), rgba(78, 205, 196, 0.1));
            box-shadow: 0 2px 8px rgba(42, 157, 143, 0.3);
        }
        
        .achievementItem:hover {
            transform: translateX(3px);
            background: rgba(20, 27, 34, 0.8);
            filter: brightness(1.2);
        }
        
        .achievementIcon {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            flex-shrink: 0;
        }
        
        .achievementIcon.unlocked {
            background: #F2C94C;
            color: #0B0E12;
        }
        
        .achievementIcon.locked {
            background: #1B2836;
            color: #89A0B4;
        }
        
        .achievementInfo {
            flex: 1;
        }
        
        .achievementName {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 4px;
        }
        
        .achievementDesc {
            font-size: 14px;
            color: #BFD1E0;
        }
        
        .achievementTier {
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 4px;
            text-transform: uppercase;
            font-weight: 600;
        }
        
        .tier-easier { background: #27AE60; color: white; }
        .tier-easy { background: #2D9CDB; color: white; }
        .tier-mid { background: #F39C12; color: white; }
        .tier-mid-hard { background: #E67E22; color: white; }
        .tier-very-hard { background: #E74C3C; color: white; }
        
        .settingRow {
            margin: 20px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .settingLabel {
            font-size: 18px;
            color: #E9F0F7;
        }
        
        input[type="range"] {
            width: 200px;
        }
        
        .closeButton {
            background: linear-gradient(135deg, rgba(235, 87, 87, 0.3), rgba(231, 76, 60, 0.2));
            border-color: #EB5757;
        }
        
        .closeButton:hover {
            background: linear-gradient(135deg, rgba(235, 87, 87, 0.5), rgba(231, 76, 60, 0.3));
            border-color: #FF6B6B;
        }
        
        #pauseScreen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 14, 18, 0.95);
            z-index: 250;
            pointer-events: all;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        #pauseTitle {
            font-size: 72px;
            font-weight: 900;
            color: #F2C94C;
            margin-bottom: 40px;
            letter-spacing: 6px;
        }
        
        #bonusMessage {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 15;
            animation: bonusFadeIn 0.5s ease-out;
            pointer-events: none;
        }
        
        #bonusText {
            font-size: 48px;
            font-weight: 900;
            color: #F2C94C;
            text-shadow: 0 0 20px rgba(242, 201, 76, 0.8);
            margin-bottom: 20px;
            letter-spacing: 4px;
        }
        
        #bonusScore {
            font-size: 72px;
            font-weight: 900;
            color: #4ECDC4;
            text-shadow: 0 0 30px rgba(78, 205, 196, 0.8);
            font-family: 'JetBrains Mono', monospace;
        }
        
        #level10Notification {
            display: none;
            position: fixed;
            left: 60px;
            top: 50%;
            transform: translateY(-50%);
            background: linear-gradient(135deg, rgba(42, 157, 143, 0.95), rgba(27, 94, 86, 0.95));
            border: 3px solid #F2C94C;
            border-radius: 20px;
            padding: 30px;
            max-width: 350px;
            z-index: 300;
            pointer-events: all;
            box-shadow: 0 0 40px rgba(242, 201, 76, 0.6);
            animation: slideInFromLeft 0.5s ease-out;
        }
        
        @keyframes slideInFromLeft {
            from {
                opacity: 0;
                transform: translateY(-50%) translateX(-100px);
            }
            to {
                opacity: 1;
                transform: translateY(-50%) translateX(0);
            }
        }
        
        #level10Notification h2 {
            font-size: 36px;
            font-weight: 900;
            color: #F2C94C;
            margin: 0 0 15px 0;
            text-align: center;
            text-shadow: 0 0 10px rgba(242, 201, 76, 0.5);
            letter-spacing: 2px;
        }
        
        #level10Notification p {
            font-size: 18px;
            color: #F2F6F9;
            margin: 0 0 20px 0;
            line-height: 1.6;
            text-align: center;
        }
        
        .multiChainPreview {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            margin: 20px 0;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }
        
        .previewLink {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 0 15px currentColor;
        }
        
        .previewLink.gold { background: #F2C94C; color: #F2C94C; }
        .previewLink.blue { background: #2D9CDB; color: #2D9CDB; }
        .previewLink.green { background: #27AE60; color: #27AE60; }
        .previewLink.red { background: #EB5757; color: #EB5757; }
        .previewLink.encrypted {
            background: linear-gradient(135deg, #555 0%, #333 100%);
            color: #FFD85A;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: 900;
            text-shadow: 0 0 10px rgba(255, 216, 90, 0.8);
            animation: encryptedPulse 1.5s infinite;
        }
        
        @keyframes encryptedPulse {
            0%, 100% { box-shadow: 0 0 15px #FFD85A; }
            50% { box-shadow: 0 0 25px #FFD85A, 0 0 35px #FFD85A; }
        }
        
        .previewLink.glowing {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            color: #FFF;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: 900;
            text-shadow: 0 0 10px rgba(255, 255, 255, 1);
            animation: glowingPulse 1.2s infinite;
        }
        
        @keyframes glowingPulse {
            0%, 100% { 
                box-shadow: 0 0 20px #FFD700, 0 0 30px #FFA500;
                transform: scale(1);
            }
            50% { 
                box-shadow: 0 0 30px #FFD700, 0 0 50px #FFA500, 0 0 60px #FF8C00;
                transform: scale(1.05);
            }
        }
        
        @keyframes sandblastingBlink {
            0%, 100% {
                border-color: #FF6B35;
                border-width: 1px;
            }
            50% {
                border-color: #FFA07A;
                border-width: 3px;
            }
        }
        
        #level10Notification .button {
            width: 100%;
            margin: 10px 0 0 0;
        }
        
        #level20Notification {
            display: none;
            position: fixed;
            left: 60px;
            top: 50%;
            transform: translateY(-50%);
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.95), rgba(79, 70, 229, 0.95));
            border: 3px solid #FFD85A;
            border-radius: 20px;
            padding: 30px;
            max-width: 350px;
            z-index: 300;
            pointer-events: all;
            box-shadow: 0 0 40px rgba(255, 216, 90, 0.6);
            animation: slideInFromLeft 0.5s ease-out;
        }
        
        #level20Notification h2 {
            font-size: 36px;
            font-weight: 900;
            color: #FFD85A;
            margin: 0 0 15px 0;
            text-align: center;
            text-shadow: 0 0 10px rgba(255, 216, 90, 0.5);
            letter-spacing: 2px;
        }
        
        #level20Notification p {
            font-size: 18px;
            color: #F2F6F9;
            margin: 0 0 20px 0;
            line-height: 1.6;
            text-align: center;
        }
        
        #level20Notification .button {
            width: 100%;
            margin: 10px 0 0 0;
        }
        
        #level50Notification {
            display: none;
            position: fixed;
            left: 60px;
            top: 50%;
            transform: translateY(-50%);
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.95), rgba(255, 140, 0, 0.95));
            border: 3px solid #FFD700;
            border-radius: 20px;
            padding: 30px;
            max-width: 350px;
            z-index: 300;
            pointer-events: all;
            box-shadow: 0 0 40px rgba(255, 215, 0, 0.6);
            animation: slideInFromLeft 0.5s ease-out;
        }
        
        #level50Notification h2 {
            font-size: 36px;
            font-weight: 900;
            color: #FFD700;
            margin: 0 0 15px 0;
            text-align: center;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            letter-spacing: 2px;
        }
        
        #level50Notification p {
            font-size: 18px;
            color: #F2F6F9;
            margin: 0 0 20px 0;
            line-height: 1.6;
            text-align: center;
        }
        
        #level50Notification .button {
            width: 100%;
            margin: 10px 0 0 0;
        }
        
        #glowingLinksGuide {
            display: none;
            position: fixed;
            left: 60px;
            top: 50%;
            transform: translateY(-50%);
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(240, 240, 240, 0.95));
            border: 3px solid #FFFFFF;
            border-radius: 20px;
            padding: 30px;
            max-width: 350px;
            z-index: 300;
            pointer-events: all;
            box-shadow: 0 0 40px rgba(255, 255, 255, 0.8);
            animation: slideInFromLeft 0.5s ease-out;
        }
        
        #glowingLinksGuide h2 {
            font-size: 36px;
            font-weight: 900;
            color: #FFD700;
            margin: 0 0 15px 0;
            text-align: center;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
            letter-spacing: 2px;
        }
        
        #glowingLinksGuide p {
            font-size: 18px;
            color: #333;
            margin: 0 0 20px 0;
            line-height: 1.6;
            text-align: center;
        }
        
        #glowingLinksGuide .button {
            width: 100%;
            margin: 10px 0 0 0;
        }
        
        @keyframes bonusFadeIn {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }
        
        #versionDisplay {
            position: fixed;
            bottom: 10px;
            right: 10px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            color: #89A0B4;
            opacity: 0.6;
            z-index: 5;
            pointer-events: none;
        }
        
        #performanceDisplay {
            position: fixed;
            top: 50%;
            right: 10px;
            transform: translateY(-50%);
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: #89A0B4;
            background: rgba(11, 14, 18, 0.7);
            padding: 8px 10px;
            border-radius: 6px;
            border: 1px solid rgba(137, 160, 180, 0.2);
            z-index: 5;
            pointer-events: none;
            line-height: 1.6;
        }
        
        #performanceDisplay .perf-label {
            color: #5A7A91;
            font-size: 10px;
        }
        
        #performanceDisplay .perf-value {
            color: #F2C94C;
            font-weight: 600;
        }
        
        #compassDisplay {
            position: fixed;
            bottom: 40px;
            left: 60px;
            width: 120px;
            height: 120px;
            pointer-events: none;
            z-index: 15;
        }
        
        .compassRing {
            position: absolute;
            width: 100%;
            height: 100%;
            border: 3px solid #26313B;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(10, 14, 18, 0.9), rgba(10, 14, 18, 0.7));
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5), inset 0 0 20px rgba(38, 49, 59, 0.3);
        }
        
        .compassDirection {
            position: absolute;
            font-family: 'JetBrains Mono', monospace;
            font-weight: 700;
            font-size: 18px;
            color: #89A0B4;
            transition: all 0.3s ease;
            cursor: pointer;
            pointer-events: auto;
        }
        
        .compassDirection:hover {
            color: #B8D4E8;
            text-shadow: 0 0 8px rgba(184, 212, 232, 0.4);
        }
        
        .compassDirection.active {
            color: #F2C94C;
            text-shadow: 0 0 10px rgba(242, 201, 76, 0.6);
            font-size: 24px;
        }
        
        .compassN {
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .compassE {
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        .compassS {
            bottom: 5px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .compassW {
            left: 8px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        .compassCenter {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 8px;
            height: 8px;
            background: #F2C94C;
            border-radius: 50%;
            box-shadow: 0 0 8px rgba(242, 201, 76, 0.8);
        }
        
        .compassNeedle {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 35px solid #2D9CDB;
            transform-origin: 50% 85%;
            transform: translate(-50%, -85%) rotate(0deg);
            transition: transform 0.45s cubic-bezier(0.4, 0, 0.2, 1);
            filter: drop-shadow(0 0 5px rgba(45, 156, 219, 0.6));
        }
        
        #topDownButton {
            position: fixed;
            bottom: 15px;
            left: 60px;
            width: 120px;
            padding: 8px 0;
            background: rgba(10, 14, 18, 0.9);
            border: 2px solid #26313B;
            border-radius: 8px;
            font-family: 'JetBrains Mono', monospace;
            font-weight: 700;
            font-size: 14px;
            color: #89A0B4;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 15;
        }
        
        #topDownButton:hover {
            background: rgba(38, 49, 59, 0.95);
            color: #B8D4E8;
            border-color: #2D9CDB;
            box-shadow: 0 0 10px rgba(45, 156, 219, 0.3);
        }
        
        #topDownButton.active {
            background: rgba(45, 156, 219, 0.2);
            color: #2D9CDB;
            border-color: #2D9CDB;
            box-shadow: 0 0 15px rgba(45, 156, 219, 0.5);
        }
    </style>
</head>
<body>
    <div id="overlay" onclick="closeAllPanels()"></div>
    
    <div id="settingsPanel">
        <div class="panelTitle">SETTINGS</div>
        <div class="settingRow">
            <span class="settingLabel">Show Hitboxes (Debug)</span>
            <input type="checkbox" id="showHitboxes" onchange="updateSettings()">
        </div>
        <div style="margin: 10px 0; padding: 10px; background: rgba(0, 255, 255, 0.1); border-radius: 5px; font-size: 11px; color: #89A0B4;">
            ðŸ’¡ Enable hitboxes, then press <strong style="color: #00ffff;">P</strong> to create particle placements.<br>
            Click boxes to edit, click arrows to move, test/duplicate/delete in menu.
        </div>
        <div class="settingRow">
            <span class="settingLabel">Auto Restart Game</span>
            <input type="checkbox" id="autoRestart" checked onchange="updateSettings()">
        </div>
        <div class="settingRow" style="border-top: 2px solid #26313B; padding-top: 20px; margin-top: 20px;">
            <span class="settingLabel">AI Player (Testing)</span>
            <input type="checkbox" id="aiEnabled" onchange="updateSettings()">
        </div>
        <button class="button" style="margin-top: 30px; background: #EB5757;" onclick="clearHighScores()">CLEAR HIGH SCORES<span style="display: inline-block; width: 26px; height: 26px; background: #3498DB; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">X</span></button>
        <button class="button closeButton" onclick="closeAllPanels()" style="margin-top: 20px; width: 100%;">CLOSE<span style="display: inline-block; width: 26px; height: 26px; background: #E74C3C; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">B</span></button>
    </div>
    
    <div id="highScoresPanel">
        <div class="panelTitle">HIGH SCORES</div>
        <div id="highScoresList"></div>
        <button class="button closeButton" onclick="closeAllPanels()" style="width: 100%; margin-top: 20px;">CLOSE<span style="display: inline-block; width: 26px; height: 26px; background: #E74C3C; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">B</span></button>
    </div>
    
    <div id="achievementsPanel">
        <div class="panelTitle">ACHIEVEMENTS</div>
        <div id="achievementsList"></div>
        <button class="button closeButton" onclick="closeAllPanels()" style="width: 100%; margin-top: 20px;">CLOSE<span style="display: inline-block; width: 26px; height: 26px; background: #E74C3C; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">B</span></button>
    </div>
    
    <div id="aboutPanel">
        <div class="panelTitle">ABOUT / DONATE</div>
        <div style="font-family: 'Inter', sans-serif; color: #D4E3F0; line-height: 1.8; text-align: center;">
            <div style="margin-bottom: 25px;">
                <div style="font-size: 18px; font-weight: 700; color: #F2C94C; margin-bottom: 10px;">Created by CyberAxe</div>
                <div style="font-size: 16px; margin-bottom: 5px;">
                    <a href="https://www.OutlandishlyCrafted.com" target="_blank" style="color: #2D9CDB; text-decoration: none; font-weight: 600;">www.OutlandishlyCrafted.com</a>
                </div>
            </div>
            
            <div style="margin-bottom: 25px; padding-top: 20px; border-top: 2px solid #26313B;">
                <div style="font-size: 16px; font-weight: 700; color: #27AE60; margin-bottom: 10px;">Report Bugs & Get Support</div>
                <div style="font-size: 14px;">
                    <a href="https://github.com/Jbenisek/ZLOCK-ZHAINER" target="_blank" style="color: #2D9CDB; text-decoration: none; font-weight: 600;">github.com/Jbenisek/ZLOCK-ZHAINER</a>
                </div>
            </div>
            
            <div style="margin-bottom: 20px; padding-top: 20px; border-top: 2px solid #26313B;">
                <div style="font-size: 18px; font-weight: 700; color: #EB5757; margin-bottom: 15px;">Donate and Support</div>
                <div style="font-size: 11px; font-family: 'JetBrains Mono', monospace; background: rgba(0, 0, 0, 0.3); padding: 12px; border-radius: 8px; word-break: break-all; color: #F2C94C; margin-bottom: 15px;">
                    u1gvnthgukm0ecnan3tgj3h6pdhrmmv8zyqx8ayup9yg9er4t5l7nesas6leavc4x3rsj98n65nn2w3ekzur9yejadlmv7k4vjgu8kp58q
                </div>
                <div>
                    <img src="items/CyberAxeZcashWalletQR.PNG" alt="Zcash Donation QR Code" style="max-width: 200px; border: 2px solid #26313B; border-radius: 8px; background: white; padding: 10px;">
                </div>
            </div>
        </div>
        <button class="button closeButton" onclick="closeAllPanels()" style="width: 100%; margin-top: 20px;">CLOSE<span style="display: inline-block; width: 26px; height: 26px; background: #E74C3C; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">B</span></button>
    </div>
    
    <div id="pauseScreen">
        <div id="pauseTitle">PAUSED</div>
        <button class="button" onclick="resumeGame()">RESUME<span style="display: inline-block; width: 26px; height: 26px; background: #E74C3C; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">B</span></button>
        <button class="button" onclick="restartFromPause()">RESTART<span style="display: inline-block; width: 26px; height: 26px; background: #3498DB; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">X</span></button>
        <button class="button" onclick="showSettingsFromPause()">SETTINGS<span style="display: inline-block; width: 26px; height: 26px; background: #F39C12; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">Y</span></button>
        <button class="button" onclick="quitToMenu()">QUIT TO MENU<span style="display: inline-block; padding: 4px 10px; background: #555; border-radius: 5px; margin-left: 10px; font-weight: bold; color: white; font-size: 12px;">â—€</span></button>
    </div>
    
    <div id="level10Notification">
        <h2>LEVEL 10 UNLOCKED!</h2>
        <p><strong>NEW CHAIN TYPE:</strong> Multi-Color Chains</p>
        <p>Chains can now contain multiple link types! Each link may be a different color.</p>
        <div class="multiChainPreview">
            <div class="previewLink gold"></div>
            <div class="previewLink blue"></div>
            <div class="previewLink green"></div>
            <div class="previewLink red"></div>
        </div>
        <p style="font-size: 16px; color: #FFD85A;">Match links by their individual color, not the entire chain!</p>
        <p style="font-size: 18px; color: #F2C94C; margin-top: 20px;"><strong>NEW ABILITY:</strong> Flip Chain</p>
        <p>Press <span class="key" style="background: #26313B; color: #F2C94C; padding: 4px 12px; border-radius: 4px; font-weight: 700;">SHIFT</span> to swap the top and bottom links!</p>
        <div class="multiChainPreview" style="margin-top: 15px;">
            <div style="display: flex; flex-direction: column; align-items: center; gap: 8px;">
                <div class="previewLink gold" style="width: 40px; height: 40px;"></div>
                <div style="font-size: 24px; color: #F2C94C;">â‡…</div>
                <div class="previewLink red" style="width: 40px; height: 40px;"></div>
            </div>
        </div>
        <p style="font-size: 14px; color: #BFD1E0; margin-top: 10px;">Works on all chains - perfect for getting the right color on top or bottom!</p>
        <div style="display: flex; gap: 10px; justify-content: center;">
            <button class="button" style="font-size: 14px; white-space: nowrap;" onclick="closeLevel10Notification()">GOT IT!<span style="display: inline-block; width: 20px; height: 20px; background: #27AE60; border-radius: 50%; text-align: center; line-height: 20px; margin-left: 6px; font-weight: bold; color: white; font-size: 12px;">A</span></button>
            <button class="button" style="background: #4A5568; border-color: #4A5568; font-size: 14px; white-space: nowrap;" onclick="skipAllHints()">SKIP ALL<span style="display: inline-block; width: 20px; height: 20px; background: #F39C12; border-radius: 50%; text-align: center; line-height: 20px; margin-left: 6px; font-weight: bold; color: white; font-size: 12px;">Y</span></button>
        </div>
    </div>
    
    <div id="glowingLinksGuide">
        <h2>GLOWING LINKS! âœ¨</h2>
        <p><strong>TIP:</strong> Broken/Glowing Links</p>
        <p>White glowing links are <strong>broken</strong> and ready to destroy!</p>
        <div class="multiChainPreview">
            <div class="previewLink glowing">â˜…</div>
            <div class="previewLink glowing">â˜…</div>
            <div class="previewLink glowing">â˜…</div>
        </div>
        <p style="font-size: 16px; color: #FFD700; font-weight: bold;">CLICK or SHOOT them for 100 points each!</p>
        <p style="font-size: 14px; color: #666;">They'll auto-destroy when they hit the floor</p>
        <div style="display: flex; gap: 10px; justify-content: center;">
            <button class="button" style="font-size: 14px; white-space: nowrap;" onclick="closeGlowingLinksGuide()">GOT IT!<span style="display: inline-block; width: 20px; height: 20px; background: #27AE60; border-radius: 50%; text-align: center; line-height: 20px; margin-left: 6px; font-weight: bold; color: white; font-size: 12px;">A</span></button>
            <button class="button" style="background: #4A5568; border-color: #4A5568; font-size: 14px; white-space: nowrap;" onclick="skipAllHints()">SKIP ALL<span style="display: inline-block; width: 20px; height: 20px; background: #F39C12; border-radius: 50%; text-align: center; line-height: 20px; margin-left: 6px; font-weight: bold; color: white; font-size: 12px;">Y</span></button>
        </div>
    </div>
    
    <div id="level20Notification">
        <h2>LEVEL 20 UNLOCKED!</h2>
        <p><strong>NEW CHAIN TYPE:</strong> Encrypted Chains</p>
        <p>Some chains are now ENCRYPTED! Their link colors are hidden until they land.</p>
        <div class="multiChainPreview">
            <div class="previewLink encrypted">?</div>
            <div class="previewLink encrypted">?</div>
            <div class="previewLink encrypted">?</div>
            <div class="previewLink encrypted">?</div>
        </div>
        <p style="font-size: 16px; color: #EB5757;">Plan carefully - you won't know what you have until it locks in!</p>
        <div style="display: flex; gap: 10px; justify-content: center;">
            <button class="button" style="font-size: 14px; white-space: nowrap;" onclick="closeLevel20Notification()">GOT IT!<span style="display: inline-block; width: 20px; height: 20px; background: #27AE60; border-radius: 50%; text-align: center; line-height: 20px; margin-left: 6px; font-weight: bold; color: white; font-size: 12px;">A</span></button>
            <button class="button" style="background: #4A5568; border-color: #4A5568; font-size: 14px; white-space: nowrap;" onclick="skipAllHints()">SKIP ALL<span style="display: inline-block; width: 20px; height: 20px; background: #F39C12; border-radius: 50%; text-align: center; line-height: 20px; margin-left: 6px; font-weight: bold; color: white; font-size: 12px;">Y</span></button>
        </div>
    </div>
    
    <div id="level50Notification">
        <h2>LEVEL 50 UNLOCKED!</h2>
        <p><strong>NEW CHAIN TYPE:</strong> Glowing Chains</p>
        <p>These chains are already glowing - click them for bonus points!</p>
        <div class="multiChainPreview">
            <div class="previewLink glowing">â˜…</div>
            <div class="previewLink glowing">â˜…</div>
            <div class="previewLink glowing">â˜…</div>
            <div class="previewLink glowing">â˜…</div>
            <div class="previewLink glowing">â˜…</div>
        </div>
        <p style="font-size: 16px; color: #FFD700;">These chains are already glowing - click to break them for bonus points!</p>
        <div style="display: flex; gap: 10px; justify-content: center;">
            <button class="button" style="font-size: 14px; white-space: nowrap;" onclick="closeLevel50Notification()">GOT IT!<span style="display: inline-block; width: 20px; height: 20px; background: #27AE60; border-radius: 50%; text-align: center; line-height: 20px; margin-left: 6px; font-weight: bold; color: white; font-size: 12px;">A</span></button>
            <button class="button" style="background: #4A5568; border-color: #4A5568; font-size: 14px; white-space: nowrap;" onclick="skipAllHints()">SKIP ALL<span style="display: inline-block; width: 20px; height: 20px; background: #F39C12; border-radius: 50%; text-align: center; line-height: 20px; margin-left: 6px; font-weight: bold; color: white; font-size: 12px;">Y</span></button>
        </div>
    </div>
    
    <div id="gameContainer">
        <canvas id="renderCanvas"></canvas>
        
        <div id="versionDisplay">v0.20.21</div>
        
        <div id="performanceDisplay">
            <div><span class="perf-label">FPS:</span> <span class="perf-value" id="fpsValue">60</span></div>
            <div><span class="perf-label">Memory:</span> <span class="perf-value" id="memoryValue">0 MB</span></div>
            <div><span class="perf-label">Particles:</span> <span class="perf-value" id="particleCount">0</span></div>
        </div>
        
        <!-- Special Abilities Panel -->
        <div id="specialAbilitiesPanel">
            <div class="specialAbility" style="border-color: #EB5757;">
                <div class="specialIconContainer">
                    <div class="specialBarVertical">
                        <div class="specialBarFillVertical" id="zookoBar" style="background: linear-gradient(0deg, #EB5757, #FF6B6B);"></div>
                    </div>
                    <div id="zookoIcon" class="specialIcon" style="background: #EB5757; background-image: url('people/zooko_a_head_compressed.png'); background-size: cover; background-position: center;" onclick="playZookoSpecialAnimation()"></div>
                </div>
                <div class="specialInfo">
                    <div class="specialName" style="font-weight: 900; font-size: 15px;">Zooko</div>
                    <div class="specialKey" style="font-size: 12px; font-weight: 700;">Press [1] or <span style="display: inline-block; padding: 2px 6px; background: #555; border-radius: 4px; font-weight: bold; color: white; font-size: 11px; vertical-align: middle;">â–²</span></div>
                </div>
                <div class="specialTooltip" style="border-color: #EB5757;">
                    <div class="tooltipTitle" style="color: #FF6B6B;">Cypherpunk Wizardry</div>
                    Mathematical magic creates micro-consensus, shattering the most common block type across the network!
                </div>
            </div>
            
            <div class="specialAbility" style="border-color: #F2C94C;">
                <div class="specialIconContainer">
                    <div class="specialBarVertical">
                        <div class="specialBarFillVertical" id="nateBar" style="background: linear-gradient(0deg, #F2C94C, #FFD700);"></div>
                    </div>
                    <div id="nateIcon" class="specialIcon" style="background: #F2C94C; background-image: url('people/Nate_a_head_compressed.png'); background-size: cover; background-position: center;" onclick="playNateSpecialAnimation()"></div>
                </div>
                <div class="specialInfo">
                    <div class="specialName" style="font-weight: 900; font-size: 15px;">Nate</div>
                    <div class="specialKey" style="font-size: 12px; font-weight: 700;">Press [2] or <span style="display: inline-block; padding: 2px 6px; background: #555; border-radius: 4px; font-weight: bold; color: white; font-size: 11px; vertical-align: middle;">â–¼</span></div>
                </div>
                <div class="specialTooltip" style="border-color: #F2C94C;">
                    <div class="tooltipTitle" style="color: #FFD700;">Code Whirlwind</div>
                    Super-hero level coding destroys all glowing links, then unleashes a cleanup tornado that shuffles the board!
                </div>
            </div>
            
            <div class="specialAbility" style="border-color: #27AE60;">
                <div class="specialIconContainer">
                    <div class="specialBarVertical">
                        <div class="specialBarFillVertical" id="zancasBar" style="background: linear-gradient(0deg, #27AE60, #2ECC71);"></div>
                    </div>
                    <div id="zancasIcon" class="specialIcon" style="background: #27AE60; background-image: url('people/Zancas_a_head_compressed.png'); background-size: cover; background-position: center;" onclick="playZancasSpecialAnimation()"></div>
                </div>
                <div class="specialInfo">
                    <div class="specialName" style="font-weight: 900; font-size: 15px;">Zancas</div>
                    <div class="specialKey" style="font-size: 12px; font-weight: 700;">Press [3] or <span style="display: inline-block; padding: 2px 6px; background: #555; border-radius: 4px; font-weight: bold; color: white; font-size: 11px; vertical-align: middle;">â—€</span></div>
                </div>
                <div class="specialTooltip" style="border-color: #27AE60;">
                    <div class="tooltipTitle" style="color: #2ECC71;">Peaceful Harmony</div>
                    Zen energy transforms the two most common block types into Gold, creating balance and consensus!
                </div>
            </div>
            
            <div class="specialAbility" style="border-color: #2E86DE;">
                <div class="specialIconContainer">
                    <div class="specialBarVertical">
                        <div class="specialBarFillVertical" id="cyberaxeBar" style="background: linear-gradient(0deg, #2E86DE, #54A0FF);"></div>
                    </div>
                    <div id="cyberaxeIcon" class="specialIcon" style="background: #2E86DE; background-image: url('people/cyberaxe_a_head_compressed.png'); background-size: cover; background-position: center;" onclick="playCyberAxeSpecialAnimation()"></div>
                </div>
                <div class="specialInfo">
                    <div class="specialName" style="font-weight: 900; font-size: 15px;">CyberAxe</div>
                    <div class="specialKey" style="font-size: 12px; font-weight: 700;">Press [4] or <span style="display: inline-block; padding: 2px 6px; background: #555; border-radius: 4px; font-weight: bold; color: white; font-size: 11px; vertical-align: middle;">â–¶</span></div>
                </div>
                <div class="specialTooltip" style="border-color: #2E86DE;">
                    <div class="tooltipTitle" style="color: #54A0FF;">Node Overload</div>
                    Technologist using game mod unleashes an overload of laser fury, maximizing node output and clearing entire columns!
                </div>
            </div>
        </div>
        
        <!-- Rogue Government Sandblasting Panel -->
        <div id="sandblastingPanel" style="
            position: absolute;
            bottom: 120px;
            right: 20px;
            width: 200px;
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            border: 2px solid #FF6B35;
            border-radius: 10px;
            padding: 15px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
        ">
            <div style="text-align: center; margin-bottom: 10px;">
                <div style="font-size: 14px; font-weight: 600; color: #FF6B35; margin-bottom: 5px;">ROGUE GOVERNMENT</div>
                <div style="font-size: 12px; color: #FFB399;">SANDBLASTING</div>
            </div>
            <div id="sandblastingBarContainer" style="position: relative; width: 100%; height: 120px; background: rgba(0,0,0,0.4); border-radius: 8px; overflow: hidden; border: 1px solid #FF6B35;">
                <div id="sandblastingBarFill" style="
                    position: absolute;
                    bottom: 0;
                    left: 0;
                    width: 100%;
                    height: 0%;
                    background: linear-gradient(0deg, #FF6B35, #FFA07A);
                    transition: height 0.3s ease;
                "></div>
                <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 80px; height: 80px; background: #333; border-radius: 8px; border: 2px solid #FF6B35; background-image: url('items/sandblast_compressed.png'); background-size: cover; background-position: center;"></div>
            </div>
            <div id="sandblastingPercent" style="text-align: center; margin-top: 8px; font-size: 18px; font-weight: 700; color: #FF6B35;">0%</div>
            <div style="
                position: absolute;
                right: 100%;
                top: 50%;
                transform: translateY(-50%);
                margin-right: 15px;
                background: linear-gradient(135deg, rgba(10, 14, 18, 0.98), rgba(20, 27, 34, 0.95));
                border: 2px solid #FF6B35;
                border-radius: 12px;
                padding: 14px 16px;
                width: 240px;
                font-size: 13px;
                color: #D4E3F0;
                opacity: 0;
                pointer-events: none;
                transition: opacity 0.3s, transform 0.3s;
                z-index: 1000;
                line-height: 1.5;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
            " id="sandblastingTooltip">
                <div style="
                    content: '';
                    position: absolute;
                    right: -10px;
                    top: 50%;
                    transform: translateY(-50%);
                    width: 0;
                    height: 0;
                    border-top: 8px solid transparent;
                    border-bottom: 8px solid transparent;
                    border-left: 10px solid #FF6B35;
                "></div>
                <div style="font-weight: 800; font-size: 14px; margin-bottom: 6px; text-transform: uppercase; color: #FFA07A;">Sandblasting</div>
                Charges 25% per special ability used. At 100%, unleashes chaos as 60-100 random links rain down from the sky over 7 seconds!
            </div>
        </div>
        
        <script>
            // Add hover effect for sandblasting tooltip
            document.getElementById('sandblastingPanel').addEventListener('mouseenter', function() {
                document.getElementById('sandblastingTooltip').style.opacity = '1';
                document.getElementById('sandblastingTooltip').style.transform = 'translateY(-50%) translateX(-5px)';
            });
            document.getElementById('sandblastingPanel').addEventListener('mouseleave', function() {
                document.getElementById('sandblastingTooltip').style.opacity = '0';
                document.getElementById('sandblastingTooltip').style.transform = 'translateY(-50%)';
            });
        </script>
        
        <!-- How to Play Modal -->
        <div id="howToPlayPanel" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 90%; max-width: 900px; max-height: 90vh; overflow-y: auto; background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9)); border: 2px solid #2A9D8F; border-radius: 12px; padding: 25px; z-index: 200; box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8); backdrop-filter: blur(10px); pointer-events: all;">
            
            <h2 style="color: #2A9D8F; font-size: 32px; margin-bottom: 25px; text-align: center; font-weight: 900;">ðŸ“– HOW TO PLAY</h2>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                <!-- Left Column -->
                <div>
                    <div style="background: rgba(42, 157, 143, 0.1); border: 2px solid #2A9D8F; border-radius: 10px; padding: 15px; margin-bottom: 15px;">
                        <h3 style="color: #2A9D8F; font-size: 18px; margin-bottom: 10px; font-weight: 700;">ðŸŽ¯ OBJECTIVE</h3>
                        <p style="color: #D4E3F0; font-size: 14px; line-height: 1.6;">Match <strong>6 connected blocks</strong> of the same color in a <strong>6Ã—25Ã—6 3D grid</strong>. Clear blocks to score points and survive as chains fall faster each level!</p>
                    </div>
                    
                    <div style="background: rgba(42, 157, 143, 0.1); border: 2px solid #2A9D8F; border-radius: 10px; padding: 15px; margin-bottom: 15px;">
                        <h3 style="color: #2A9D8F; font-size: 18px; margin-bottom: 10px; font-weight: 700;">âŒ¨ï¸ CONTROLS</h3>
                        <div style="color: #D4E3F0; font-size: 13px; line-height: 1.8;">
                            <div style="margin-bottom: 8px;"><span style="background: #1a2332; padding: 3px 8px; border-radius: 4px; font-family: monospace;">WASD</span> Move chain (X/Z)</div>
                            <div style="margin-bottom: 8px;"><span style="background: #1a2332; padding: 3px 8px; border-radius: 4px; font-family: monospace;">â†â†’</span> Rotate chain 90Â°</div>
                            <div style="margin-bottom: 8px;"><span style="background: #1a2332; padding: 3px 8px; border-radius: 4px; font-family: monospace;">SHIFT</span> Flip chain</div>
                            <div style="margin-bottom: 8px;"><span style="background: #1a2332; padding: 3px 8px; border-radius: 4px; font-family: monospace;">SPACE</span> Fast drop (2x for instant)</div>
                            <div style="margin-bottom: 8px;"><span style="background: #1a2332; padding: 3px 8px; border-radius: 4px; font-family: monospace;">Q/E</span> Rotate camera</div>
                            <div style="margin-bottom: 8px;"><span style="background: #1a2332; padding: 3px 8px; border-radius: 4px; font-family: monospace;">T</span> Top-down view</div>
                            <div><span style="background: #1a2332; padding: 3px 8px; border-radius: 4px; font-family: monospace;">1-4</span> Character specials</div>
                        </div>
                    </div>
                    
                    <div style="background: rgba(42, 157, 143, 0.1); border: 2px solid #2A9D8F; border-radius: 10px; padding: 15px;">
                        <h3 style="color: #2A9D8F; font-size: 18px; margin-bottom: 10px; font-weight: 700;">ðŸŽ® GAMEPAD</h3>
                        <div style="color: #D4E3F0; font-size: 13px; line-height: 1.8;">
                            <div style="margin-bottom: 6px;"><span style="background: #27AE60; color: white; padding: 2px 6px; border-radius: 50%; font-weight: bold; width: 20px; display: inline-block; text-align: center;">A</span> Fast/Instant drop</div>
                            <div style="margin-bottom: 6px;"><span style="background: #E74C3C; color: white; padding: 2px 6px; border-radius: 50%; font-weight: bold; width: 20px; display: inline-block; text-align: center;">B</span> Flip</div>
                            <div style="margin-bottom: 6px;"><span style="background: #F39C12; color: white; padding: 2px 6px; border-radius: 50%; font-weight: bold; width: 20px; display: inline-block; text-align: center;">Y</span> Rotate</div>
                            <div style="margin-bottom: 6px;"><span style="background: #555; color: white; padding: 2px 6px; border-radius: 3px; font-weight: bold; font-size: 10px;">D-PAD</span> Character specials</div>
                        </div>
                    </div>
                </div>
                
                <!-- Right Column -->
                <div>
                    <div style="background: rgba(255, 107, 53, 0.1); border: 2px solid #FF6B35; border-radius: 10px; padding: 15px; margin-bottom: 15px;">
                        <h3 style="color: #FF6B35; font-size: 18px; margin-bottom: 10px; font-weight: 700;">ðŸŒªï¸ SANDBLASTING</h3>
                        <p style="color: #D4E3F0; font-size: 13px; line-height: 1.6;">Charges <strong>+25%</strong> each time you use a character special. At <strong>100%</strong>, unleashes random links from the sky over 7 seconds!<br><strong>Link Count by Level:</strong> &lt;50: 50 links | 50-99: 75 | 100-249: 100 | 250-499: 125 | 500-999: 150 | 1000+: 200</p>
                    </div>
                    
                    <div style="background: rgba(139, 92, 246, 0.1); border: 2px solid #8B5CF6; border-radius: 10px; padding: 15px; margin-bottom: 15px;">
                        <h3 style="color: #8B5CF6; font-size: 18px; margin-bottom: 10px; font-weight: 700;">ðŸ”“ CHAIN TYPES UNLOCK</h3>
                        <div style="color: #D4E3F0; font-size: 13px; line-height: 1.7;">
                            <div style="margin-bottom: 10px;">
                                <div style="font-weight: 700; color: #2A9D8F;">Level 10: Multi-Color Chains</div>
                                <div style="font-size: 12px; opacity: 0.9;">Each link can be different colors (30% spawn)</div>
                            </div>
                            <div style="margin-bottom: 10px;">
                                <div style="font-weight: 700; color: #8B5CF6;">Level 20: Encrypted Chains</div>
                                <div style="font-size: 12px; opacity: 0.9;">Colors hidden until landing (20% spawn)</div>
                            </div>
                            <div>
                                <div style="font-weight: 700; color: #FFD700;">Level 50: Glowing Chains</div>
                                <div style="font-size: 12px; opacity: 0.9;">Pre-glowing, 2-5 links, bonus points (15% spawn)</div>
                            </div>
                        </div>
                    </div>
                    
                    <div style="background: rgba(242, 201, 76, 0.1); border: 2px solid #F2C94C; border-radius: 10px; padding: 15px;">
                        <h3 style="color: #F2C94C; font-size: 18px; margin-bottom: 10px; font-weight: 700;">âš¡ CHARACTER SPECIALS</h3>
                        <div style="color: #D4E3F0; font-size: 12px; line-height: 1.6;">
                            <div style="margin-bottom: 8px;"><span style="color: #EB5757; font-weight: 700;">ðŸ”´ Zooko (1)</span> - Destroys most common block type</div>
                            <div style="margin-bottom: 8px;"><span style="color: #F2C94C; font-weight: 700;">ðŸŸ¡ Nate (2)</span> - Breaks glowing blocks + tornado shuffle</div>
                            <div style="margin-bottom: 8px;"><span style="color: #27AE60; font-weight: 700;">ðŸŸ¢ Zancas (3)</span> - Transforms 2 common types to gold</div>
                            <div><span style="color: #2D9CDB; font-weight: 700;">ðŸ”µ CyberAxe (4)</span> - Laser destroys entire column</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div style="background: rgba(42, 157, 143, 0.15); border: 2px solid #2A9D8F; border-radius: 10px; padding: 15px; margin-top: 20px; text-align: center;">
                <h3 style="color: #2A9D8F; font-size: 16px; margin-bottom: 8px; font-weight: 700;">ðŸ’¡ PRO TIP</h3>
                <p style="color: #D4E3F0; font-size: 14px; line-height: 1.6; margin: 0;">Drop speed increases each level! Use <strong>Q/E</strong> to rotate your view and <strong>T</strong> for top-down perspective to plan your moves better. Match colors strategically to charge character specials!</p>
            </div>
            <button class="button closeButton" onclick="closeHowToPlay()" style="width: 100%; margin-top: 20px;">CLOSE<span style="display: inline-block; width: 26px; height: 26px; background: #E74C3C; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">B</span></button>
        </div>
        
        <!-- About/Donate Button under Sandblasting Panel -->
        <div style="
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            background: rgba(10, 14, 18, 0.8);
            border: 2px solid #2D9CDB;
            border-radius: 10px;
            padding: 12px;
            backdrop-filter: blur(10px);
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        " onclick="showAbout()" onmouseenter="this.style.borderColor='#F2C94C'; this.style.boxShadow='0 0 15px rgba(242, 201, 76, 0.4)';" onmouseleave="this.style.borderColor='#2D9CDB'; this.style.boxShadow='none';">
            <div style="font-size: 14px; font-weight: 700; color: #F2C94C; margin-bottom: 3px;">ABOUT / DONATE</div>
            <div style="font-size: 11px; color: #89A0B4;">Support Development</div>
        </div>
        
        <div id="compassDisplay">
            <div class="compassRing"></div>
            <div class="compassDirection compassN active" onclick="switchToView(0)">N</div>
            <div class="compassDirection compassE" onclick="switchToView(1)">E</div>
            <div class="compassDirection compassS" onclick="switchToView(2)">S</div>
            <div class="compassDirection compassW" onclick="switchToView(3)">W</div>
            <div class="compassCenter"></div>
            <div class="compassNeedle"></div>
        </div>
        
        <div id="topDownButton" onclick="switchToTopDown()">TOP DOWN</div>
        
        <div id="chainPreview">
            <div class="chainPreviewItem">
                <div class="chainPreviewLabel">NEXT</div>
                <div class="chainPreviewChain" id="preview1"></div>
            </div>
            <div class="chainPreviewItem">
                <div class="chainPreviewLabel">THEN</div>
                <div class="chainPreviewChain" id="preview2"></div>
            </div>
            <div class="chainPreviewItem">
                <div class="chainPreviewLabel">AFTER</div>
                <div class="chainPreviewChain" id="preview3"></div>
            </div>
        </div>
        
        <div id="hud">
            <div id="levelDisplay">
                <div id="levelLabel">LEVEL</div>
                <div id="levelValue">1</div>
            </div>
            
            <div id="scoreDisplay">
                <div id="scoreLabel">SCORE</div>
                <div id="scoreValue">0</div>
            </div>
            
            <div id="comboDisplay" style="display: none;">
                <div id="comboLabel">COMBO</div>
                <div id="comboValue">Ã—1.0</div>
            </div>
            
            <div id="consensusDisplay">
                <div id="consensusLabel">CONSENSUS</div>
                <div id="consensusValue">0</div>
            </div>
            
            <div id="spmDisplay">
                <div id="spmLabel">SCORE/MIN</div>
                <div id="spmValue">0</div>
            </div>
            
            <div id="dropSpeedDisplay">
                <div id="dropSpeedLabel">DROP SPEED</div>
                <div id="dropSpeedValue">0.15Ã—</div>
            </div>
            
            <div id="aiIndicator" style="display: none; position: absolute; top: 460px; right: 60px; text-align: right;">
                <div style="font-size: 16px; color: #EB5757; font-weight: 700; text-shadow: 0 0 10px rgba(235, 87, 87, 0.8);">ðŸ¤– AI PLAYING</div>
            </div>
            
            <div id="instructions">
                <div class="controlTitle">âŒ¨ï¸ KEYBOARD</div>
                <div><span class="key">WASD</span> Move</div>
                <div><span class="key">SPACE</span> Fast Drop (2x Instant)</div>
                <div><span class="key">SHIFT</span> Flip Chain</div>
                <div><span class="key">â†‘</span><span class="key">â†“</span><span class="key">â†</span><span class="key">â†’</span> Rotate Piece</div>
                <div><span class="key">Q</span> <span class="key">E</span> Rotate View</div>
                <div><span class="key">T</span> Top-Down <span class="key">ESC</span> Pause</div>
                <div><span class="key">1-4</span> Character Specials</div>
                
                <div class="controlTitle">ðŸŽ® CONTROLLER</div>
                <div class="controllerGrid">
                    <div class="fullWidth"><span class="controllerBtn green">A</span> Fast Drop (2x Instant)</div>
                    <div><span class="controllerBtn red">B</span> Flip</div>
                    <div><span class="controllerBtn yellow">Y</span> Rotate R</div>
                    <div><span class="controllerBtn blue">X</span> Rotate L</div>
                    <div><span class="controllerBtn gray">LB</span> Cam</div>
                    <div><span class="controllerBtn gray">RB</span> Cam</div>
                    <div><span class="controllerBtn gray">START</span> Pause</div>
                    <div class="fullWidth"><span class="controllerBtn gray">SELECT</span> Top-Down</div>
                    <div><span class="controllerBtn gray">â–²</span> Zooko</div>
                    <div><span class="controllerBtn gray">â—€</span> Zancas</div>
                    <div><span class="controllerBtn gray">â–¼</span> Nate</div>
                    <div><span class="controllerBtn gray">â–¶</span> CyberAxe</div>
                </div>
            </div>
            
            <div id="controlsHintTooltip" style="display: none; position: absolute; bottom: 55px; right: 180px; background: rgba(42, 157, 143, 0.95); color: white; padding: 8px 12px; border-radius: 6px; font-family: 'JetBrains Mono', monospace; font-size: 11px; font-weight: 700; pointer-events: none; z-index: 20; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4); white-space: nowrap;">
                âŒ¨ï¸ Keyboard & Controls Guide
            </div>
            
            <div id="gameControls">
                <div id="gameControlsButtons">
                    <button id="lightsBtn" class="active" onclick="toggleLights()" title="Toggle Lights">ðŸ’¡</button>
                    <button id="particlesBtn" class="active" onclick="toggleParticles()" title="Toggle Particles">âœ¨</button>
                    <button id="wallEmissiveBtn" class="active" onclick="toggleButton1()" title="Toggle Wall Emissive">ðŸ’ </button>
                    <button id="modelsBtn" class="active" onclick="toggleButton2()" title="Toggle 3D Models">ðŸ§</button>
                    <button id="animationsBtn" class="active" onclick="toggleButton3()" title="Toggle Animations">ðŸŽ¬</button>
                    <button id="colorPickerBtn" onclick="toggleColorPicker()" title="Grid Color Settings">ðŸŽ¨</button>
                    <button id="controlsBtn" onclick="toggleControls()" title="Toggle Controls Panel">âŒ¨ï¸</button>
                    <button id="gridEffectBtn" onclick="cycleGridEffect()" title="Grid Effect: None">ðŸŒŒ</button>
                    <button id="qualityBtn" class="active" onclick="toggleQuality()" title="Quality: High Performance">ðŸŽ­</button>
                </div>
            </div>
            
            <!-- Color Picker Modal -->
            <div id="colorPickerModal" style="
                display: none;
                position: absolute;
                bottom: 45px;
                left: 50%;
                transform: translateX(-50%);
                background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
                border: 2px solid #2A9D8F;
                border-radius: 8px;
                padding: 12px;
                z-index: 10000;
                min-width: 280px;
                pointer-events: auto;
                backdrop-filter: blur(10px);
                box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8);
            ">
                <h3 style="margin: 0 0 10px 0; color: #2A9D8F; font-family: 'JetBrains Mono', monospace; font-size: 12px; text-align: center; font-weight: 900; text-transform: uppercase; letter-spacing: 1px;">Grid Color Settings</h3>
                
                <div style="margin-bottom: 10px;">
                    <label style="color: #BFD1E0; font-family: 'JetBrains Mono', monospace; font-size: 11px; display: block; margin-bottom: 6px;">Floor Hint Color:</label>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <input type="color" id="floorColorPicker" value="#00FFFF" style="width: 50px; height: 32px; border: 2px solid #2A9D8F; border-radius: 5px; cursor: pointer; background: rgba(10, 14, 18, 0.8);">
                        <button onclick="setFloorColorNone()" style="
                            flex: 1;
                            padding: 6px;
                            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
                            color: #E9F0F7;
                            border: 2px solid #2A9D8F;
                            border-radius: 5px;
                            font-family: 'JetBrains Mono', monospace;
                            cursor: pointer;
                            font-size: 10px;
                            font-weight: 700;
                            transition: all 0.2s;
                        ">None</button>
                    </div>
                </div>
                
                <div style="margin-bottom: 10px;">
                    <label style="color: #BFD1E0; font-family: 'JetBrains Mono', monospace; font-size: 11px; display: block; margin-bottom: 6px;">Laser Line Color:</label>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <input type="color" id="laserColorPicker" value="#00FFFF" style="width: 50px; height: 32px; border: 2px solid #2A9D8F; border-radius: 5px; cursor: pointer; background: rgba(10, 14, 18, 0.8);">
                        <button onclick="setLaserColorNone()" style="
                            flex: 1;
                            padding: 6px;
                            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
                            color: #E9F0F7;
                            border: 2px solid #2A9D8F;
                            border-radius: 5px;
                            font-family: 'JetBrains Mono', monospace;
                            cursor: pointer;
                            font-size: 10px;
                            font-weight: 700;
                            transition: all 0.2s;
                        ">None</button>
                    </div>
                </div>
                
                <div style="display: flex; gap: 8px; margin-top: 12px;">
                    <button onclick="applyColorSettings()" style="
                        flex: 1;
                        padding: 7px;
                        background: linear-gradient(135deg, rgba(39, 174, 96, 0.3), rgba(39, 174, 96, 0.2));
                        color: #E9F0F7;
                        border: 2px solid #27AE60;
                        border-radius: 5px;
                        font-family: 'JetBrains Mono', monospace;
                        cursor: pointer;
                        font-weight: bold;
                        transition: all 0.2s;
                        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
                    ">Accept</button>
                    <button onclick="cancelColorSettings()" style="
                        flex: 1;
                        padding: 7px;
                        background: linear-gradient(135deg, rgba(235, 87, 87, 0.3), rgba(231, 76, 60, 0.2));
                        color: #E9F0F7;
                        border: 2px solid #EB5757;
                        border-radius: 5px;
                        font-family: 'JetBrains Mono', monospace;
                        cursor: pointer;
                        font-weight: bold;
                        transition: all 0.2s;
                        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
                    ">Cancel</button>
                </div>
            </div>
            
            <!-- Particle Placement Menu -->
            <div id="placementMenu" style="display: none; position: fixed; background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9)); border: 2px solid #2A9D8F; border-radius: 8px; padding: 10px; z-index: 10000; pointer-events: auto; backdrop-filter: blur(10px); box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8);">
                <h3 style="margin: 0 0 8px 0; color: #2A9D8F; font-family: 'JetBrains Mono', monospace; font-weight: 900; text-transform: uppercase; letter-spacing: 0.5px; font-size: 11px;">Particle Placement</h3>
                
                <div style="margin-bottom: 6px; pointer-events: auto;">
                    <label style="color: #BFD1E0; font-family: 'JetBrains Mono', monospace; font-size: 9px; display: block; margin-bottom: 2px;">Effect:</label>
                    <select id="placementEffectSelect" onchange="onPlacementEffectChange()" style="width: 100%; padding: 3px; background: rgba(10, 14, 18, 0.8); color: #E9F0F7; border: 2px solid #2A9D8F; border-radius: 3px; font-family: 'JetBrains Mono', monospace; font-size: 9px; cursor: pointer; pointer-events: auto;">
                    </select>
                </div>
                
                <div style="margin-bottom: 6px; display: flex; gap: 8px; pointer-events: auto;">
                    <div><input type="checkbox" id="placementEnabledCheck" onclick="onPlacementEnabledChange()" style="margin-right: 3px; cursor: pointer; width: 14px; height: 14px; pointer-events: auto;"><label for="placementEnabledCheck" style="color: #BFD1E0; font-family: 'JetBrains Mono', monospace; font-size: 9px; cursor: pointer;">Enabled</label></div>
                    <div><input type="checkbox" id="placementLoopCheck" onclick="onPlacementLoopChange()" style="margin-right: 3px; cursor: pointer; width: 14px; height: 14px; pointer-events: auto;"><label for="placementLoopCheck" style="color: #BFD1E0; font-family: 'JetBrains Mono', monospace; font-size: 9px; cursor: pointer;">Loop</label></div>
                </div>
                
                <div style="margin-bottom: 6px;">
                    <label style="color: #BFD1E0; font-family: 'JetBrains Mono', monospace; font-size: 9px; display: block; margin-bottom: 2px;">Position:</label>
                    <div style="display: flex; gap: 3px; align-items: center;">
                        <div style="display: flex; align-items: center; gap: 2px;">
                            <label style="color: #2A9D8F; font-family: 'JetBrains Mono', monospace; font-size: 9px;">X:</label>
                            <input type="number" id="placementPosX" step="0.5" onchange="onPlacementPositionChange()" style="width: 50px; padding: 2px; background: rgba(10, 14, 18, 0.8); color: #E9F0F7; border: 2px solid #2A9D8F; border-radius: 3px; font-family: 'JetBrains Mono', monospace; font-size: 9px; pointer-events: auto;">
                        </div>
                        <div style="display: flex; align-items: center; gap: 2px;">
                            <label style="color: #2A9D8F; font-family: 'JetBrains Mono', monospace; font-size: 9px;">Y:</label>
                            <input type="number" id="placementPosY" step="0.5" onchange="onPlacementPositionChange()" style="width: 50px; padding: 2px; background: rgba(10, 14, 18, 0.8); color: #E9F0F7; border: 2px solid #2A9D8F; border-radius: 3px; font-family: 'JetBrains Mono', monospace; font-size: 9px; pointer-events: auto;">
                        </div>
                        <div style="display: flex; align-items: center; gap: 2px;">
                            <label style="color: #2A9D8F; font-family: 'JetBrains Mono', monospace; font-size: 9px;">Z:</label>
                            <input type="number" id="placementPosZ" step="0.5" onchange="onPlacementPositionChange()" style="width: 50px; padding: 2px; background: rgba(10, 14, 18, 0.8); color: #E9F0F7; border: 2px solid #2A9D8F; border-radius: 3px; font-family: 'JetBrains Mono', monospace; font-size: 9px; pointer-events: auto;">
                        </div>
                    </div>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 3px; margin-bottom: 4px; pointer-events: auto;">
                    <button onclick="testPlacementParticle()" style="padding: 3px 6px; font-size: 9px; background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9)); color: #E9F0F7; border: 2px solid #2A9D8F; border-radius: 6px; cursor: pointer; pointer-events: auto;">Test</button>
                    <button onclick="duplicateCurrentPlacement()" style="padding: 3px 6px; font-size: 9px; background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9)); color: #E9F0F7; border: 2px solid #2A9D8F; border-radius: 6px; cursor: pointer; pointer-events: auto;">Dup</button>
                    <button onclick="deleteCurrentPlacement()" style="padding: 3px 6px; font-size: 9px; background: linear-gradient(135deg, rgba(235, 87, 87, 0.3), rgba(231, 76, 60, 0.2)); color: #E9F0F7; border: 2px solid #EB5757; border-radius: 6px; cursor: pointer; pointer-events: auto;">Del</button>
                    <button onclick="closePlacementMenu()" style="padding: 3px 6px; font-size: 9px; background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9)); color: #E9F0F7; border: 2px solid #2A9D8F; border-radius: 6px; cursor: pointer; pointer-events: auto;">Close</button>
                </div>
                
                <div style="pointer-events: auto;">
                    <button onclick="copyParticlePlacementData()" style="width: 100%; padding: 3px 6px; font-size: 9px; background: linear-gradient(135deg, rgba(39, 174, 96, 0.3), rgba(39, 174, 96, 0.2)); color: #E9F0F7; border: 2px solid #27AE60; border-radius: 6px; cursor: pointer; pointer-events: auto;">ðŸ“‹ Copy</button>
                </div>
            </div>
        </div>
        
        <!-- Model Placement Menu -->
        <div id="modelPlacementMenu" style="display: none; position: fixed; background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9)); border: 2px solid #8B5CF6; border-radius: 8px; padding: 10px; z-index: 10000; pointer-events: auto; backdrop-filter: blur(10px); box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8);">
            <h3 style="margin: 0 0 8px 0; color: #8B5CF6; font-family: 'JetBrains Mono', monospace; font-weight: 900; text-transform: uppercase; letter-spacing: 0.5px; font-size: 11px;">Model Placement</h3>
            
            <div style="margin-bottom: 6px; pointer-events: auto;">
                <label style="color: #BFD1E0; font-family: 'JetBrains Mono', monospace; font-size: 9px; display: block; margin-bottom: 2px;">Model:</label>
                <select id="modelPlacementSelect" onchange="onModelPlacementModelChange()" style="width: 100%; padding: 3px; background: rgba(10, 14, 18, 0.8); color: #E9F0F7; border: 2px solid #8B5CF6; border-radius: 3px; font-family: 'JetBrains Mono', monospace; font-size: 9px; cursor: pointer; pointer-events: auto;">
                </select>
            </div>
            
            <div style="margin-bottom: 6px;">
                <label style="color: #BFD1E0; font-family: 'JetBrains Mono', monospace; font-size: 9px; display: block; margin-bottom: 2px;">Position:</label>
                <div style="display: flex; gap: 3px; align-items: center;">
                    <div style="display: flex; align-items: center; gap: 2px;">
                        <label style="color: #8B5CF6; font-family: 'JetBrains Mono', monospace; font-size: 9px;">X:</label>
                        <input type="number" id="modelPosX" step="0.5" onchange="onModelPositionChange()" style="width: 50px; padding: 2px; background: rgba(10, 14, 18, 0.8); color: #E9F0F7; border: 2px solid #8B5CF6; border-radius: 3px; font-family: 'JetBrains Mono', monospace; font-size: 9px; pointer-events: auto;">
                    </div>
                    <div style="display: flex; align-items: center; gap: 2px;">
                        <label style="color: #8B5CF6; font-family: 'JetBrains Mono', monospace; font-size: 9px;">Y:</label>
                        <input type="number" id="modelPosY" step="0.5" onchange="onModelPositionChange()" style="width: 50px; padding: 2px; background: rgba(10, 14, 18, 0.8); color: #E9F0F7; border: 2px solid #8B5CF6; border-radius: 3px; font-family: 'JetBrains Mono', monospace; font-size: 9px; pointer-events: auto;">
                    </div>
                    <div style="display: flex; align-items: center; gap: 2px;">
                        <label style="color: #8B5CF6; font-family: 'JetBrains Mono', monospace; font-size: 9px;">Z:</label>
                        <input type="number" id="modelPosZ" step="0.5" onchange="onModelPositionChange()" style="width: 50px; padding: 2px; background: rgba(10, 14, 18, 0.8); color: #E9F0F7; border: 2px solid #8B5CF6; border-radius: 3px; font-family: 'JetBrains Mono', monospace; font-size: 9px; pointer-events: auto;">
                    </div>
                </div>
            </div>
            
            <div style="margin-bottom: 6px;">
                <label style="color: #BFD1E0; font-family: 'JetBrains Mono', monospace; font-size: 9px; display: block; margin-bottom: 2px;">Rotation:</label>
                <div style="display: flex; gap: 3px; align-items: center;">
                    <div style="display: flex; align-items: center; gap: 2px;">
                        <label style="color: #8B5CF6; font-family: 'JetBrains Mono', monospace; font-size: 9px;">X:</label>
                        <input type="number" id="modelRotX" step="15" onchange="onModelRotationChange()" style="width: 50px; padding: 2px; background: rgba(10, 14, 18, 0.8); color: #E9F0F7; border: 2px solid #8B5CF6; border-radius: 3px; font-family: 'JetBrains Mono', monospace; font-size: 9px; pointer-events: auto;">
                    </div>
                    <div style="display: flex; align-items: center; gap: 2px;">
                        <label style="color: #8B5CF6; font-family: 'JetBrains Mono', monospace; font-size: 9px;">Y:</label>
                        <input type="number" id="modelRotY" step="15" onchange="onModelRotationChange()" style="width: 50px; padding: 2px; background: rgba(10, 14, 18, 0.8); color: #E9F0F7; border: 2px solid #8B5CF6; border-radius: 3px; font-family: 'JetBrains Mono', monospace; font-size: 9px; pointer-events: auto;">
                    </div>
                    <div style="display: flex; align-items: center; gap: 2px;">
                        <label style="color: #8B5CF6; font-family: 'JetBrains Mono', monospace; font-size: 9px;">Z:</label>
                        <input type="number" id="modelRotZ" step="15" onchange="onModelRotationChange()" style="width: 50px; padding: 2px; background: rgba(10, 14, 18, 0.8); color: #E9F0F7; border: 2px solid #8B5CF6; border-radius: 3px; font-family: 'JetBrains Mono', monospace; font-size: 9px; pointer-events: auto;">
                    </div>
                </div>
            </div>
            
            <div style="margin-bottom: 6px; display: flex; gap: 8px;">
                <div style="flex: 1;"><label style="color: #BFD1E0; font-family: 'JetBrains Mono', monospace; font-size: 9px; display: block; margin-bottom: 2px;">Scale:</label>
                <input type="number" id="modelScale" step="0.5" min="0.1" max="1000" onchange="onModelScaleChange()" style="width: 100%; padding: 2px; background: rgba(10, 14, 18, 0.8); color: #E9F0F7; border: 2px solid #8B5CF6; border-radius: 3px; font-family: 'JetBrains Mono', monospace; font-size: 9px; pointer-events: auto;"></div>
                <div style="display: flex; align-items: flex-end; pointer-events: auto;">
                <input type="checkbox" id="modelAnimLoopCheck" onclick="onModelAnimLoopChange()" style="margin-right: 3px; cursor: pointer; width: 14px; height: 14px; pointer-events: auto;">
                <label for="modelAnimLoopCheck" style="color: #BFD1E0; font-family: 'JetBrains Mono', monospace; font-size: 9px; cursor: pointer; white-space: nowrap;">Loop</label>
            </div></div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 3px; margin-bottom: 4px; pointer-events: auto;">
                <button onclick="testModelPlacement()" style="padding: 3px 6px; font-size: 9px; background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9)); color: #E9F0F7; border: 2px solid #8B5CF6; border-radius: 6px; cursor: pointer; pointer-events: auto;">Test</button>
                <button onclick="duplicateCurrentModel()" style="padding: 3px 6px; font-size: 9px; background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9)); color: #E9F0F7; border: 2px solid #8B5CF6; border-radius: 6px; cursor: pointer; pointer-events: auto;">Dup</button>
                <button onclick="deleteCurrentModel()" style="padding: 3px 6px; font-size: 9px; background: linear-gradient(135deg, rgba(235, 87, 87, 0.3), rgba(231, 76, 60, 0.2)); color: #E9F0F7; border: 2px solid #EB5757; border-radius: 6px; cursor: pointer; pointer-events: auto;">Del</button>
                <button onclick="closeModelPlacementMenu()" style="padding: 3px 6px; font-size: 9px; background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9)); color: #E9F0F7; border: 2px solid #8B5CF6; border-radius: 6px; cursor: pointer; pointer-events: auto;">Close</button>
            </div>
            
            <div style="pointer-events: auto;">
                <button onclick="copyModelPlacementData()" style="width: 100%; padding: 3px 6px; font-size: 9px; background: linear-gradient(135deg, rgba(39, 174, 96, 0.3), rgba(39, 174, 96, 0.2)); color: #E9F0F7; border: 2px solid #27AE60; border-radius: 6px; cursor: pointer; pointer-events: auto;">ðŸ“‹ Copy</button>
            </div>
        </div>
        
        <!-- Chain Column Menu -->
        <div id="chainColumnMenu" style="display: none; position: fixed; background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9)); border: 2px solid #FF9F1C; border-radius: 8px; padding: 12px; z-index: 10000; pointer-events: auto; backdrop-filter: blur(10px); box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8);">
            <h3 style="margin: 0 0 10px 0; color: #FF9F1C; font-family: 'JetBrains Mono', monospace; font-size: 13px; font-weight: 900; text-transform: uppercase; letter-spacing: 1px;">Chain Column</h3>
            
            <div style="margin-bottom: 8px;">
                <label style="color: #BFD1E0; font-family: 'JetBrains Mono', monospace; font-size: 10px; display: block; margin-bottom: 3px;">Position:</label>
                <div style="display: flex; gap: 4px; align-items: center;">
                    <div style="display: flex; align-items: center; gap: 2px;">
                        <label style="color: #FF9F1C; font-family: 'JetBrains Mono', monospace; font-size: 9px;">X:</label>
                        <input type="number" id="chainColPosX" step="0.5" onchange="onChainColumnPositionChange()" style="width: 50px; padding: 2px; background: rgba(10, 14, 18, 0.8); color: #E9F0F7; border: 2px solid #FF9F1C; border-radius: 3px; font-family: 'JetBrains Mono', monospace; font-size: 9px; pointer-events: auto;">
                    </div>
                    <div style="display: flex; align-items: center; gap: 2px;">
                        <label style="color: #FF9F1C; font-family: 'JetBrains Mono', monospace; font-size: 9px;">Y:</label>
                        <input type="number" id="chainColPosY" step="0.5" onchange="onChainColumnPositionChange()" style="width: 50px; padding: 2px; background: rgba(10, 14, 18, 0.8); color: #E9F0F7; border: 2px solid #FF9F1C; border-radius: 3px; font-family: 'JetBrains Mono', monospace; font-size: 9px; pointer-events: auto;">
                    </div>
                    <div style="display: flex; align-items: center; gap: 2px;">
                        <label style="color: #FF9F1C; font-family: 'JetBrains Mono', monospace; font-size: 9px;">Z:</label>
                        <input type="number" id="chainColPosZ" step="0.5" onchange="onChainColumnPositionChange()" style="width: 50px; padding: 2px; background: rgba(10, 14, 18, 0.8); color: #E9F0F7; border: 2px solid #FF9F1C; border-radius: 3px; font-family: 'JetBrains Mono', monospace; font-size: 9px; pointer-events: auto;">
                    </div>
                </div>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px; margin-bottom: 8px;">
                <div>
                    <label style="color: #BFD1E0; font-family: 'JetBrains Mono', monospace; font-size: 9px; display: block; margin-bottom: 2px;">Rotation:</label>
                    <input type="number" id="chainColRotation" step="0.1" onchange="onChainColumnRotationChange()" style="width: 100%; padding: 3px; background: rgba(10, 14, 18, 0.8); color: #E9F0F7; border: 2px solid #FF9F1C; border-radius: 3px; font-family: 'JetBrains Mono', monospace; font-size: 9px; pointer-events: auto;">
                </div>
                <div>
                    <label style="color: #BFD1E0; font-family: 'JetBrains Mono', monospace; font-size: 9px; display: block; margin-bottom: 2px;">Length:</label>
                    <input type="number" id="chainColLength" step="1" onchange="onChainColumnLengthChange()" style="width: 100%; padding: 3px; background: rgba(10, 14, 18, 0.8); color: #E9F0F7; border: 2px solid #FF9F1C; border-radius: 3px; font-family: 'JetBrains Mono', monospace; font-size: 9px; pointer-events: auto;">
                </div>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px; margin-bottom: 8px; pointer-events: auto;">
                <div>
                    <label style="color: #BFD1E0; font-family: 'JetBrains Mono', monospace; font-size: 9px; display: block; margin-bottom: 2px;">Color:</label>
                    <select id="chainColColorMode" onchange="onChainColumnColorModeChange()" style="width: 100%; padding: 3px; background: rgba(10, 14, 18, 0.8); color: #E9F0F7; border: 2px solid #FF9F1C; border-radius: 3px; font-family: 'JetBrains Mono', monospace; font-size: 9px; cursor: pointer; pointer-events: auto;">
                        <option value="random">Random</option>
                        <option value="single">Single</option>
                    </select>
                </div>
                <div>
                    <label style="color: #BFD1E0; font-family: 'JetBrains Mono', monospace; font-size: 9px; display: block; margin-bottom: 2px;">Direction:</label>
                    <select id="chainColDirection" onchange="onChainColumnDirectionChange()" style="width: 100%; padding: 3px; background: rgba(10, 14, 18, 0.8); color: #E9F0F7; border: 2px solid #FF9F1C; border-radius: 3px; font-family: 'JetBrains Mono', monospace; font-size: 9px; cursor: pointer; pointer-events: auto;">
                        <option value="up">Up</option>
                        <option value="down">Down</option>
                    </select>
                </div>
            </div>
            
            <div id="chainColSingleColorDiv" style="margin-bottom: 8px; display: none; pointer-events: auto;">
                <label style="color: #BFD1E0; font-family: 'JetBrains Mono', monospace; font-size: 9px; display: block; margin-bottom: 2px;">Single Color:</label>
                <select id="chainColSingleColor" onchange="onChainColumnSingleColorChange()" style="width: 100%; padding: 3px; background: rgba(10, 14, 18, 0.8); color: #E9F0F7; border: 2px solid #FF9F1C; border-radius: 3px; font-family: 'JetBrains Mono', monospace; font-size: 9px; cursor: pointer; pointer-events: auto;">
                    <option value="ZEC_A">Yellow</option>
                    <option value="ZEC_B">Blue</option>
                    <option value="ZEC_C">Green</option>
                    <option value="ZEC_D">Red</option>
                </select>
            </div>
            
            <div style="margin-bottom: 8px; pointer-events: auto;">
                <input type="checkbox" id="chainColEnabled" onclick="onChainColumnEnabledChange()" style="margin-right: 5px; cursor: pointer; width: 14px; height: 14px; pointer-events: auto;">
                <label for="chainColEnabled" style="color: #BFD1E0; font-family: 'JetBrains Mono', monospace; font-size: 10px; cursor: pointer;">Enabled</label>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 4px; pointer-events: auto; margin-bottom: 6px;">
                <button onclick="duplicateCurrentChainColumn()" style="padding: 3px 4px; font-size: 9px; background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9)); color: #E9F0F7; border: 2px solid #FF9F1C; border-radius: 6px; cursor: pointer; pointer-events: auto;">Dup</button>
                <button onclick="deleteCurrentChainColumn()" style="padding: 3px 4px; font-size: 9px; background: linear-gradient(135deg, rgba(235, 87, 87, 0.3), rgba(231, 76, 60, 0.2)); color: #E9F0F7; border: 2px solid #EB5757; border-radius: 6px; cursor: pointer; pointer-events: auto;">Del</button>
                <button onclick="closeChainColumnMenu()" style="padding: 3px 4px; font-size: 9px; background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9)); color: #E9F0F7; border: 2px solid #FF9F1C; border-radius: 6px; cursor: pointer; pointer-events: auto;">Close</button>
            </div>
            
            <div style="pointer-events: auto;">
                <button onclick="copyChainColumnData()" style="width: 100%; padding: 3px 4px; font-size: 9px; background: linear-gradient(135deg, rgba(39, 174, 96, 0.3), rgba(39, 174, 96, 0.2)); color: #E9F0F7; border: 2px solid #27AE60; border-radius: 6px; cursor: pointer; pointer-events: auto;">ðŸ“‹ Copy</button>
            </div>
        </div>
        
        <div id="bonusMessage" style="display: none;">
            <div id="bonusText"></div>
            <div id="bonusScore"></div>
        </div>
        
```        <div id="titleScreen">
            <div id="title">ZLOCK</div>
            <div id="subtitle">ZHAINER</div>
            <button class="button" onclick="startGame()">START GAME<span style="display: inline-block; width: 26px; height: 26px; background: #27AE60; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">A</span></button>
            <button class="button" onclick="showSettings()">SETTINGS<span style="display: inline-block; width: 26px; height: 26px; background: #3498DB; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">â–¶</span></button>
            <button class="button" onclick="showHighScores()">HIGH SCORES<span style="display: inline-block; width: 26px; height: 26px; background: #3498DB; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">X</span></button>
            <button class="button" onclick="showAchievements()">ACHIEVEMENTS<span style="display: inline-block; width: 26px; height: 26px; background: #F39C12; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">Y</span></button>
            <button class="aboutButton" onclick="showHowToPlay()" style="background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9)); border-color: #2A9D8F; bottom: 125px;">ðŸ“– HOW TO PLAY & CONTROLS<span style="display: inline-block; padding: 4px 10px; background: #555; border-radius: 5px; margin-left: 10px; font-weight: bold; color: white; font-size: 12px;">SELECT</span></button>
            <button class="aboutButton" onclick="showAbout()">ABOUT / DONATE<span style="display: inline-block; width: 26px; height: 26px; background: #E74C3C; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">B</span></button>
            <button class="preFillButton" onclick="startGameWithPreFill()">NEED MORE ACTION? PRE-FILLED GRID<span style="display: inline-block; padding: 4px 10px; background: #555; border-radius: 5px; margin-left: 8px; font-weight: bold; color: white; font-size: 12px;">â–²</span></button>
            <button class="skipButton" onclick="startGameAtLevel10()">BEEN HERE BEFORE? SKIP TUTORIAL <br>LEVEL 10<span style="display: inline-block; padding: 4px 10px; background: #555; border-radius: 5px; margin-left: 8px; font-weight: bold; color: white; font-size: 12px;">â—€</span></button>
            <button class="skipButton50" onclick="startGameAtLevel50()">ARE YOU GOOD? NORMAL MODE <br>LEVEL 50<span style="display: inline-block; padding: 4px 10px; background: #555; border-radius: 5px; margin-left: 8px; font-weight: bold; color: white; font-size: 12px;">â–¶</span></button>
            <button class="skipButton100" onclick="startGameAtLevel100()">YOU'VE GOT THIS? EXPERT MODE<br>LEVEL 100<span style="display: inline-block; padding: 4px 10px; background: #555; border-radius: 5px; margin-left: 8px; font-weight: bold; color: white; font-size: 12px;">â–¼</span></button>
            <button class="skipButton1000" onclick="startGameAtLevel1000()">ARE YOU LOCO? INSANE MODE<br>LEVEL 1000</button>
            <button class="skipButton10000" onclick="startGameAtLevel10000()">WILL YOU BE MY SUPERHUMAN!<br>LEVEL 10,000</button>
            <div style="position: absolute; left: 60px; top: calc(50% + 470px); font-family: 'JetBrains Mono', monospace; font-size: 12px; color: #89A0B4; width: 220px; text-align: center; line-height: 1.4;">
                <strong>NOTE:</strong><br>Skipping past Level 10<br>disables most achievements
            </div>
            <div style="margin-top: 40px; font-family: 'JetBrains Mono', monospace; font-size: 14px; color: #89A0B4;">
                Version v0.20.21 â€¢ 2025-11-20
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script>
        // Game Version
        const GAME_VERSION = 'v0.20.21';
        
        // Game State
        const GameState = {
            MENU: 'menu',
            PLAYING: 'playing',
            PAUSED: 'paused',
            GAMEOVER: 'gameover'
        };
        
        let currentState = GameState.MENU;
        
        // ===== GAMEPAD SUPPORT =====
        let gamepadConnected = false;
        let gamepadIndex = null;
        let gamepadButtonStates = {};
        let gamepadAxisDeadzone = 0.25;
        let lastGamepadUpdate = 0;
        const gamepadUpdateInterval = 16; // ~60Hz polling
        
        // Analog stick state tracking for edge detection
        let lastAnalogState = {
            up: false,
            down: false,
            left: false,
            right: false
        };
        
        // Button mapping (standard gamepad layout)
        const GamepadButtons = {
            A: 0,           // Bottom face button (A on Xbox, X on PlayStation)
            B: 1,           // Right face button (B on Xbox, Circle on PlayStation)
            X: 2,           // Left face button (X on Xbox, Square on PlayStation)
            Y: 3,           // Top face button (Y on Xbox, Triangle on PlayStation)
            LB: 4,          // Left bumper
            RB: 5,          // Right bumper
            LT: 6,          // Left trigger
            RT: 7,          // Right trigger
            SELECT: 8,      // Select/Back/Share
            START: 9,       // Start/Menu/Options
            L3: 10,         // Left stick button
            R3: 11,         // Right stick button
            DPAD_UP: 12,
            DPAD_DOWN: 13,
            DPAD_LEFT: 14,
            DPAD_RIGHT: 15
        };
        
        // Axis mapping
        const GamepadAxes = {
            LEFT_X: 0,
            LEFT_Y: 1,
            RIGHT_X: 2,
            RIGHT_Y: 3
        };
        // ===== END GAMEPAD SUPPORT =====
        let score = 0;
        let level = 1;
        let startLevel = 1; // Track what level the game started at
        let usedAI = false; // Track if AI was ever used during this game
        let combo = 1.0;
        let lastClearTime = 0;
        let floorClearBonusAwarded = false;
        let consensusCleared = 0;
        let level10NotificationShown = false; // Track if we've shown the level 10 popup
        let level20NotificationShown = false; // Track if we've shown the level 20 popup
        let level50NotificationShown = false; // Track if we've shown the level 50 popup
        let glowingLinksGuideShown = false; // Track if we've shown the glowing links guide
        
        // Chain Type Configuration System
        // Template for adding new chain types - just add an entry here!
        const CHAIN_TYPE_CONFIGS = [
            {
                level: 10,
                name: "Multi-Color Chains",
                description: "Chains with multiple link types - each link can be a different color!",
                spawnRate: 0.3,
                notificationVar: 'level10NotificationShown',
                gradient: 'linear-gradient(135deg, rgba(42, 157, 143, 0.95), rgba(27, 94, 86, 0.95))',
                borderColor: '#F2C94C',
                previewLinks: [
                    { class: 'gold', text: '' },
                    { class: 'blue', text: '' },
                    { class: 'green', text: '' },
                    { class: 'red', text: '' }
                ],
                warningText: null,
                customLogic: (chain, chainLength, baseTypes) => {
                    // Multi-color chain logic
                    chain.type = LinkType.ZEC_MULTI;
                    for (let i = 0; i < chainLength; i++) {
                        const linkType = baseTypes[Math.floor(Math.random() * baseTypes.length)];
                        chain.linkTypes.push(linkType);
                    }
                    return true; // Chain was created
                }
            },
            {
                level: 20,
                name: "Encrypted Chains",
                description: "Some chains are now ENCRYPTED! Their link colors are hidden until they land.",
                spawnRate: 0.2,
                notificationVar: 'level20NotificationShown',
                gradient: 'linear-gradient(135deg, rgba(139, 92, 246, 0.95), rgba(79, 70, 229, 0.95))',
                borderColor: '#8B5CF6',
                previewLinks: [
                    { class: 'encrypted', text: '?' },
                    { class: 'encrypted', text: '?' },
                    { class: 'encrypted', text: '?' },
                    { class: 'encrypted', text: '?' }
                ],
                warningText: "Plan carefully - you won't know what you have until it locks in!",
                customLogic: (chain, chainLength, baseTypes) => {
                    // Encrypted chain logic
                    chain.isEncrypted = true;
                    for (let i = 0; i < chainLength; i++) {
                        const actualLinkType = baseTypes[Math.floor(Math.random() * baseTypes.length)];
                        const encryptedLinkType = { color: 0x555555, emissive: 0x333333, name: 'ENCRYPTED' };
                        chain.actualLinkTypes.push(actualLinkType);
                        chain.linkTypes.push(encryptedLinkType);
                    }
                    return true; // Chain was created
                }
            },
            {
                level: 50,
                name: "Glowing Chains",
                description: "Intense glowing chains with extended length - can be up to 5 links long!",
                spawnRate: 0.15,
                notificationVar: 'level50NotificationShown',
                gradient: 'linear-gradient(135deg, rgba(255, 215, 0, 0.95), rgba(255, 140, 0, 0.95))',
                borderColor: '#FFD700',
                previewLinks: [
                    { class: 'glowing', text: 'â˜…' },
                    { class: 'glowing', text: 'â˜…' },
                    { class: 'glowing', text: 'â˜…' },
                    { class: 'glowing', text: 'â˜…' },
                    { class: 'glowing', text: 'â˜…' }
                ],
                warningText: "These chains are already glowing - click to break them for bonus points!",
                lengthRange: [2, 5], // Custom length for glowing chains
                customLogic: (chain, chainLength, baseTypes) => {
                    // Glowing chain logic - each link is a random type
                    chain.isGlowing = true;
                    for (let i = 0; i < chainLength; i++) {
                        const linkType = baseTypes[Math.floor(Math.random() * baseTypes.length)];
                        chain.linkTypes.push(linkType);
                    }
                    return true; // Chain was created
                }
            }
        ];
        
        // Three.js setup
        let scene, camera, renderer;
        let grid = []; // 3D grid [x][y][z]
        const GRID_WIDTH = 6;
        const GRID_HEIGHT = 25;  // Extended from 18 to 25 to add spawn room at top
        const GRID_DEPTH = 6;
        
        // Model loading
        let chainLinkModel = null;
        let chainModelYellow = null;
        let chainModelBlue = null;
        let chainModelGreen = null;
        let chainModelRed = null;
        let modelLoaded = false;
        let tableModel = null;
        let tableModelLoaded = false;
        
        // Zooko model and animation
        let zookoModel = null;
        let zookoMixer = null;
        let zookoLoaded = false;
        let zookoIdleAction = null;
        let zookoSpecialAction = null;
        let zookoSpecialClip = null;
        let zookoClickBox = null;
        let zookoHeadBone = null;
        let zookoHeadOffset = { x: 0, y: 0, z: -3.25 }; // Offset from head bone to particle spawn point
        let zookoHatOffset = { x: 0, y: -4, z: -5 }; // Offset from head bone to hat particle spawn point
        
        // CyberAxe model and animation
        let cyberAxeModel = null;
        let cyberAxeMixer = null;
        let cyberAxeLoaded = false;
        let cyberAxeIdleAction = null;
        let cyberAxeSpecialAction = null;
        let cyberAxeSpecialClip = null;
        let cyberAxeClickBox = null;
        let cyberAxeBaseRotation = -Math.PI * 3 / 4; // Base rotation for idle
        let cyberAxeSpecialRotation = Math.PI / 3; // Rotation for special animation (face wall)
        let cyberAxeSpecialPosition = { x: 25, y: -7, z: 25 }; // Position for special animation
        let cyberAxeSpecialLoopCount = 0;
        
        // Scene lights
        let keyLight = null;
        let fillLight = null;
        let ambientLight = null;
        let rimLight = null;
        let playerLight = null;
        let chainLight = null; // Light that follows the chain
        
        // Zancas model and animation
        let zancasModel = null;
        let zancasMixer = null;
        let zancasLoaded = false;
        let zancasIdleAction = null;
        let zancasSpecialAction = null;
        let zancasSpecialClip = null;
        let zancasClickBox = null;
        let zancasBaseRotation = -Math.PI / 4; // Base rotation for idle
        let zancasSpecialRotation = Math.PI+3; // Rotation for special animation
        let zancasSpecialPosition = { x: 15, y: -9, z: -15 }; // Position for special animation
        let zancasSpecialLoopCount = 0;
        let zancasHandBone = null;
        let zancasHandOffset = { x: 0, y: -2, z: 0 }; // Offset from hand bone to particle spawn point
        let zancasLeftHandBone = null;
        let zancasLeftHandOffset = { x: -2, y: 2, z: 0 }; // Offset from left hand bone to particle spawn point
        let cyberAxeHandBone = null;
        let cyberAxeHandOffset = { x: 0, y: 0, z: 0 }; // Offset from hand bone to particle spawn point
        let cyberAxeLeftHandBone = null;
        let cyberAxeLeftHandOffset = { x: 0, y: 0, z: 0 }; // Offset from left hand bone to particle spawn point
        let cyberAxeChestBone = null;
        let cyberAxeChestOffset = { x: -0.25, y: 0.25, z: 4 }; // Offset from chest bone to particle spawn point
        
        // Nate model and animation
        let nateModel = null;
        let nateMixer = null;
        let nateLoaded = false;
        let nateIdleAction = null;
        let nateSpecialAction = null;
        let nateSpecialClip = null;
        let nateClickBox = null;
        let nateBaseRotation = Math.PI / 1.5; // Base rotation for idle
        let nateSpecialRotation = Math.PI; // Rotation for special animation
        let nateSpecialPosition = { x: -14, y: -9, z: 12 }; // Position for special animation
        let nateSpecialLoopCount = 0;
        
        // TEST: Looping particle timer
        let testParticleTimer = 0;
        const testParticleInterval = 5500; // 5.5 seconds (effect duration)
        
        // Broken links tracking
        let brokenLinks = new Set();
        
        // Default light intensities (stock game state)
        const DEFAULT_KEY_LIGHT = 1.2;
        const DEFAULT_FILL_LIGHT = 0.6;
        const DEFAULT_AMBIENT_LIGHT = 0.3;
        const DEFAULT_RIM_LIGHT = 0.4;
        const DEFAULT_WALL_EMISSIVE = 0.5;
        
        // Camera positions (4 chairs + top-down view)
        let currentChair = 0; // 0=North, 1=East, 2=South, 3=West
        let isTopDownView = false; // Toggle for 5th camera view
        let cameraDistance = 20;
        const baseCameraDistance = 20;
        const minCameraDistance = 8;
        const maxCameraDistance = 28;
        const cameraHeight = 9;
        const topDownHeight = 24; // Height for top-down view
        
        // Link types - simple name references
        const LinkType = {
            ZEC_A: { name: 'ZEC-A' },     // Yellow
            ZEC_B: { name: 'ZEC-B' },     // Blue
            ZEC_C: { name: 'ZEC-C' },     // Green
            ZEC_D: { name: 'ZEC-D' },     // Red
            ZEC_MULTI: { name: 'ZEC-MULTI' } // Multi-type chain (level 10+)
        };
        
        // Simple color mapping for UI preview only
        const PREVIEW_COLORS = {
            'ZEC-A': '#F2C94C',  // Yellow
            'ZEC-B': '#2D9CDB',  // Blue
            'ZEC-C': '#27AE60',  // Green
            'ZEC-D': '#EB5757'   // Red
        };
        
        // Column tubes
        let columnTubes = [];
        let floorIndicators = [];
        
        // Room walls for LED pulse effect
        let roomWalls = [];
        
        // Corner feed tubes
        let cornerTubes = [];
        let cornerChains = [];
        
        // Active falling chain
        let fallingChain = null;
        let lastDropEffectTime = 0; // Track last time drop effect was spawned
        let chainQueue = []; // Queue of next 3 chains to preview
        let chainReadyToGlow = false;  // Simple flag - chain exists and is ready to show
        let chainVelocity = 0;
        let lastUpdateTime = Date.now();
        const gravity = 9.81;
        let fastDrop = false;
        
        // Shared materials for HQ and LQ modes (8 total: 4 colors Ã— 2 modes)
        let materialsHQ = { yellow: null, blue: null, green: null, red: null };
        let materialsLQ = { yellow: null, blue: null, green: null, red: null };
        let instantDrop = false;
        let lastSpaceTime = 0;
        const doubleTapThreshold = 300; // milliseconds for double-tap detection
        let hasLogged = false;  // Track if we've logged collision for this chain
        let spawnScheduled = false;  // Prevent double-spawning
        
        // Game timing and scoring
        let gameStartTime = null; // Track when gameplay started for SPM calculation
        let pauseStartTime = null; // Track when pause started
        let totalPausedTime = 0; // Total time spent paused
        let scorePerMinute = 0;
        let hyperModeEndTime = 0; // When hyper mode should end
        let hyperModeLevel = 0; // Stack multiple bonuses
        
        // Special ability charges (0-100)
        let zookoCharge = 0;
        let nateCharge = 0;
        let zancasCharge = 0;
        let cyberaxeCharge = 0;
        
        // Rogue Government Sandblasting charge (0-100)
        let sandblastingCharge = 0;
        let sandblastingActive = false;
        
        // Grid visual effects
        let currentGridEffect = 0;
        const GRID_EFFECTS = [
            { name: 'None', icon: 'ðŸŒŒ' },
            { name: 'Pulse Wave', icon: 'ðŸŒŠ' },
            { name: 'Deep Ocean', icon: 'ðŸŒŠ', solid: true, color: 0x0077BE },
            { name: 'Neon Glow', icon: 'ðŸ”†' },
            { name: 'Hot Pink', icon: 'ðŸ’–', solid: true, color: 0xFF1493 },
            { name: 'Rainbow Spectrum', icon: 'ðŸŒˆ' },
            { name: 'Lime Green', icon: 'ðŸ', solid: true, color: 0x00FF41 },
            { name: 'Digital Matrix', icon: 'ðŸ’»' },
            { name: 'Deep Purple', icon: 'ðŸ‡', solid: true, color: 0x9D00FF },
            { name: 'Plasma Field', icon: 'âš¡' },
            { name: 'Amber Gold', icon: 'ðŸŸ¡', solid: true, color: 0xFFBF00 },
            { name: 'Crystal Refraction', icon: 'ðŸ”¸' },
            { name: 'Crimson Red', icon: 'ðŸ”´', solid: true, color: 0xDC143C },
            { name: 'Synthwave Grid', icon: 'ðŸŒ†' },
            { name: 'Aqua Mint', icon: 'ðŸŒ¿', solid: true, color: 0x7FFFD4 },
            { name: 'Cyber Scanlines', icon: 'ðŸ“¡' },
            { name: 'Electric Blue', icon: 'âš¡', solid: true, color: 0x00D4FF },
            { name: 'Hypnotic Spiral', icon: 'ðŸŒ€' },
            { name: 'Sunset Orange', icon: 'ðŸŠ', solid: true, color: 0xFF6B35 },
            { name: 'Quantum Shimmer', icon: 'âœ¨' },
            { name: 'Violet Dream', icon: 'ðŸ’œ', solid: true, color: 0xB565D8 }
        ];
        
        // Performance tracking
        let frameCount = 0;
        let lastFpsUpdate = Date.now();
        let currentFps = 60;
        
        // Particle effect system
        let particleEffects = [];
        
        // Reusable objects for particle bone tracking (avoid creating new objects every frame)
        const _boneTempWorldPos = new THREE.Vector3();
        const _boneTempOffsetVec = new THREE.Vector3();
        const _boneTempWorldQuat = new THREE.Quaternion();
        const _boneTempHeadPos = new THREE.Vector3();
        
        // Reusable objects for camera-relative particle spawning
        const _spawnTempCamDir = new THREE.Vector3();
        const _spawnTempSpawnPos = new THREE.Vector3();
        let particleEffectTextures = {};
        
        // Floor cell animation system
        let floorCells = []; // Array of 6x6 floor cell meshes
        let floorCellGeometry = null; // Shared geometry for all floor cells
        let floorCellMaterials = []; // Pool of reusable materials
        let floorAtlasF = null; // Atlas F texture reference
        let floorAtlasG = null; // Atlas G texture reference
        let floorAnimationTime = 0; // Separate timer for floor animations
        
        // Animation frame ID tracking for cleanup
        let mainAnimationFrameId = null;
        let activeAnimationFrames = [];
        
        // Timer tracking for cleanup
        let activeTimeouts = [];
        let activeIntervals = [];
        
        // Wrapper functions to auto-track timers
        const trackedSetTimeout = (callback, delay, ...args) => {
            const id = window.setTimeout(callback, delay, ...args);
            activeTimeouts.push(id);
            return id;
        };
        
        const trackedSetInterval = (callback, delay, ...args) => {
            const id = window.setInterval(callback, delay, ...args);
            activeIntervals.push(id);
            return id;
        };
        
        const trackedClearTimeout = (id) => {
            window.clearTimeout(id);
            activeTimeouts = activeTimeouts.filter(tid => tid !== id);
        };
        
        const trackedClearInterval = (id) => {
            window.clearInterval(id);
            activeIntervals = activeIntervals.filter(tid => tid !== id);
        };
        
        // Zooko special effect state
        let zookoSpecialActive = false;
        let cyberAxeSpecialActive = false;
        let zancasSpecialActive = false;
        let nateSpecialActive = false;
        let normalTimeScale = 1.0;
        let slowTimeScale = 0.3;
        let currentTimeScale = 1.0;
        let cyberAxeFlickerTimeouts = []; // Track flicker timeout IDs to clear them
        let cyberAxeFlashInterval = null; // Track wall flash interval to clear it
        let cyberAxeCleanupTimeout = null; // Track cleanup timeout to clear it
        
        // Input state
        let keys = {};
        let dasTimer = 0;
        let arrTimer = 0;
        const DAS_DELAY = 180;
        const ARR_DELAY = 90;
        
        // Settings and Storage
        const STORAGE_KEYS = {
            SETTINGS: 'zlock_settings',
            HIGH_SCORES: 'zlock_highscores',
            GAME_HISTORY: 'zlock_gamehistory',
            ACHIEVEMENTS: 'zlock_achievements'
        };
        
        let settings = {
            colorBlindMode: 'none', // 'none', 'protanopia', 'deuteranopia', 'tritanopia'
            showHitboxes: false,
            autoRestart: true, // Auto restart game on game over
            aiEnabled: false // AI player for testing
        };
        
        // ===== PARTICLE PLACEMENT SYSTEM =====
        let particlePlacements = [];
        let selectedPlacement = null;
        let placementIdCounter = 0;
        
        // ===== MODEL PLACEMENT SYSTEM =====
        let modelPlacements = [];
        let selectedModelPlacement = null;
        let selectedChainColumn = null;
        let modelPlacementIdCounter = 0;
        
        // Available models
        const availableModels = [
            'models/Zcash_Chain_Link_A.glb',
            'models/Zcash_GameTable_A.glb',
            'people/alien_female_1_sitting_idle.glb',
            'people/alien_male_1_idle.glb',
            'people/alien_male_1_sitting_idle.glb',
            'people/cyberaxe_a.glb',
            'people/cyberaxe_a_special.glb',
            'people/female_1_idle.glb',
            'people/female_2_idle.glb',
            'people/female_3_idle.glb',
            'people/female_4_idle.glb',
            'people/male_1_idle.glb',
            'people/male_2_sitting_idle.glb',
            'people/nate_a.glb',
            'people/nate_a_special.glb',
            'people/zancas_a.glb',
            'people/zancas_a_special.glb',
            'people/zooko_a.glb',
            'people/zooko_a_special.glb'
        ];
        
        // Available particle effects
        const availableParticleEffects = [
            'effect/cyberaxe_electric.json',
            'effect/cyberaxe_electric_left.json',
            'effect/cyberaxe_electric_walls.json',
            'effect/cyberaxe_electric_walls_red.json',
            'effect/cyberaxe_electric_walls_spark.json',
            'effect/cyberaxe_electric_walls_yellow.json',
            'effect/cyberaxe_shield.json',
            'effect/cyberaxe_special_laser_a.json',
            'effect/cyberaxe_special_laser_b.json',
            'effect/cyberaxe_special_laser_c.json',
            'effect/drop_effect_a.json',
            'effect/drop_effect_blue.json',
            'effect/drop_effect_green.json',
            'effect/drop_effect_red.json',
            'effect/drop_effect_yellow.json',
            'effect/nate_special.json',
            'effect/Nate_special_break.json',
            'effect/zancas_special.json',
            'effect/zancas_special_break.json',
            'effect/zancas_special_orb.json',
            'effect/zancas_special_orb_left.json',
            'effect/zooko_hat.json',
            'effect/zooko_shield.json',
            'effect/zooko_special.json',
            'effect/zooko_special_break.json'
        ];
        
        // Load saved placements from localStorage
        function loadParticlePlacements() {
            // Default permanent particle placements - hardcoded in HTML, no localStorage
            particlePlacements = [
                {
                    id: 2,
                    position: { x: 41, y: 1.5, z: 35 },
                    particleEffect: 'effect/cyberaxe_electric_walls.json',
                    enabled: true,
                    loop: true
                },
                {
                    id: 3,
                    position: { x: 35.5, y: 1.5, z: 41 },
                    particleEffect: 'effect/cyberaxe_electric_walls.json',
                    enabled: true,
                    loop: true
                }
            ];
            
            placementIdCounter = particlePlacements.length;
            
            // Recreate placement boxes and spawn particles
            particlePlacements.forEach(placement => {
                createPlacementBox(placement);
                if (placement.enabled && placement.loop) {
                    startLoopingParticle(placement);
                }
            });
        }
        
        // Save placements to localStorage
        function saveParticlePlacements() {
            // Do nothing - localStorage disabled
        }
        
        // Create a new particle placement
        function createParticlePlacement() {
            const placement = {
                id: placementIdCounter++,
                position: { x: GRID_WIDTH / 2, y: 5, z: GRID_DEPTH / 2 },
                particleEffect: availableParticleEffects[0],
                enabled: true,
                loop: false,
                box: null,
                arrows: [],
                activeParticle: null,
                loopInterval: null
            };
            
            particlePlacements.push(placement);
            createPlacementBox(placement);
            saveParticlePlacements();
            
            return placement;
        }
        
        // Create visual box and arrows for placement
        function createPlacementBox(placement) {
            // Create box
            const boxGeometry = new THREE.BoxGeometry(2, 2, 2);
            const boxMaterial = new THREE.MeshBasicMaterial({
                color: placement.enabled ? 0x00ff00 : 0xff0000,
                wireframe: true,
                transparent: true,
                opacity: 0.7
            });
            const box = new THREE.Mesh(boxGeometry, boxMaterial);
            box.position.set(placement.position.x, placement.position.y, placement.position.z);
            box.userData.placementId = placement.id;
            box.userData.isPlacementBox = true;
            box.visible = settings.showHitboxes;
            scene.add(box);
            placement.box = box;
            
            // Create arrows for movement
            const arrowLength = 3.0;
            const arrowColor = 0xffff00;
            const directions = [
                { dir: new THREE.Vector3(1, 0, 0), offset: new THREE.Vector3(3, 0, 0), axis: 'x', sign: 1 },
                { dir: new THREE.Vector3(-1, 0, 0), offset: new THREE.Vector3(-3, 0, 0), axis: 'x', sign: -1 },
                { dir: new THREE.Vector3(0, 1, 0), offset: new THREE.Vector3(0, 3, 0), axis: 'y', sign: 1 },
                { dir: new THREE.Vector3(0, -1, 0), offset: new THREE.Vector3(0, -3, 0), axis: 'y', sign: -1 },
                { dir: new THREE.Vector3(0, 0, 1), offset: new THREE.Vector3(0, 0, 3), axis: 'z', sign: 1 },
                { dir: new THREE.Vector3(0, 0, -1), offset: new THREE.Vector3(0, 0, -3), axis: 'z', sign: -1 }
            ];
            
            placement.arrows = [];
            directions.forEach(d => {
                const arrow = new THREE.ArrowHelper(d.dir, box.position.clone().add(d.offset), arrowLength, arrowColor, 1.0, 0.6);
                arrow.userData.placementId = placement.id;
                arrow.userData.isPlacementArrow = true;
                arrow.userData.axis = d.axis;
                arrow.userData.sign = d.sign;
                arrow.visible = settings.showHitboxes;
                scene.add(arrow);
                placement.arrows.push(arrow);
            });
        }
        
        // Start looping particle effect
        function startLoopingParticle(placement) {
            if (!placement.enabled || !placement.loop) return;
            
            // Spawn initial particle
            spawnPlacementParticle(placement);
            
            // Get particle duration and setup loop
            loadParticleEffectFromJSON(placement.particleEffect, (config) => {
                // Loop duration = emission time only (not particle lifetime)
                const emitDuration = (config.emitDuration || 2) * 1000;
                
                if (placement.loopInterval) {
                    trackedClearInterval(placement.loopInterval);
                }
                
                placement.loopInterval = trackedSetInterval(() => {
                    if (placement.enabled && placement.loop) {
                        spawnPlacementParticle(placement);
                    }
                }, emitDuration);
            });
        }
        
        // Spawn particle at placement position
        function spawnPlacementParticle(placement) {
            spawnParticleEffect(
                placement.particleEffect,
                placement.position.x,
                placement.position.y,
                placement.position.z,
                { spawnMode: 'world', rotation: { x: 0, y: 0, z: 0 } }
            );
        }
        
        // Stop looping particle
        function stopLoopingParticle(placement) {
            if (placement.loopInterval) {
                trackedClearInterval(placement.loopInterval);
                placement.loopInterval = null;
            }
        }
        
        // Delete placement
        function deletePlacement(placement) {
            stopLoopingParticle(placement);
            
            // Remove box and arrows from scene and dispose
            if (placement.box) {
                scene.remove(placement.box);
                placement.box.geometry.dispose();
                placement.box.material.dispose();
            }
            placement.arrows.forEach(arrow => {
                scene.remove(arrow);
                arrow.geometry.dispose();
                arrow.material.dispose();
            });
            
            // Remove from array
            const index = particlePlacements.findIndex(p => p.id === placement.id);
            if (index !== -1) {
                particlePlacements.splice(index, 1);
            }
            
            saveParticlePlacements();
            closePlacementMenu();
        }
        
        // Duplicate placement
        function duplicatePlacement(placement) {
            const newPlacement = {
                id: placementIdCounter++,
                position: { x: placement.position.x + 2, y: placement.position.y, z: placement.position.z },
                particleEffect: placement.particleEffect,
                enabled: placement.enabled,
                loop: placement.loop,
                box: null,
                arrows: [],
                activeParticle: null,
                loopInterval: null
            };
            
            particlePlacements.push(newPlacement);
            createPlacementBox(newPlacement);
            
            if (newPlacement.enabled && newPlacement.loop) {
                startLoopingParticle(newPlacement);
            }
            
            saveParticlePlacements();
        }
        
        // ===== MODEL PLACEMENT SYSTEM FUNCTIONS =====
        
        // Load model placements
        function loadModelPlacements() {
            // Default permanent model placements - hardcoded in HTML, no localStorage
            modelPlacements = [
                {
                    id: 0,
                    position: { x: 17, y: -8.25, z: -31 },
                    rotation: { x: 0, y: 0, z: 0 },
                    scale: 12,
                    modelPath: 'people/female_1_idle.glb',
                    animLoop: true
                },
                {
                    id: 1,
                    position: { x: -27.25, y: -5, z: -13 },
                    rotation: { x: -5, y: 60, z: 0 },
                    scale: 12,
                    modelPath: 'people/alien_female_1_sitting_idle.glb',
                    animLoop: true
                },
                {
                    id: 2,
                    position: { x: 17, y: -8.25, z: 36 },
                    rotation: { x: 0, y: 190, z: 0 },
                    scale: 12,
                    modelPath: 'people/female_3_idle.glb',
                    animLoop: true
                },
                {
                    id: 3,
                    position: { x: -21, y: -9, z: 36 },
                    rotation: { x: 0, y: 140, z: 0 },
                    scale: 12,
                    modelPath: 'people/alien_male_1_idle.glb',
                    animLoop: true
                },
                {
                    id: 4,
                    position: { x: -25, y: -8.25, z: 16 },
                    rotation: { x: 0, y: 90, z: 0 },
                    scale: 12,
                    modelPath: 'people/female_4_idle.glb',
                    animLoop: true
                },
                {
                    id: 5,
                    position: { x: -8, y: -6.5, z: -28 },
                    rotation: { x: 0, y: 0, z: 0 },
                    scale: 14,
                    modelPath: 'people/male_2_sitting_idle.glb',
                    animLoop: true
                },
                {
                    id: 6,
                    position: { x: 34, y: -8, z: 2.5 },
                    rotation: { x: 0, y: -45, z: 0 },
                    scale: 12,
                    modelPath: 'people/alien_male_1_sitting_idle.glb',
                    animLoop: true
                }
            ];
            
            modelPlacementIdCounter = modelPlacements.length;
            
            // Recreate placement boxes and load models
            modelPlacements.forEach(placement => {
                createModelPlacementBox(placement);
                loadModelPlacementModel(placement);
            });
        }
        
        // Save model placements (disabled)
        function saveModelPlacements() {
            // Do nothing - localStorage disabled
        }
        
        // Create a new model placement
        function createModelPlacement() {
            const placement = {
                id: modelPlacementIdCounter++,
                position: { x: GRID_WIDTH / 2, y: 5, z: GRID_DEPTH / 2 },
                rotation: { x: 0, y: 0, z: 0 },
                scale: 1.0,
                modelPath: availableModels[0],
                animLoop: false,
                box: null,
                arrows: [],
                model: null,
                mixer: null
            };
            
            modelPlacements.push(placement);
            createModelPlacementBox(placement);
            loadModelPlacementModel(placement);
            saveModelPlacements();
            
            return placement;
        }
        
        // Create visual box and arrows for model placement
        function createModelPlacementBox(placement) {
            // Create box at center height (offset Y by 3 units to be at torso level instead of feet)
            const boxGeometry = new THREE.BoxGeometry(2, 2, 2);
            const boxMaterial = new THREE.MeshBasicMaterial({
                color: 0xff00ff,
                wireframe: true,
                transparent: true,
                opacity: 0.7
            });
            const box = new THREE.Mesh(boxGeometry, boxMaterial);
            box.position.set(placement.position.x, placement.position.y + 3, placement.position.z);
            box.userData.modelPlacementId = placement.id;
            box.userData.isModelPlacementBox = true;
            box.visible = settings.showHitboxes;
            scene.add(box);
            placement.box = box;
            
            // Create arrows for movement
            const arrowLength = 3.0;
            const arrowColor = 0xff00ff;
            const directions = [
                { dir: new THREE.Vector3(1, 0, 0), offset: new THREE.Vector3(3, 0, 0), axis: 'x', sign: 1 },
                { dir: new THREE.Vector3(-1, 0, 0), offset: new THREE.Vector3(-3, 0, 0), axis: 'x', sign: -1 },
                { dir: new THREE.Vector3(0, 1, 0), offset: new THREE.Vector3(0, 3, 0), axis: 'y', sign: 1 },
                { dir: new THREE.Vector3(0, -1, 0), offset: new THREE.Vector3(0, -3, 0), axis: 'y', sign: -1 },
                { dir: new THREE.Vector3(0, 0, 1), offset: new THREE.Vector3(0, 0, 3), axis: 'z', sign: 1 },
                { dir: new THREE.Vector3(0, 0, -1), offset: new THREE.Vector3(0, 0, -3), axis: 'z', sign: -1 }
            ];
            
            placement.arrows = [];
            directions.forEach(d => {
                const arrow = new THREE.ArrowHelper(d.dir, box.position.clone().add(d.offset), arrowLength, arrowColor, 1.0, 0.6);
                arrow.userData.modelPlacementId = placement.id;
                arrow.userData.isModelPlacementArrow = true;
                arrow.userData.axis = d.axis;
                arrow.userData.sign = d.sign;
                arrow.visible = settings.showHitboxes;
                scene.add(arrow);
                placement.arrows.push(arrow);
            });
        }
        
        // Load and display model
        function loadModelPlacementModel(placement) {
            // Remove old model if exists
            if (placement.model) {
                scene.remove(placement.model);
                // Dispose geometry and materials
                placement.model.traverse(child => {
                    if (child.isMesh) {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(mat => mat.dispose());
                            } else {
                                child.material.dispose();
                            }
                        }
                    }
                });
                // Dispose animation mixer if exists
                if (placement.mixer) {
                    placement.mixer.stopAllAction();
                    placement.mixer.uncacheRoot(placement.model);
                }
                placement.model = null;
                placement.mixer = null;
            }
            
            const loader = new THREE.GLTFLoader();
            loader.load(placement.modelPath, (gltf) => {
                placement.model = gltf.scene;
                placement.model.position.set(placement.position.x, placement.position.y, placement.position.z);
                placement.model.rotation.set(
                    THREE.MathUtils.degToRad(placement.rotation.x),
                    THREE.MathUtils.degToRad(placement.rotation.y),
                    THREE.MathUtils.degToRad(placement.rotation.z)
                );
                placement.model.scale.setScalar(placement.scale);
                
                placement.model.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                
                scene.add(placement.model);
                
                // Setup animation if exists
                if (gltf.animations && gltf.animations.length > 0 && placement.animLoop) {
                    placement.mixer = new THREE.AnimationMixer(placement.model);
                    const action = placement.mixer.clipAction(gltf.animations[0]);
                    action.play();
                }
            });
        }
        
        // Move model placement
        function moveModelPlacement(placement, axis, sign) {
            placement.position[axis] += sign * 2.0;
            
            // Update box position (offset Y+3 for center)
            if (axis === 'y') {
                placement.box.position.set(placement.position.x, placement.position.y + 3, placement.position.z);
            } else {
                placement.box.position.set(placement.position.x, placement.position.y + 3, placement.position.z);
            }
            
            // Update model position
            if (placement.model) {
                placement.model.position.set(placement.position.x, placement.position.y, placement.position.z);
            }
            
            // Update arrow positions
            const directions = [
                { offset: new THREE.Vector3(3, 0, 0) },
                { offset: new THREE.Vector3(-3, 0, 0) },
                { offset: new THREE.Vector3(0, 3, 0) },
                { offset: new THREE.Vector3(0, -3, 0) },
                { offset: new THREE.Vector3(0, 0, 3) },
                { offset: new THREE.Vector3(0, 0, -3) }
            ];
            
            placement.arrows.forEach((arrow, i) => {
                arrow.position.copy(placement.box.position.clone().add(directions[i].offset));
            });
            
            saveModelPlacements();
        }
        
        // Delete model placement
        function deleteModelPlacement(placement) {
            // Remove model from scene and dispose
            if (placement.model) {
                scene.remove(placement.model);
                placement.model.traverse(child => {
                    if (child.isMesh) {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(mat => mat.dispose());
                            } else {
                                child.material.dispose();
                            }
                        }
                    }
                });
            }
            // Remove box and arrows from scene and dispose
            if (placement.box) {
                scene.remove(placement.box);
                placement.box.geometry.dispose();
                placement.box.material.dispose();
            }
            placement.arrows.forEach(arrow => {
                disposeArrowHelper(arrow);
            });
            
            // Remove from array
            const index = modelPlacements.findIndex(p => p.id === placement.id);
            if (index !== -1) {
                modelPlacements.splice(index, 1);
            }
            
            saveModelPlacements();
            closeModelPlacementMenu();
        }
        
        // Duplicate model placement
        function duplicateModelPlacement(placement) {
            const newPlacement = {
                id: modelPlacementIdCounter++,
                position: { x: placement.position.x + 2, y: placement.position.y, z: placement.position.z },
                rotation: { x: placement.rotation.x, y: placement.rotation.y, z: placement.rotation.z },
                scale: placement.scale,
                modelPath: placement.modelPath,
                animLoop: placement.animLoop,
                box: null,
                arrows: [],
                model: null,
                mixer: null
            };
            
            modelPlacements.push(newPlacement);
            createModelPlacementBox(newPlacement);
            loadModelPlacementModel(newPlacement);
            saveModelPlacements();
        }
        
        // Toggle visibility of model placement boxes
        function updateModelPlacementBoxVisibility() {
            modelPlacements.forEach(placement => {
                if (placement.box) {
                    placement.box.visible = settings.showHitboxes;
                }
                placement.arrows.forEach(arrow => {
                    arrow.visible = settings.showHitboxes;
                });
            });
        }
        
        // ===== END MODEL PLACEMENT SYSTEM =====
        
        // Move placement in direction
        function movePlacement(placement, axis, sign) {
            placement.position[axis] += sign * 2.0;
            
            // Update box position
            placement.box.position.set(placement.position.x, placement.position.y, placement.position.z);
            
            // Update arrow positions
            const directions = [
                { offset: new THREE.Vector3(3, 0, 0) },
                { offset: new THREE.Vector3(-3, 0, 0) },
                { offset: new THREE.Vector3(0, 3, 0) },
                { offset: new THREE.Vector3(0, -3, 0) },
                { offset: new THREE.Vector3(0, 0, 3) },
                { offset: new THREE.Vector3(0, 0, -3) }
            ];
            
            placement.arrows.forEach((arrow, i) => {
                arrow.position.copy(placement.box.position.clone().add(directions[i].offset));
            });
            
            saveParticlePlacements();
        }
        
        // Toggle visibility of placement boxes
        function updatePlacementBoxVisibility() {
            particlePlacements.forEach(placement => {
                if (placement.box) {
                    placement.box.visible = settings.showHitboxes;
                }
                placement.arrows.forEach(arrow => {
                    arrow.visible = settings.showHitboxes;
                });
            });
        }
        
        // ===== AI PLAYER (FOR TESTING - CAN BE REMOVED LATER) =====
        let aiState = {
            enabled: false,
            nextMoveTime: 0,
            moveDelay: 100, // ms between AI moves (fast play)
            targetX: null,
            targetZ: null,
            targetRotation: 0,
            hasDecided: false
        };
        // ===== END AI PLAYER SECTION =====
        
        let highScores = [];
        let achievements = [];
        
        function loadSettings() {
            const saved = localStorage.getItem(STORAGE_KEYS.SETTINGS);
            if (saved) {
                settings = { ...settings, ...JSON.parse(saved) };
            }
            
            // ===== AI PLAYER =====
            // Initialize AI state from settings
            aiState.enabled = settings.aiEnabled;
            if (document.getElementById('aiIndicator')) {
                document.getElementById('aiIndicator').style.display = settings.aiEnabled ? 'block' : 'none';
            }
            // ===== END AI PLAYER =====
        }
        
        function saveSettings() {
            localStorage.setItem(STORAGE_KEYS.SETTINGS, JSON.stringify(settings));
        }
        
        function loadHighScores() {
            const saved = localStorage.getItem(STORAGE_KEYS.HIGH_SCORES);
            if (saved) {
                highScores = JSON.parse(saved);
            }
        }
        
        function saveHighScore(score, level) {
            const playTime = (Date.now() - stats.startTime) / 1000;
            const scorePerMinute = playTime > 0 ? Math.floor((score / playTime) * 60) : 0;
            
            const gameData = {
                score: score,
                level: level,
                startLevel: startLevel, // Track what level game started at
                usedAI: usedAI, // Track if AI was used
                time: Math.floor(playTime),
                scorePerMinute: scorePerMinute,
                date: new Date().toISOString()
            };
            
            // Add to high scores (top 20) - exclude AI games
            if (!usedAI) {
                highScores.push(gameData);
                highScores.sort((a, b) => b.score - a.score);
                highScores = highScores.slice(0, 20);
                localStorage.setItem(STORAGE_KEYS.HIGH_SCORES, JSON.stringify(highScores));
            }
            
            // Add to game history (last 5) - include all games
            let gameHistory = JSON.parse(localStorage.getItem(STORAGE_KEYS.GAME_HISTORY) || '[]');
            gameHistory.unshift(gameData);
            gameHistory = gameHistory.slice(0, 5);
            localStorage.setItem(STORAGE_KEYS.GAME_HISTORY, JSON.stringify(gameHistory));
        }
        
        // Achievement System - 50 achievements (10 easier, 10 easy, 10 mid, 10 mid-hard, 10 very hard)
        function initializeAchievements() {
            const defaultAchievements = [
                // 10 EASIER
                { id: 'first_clear', name: 'First Consensus', desc: 'Clear your first cluster', unlocked: false, tier: 'easier' },
                { id: 'score_100', name: 'Century', desc: 'Score 100 points', unlocked: false, tier: 'easier' },
                { id: 'level_2', name: 'Getting Started', desc: 'Reach level 2', unlocked: false, tier: 'easier' },
                { id: 'chains_10', name: 'Chain Reaction', desc: 'Place 10 chains', unlocked: false, tier: 'easier' },
                { id: 'clear_size_5', name: 'Small Network', desc: 'Clear a cluster of 5 links', unlocked: false, tier: 'easier' },
                { id: 'rotate_view', name: 'New Perspective', desc: 'Rotate the camera view', unlocked: false, tier: 'easier' },
                { id: 'fast_drop', name: 'Speed Demon', desc: 'Use fast drop 10 times', unlocked: false, tier: 'easier' },
                { id: 'play_5min', name: 'Patient Player', desc: 'Play for 5 minutes', unlocked: false, tier: 'easier' },
                { id: 'score_500', name: 'High Roller', desc: 'Score 500 points', unlocked: false, tier: 'easier' },
                { id: 'cascade_once', name: 'Gravity Works', desc: 'Trigger a cascade', unlocked: false, tier: 'easier' },
                
                // 10 EASY
                { id: 'level_5', name: 'Novice Miner', desc: 'Reach level 5', unlocked: false, tier: 'easy' },
                { id: 'score_1000', name: 'One Thousand', desc: 'Score 1,000 points', unlocked: false, tier: 'easy' },
                { id: 'combo_2x', name: 'Double Trouble', desc: 'Achieve Ã—2.0 combo multiplier', unlocked: false, tier: 'easy' },
                { id: 'clear_size_8', name: 'Medium Network', desc: 'Clear a cluster of 8 links', unlocked: false, tier: 'easy' },
                { id: 'chains_50', name: 'Chain Master', desc: 'Place 50 chains', unlocked: false, tier: 'easy' },
                { id: 'level_10', name: 'Double Digits', desc: 'Reach level 10', unlocked: false, tier: 'easy' },
                { id: 'clears_25', name: 'Quarter Century', desc: 'Clear 25 clusters', unlocked: false, tier: 'easy' },
                { id: 'all_types', name: 'Rainbow Miner', desc: 'Clear all 4 link types', unlocked: false, tier: 'easy' },
                { id: 'score_5000', name: 'Five Grand', desc: 'Score 5,000 points', unlocked: false, tier: 'easy' },
                { id: 'cascade_5', name: 'Chain Specialist', desc: 'Trigger 5 cascades in one game', unlocked: false, tier: 'easy' },
                
                // 10 MID
                { id: 'level_15', name: 'Experienced', desc: 'Reach level 15', unlocked: false, tier: 'mid' },
                { id: 'score_10000', name: 'Ten Thousand', desc: 'Score 10,000 points', unlocked: false, tier: 'mid' },
                { id: 'combo_3x', name: 'Triple Threat', desc: 'Achieve Ã—3.0 combo multiplier', unlocked: false, tier: 'mid' },
                { id: 'clear_size_12', name: 'Large Network', desc: 'Clear a cluster of 12 links', unlocked: false, tier: 'mid' },
                { id: 'level_25', name: 'Quarter Master', desc: 'Reach level 25', unlocked: false, tier: 'mid' },
                { id: 'clears_100', name: 'Centurion', desc: 'Clear 100 clusters', unlocked: false, tier: 'mid' },
                { id: 'score_25000', name: 'Twenty-Five K', desc: 'Score 25,000 points', unlocked: false, tier: 'mid' },
                { id: 'chains_200', name: 'Chain Veteran', desc: 'Place 200 chains', unlocked: false, tier: 'mid' },
                { id: 'combo_4x', name: 'Quadruple Power', desc: 'Achieve Ã—4.0 combo multiplier', unlocked: false, tier: 'mid' },
                { id: 'score_50000', name: 'Fifty K', desc: 'Score 50,000 points', unlocked: false, tier: 'mid' },
                
                // 10 MID-HARD
                { id: 'level_40', name: 'Advanced Miner', desc: 'Reach level 40', unlocked: false, tier: 'mid-hard' },
                { id: 'score_100000', name: 'Six Figures', desc: 'Score 100,000 points', unlocked: false, tier: 'mid-hard' },
                { id: 'combo_5x', name: 'Maximum Combo', desc: 'Achieve Ã—5.0 combo multiplier', unlocked: false, tier: 'mid-hard' },
                { id: 'clear_size_20', name: 'Massive Network', desc: 'Clear a cluster of 20 links', unlocked: false, tier: 'mid-hard' },
                { id: 'level_50', name: 'Halfway There', desc: 'Reach level 50', unlocked: false, tier: 'mid-hard' },
                { id: 'clears_250', name: 'Clear Mastery', desc: 'Clear 250 clusters', unlocked: false, tier: 'mid-hard' },
                { id: 'score_250000', name: 'Quarter Million', desc: 'Score 250,000 points', unlocked: false, tier: 'mid-hard' },
                { id: 'combo_5x_x5', name: 'Combo King', desc: 'Achieve Ã—5.0 combo 5 times in one game', unlocked: false, tier: 'mid-hard' },
                { id: 'cascade_double', name: 'Double Cascade', desc: 'Trigger 2 cascades from one clear', unlocked: false, tier: 'mid-hard' },
                { id: 'score_500000', name: 'Half Million', desc: 'Score 500,000 points', unlocked: false, tier: 'mid-hard' },
                
                // 10 VERY HARD
                { id: 'level_75', name: 'Elite Miner', desc: 'Reach level 75', unlocked: false, tier: 'very-hard' },
                { id: 'score_1000000', name: 'Millionaire', desc: 'Score 1,000,000 points', unlocked: false, tier: 'very-hard' },
                { id: 'level_99', name: 'Veil Threshold', desc: 'Reach level 99', unlocked: false, tier: 'very-hard' },
                { id: 'veil_protocol', name: 'Decryption Attempted', desc: 'Enter Veil Protocol', unlocked: false, tier: 'very-hard' },
                { id: 'clear_size_30', name: 'Mega Network', desc: 'Clear a cluster of 30 links', unlocked: false, tier: 'very-hard' },
                { id: 'clears_500', name: 'Clear Legend', desc: 'Clear 500 clusters in one game', unlocked: false, tier: 'very-hard' },
                { id: 'perfect_10', name: 'Perfect Ten', desc: 'Clear 10 clusters in a row without missing', unlocked: false, tier: 'very-hard' },
                { id: 'veil_100', name: 'Veil Survivor', desc: 'Place 100 chains in Veil Protocol', unlocked: false, tier: 'very-hard' },
                { id: 'veil_complete', name: 'Satoshi\'s Shadow', desc: 'Complete all 1000 moves in Veil Protocol', unlocked: false, tier: 'very-hard' },
                { id: 'score_5000000', name: 'Legend', desc: 'Score 5,000,000 points', unlocked: false, tier: 'very-hard' }
            ];
            
            const saved = localStorage.getItem(STORAGE_KEYS.ACHIEVEMENTS);
            if (saved) {
                achievements = JSON.parse(saved);
                // Merge with defaults in case new achievements added
                defaultAchievements.forEach(def => {
                    if (!achievements.find(a => a.id === def.id)) {
                        achievements.push(def);
                    }
                });
            } else {
                achievements = defaultAchievements;
            }
        }
        
        function unlockAchievement(id) {
            const achievement = achievements.find(a => a.id === id);
            if (achievement && !achievement.unlocked) {
                achievement.unlocked = true;
                localStorage.setItem(STORAGE_KEYS.ACHIEVEMENTS, JSON.stringify(achievements));
                showAchievementNotification(achievement);
            }
        }
        
        function showAchievementNotification(achievement) {
            // Create notification popup
            const notif = document.createElement('div');
            notif.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: linear-gradient(135deg, #F2C94C, #FFD85A);
                color: #0B0E12;
                padding: 20px 30px;
                border-radius: 14px;
                font-weight: 700;
                font-size: 18px;
                box-shadow: 0 10px 30px rgba(242, 201, 76, 0.5);
                z-index: 1000;
                animation: slideIn 0.3s ease-out;
            `;
            notif.innerHTML = `
                <div style="font-size: 14px; opacity: 0.8; margin-bottom: 4px;">ACHIEVEMENT UNLOCKED</div>
                <div style="font-size: 20px; font-weight: 900;">${achievement.name}</div>
                <div style="font-size: 14px; margin-top: 4px;">${achievement.desc}</div>
            `;
            document.body.appendChild(notif);
            
            trackedSetTimeout(() => {
                notif.style.animation = 'slideOut 0.3s ease-in';
                trackedSetTimeout(() => document.body.removeChild(notif), 300);
            }, 3000);
        }
        
        // Track stats for achievements
        let stats = {
            chainsPlaced: 0,
            clustersCleared: 0,
            cascadesTriggered: 0,
            fastDropsUsed: 0,
            typesClearedSet: new Set(),
            maxComboReached: 1.0,
            combo5xCount: 0,
            startTime: null,
            consecutiveClears: 0,
            veilMoves: 0
        };
        
        function checkAchievements() {
            // Only award achievements if started from level 1 or 10 (tutorial skip is OK)
            // Starting at level 50+ disables most achievements
            const earnedNotSkipped = (startLevel === 1 || startLevel === 10);
            
            // Score-based (only if earned)
            if (earnedNotSkipped) {
                if (score >= 100) unlockAchievement('score_100');
                if (score >= 500) unlockAchievement('score_500');
                if (score >= 1000) unlockAchievement('score_1000');
                if (score >= 5000) unlockAchievement('score_5000');
                if (score >= 10000) unlockAchievement('score_10000');
                if (score >= 25000) unlockAchievement('score_25000');
                if (score >= 50000) unlockAchievement('score_50000');
                if (score >= 100000) unlockAchievement('score_100000');
                if (score >= 250000) unlockAchievement('score_250000');
                if (score >= 500000) unlockAchievement('score_500000');
                if (score >= 1000000) unlockAchievement('score_1000000');
                if (score >= 5000000) unlockAchievement('score_5000000');
            }
            
            // Level-based (special rules)
            if (earnedNotSkipped) {
                // All levels if earned from level 1
                if (level >= 2) unlockAchievement('level_2');
                if (level >= 5) unlockAchievement('level_5');
                if (level >= 10) unlockAchievement('level_10');
                if (level >= 15) unlockAchievement('level_15');
                if (level >= 25) unlockAchievement('level_25');
                if (level >= 40) unlockAchievement('level_40');
                if (level >= 50) unlockAchievement('level_50');
                if (level >= 75) unlockAchievement('level_75');
                if (level >= 99) unlockAchievement('level_99');
            } else {
                // If skipped, only award the exact milestone you started at or above
                if (startLevel === 10 && level >= 10) unlockAchievement('level_10');
                if (startLevel === 50 && level >= 50) unlockAchievement('level_50');
                if (startLevel === 100 && level >= 99) unlockAchievement('level_99');
                if (startLevel === 1000 && level >= 99) unlockAchievement('level_99');
                if (startLevel === 10000 && level >= 99) unlockAchievement('level_99');
            }
            
            // Stats-based (only if earned)
            if (earnedNotSkipped) {
                if (stats.chainsPlaced >= 10) unlockAchievement('chains_10');
                if (stats.chainsPlaced >= 50) unlockAchievement('chains_50');
                if (stats.chainsPlaced >= 200) unlockAchievement('chains_200');
                
                if (stats.clustersCleared >= 25) unlockAchievement('clears_25');
                if (stats.clustersCleared >= 100) unlockAchievement('clears_100');
                if (stats.clustersCleared >= 250) unlockAchievement('clears_250');
                if (stats.clustersCleared >= 500) unlockAchievement('clears_500');
                
                if (stats.cascadesTriggered >= 1) unlockAchievement('cascade_once');
                if (stats.cascadesTriggered >= 5) unlockAchievement('cascade_5');
                
                if (stats.typesClearedSet.size >= 4) unlockAchievement('all_types');
                
                // Combo-based
                if (stats.maxComboReached >= 2.0) unlockAchievement('combo_2x');
                if (stats.maxComboReached >= 3.0) unlockAchievement('combo_3x');
                if (stats.maxComboReached >= 4.0) unlockAchievement('combo_4x');
                if (stats.maxComboReached >= 5.0) unlockAchievement('combo_5x');
                if (stats.combo5xCount >= 5) unlockAchievement('combo_5x_x5');
                
                if (stats.consecutiveClears >= 10) unlockAchievement('perfect_10');
            }
        }
        
        // Game Controls Functions
        let lightsEnabled = true;
        let particlesEnabled = true;
        let wallEmissiveEnabled = true;
        let modelsEnabled = true;
        let animationsEnabled = true;
        let highQualityMode = true; // true = High Performance, false = Cartoon
        
        function toggleLights() {
            lightsEnabled = !lightsEnabled;
            const lightsBtn = document.getElementById('lightsBtn');
            if (!lightsEnabled) {
                keyLight.intensity = 0;
                fillLight.intensity = 0;
                ambientLight.intensity = 0.05;
                rimLight.intensity = 0;
                if (playerLight) playerLight.intensity = 0;
                lightsBtn.textContent = 'ðŸŒ‘';
                lightsBtn.classList.remove('active');
            } else {
                keyLight.intensity = 1.2;
                fillLight.intensity = 0.6;
                ambientLight.intensity = 0.3;
                rimLight.intensity = 0.4;
                if (playerLight && !isTopDownView) playerLight.intensity = 8.0;
                lightsBtn.textContent = 'ðŸ’¡';
                lightsBtn.classList.add('active');
            }
        }
        
        function toggleParticles() {
            particlesEnabled = !particlesEnabled;
            const particlesBtn = document.getElementById('particlesBtn');
            if (particlesEnabled) {
                particlesBtn.textContent = 'âœ¨';
                particlesBtn.classList.add('active');
            } else {
                particlesBtn.textContent = 'âŒ';
                particlesBtn.classList.remove('active');
            }
        }
        
        function toggleQuality() {
            highQualityMode = !highQualityMode;
            const qualityBtn = document.getElementById('qualityBtn');
            if (highQualityMode) {
                qualityBtn.textContent = 'ðŸŽ­';
                qualityBtn.title = 'Quality: High Performance';
                qualityBtn.classList.add('active');
                applyHighQualityMode();
            } else {
                qualityBtn.textContent = 'ðŸŽ¨';
                qualityBtn.title = 'Quality: Cartoon';
                qualityBtn.classList.remove('active');
                applyCartoonMode();
            }
        }
        
        function applyHighQualityMode() {
            // Update all chain instances in grid
            for (let x = 0; x < GRID_WIDTH; x++) {
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    for (let z = 0; z < GRID_DEPTH; z++) {
                        if (grid[x][y][z] && grid[x][y][z].mesh) {
                            const materialKey = getMaterialKeyForType(grid[x][y][z].type);
                            grid[x][y][z].mesh.traverse(child => {
                                if (child.isMesh && child.material) {
                                    child.material = materialsHQ[materialKey];
                                }
                            });
                        }
                    }
                }
            }
            
            // Update falling chain if exists
            if (fallingChain) {
                fallingChain.links.forEach(link => {
                    if (link.mesh) {
                        const materialKey = getMaterialKeyForType(link.type);
                        link.mesh.traverse(child => {
                            if (child.isMesh && child.material) {
                                child.material = materialsHQ[materialKey];
                            }
                        });
                    }
                });
            }
            
            // Update corner chain columns (use random HQ materials)
            cornerChains.forEach(chainColumn => {
                chainColumn.links.forEach((link) => {
                    const materialKeys = ['yellow', 'blue', 'green', 'red'];
                    const randomKey = materialKeys[Math.floor(Math.random() * materialKeys.length)];
                    link.traverse(child => {
                        if (child.isMesh && child.material) {
                            child.material = materialsHQ[randomKey];
                        }
                    });
                });
            });
        }
        
        function applyCartoonMode() {
            // Update all chain instances in grid
            for (let x = 0; x < GRID_WIDTH; x++) {
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    for (let z = 0; z < GRID_DEPTH; z++) {
                        if (grid[x][y][z] && grid[x][y][z].mesh) {
                            const materialKey = getMaterialKeyForType(grid[x][y][z].type);
                            grid[x][y][z].mesh.traverse(child => {
                                if (child.isMesh && child.material) {
                                    child.material = materialsLQ[materialKey];
                                }
                            });
                        }
                    }
                }
            }
            
            // Update falling chain if exists
            if (fallingChain) {
                fallingChain.links.forEach(link => {
                    if (link.mesh) {
                        const materialKey = getMaterialKeyForType(link.type);
                        link.mesh.traverse(child => {
                            if (child.isMesh && child.material) {
                                child.material = materialsLQ[materialKey];
                            }
                        });
                    }
                });
            }
            
            // Update corner chain columns (use random LQ materials)
            cornerChains.forEach(chainColumn => {
                chainColumn.links.forEach((link) => {
                    const materialKeys = ['yellow', 'blue', 'green', 'red'];
                    const randomKey = materialKeys[Math.floor(Math.random() * materialKeys.length)];
                    link.traverse(child => {
                        if (child.isMesh && child.material) {
                            child.material = materialsLQ[randomKey];
                        }
                    });
                });
            });
        }
        
        function getMaterialKeyForType(linkType) {
            if (!linkType) return 'yellow';
            switch(linkType.name) {
                case 'ZEC-A': return 'yellow';
                case 'ZEC-B': return 'blue';
                case 'ZEC-C': return 'green';
                case 'ZEC-D': return 'red';
                default: return 'yellow';
            }
        }
        
        function toggleButton1() {
            wallEmissiveEnabled = !wallEmissiveEnabled;
            const wallEmissiveBtn = document.getElementById('wallEmissiveBtn');
            // If disabling, set all walls to low emissive
            if (!wallEmissiveEnabled) {
                roomWalls.forEach(wall => {
                    if (wall.material && wall.material.emissiveIntensity !== undefined) {
                        wall.material.emissiveIntensity = 0.05; // Very dim
                    }
                });
                wallEmissiveBtn.textContent = 'âš«';
                wallEmissiveBtn.classList.remove('active');
            } else {
                wallEmissiveBtn.textContent = 'ðŸ’ ';
                wallEmissiveBtn.classList.add('active');
            }
            // updateLEDPulse will resume animation when enabled
        }
        
        function toggleButton2() {
            modelsEnabled = !modelsEnabled;
            const modelsBtn = document.getElementById('modelsBtn');
            
            // Toggle visibility of all model placements
            modelPlacements.forEach(placement => {
                if (placement.model) {
                    placement.model.visible = modelsEnabled;
                }
            });
            
            // Update button state
            if (modelsEnabled) {
                modelsBtn.textContent = 'ðŸ§';
                modelsBtn.classList.add('active');
            } else {
                modelsBtn.textContent = 'âŒ';
                modelsBtn.classList.remove('active');
            }
        }
        
        function toggleButton3() {
            animationsEnabled = !animationsEnabled;
            const animationsBtn = document.getElementById('animationsBtn');
            
            // If disabling, pause all animations at current frame
            // If enabling, animations will resume updating in animate loop
            
            // Update button state
            if (animationsEnabled) {
                animationsBtn.textContent = 'ðŸŽ¬';
                animationsBtn.classList.add('active');
            } else {
                animationsBtn.textContent = 'âŒ';
                animationsBtn.classList.remove('active');
            }
        }
        
        // Color picker settings
        let floorHintColor = 0x00FFFF; // Default cyan
        let laserLineColor = 0x00FFFF; // Default cyan
        let floorHintEnabled = true;
        let laserLineEnabled = true;
        let tempFloorColor = null;
        let tempLaserColor = null;
        let tempFloorEnabled = true;
        let tempLaserEnabled = true;
        
        function toggleColorPicker() {
            const modal = document.getElementById('colorPickerModal');
            const btn = document.getElementById('colorPickerBtn');
            if (modal.style.display === 'none') {
                // Store current settings as temp
                tempFloorColor = floorHintColor;
                tempLaserColor = laserLineColor;
                tempFloorEnabled = floorHintEnabled;
                tempLaserEnabled = laserLineEnabled;
                
                // Update color pickers to current values
                if (floorHintEnabled) {
                    document.getElementById('floorColorPicker').value = '#' + floorHintColor.toString(16).padStart(6, '0').toUpperCase();
                }
                if (laserLineEnabled) {
                    document.getElementById('laserColorPicker').value = '#' + laserLineColor.toString(16).padStart(6, '0').toUpperCase();
                }
                
                // Position modal above the button
                const rect = btn.getBoundingClientRect();
                
                modal.style.position = 'fixed';
                modal.style.left = (rect.left + rect.width / 2) + 'px';
                modal.style.bottom = (window.innerHeight - rect.top + 5) + 'px';
                modal.style.transform = 'translateX(-50%)';
                
                modal.style.display = 'block';
            } else {
                modal.style.display = 'none';
            }
        }
        
        function toggleControls() {
            const panel = document.getElementById('instructions');
            const btn = document.getElementById('controlsBtn');
            const tooltip = document.getElementById('controlsHintTooltip');
            if (panel.classList.contains('show')) {
                panel.classList.remove('show');
                btn.classList.remove('active');
            } else {
                panel.classList.add('show');
                btn.classList.add('active');
                btn.classList.remove('hint'); // Stop hint animation when opened
                tooltip.classList.remove('show');
                tooltip.style.display = 'none';
            }
        }
        
        function cycleGridEffect() {
            currentGridEffect = (currentGridEffect + 1) % GRID_EFFECTS.length;
            const effect = GRID_EFFECTS[currentGridEffect];
            const btn = document.getElementById('gridEffectBtn');
            btn.textContent = effect.icon;
            btn.title = `Grid Effect: ${effect.name}`;
            applyGridEffect();
        }
        
        function applyGridEffect() {
            const effect = GRID_EFFECTS[currentGridEffect];
            const time = Date.now() * 0.001; // Convert to seconds
            
            // Find all grid lines in the scene (they are THREE.Line objects with LineBasicMaterial)
            const gridLines = [];
            scene.traverse((object) => {
                if (object instanceof THREE.Line && object.material instanceof THREE.LineBasicMaterial) {
                    gridLines.push(object);
                }
            });
            
            if (gridLines.length === 0) return;
            
            gridLines.forEach((line, index) => {
                if (!line.material) return;
                
                // Handle solid color effects
                if (effect.solid) {
                    line.material.color.setHex(effect.color);
                    line.material.opacity = 0.6;
                    return;
                }
                
                switch(effect.name) {
                    case 'None':
                        line.material.color.setHex(0x233142);
                        line.material.opacity = 0.3;
                        break;
                        
                    case 'Pulse Wave':
                        const pulse = Math.sin(time * 0.3 + index * 0.05) * 0.5 + 0.5;
                        line.material.color.setRGB(0, pulse * 0.8, pulse);
                        line.material.opacity = 0.3 + pulse * 0.4;
                        break;
                        
                    case 'Neon Glow':
                        line.material.color.setHex(0x00FFFF);
                        line.material.opacity = 0.6 + Math.sin(time * 3) * 0.2;
                        break;
                        
                    case 'Rainbow Spectrum':
                        const hue = (time * 0.2 + index * 0.05) % 1;
                        line.material.color.setHSL(hue, 1, 0.5);
                        line.material.opacity = 0.5;
                        break;
                        
                    case 'Digital Matrix':
                        const matrix = Math.sin(time * 1.5 + index * 0.2) * 0.5 + 0.5;
                        line.material.color.setHex(0x00FF00);
                        line.material.opacity = 0.2 + matrix * 0.5;
                        break;
                        
                    case 'Plasma Field':
                        const plasma = Math.sin(time * 2 + index * 0.3) * Math.cos(time * 1.5 + index * 0.2);
                        line.material.color.setRGB(plasma * 0.5 + 0.5, 0.2, 1 - (plasma * 0.5 + 0.5));
                        line.material.opacity = 0.4 + Math.abs(plasma) * 0.3;
                        break;
                        
                    case 'Crystal Refraction':
                        const crystal = (Math.sin(time + index * 0.15) + 1) * 0.5;
                        line.material.color.setRGB(crystal, crystal * 0.8 + 0.2, 1);
                        line.material.opacity = 0.3 + crystal * 0.4;
                        break;
                        
                    case 'Synthwave Grid':
                        const synth = index % 2 === 0 ? 0xFF1493 : 0x00CED1;
                        line.material.color.setHex(synth);
                        line.material.opacity = 0.4 + Math.sin(time * 2) * 0.2;
                        break;
                        
                    case 'Cyber Scanlines':
                        const scan = Math.sin(time * 1.2 + index * 0.25) * 0.5 + 0.5;
                        line.material.color.setHex(0x00FFAA);
                        line.material.opacity = 0.3 + scan * 0.5;
                        break;
                        
                    case 'Hypnotic Spiral':
                        const spiral = Math.sin(time * 3 + index * 0.2) * 0.5 + 0.5;
                        const spiralHue = (time * 0.3 + index * 0.1) % 1;
                        line.material.color.setHSL(spiralHue, 0.8, 0.5);
                        line.material.opacity = 0.3 + spiral * 0.5;
                        break;
                        
                    case 'Quantum Shimmer':
                        const shimmer = Math.sin(time * 2.5 + index * 0.15) * 0.5 + 0.5;
                        const qHue = (time * 0.3 + index * 0.08) % 1;
                        line.material.color.setHSL(qHue, 1, 0.4 + shimmer * 0.3);
                        line.material.opacity = 0.4 + shimmer * 0.4;
                        break;
                }
            });
            
            // Apply coordinated tube animations
            applyTubeEffects(effect, time);
        }
        
        function applyTubeEffects(effect, time) {
            if (columnTubes.length === 0) return;
            
            columnTubes.forEach((tube, tubeIndex) => {
                if (!tube.material) return;
                
                const gridX = tube.userData.gridX || 0;
                const gridZ = tube.userData.gridZ || 0;
                const posIndex = gridX + gridZ * GRID_WIDTH;
                
                // Center position for radial effects
                const centerX = GRID_WIDTH / 2;
                const centerZ = GRID_DEPTH / 2;
                const distFromCenter = Math.sqrt(Math.pow(gridX - centerX, 2) + Math.pow(gridZ - centerZ, 2));
                const maxDist = Math.sqrt(centerX * centerX + centerZ * centerZ);
                const normalizedDist = distFromCenter / maxDist;
                
                // Angle from center for spiral/radial effects
                const angleFromCenter = Math.atan2(gridZ - centerZ, gridX - centerX);
                
                // Handle solid color effects
                if (effect.solid) {
                    const solidHue = (time * 0.2 + normalizedDist * 0.5) % 1;
                    tube.material.color.setHSL(solidHue, 1, 0.5);
                    tube.material.opacity = 0.25 + Math.sin(time * 2 + posIndex * 0.3) * 0.15;
                    return;
                }
                
                switch(effect.name) {
                    case 'None':
                        tube.material.color.setHex(0x00FFFF);
                        tube.material.opacity = 0.3;
                        break;
                        
                    case 'Pulse Wave':
                        // Center out pulse rings
                        const pulseRing = Math.sin(time * 2 - distFromCenter * 0.5) * 0.5 + 0.5;
                        const pulseHue = (time * 0.1 + normalizedDist * 0.3) % 1;
                        tube.material.color.setHSL(pulseHue, 1, 0.5);
                        tube.material.opacity = 0.2 + pulseRing * 0.6;
                        break;
                        
                    case 'Deep Ocean':
                        // Outside in wave collapse
                        const collapseWave = Math.sin(time * 2.5 + (1 - normalizedDist) * Math.PI * 4) * 0.5 + 0.5;
                        const oceanHue = 0.55 + collapseWave * 0.1; // Blue to cyan
                        tube.material.color.setHSL(oceanHue, 0.9, 0.4 + collapseWave * 0.3);
                        tube.material.opacity = 0.25 + collapseWave * 0.5;
                        break;
                        
                    case 'Neon Glow':
                        // Horizontal stripes scrolling
                        const stripePhase = Math.sin(time * 3 + gridZ * 0.8) * 0.5 + 0.5;
                        const neonHue = 0.5 + stripePhase * 0.15; // Cyan to blue
                        tube.material.color.setHSL(neonHue, 1, 0.5 + stripePhase * 0.2);
                        tube.material.opacity = 0.3 + stripePhase * 0.5;
                        break;
                        
                    case 'Hot Pink':
                        // Vertical stripes scrolling
                        const vStripe = Math.sin(time * 3.5 + gridX * 0.8) * 0.5 + 0.5;
                        const pinkHue = 0.9 + vStripe * 0.08; // Pink to magenta
                        tube.material.color.setHSL(pinkHue, 1, 0.5 + vStripe * 0.2);
                        tube.material.opacity = 0.25 + vStripe * 0.5;
                        break;
                        
                    case 'Rainbow Spectrum':
                        // Diagonal rainbow sweep
                        const diagPhase = (time * 0.3 + (gridX + gridZ) * 0.15) % 1;
                        tube.material.color.setHSL(diagPhase, 1, 0.5);
                        tube.material.opacity = 0.3 + Math.sin(diagPhase * Math.PI * 2) * 0.3;
                        break;
                        
                    case 'Lime Green':
                        // Checkerboard flash
                        const checker = (gridX + gridZ) % 2;
                        const flash = Math.sin(time * 4 + checker * Math.PI) * 0.5 + 0.5;
                        const greenHue = 0.3 + flash * 0.1; // Lime to yellow-green
                        tube.material.color.setHSL(greenHue, 1, 0.5 + flash * 0.2);
                        tube.material.opacity = 0.2 + flash * 0.6;
                        break;
                        
                    case 'Digital Matrix':
                        // Random column drops like Matrix code
                        const dropPhase = (time * 2 + gridX * 0.5) % (Math.PI * 2);
                        const dropIntensity = Math.max(0, Math.sin(dropPhase));
                        const matrixFlicker = Math.random() < 0.1 ? 1.5 : 1;
                        tube.material.color.setHSL(0.33, 1, 0.3 + dropIntensity * 0.4); // Green
                        tube.material.opacity = (0.15 + dropIntensity * 0.6) * matrixFlicker;
                        break;
                        
                    case 'Deep Purple':
                        // Rotating quad sections
                        const quadrant = (Math.floor((angleFromCenter + Math.PI) / (Math.PI / 2)) % 4);
                        const quadPhase = Math.sin(time * 2 + quadrant * Math.PI / 2) * 0.5 + 0.5;
                        tube.material.color.setHSL(0.75 + quadPhase * 0.1, 1, 0.4 + quadPhase * 0.3);
                        tube.material.opacity = 0.25 + quadPhase * 0.5;
                        break;
                        
                    case 'Plasma Field':
                        // Lumines-style plasma swirl
                        const plasmaX = Math.sin(time * 1.5 + gridX * 0.4);
                        const plasmaZ = Math.cos(time * 1.2 + gridZ * 0.35);
                        const plasmaHue = ((plasmaX + plasmaZ) * 0.5 + 0.5 + time * 0.1) % 1;
                        const plasmaBright = Math.abs(plasmaX * plasmaZ);
                        tube.material.color.setHSL(plasmaHue, 1, 0.4 + plasmaBright * 0.3);
                        tube.material.opacity = 0.25 + plasmaBright * 0.5;
                        break;
                        
                    case 'Amber Gold':
                        // Expanding/contracting rings
                        const ringPhase = Math.sin(time * 1.8) * maxDist * 0.5;
                        const ringMatch = 1 - Math.abs(distFromCenter - ringPhase) / (maxDist * 0.2);
                        const ringIntensity = Math.max(0, ringMatch);
                        tube.material.color.setHSL(0.12 + ringIntensity * 0.05, 1, 0.4 + ringIntensity * 0.4);
                        tube.material.opacity = 0.2 + ringIntensity * 0.6;
                        break;
                        
                    case 'Crystal Refraction':
                        // Prismatic radial burst
                        const burstHue = (angleFromCenter / (Math.PI * 2) + time * 0.2) % 1;
                        const burstPulse = Math.sin(time * 2.5 - distFromCenter * 0.6) * 0.5 + 0.5;
                        tube.material.color.setHSL(burstHue, 1, 0.5 + burstPulse * 0.2);
                        tube.material.opacity = 0.2 + burstPulse * 0.6;
                        break;
                        
                    case 'Crimson Red':
                        // Pulsing cross pattern
                        const crossDist = Math.min(Math.abs(gridX - centerX), Math.abs(gridZ - centerZ));
                        const crossPulse = Math.sin(time * 3 - crossDist * 0.5) * 0.5 + 0.5;
                        tube.material.color.setHSL(0, 1, 0.4 + crossPulse * 0.3);
                        tube.material.opacity = 0.25 + crossPulse * 0.5;
                        break;
                        
                    case 'Synthwave Grid':
                        // Alternating wave pattern
                        const synthWave = (gridX % 2) + (gridZ % 2);
                        const synthTime = Math.sin(time * 2.5 + synthWave * Math.PI / 2) * 0.5 + 0.5;
                        const synthHue = synthWave === 1 ? 0.9 : 0.5; // Pink or cyan
                        tube.material.color.setHSL(synthHue, 1, 0.5 + synthTime * 0.2);
                        tube.material.opacity = 0.25 + synthTime * 0.5;
                        break;
                        
                    case 'Aqua Mint':
                        // Diagonal wave sweep
                        const diagWave = Math.sin(time * 2 + (gridX - gridZ) * 0.5) * 0.5 + 0.5;
                        tube.material.color.setHSL(0.5, 0.7, 0.5 + diagWave * 0.3);
                        tube.material.opacity = 0.2 + diagWave * 0.5;
                        break;
                        
                    case 'Cyber Scanlines':
                        // Grid scanlines X and Z
                        const scanX = Math.abs(Math.sin(time * 1.5 + gridX * 0.5));
                        const scanZ = Math.abs(Math.sin(time * 1.2 + gridZ * 0.5));
                        const scanCombined = (scanX + scanZ) * 0.5;
                        tube.material.color.setHSL(0.45, 1, 0.4 + scanCombined * 0.4);
                        tube.material.opacity = 0.15 + scanCombined * 0.6;
                        break;
                        
                    case 'Electric Blue':
                        // Lightning arcs between tubes
                        const arcPhase = Math.sin(time * 5 + posIndex * 0.3);
                        const lightningBolt = Math.random() < 0.05 ? 2 : 1;
                        const arcIntensity = (arcPhase * 0.5 + 0.5) * lightningBolt;
                        tube.material.color.setHSL(0.55, 1, 0.4 + arcIntensity * 0.4);
                        tube.material.opacity = Math.min(0.2 + arcIntensity * 0.6, 0.9);
                        break;
                        
                    case 'Hypnotic Spiral':
                        // Rotating spiral from center
                        const spiralPhase = (angleFromCenter + time * 2) % (Math.PI * 2);
                        const spiralRing = Math.sin(spiralPhase * 3 - distFromCenter * 1.5) * 0.5 + 0.5;
                        const spiralHue = (time * 0.25 + normalizedDist * 0.5 + spiralPhase / (Math.PI * 2)) % 1;
                        tube.material.color.setHSL(spiralHue, 1, 0.4 + spiralRing * 0.3);
                        tube.material.opacity = 0.2 + spiralRing * 0.6;
                        break;
                        
                    case 'Sunset Orange':
                        // Horizontal gradient waves
                        const sunsetWave = Math.sin(time * 1.5 + gridZ * 0.4) * 0.5 + 0.5;
                        const sunsetHue = 0.08 + sunsetWave * 0.05; // Orange to red-orange
                        tube.material.color.setHSL(sunsetHue, 1, 0.5 + sunsetWave * 0.2);
                        tube.material.opacity = 0.25 + sunsetWave * 0.5;
                        break;
                        
                    case 'Quantum Shimmer':
                        // Random quantum state changes
                        const quantumPhase = (time * 0.5 + posIndex * 0.2) % 1;
                        const quantumJump = Math.sin(time * 8 + posIndex) > 0.8 ? 1.3 : 1;
                        const quantumHue = (quantumPhase + Math.sin(time * 4) * 0.2) % 1;
                        tube.material.color.setHSL(quantumHue, 1, 0.4 + quantumPhase * 0.3);
                        tube.material.opacity = (0.25 + quantumPhase * 0.5) * quantumJump;
                        break;
                        
                    case 'Violet Dream':
                        // Soft radial pulse
                        const dreamPulse = Math.sin(time * 1.4 - distFromCenter * 0.4) * 0.5 + 0.5;
                        tube.material.color.setHSL(0.8, 0.7, 0.4 + dreamPulse * 0.3);
                        tube.material.opacity = 0.2 + dreamPulse * 0.5;
                        break;
                }
            });
            
            // Apply effects to corner tubes (tubes around chain columns)
            applyCornerTubeEffects(effect, time);
        }
        
        function applyCornerTubeEffects(effect, time) {
            if (cornerTubes.length === 0) return;
            
            cornerTubes.forEach((tube, index) => {
                if (!tube.material) return;
                
                // Keep opacity mostly static (subtle changes only)
                const baseOpacity = 0.3;
                const opacityRange = 0.15;
                
                // Handle solid color effects
                if (effect.solid) {
                    const solidHue = (time * 0.25 + index * 0.25) % 1;
                    tube.material.color.setHSL(solidHue, 1, 0.5);
                    tube.material.opacity = baseOpacity + Math.sin(time * 1.5 + index * 0.5) * opacityRange;
                    return;
                }
                
                switch(effect.name) {
                    case 'None':
                        tube.material.color.setHex(0x00FFFF);
                        tube.material.opacity = baseOpacity;
                        break;
                        
                    case 'Pulse Wave':
                        // Sequential pulse around the 4 corners
                        const pulseTiming = Math.sin(time * 2 - index * Math.PI / 2) * 0.5 + 0.5;
                        const pulseHue = (time * 0.15 + index * 0.25) % 1;
                        tube.material.color.setHSL(pulseHue, 1, 0.4 + pulseTiming * 0.3);
                        tube.material.opacity = baseOpacity + pulseTiming * opacityRange;
                        break;
                        
                    case 'Deep Ocean':
                        // All pulse together, different hues
                        const oceanWave = Math.sin(time * 2.5) * 0.5 + 0.5;
                        tube.material.color.setHSL(0.55 + oceanWave * 0.1 + index * 0.05, 0.9, 0.4 + oceanWave * 0.3);
                        tube.material.opacity = baseOpacity + oceanWave * opacityRange;
                        break;
                        
                    case 'Neon Glow':
                        // Alternating pairs flash
                        const neonFlash = Math.sin(time * 3 + (index % 2) * Math.PI) * 0.5 + 0.5;
                        tube.material.color.setHSL(0.5, 1, 0.5 + neonFlash * 0.2);
                        tube.material.opacity = baseOpacity + neonFlash * opacityRange;
                        break;
                        
                    case 'Hot Pink':
                        // Opposite corners pulse together
                        const pinkPulse = Math.sin(time * 3 + (index < 2 ? 0 : Math.PI)) * 0.5 + 0.5;
                        tube.material.color.setHSL(0.9, 1, 0.5 + pinkPulse * 0.2);
                        tube.material.opacity = baseOpacity + pinkPulse * opacityRange;
                        break;
                        
                    case 'Rainbow Spectrum':
                        // Rainbow rotation around corners
                        const rainbowHue = (time * 0.2 + index * 0.25) % 1;
                        tube.material.color.setHSL(rainbowHue, 1, 0.5);
                        tube.material.opacity = baseOpacity + Math.sin(time * 2 + index) * opacityRange;
                        break;
                        
                    case 'Lime Green':
                        // Random flashes per tube
                        const greenFlash = Math.random() < 0.08 ? 1.5 : Math.sin(time * 4 + index) * 0.5 + 0.5;
                        tube.material.color.setHSL(0.3, 1, 0.4 + greenFlash * 0.3);
                        tube.material.opacity = Math.min(baseOpacity + greenFlash * opacityRange * 1.5, 0.6);
                        break;
                        
                    case 'Digital Matrix':
                        // Cascading activation
                        const matrixCascade = Math.sin(time * 2.5 - index * 0.5) * 0.5 + 0.5;
                        const matrixFlicker = Math.sin(time * 8 + index * 2) > 0.6 ? 1.2 : 1;
                        tube.material.color.setHSL(0.33, 1, 0.3 + matrixCascade * 0.4);
                        tube.material.opacity = (baseOpacity + matrixCascade * opacityRange) * matrixFlicker;
                        break;
                        
                    case 'Deep Purple':
                        // Slow rotation around corners
                        const purpleRotate = Math.sin(time * 1.5 + index * Math.PI / 2) * 0.5 + 0.5;
                        tube.material.color.setHSL(0.75 + purpleRotate * 0.1, 1, 0.4 + purpleRotate * 0.3);
                        tube.material.opacity = baseOpacity + purpleRotate * opacityRange;
                        break;
                        
                    case 'Plasma Field':
                        // Organic plasma flow
                        const plasmaPhase = Math.sin(time * 2 + index) * Math.cos(time * 1.5 + index * 0.5);
                        const plasmaHue = ((plasmaPhase + 1) * 0.5 + time * 0.15) % 1;
                        tube.material.color.setHSL(plasmaHue, 1, 0.4 + Math.abs(plasmaPhase) * 0.3);
                        tube.material.opacity = baseOpacity + Math.abs(plasmaPhase) * opacityRange;
                        break;
                        
                    case 'Amber Gold':
                        // Synchronized pulse with hue shift
                        const amberPulse = Math.sin(time * 1.8) * 0.5 + 0.5;
                        tube.material.color.setHSL(0.12 + amberPulse * 0.05, 1, 0.5 + amberPulse * 0.2);
                        tube.material.opacity = baseOpacity + amberPulse * opacityRange;
                        break;
                        
                    case 'Crystal Refraction':
                        // Prismatic shimmer per corner
                        const crystalShimmer = Math.sin(time * 2 + index * 0.8) * 0.5 + 0.5;
                        const crystalHue = (time * 0.3 + index * 0.25) % 1;
                        tube.material.color.setHSL(crystalHue, 1, 0.5 + crystalShimmer * 0.2);
                        tube.material.opacity = baseOpacity + crystalShimmer * opacityRange;
                        break;
                        
                    case 'Crimson Red':
                        // Danger alarm flash
                        const dangerFlash = Math.sin(time * 3) * 0.5 + 0.5;
                        tube.material.color.setHSL(0, 1, 0.4 + dangerFlash * 0.3);
                        tube.material.opacity = baseOpacity + dangerFlash * opacityRange;
                        break;
                        
                    case 'Synthwave Grid':
                        // Alternating pink/cyan based on index
                        const synthHue = index % 2 === 0 ? 0.9 : 0.5;
                        const synthPulse = Math.sin(time * 2.5) * 0.5 + 0.5;
                        tube.material.color.setHSL(synthHue, 1, 0.5 + synthPulse * 0.2);
                        tube.material.opacity = baseOpacity + synthPulse * opacityRange;
                        break;
                        
                    case 'Aqua Mint':
                        // Gentle wave
                        const mintWave = Math.sin(time * 1.8 + index * 0.5) * 0.5 + 0.5;
                        tube.material.color.setHSL(0.5, 0.7, 0.5 + mintWave * 0.2);
                        tube.material.opacity = baseOpacity + mintWave * opacityRange;
                        break;
                        
                    case 'Cyber Scanlines':
                        // Sequential scan effect
                        const scanPhase = (time * 1.5) % (Math.PI * 2);
                        const scanActive = Math.sin(scanPhase - index * Math.PI / 2) * 0.5 + 0.5;
                        tube.material.color.setHSL(0.45, 1, 0.4 + scanActive * 0.4);
                        tube.material.opacity = baseOpacity + scanActive * opacityRange * 1.5;
                        break;
                        
                    case 'Electric Blue':
                        // Lightning strikes
                        const boltChance = Math.random() < 0.05;
                        const electricPulse = boltChance ? 2 : Math.sin(time * 5 + index * 0.8) * 0.5 + 0.5;
                        tube.material.color.setHSL(0.55, 1, 0.4 + electricPulse * 0.4);
                        tube.material.opacity = Math.min(baseOpacity + electricPulse * opacityRange * 1.5, 0.7);
                        break;
                        
                    case 'Hypnotic Spiral':
                        // Spiral rotation effect
                        const spiralPhase = (time * 2 + index * Math.PI / 2) % (Math.PI * 2);
                        const spiralWave = Math.sin(spiralPhase) * 0.5 + 0.5;
                        const spiralHue = (time * 0.25 + index * 0.25) % 1;
                        tube.material.color.setHSL(spiralHue, 1, 0.4 + spiralWave * 0.3);
                        tube.material.opacity = baseOpacity + spiralWave * opacityRange;
                        break;
                        
                    case 'Sunset Orange':
                        // Synchronized sunset glow
                        const sunsetGlow = Math.sin(time * 1.5) * 0.5 + 0.5;
                        tube.material.color.setHSL(0.08 + sunsetGlow * 0.05, 1, 0.5 + sunsetGlow * 0.2);
                        tube.material.opacity = baseOpacity + sunsetGlow * opacityRange;
                        break;
                        
                    case 'Quantum Shimmer':
                        // Quantum state jumps
                        const quantumJump = Math.sin(time * 7 + index * 1.5) > 0.7 ? 1.5 : 1;
                        const quantumHue = (time * 0.4 + index * 0.2) % 1;
                        const quantumBright = Math.sin(time * 2.5 + index) * 0.5 + 0.5;
                        tube.material.color.setHSL(quantumHue, 1, 0.4 + quantumBright * 0.3);
                        tube.material.opacity = (baseOpacity + quantumBright * opacityRange) * quantumJump;
                        break;
                        
                    case 'Violet Dream':
                        // Dreamy pulse
                        const dreamPulse = Math.sin(time * 1.4 + index * 0.4) * 0.5 + 0.5;
                        tube.material.color.setHSL(0.8, 0.7, 0.4 + dreamPulse * 0.3);
                        tube.material.opacity = baseOpacity + dreamPulse * opacityRange;
                        break;
                        
                    default:
                        // Gentle rainbow cycle
                        const defaultHue = (time * 0.2 + index * 0.25) % 1;
                        tube.material.color.setHSL(defaultHue, 1, 0.5);
                        tube.material.opacity = baseOpacity + Math.sin(time * 1.5 + index * 0.5) * opacityRange;
                        break;
                }
            });
        }
        
        function updateFloorCells() {
            if (floorCells.length === 0) return;
            
            const effect = GRID_EFFECTS[currentGridEffect];
            floorAnimationTime += 0.016; // Approximate 60fps timing
            const time = floorAnimationTime;
            
            // Grid dimensions
            const centerX = GRID_WIDTH / 2;
            const centerZ = GRID_DEPTH / 2;
            const maxDist = Math.sqrt(centerX * centerX + centerZ * centerZ);
            
            floorCells.forEach((cell, index) => {
                const mat = cell.material;
                const gridX = cell.userData.gridX;
                const gridZ = cell.userData.gridZ;
                const posIndex = cell.userData.cellIndex;
                
                // Calculate useful values for patterns
                const distFromCenter = Math.sqrt(Math.pow(gridX - centerX, 2) + Math.pow(gridZ - centerZ, 2));
                const normalizedDist = distFromCenter / maxDist;
                const angleFromCenter = Math.atan2(gridZ - centerZ, gridX - centerX);
                
                // Determine if we should use sprite texture (only if atlases loaded)
                const whichAtlas = Math.random() > 0.5 ? floorAtlasF : floorAtlasG;
                
                // Handle solid color effects with simpler animations
                if (effect.solid) {
                    mat.map = null;
                    const solidHue = (time * 0.1 + normalizedDist * 0.3) % 1;
                    mat.color.setHSL(solidHue, 0.8, 0.5);
                    mat.opacity = 0.3 + Math.sin(time * 2 + posIndex * 0.3) * 0.2;
                    return;
                }
                
                // Pattern-based animations synchronized with grid theme
                switch(effect.name) {
                    case 'None':
                        // SHOW THEM ANYWAY with default animation
                        mat.map = null;
                        const noneHue = (time * 0.1 + posIndex * 0.05) % 1;
                        mat.color.setHSL(noneHue, 0.5, 0.5);
                        mat.opacity = 0.3 + Math.sin(time * 2 + posIndex * 0.2) * 0.15;
                        break;
                        
                    case 'Pulse Wave':
                        // Center-out pulse rings
                        mat.map = null;
                        const pulseRing = Math.sin(time * 2 - distFromCenter * 0.8) * 0.5 + 0.5;
                        const pulseHue = (time * 0.1 + normalizedDist * 0.3) % 1;
                        mat.color.setHSL(pulseHue, 1, 0.5);
                        mat.opacity = pulseRing * 0.5;
                        break;
                        
                    case 'Deep Ocean':
                        // Outside-in wave collapse
                        mat.map = null;
                        const collapseWave = Math.sin(time * 2 + (1 - normalizedDist) * Math.PI * 3) * 0.5 + 0.5;
                        mat.color.setHSL(0.55 + collapseWave * 0.1, 0.9, 0.4);
                        mat.opacity = collapseWave * 0.6;
                        break;
                        
                    case 'Neon Glow':
                        // Horizontal scanning stripes
                        mat.map = null;
                        const stripePhase = Math.sin(time * 3 + gridZ * 1.2) * 0.5 + 0.5;
                        mat.color.setHSL(0.5 + stripePhase * 0.1, 1, 0.5);
                        mat.opacity = stripePhase * 0.6;
                        break;
                        
                    case 'Hot Pink':
                        // Vertical scanning stripes
                        mat.map = null;
                        const vStripe = Math.sin(time * 3 + gridX * 1.2) * 0.5 + 0.5;
                        mat.color.setHSL(0.9, 1, 0.5);
                        mat.opacity = vStripe * 0.6;
                        break;
                        
                    case 'Rainbow Spectrum':
                        // Diagonal rainbow sweep
                        mat.map = null;
                        const diagPhase = (time * 0.3 + (gridX + gridZ) * 0.2) % 1;
                        mat.color.setHSL(diagPhase, 1, 0.5);
                        mat.opacity = 0.4 + Math.sin(diagPhase * Math.PI * 2) * 0.3;
                        break;
                        
                    case 'Lime Green':
                        // Checkerboard flash pattern
                        mat.map = null;
                        const checker = (gridX + gridZ) % 2;
                        const flash = Math.sin(time * 4 + checker * Math.PI) * 0.5 + 0.5;
                        mat.color.setHSL(0.3, 1, 0.5);
                        mat.opacity = flash * 0.7;
                        break;
                        
                    case 'Digital Matrix':
                        // Random sprite drops with texture
                        if (Math.random() < 0.02 && whichAtlas) {
                            mat.map = whichAtlas;
                            // Random sprite UV from 4x4 atlas
                            const spriteX = Math.floor(Math.random() * 4) / 4;
                            const spriteY = Math.floor(Math.random() * 4) / 4;
                            mat.map.offset.set(spriteX, spriteY);
                            mat.map.repeat.set(0.25, 0.25);
                            mat.color.setHex(0x00FF00);
                            mat.opacity = Math.random() * 0.5 + 0.2;
                        } else {
                            mat.map = null;
                            mat.color.setHSL(0.33, 1, 0.3);
                            mat.opacity = Math.random() * 0.3;
                        }
                        break;
                        
                    case 'Deep Purple':
                        // Rotating quad sections
                        mat.map = null;
                        const quadrant = Math.floor((angleFromCenter + Math.PI) / (Math.PI / 2)) % 4;
                        const quadPhase = Math.sin(time * 2 + quadrant * Math.PI / 2) * 0.5 + 0.5;
                        mat.color.setHSL(0.75, 1, 0.4);
                        mat.opacity = quadPhase * 0.6;
                        break;
                        
                    case 'Plasma Field':
                        // Lumines-style plasma swirl
                        mat.map = null;
                        const plasmaX = Math.sin(time * 1.5 + gridX * 0.5);
                        const plasmaZ = Math.cos(time * 1.2 + gridZ * 0.45);
                        const plasmaHue = ((plasmaX + plasmaZ) * 0.5 + 0.5 + time * 0.1) % 1;
                        mat.color.setHSL(plasmaHue, 1, 0.5);
                        mat.opacity = Math.abs(plasmaX * plasmaZ) * 0.6;
                        break;
                        
                    case 'Amber Gold':
                        // Expanding/contracting rings
                        mat.map = null;
                        const ringPhase = Math.sin(time * 1.5) * maxDist * 0.4;
                        const ringMatch = 1 - Math.abs(distFromCenter - ringPhase) / (maxDist * 0.3);
                        const ringIntensity = Math.max(0, ringMatch);
                        mat.color.setHSL(0.12, 1, 0.5);
                        mat.opacity = ringIntensity * 0.8;
                        break;
                        
                    case 'Crystal Refraction':
                        // Prismatic radial burst with sprites
                        const burstPulse = Math.sin(time * 2 - distFromCenter * 0.8) * 0.5 + 0.5;
                        if (burstPulse > 0.7 && whichAtlas) {
                            mat.map = whichAtlas;
                            const spriteX = Math.floor(Math.random() * 4) / 4;
                            const spriteY = Math.floor(Math.random() * 4) / 4;
                            mat.map.offset.set(spriteX, spriteY);
                            mat.map.repeat.set(0.25, 0.25);
                            const burstHue = (angleFromCenter / (Math.PI * 2) + time * 0.2) % 1;
                            mat.color.setHSL(burstHue, 1, 0.7);
                            mat.opacity = burstPulse * 0.5;
                        } else {
                            mat.map = null;
                            const burstHue = (angleFromCenter / (Math.PI * 2) + time * 0.2) % 1;
                            mat.color.setHSL(burstHue, 1, 0.5);
                            mat.opacity = burstPulse * 0.4;
                        }
                        break;
                        
                    case 'Crimson Red':
                        // Pulsing cross pattern
                        mat.map = null;
                        const crossDist = Math.min(Math.abs(gridX - centerX), Math.abs(gridZ - centerZ));
                        const crossPulse = Math.sin(time * 3 - crossDist * 0.8) * 0.5 + 0.5;
                        mat.color.setHex(0xFF0000);
                        mat.opacity = crossPulse * 0.7;
                        break;
                        
                    case 'Synthwave Grid':
                        // Alternating wave pattern
                        mat.map = null;
                        const synthWave = (gridX % 2) + (gridZ % 2);
                        const synthTime = Math.sin(time * 2.5 + synthWave * Math.PI / 2) * 0.5 + 0.5;
                        const synthHue = synthWave === 1 ? 0.9 : 0.5;
                        mat.color.setHSL(synthHue, 1, 0.5);
                        mat.opacity = synthTime * 0.6;
                        break;
                        
                    case 'Aqua Mint':
                        // Diagonal wave sweep
                        mat.map = null;
                        const diagWave = Math.sin(time * 2 + (gridX - gridZ) * 0.6) * 0.5 + 0.5;
                        mat.color.setHSL(0.5, 0.7, 0.5);
                        mat.opacity = diagWave * 0.6;
                        break;
                        
                    case 'Cyber Scanlines':
                        // Grid scanlines with sprites
                        const scanX = Math.abs(Math.sin(time * 1.5 + gridX * 0.6));
                        const scanZ = Math.abs(Math.sin(time * 1.2 + gridZ * 0.6));
                        const scanCombined = (scanX + scanZ) * 0.5;
                        if (scanCombined > 0.8 && whichAtlas) {
                            mat.map = whichAtlas;
                            const spriteX = Math.floor(Math.random() * 4) / 4;
                            const spriteY = Math.floor(Math.random() * 4) / 4;
                            mat.map.offset.set(spriteX, spriteY);
                            mat.map.repeat.set(0.25, 0.25);
                            mat.color.setHex(0x00FFAA);
                            mat.opacity = scanCombined * 0.4;
                        } else {
                            mat.map = null;
                            mat.color.setHSL(0.45, 1, 0.5);
                            mat.opacity = scanCombined * 0.4;
                        }
                        break;
                        
                    case 'Electric Blue':
                        // Lightning arcs with random sprites
                        const arcIntensity = Math.sin(time * 5 + posIndex * 0.3) * 0.5 + 0.5;
                        const lightningBolt = Math.random() < 0.03;
                        if (lightningBolt && whichAtlas) {
                            mat.map = whichAtlas;
                            const spriteX = Math.floor(Math.random() * 4) / 4;
                            const spriteY = Math.floor(Math.random() * 4) / 4;
                            mat.map.offset.set(spriteX, spriteY);
                            mat.map.repeat.set(0.25, 0.25);
                            mat.color.setHex(0x00AAFF);
                            mat.opacity = 0.7;
                        } else {
                            mat.map = null;
                            mat.color.setHSL(0.55, 1, 0.5);
                            mat.opacity = arcIntensity * 0.4;
                        }
                        break;
                        
                    case 'Hypnotic Spiral':
                        // Rotating spiral from center
                        mat.map = null;
                        const spiralPhase = (angleFromCenter + time * 2) % (Math.PI * 2);
                        const spiralRing = Math.sin(spiralPhase * 3 - distFromCenter * 1.8) * 0.5 + 0.5;
                        const spiralHue = (time * 0.25 + normalizedDist * 0.5) % 1;
                        mat.color.setHSL(spiralHue, 1, 0.5);
                        mat.opacity = spiralRing * 0.6;
                        break;
                        
                    case 'Sunset Orange':
                        // Horizontal gradient waves
                        mat.map = null;
                        const sunsetWave = Math.sin(time * 1.5 + gridZ * 0.5) * 0.5 + 0.5;
                        mat.color.setHSL(0.08, 1, 0.5);
                        mat.opacity = sunsetWave * 0.6;
                        break;
                        
                    case 'Quantum Shimmer':
                        // Random quantum state changes with sprites
                        const quantumPhase = (time * 0.5 + posIndex * 0.2) % 1;
                        const quantumJump = Math.sin(time * 8 + posIndex) > 0.8;
                        if (quantumJump && whichAtlas) {
                            mat.map = whichAtlas;
                            const spriteX = Math.floor(Math.random() * 4) / 4;
                            const spriteY = Math.floor(Math.random() * 4) / 4;
                            mat.map.offset.set(spriteX, spriteY);
                            mat.map.repeat.set(0.25, 0.25);
                            const quantumHue = (quantumPhase + Math.random() * 0.3) % 1;
                            mat.color.setHSL(quantumHue, 1, 0.6);
                            mat.opacity = 0.5;
                        } else {
                            mat.map = null;
                            mat.color.setHSL(quantumPhase, 1, 0.4);
                            mat.opacity = quantumPhase * 0.4;
                        }
                        break;
                        
                    case 'Violet Dream':
                        // Soft radial pulse
                        mat.map = null;
                        const dreamPulse = Math.sin(time * 1.4 - distFromCenter * 0.5) * 0.5 + 0.5;
                        mat.color.setHSL(0.8, 0.7, 0.5);
                        mat.opacity = dreamPulse * 0.5;
                        break;
                        
                    default:
                        mat.opacity = 0;
                        break;
                }
                
                mat.needsUpdate = true;
            });
        }
        
        function setFloorColorNone() {
            if (tempFloorEnabled) {
                // Disable
                tempFloorEnabled = false;
                document.getElementById('floorColorPicker').disabled = true;
                document.getElementById('floorColorPicker').style.opacity = '0.5';
            } else {
                // Re-enable
                tempFloorEnabled = true;
                document.getElementById('floorColorPicker').disabled = false;
                document.getElementById('floorColorPicker').style.opacity = '1';
            }
        }
        
        function setLaserColorNone() {
            if (tempLaserEnabled) {
                // Disable
                tempLaserEnabled = false;
                document.getElementById('laserColorPicker').disabled = true;
                document.getElementById('laserColorPicker').style.opacity = '0.5';
            } else {
                // Re-enable
                tempLaserEnabled = true;
                document.getElementById('laserColorPicker').disabled = false;
                document.getElementById('laserColorPicker').style.opacity = '1';
            }
        }
        
        function applyColorSettings() {
            const floorPicker = document.getElementById('floorColorPicker');
            const laserPicker = document.getElementById('laserColorPicker');
            
            if (tempFloorEnabled) {
                floorHintColor = parseInt(floorPicker.value.replace('#', ''), 16);
                floorHintEnabled = true;
            } else {
                floorHintEnabled = false;
            }
            
            if (tempLaserEnabled) {
                laserLineColor = parseInt(laserPicker.value.replace('#', ''), 16);
                laserLineEnabled = true;
            } else {
                laserLineEnabled = false;
            }
            
            // Apply colors to existing floor indicators
            floorIndicators.forEach(indicator => {
                if (floorHintEnabled) {
                    indicator.material.color.setHex(floorHintColor);
                    if (indicator.visible) {
                        indicator.visible = true;
                    }
                } else {
                    indicator.visible = false;
                }
            });
            
            document.getElementById('colorPickerModal').style.display = 'none';
        }
        
        function cancelColorSettings() {
            // Reset temp values
            tempFloorColor = floorHintColor;
            tempLaserColor = laserLineColor;
            tempFloorEnabled = floorHintEnabled;
            tempLaserEnabled = laserLineEnabled;
            
            // Re-enable pickers
            document.getElementById('floorColorPicker').disabled = false;
            document.getElementById('floorColorPicker').style.opacity = '1';
            document.getElementById('laserColorPicker').disabled = false;
            document.getElementById('laserColorPicker').style.opacity = '1';
            
            document.getElementById('colorPickerModal').style.display = 'none';
        }
        
        // ===== PARTICLE PLACEMENT MENU FUNCTIONS =====
        
        function openPlacementMenu(placement, x, y) {
            selectedPlacement = placement;
            
            const menu = document.getElementById('placementMenu');
            const select = document.getElementById('placementEffectSelect');
            const enabledCheck = document.getElementById('placementEnabledCheck');
            const loopCheck = document.getElementById('placementLoopCheck');
            
            // Populate effect dropdown
            select.innerHTML = '';
            availableParticleEffects.forEach(effect => {
                const option = document.createElement('option');
                option.value = effect;
                option.textContent = effect.replace('effect/', '').replace('.json', '');
                if (effect === placement.particleEffect) {
                    option.selected = true;
                }
                select.appendChild(option);
            });
            
            // Set checkboxes
            enabledCheck.checked = placement.enabled;
            loopCheck.checked = placement.loop;
            
            // Update position display
            updatePlacementMenuPosition();
            
            // Position menu near click
            menu.style.left = Math.min(x, window.innerWidth - 340) + 'px';
            menu.style.top = Math.min(y, window.innerHeight - 400) + 'px';
            menu.style.display = 'block';
        }
        
        function onPlacementEffectChange() {
            if (!selectedPlacement) return;
            const select = document.getElementById('placementEffectSelect');
            selectedPlacement.particleEffect = select.value;
            saveParticlePlacements();
        }
        
        function onPlacementEnabledChange() {
            if (!selectedPlacement) return;
            const enabledCheck = document.getElementById('placementEnabledCheck');
            selectedPlacement.enabled = enabledCheck.checked;
            if (selectedPlacement.box && selectedPlacement.box.material) {
                selectedPlacement.box.material.color.setHex(selectedPlacement.enabled ? 0x00ff00 : 0xff0000);
            }
            
            if (selectedPlacement.enabled && selectedPlacement.loop) {
                startLoopingParticle(selectedPlacement);
            } else {
                stopLoopingParticle(selectedPlacement);
            }
            
            saveParticlePlacements();
        }
        
        function onPlacementPositionChange() {
            if (!selectedPlacement) return;
            
            const xInput = document.getElementById('placementPosX');
            const yInput = document.getElementById('placementPosY');
            const zInput = document.getElementById('placementPosZ');
            
            const newX = parseFloat(xInput.value);
            const newY = parseFloat(yInput.value);
            const newZ = parseFloat(zInput.value);
            
            if (!isNaN(newX)) selectedPlacement.position.x = newX;
            if (!isNaN(newY)) selectedPlacement.position.y = newY;
            if (!isNaN(newZ)) selectedPlacement.position.z = newZ;
            
            // Update box position
            selectedPlacement.box.position.set(
                selectedPlacement.position.x,
                selectedPlacement.position.y,
                selectedPlacement.position.z
            );
            
            // Update arrow positions
            const directions = [
                { offset: new THREE.Vector3(3, 0, 0) },
                { offset: new THREE.Vector3(-3, 0, 0) },
                { offset: new THREE.Vector3(0, 3, 0) },
                { offset: new THREE.Vector3(0, -3, 0) },
                { offset: new THREE.Vector3(0, 0, 3) },
                { offset: new THREE.Vector3(0, 0, -3) }
            ];
            
            selectedPlacement.arrows.forEach((arrow, i) => {
                arrow.position.copy(selectedPlacement.box.position.clone().add(directions[i].offset));
            });
            
            saveParticlePlacements();
        }
        
        function onPlacementLoopChange() {
            if (!selectedPlacement) return;
            const loopCheck = document.getElementById('placementLoopCheck');
            selectedPlacement.loop = loopCheck.checked;
            
            if (selectedPlacement.enabled && selectedPlacement.loop) {
                startLoopingParticle(selectedPlacement);
            } else {
                stopLoopingParticle(selectedPlacement);
            }
            
            saveParticlePlacements();
        }
        

        
        function closePlacementMenu() {
            document.getElementById('placementMenu').style.display = 'none';
            selectedPlacement = null;
        }

        function copyParticlePlacementData() {
            if (!selectedPlacement) return;
            
            const data = {
                id: selectedPlacement.id,
                position: {
                    x: selectedPlacement.position.x,
                    y: selectedPlacement.position.y,
                    z: selectedPlacement.position.z
                },
                particleEffect: selectedPlacement.particleEffect,
                enabled: selectedPlacement.enabled,
                loop: selectedPlacement.loop
            };
            
            const jsonString = JSON.stringify(data, null, 4);
            
            // Copy to clipboard
            navigator.clipboard.writeText(jsonString).then(() => {
                // Visual feedback - find the button that was clicked
                const buttons = document.querySelectorAll('button');
                let btn = null;
                buttons.forEach(b => {
                    if (b.textContent.includes('Copy Data') && b.onclick && b.onclick.toString().includes('copyParticlePlacementData')) {
                        btn = b;
                    }
                });
                
                if (btn) {
                    const originalText = btn.textContent;
                    btn.textContent = 'âœ“ Copied!';
                    btn.style.background = '#00ff00';
                    trackedSetTimeout(() => {
                        btn.textContent = originalText;
                        btn.style.background = '#00aa00';
                    }, 2000);
                }
            }).catch(err => {
                alert('Failed to copy: ' + err);
            });
        }
        
        function updatePlacementMenuPosition() {
            if (!selectedPlacement) return;
            
            const xInput = document.getElementById('placementPosX');
            const yInput = document.getElementById('placementPosY');
            const zInput = document.getElementById('placementPosZ');
            
            if (xInput) xInput.value = selectedPlacement.position.x.toFixed(1);
            if (yInput) yInput.value = selectedPlacement.position.y.toFixed(1);
            if (zInput) zInput.value = selectedPlacement.position.z.toFixed(1);
        }
        
        function testPlacementParticle() {
            if (!selectedPlacement) return;
            spawnPlacementParticle(selectedPlacement);
        }
        
        function duplicateCurrentPlacement() {
            if (!selectedPlacement) return;
            duplicatePlacement(selectedPlacement);
        }
        
        function deleteCurrentPlacement() {
            if (!selectedPlacement) return;
            if (confirm('Delete this particle placement?')) {
                deletePlacement(selectedPlacement);
            }
        }
        
        // ===== MODEL PLACEMENT MENU FUNCTIONS =====
        
        function openModelPlacementMenu(placement, x, y) {
            selectedModelPlacement = placement;
            
            const menu = document.getElementById('modelPlacementMenu');
            const select = document.getElementById('modelPlacementSelect');
            const animLoopCheck = document.getElementById('modelAnimLoopCheck');
            
            // Populate model dropdown
            select.innerHTML = '';
            availableModels.forEach(modelPath => {
                const option = document.createElement('option');
                option.value = modelPath;
                option.textContent = modelPath.replace('people/', '').replace('models/', '').replace('.glb', '');
                if (modelPath === placement.modelPath) {
                    option.selected = true;
                }
                select.appendChild(option);
            });
            
            // Set checkbox
            animLoopCheck.checked = placement.animLoop;
            
            // Update input fields
            updateModelPlacementMenuFields();
            
            // Position menu near click
            menu.style.left = Math.min(x, window.innerWidth - 360) + 'px';
            menu.style.top = Math.min(y, window.innerHeight - 500) + 'px';
            menu.style.display = 'block';
        }
        
        function closeModelPlacementMenu() {
            document.getElementById('modelPlacementMenu').style.display = 'none';
            selectedModelPlacement = null;
        }
        
        function updateModelPlacementMenuFields() {
            if (!selectedModelPlacement) return;
            
            document.getElementById('modelPosX').value = selectedModelPlacement.position.x.toFixed(1);
            document.getElementById('modelPosY').value = selectedModelPlacement.position.y.toFixed(1);
            document.getElementById('modelPosZ').value = selectedModelPlacement.position.z.toFixed(1);
            
            document.getElementById('modelRotX').value = selectedModelPlacement.rotation.x.toFixed(0);
            document.getElementById('modelRotY').value = selectedModelPlacement.rotation.y.toFixed(0);
            document.getElementById('modelRotZ').value = selectedModelPlacement.rotation.z.toFixed(0);
            
            document.getElementById('modelScale').value = selectedModelPlacement.scale.toFixed(1);
        }
        
        function onModelPlacementModelChange() {
            if (!selectedModelPlacement) return;
            const select = document.getElementById('modelPlacementSelect');
            selectedModelPlacement.modelPath = select.value;
            loadModelPlacementModel(selectedModelPlacement);
            saveModelPlacements();
        }
        
        function onModelPositionChange() {
            if (!selectedModelPlacement) return;
            
            const newX = parseFloat(document.getElementById('modelPosX').value);
            const newY = parseFloat(document.getElementById('modelPosY').value);
            const newZ = parseFloat(document.getElementById('modelPosZ').value);
            
            if (!isNaN(newX)) selectedModelPlacement.position.x = newX;
            if (!isNaN(newY)) selectedModelPlacement.position.y = newY;
            if (!isNaN(newZ)) selectedModelPlacement.position.z = newZ;
            
            // Update box position (offset Y+3 for center)
            selectedModelPlacement.box.position.set(
                selectedModelPlacement.position.x,
                selectedModelPlacement.position.y + 3,
                selectedModelPlacement.position.z
            );
            
            // Update model position (at feet level)
            if (selectedModelPlacement.model) {
                selectedModelPlacement.model.position.set(
                    selectedModelPlacement.position.x,
                    selectedModelPlacement.position.y,
                    selectedModelPlacement.position.z
                );
            }
            
            // Update arrow positions
            const directions = [
                { offset: new THREE.Vector3(3, 0, 0) },
                { offset: new THREE.Vector3(-3, 0, 0) },
                { offset: new THREE.Vector3(0, 3, 0) },
                { offset: new THREE.Vector3(0, -3, 0) },
                { offset: new THREE.Vector3(0, 0, 3) },
                { offset: new THREE.Vector3(0, 0, -3) }
            ];
            
            selectedModelPlacement.arrows.forEach((arrow, i) => {
                arrow.position.copy(selectedModelPlacement.box.position.clone().add(directions[i].offset));
            });
            
            saveModelPlacements();
        }
        
        function onModelRotationChange() {
            if (!selectedModelPlacement) return;
            
            const newX = parseFloat(document.getElementById('modelRotX').value);
            const newY = parseFloat(document.getElementById('modelRotY').value);
            const newZ = parseFloat(document.getElementById('modelRotZ').value);
            
            if (!isNaN(newX)) selectedModelPlacement.rotation.x = newX;
            if (!isNaN(newY)) selectedModelPlacement.rotation.y = newY;
            if (!isNaN(newZ)) selectedModelPlacement.rotation.z = newZ;
            
            // Update model rotation
            if (selectedModelPlacement.model) {
                selectedModelPlacement.model.rotation.set(
                    THREE.MathUtils.degToRad(selectedModelPlacement.rotation.x),
                    THREE.MathUtils.degToRad(selectedModelPlacement.rotation.y),
                    THREE.MathUtils.degToRad(selectedModelPlacement.rotation.z)
                );
            }
            
            saveModelPlacements();
        }
        
        function onModelScaleChange() {
            if (!selectedModelPlacement) return;
            
            const newScale = parseFloat(document.getElementById('modelScale').value);
            
            if (!isNaN(newScale) && newScale > 0) {
                selectedModelPlacement.scale = newScale;
                
                // Update model scale
                if (selectedModelPlacement.model) {
                    selectedModelPlacement.model.scale.setScalar(newScale);
                }
                
                saveModelPlacements();
            }
        }
        
        function onModelAnimLoopChange() {
            if (!selectedModelPlacement) return;
            const animLoopCheck = document.getElementById('modelAnimLoopCheck');
            selectedModelPlacement.animLoop = animLoopCheck.checked;
            
            // Reload model to apply animation change
            loadModelPlacementModel(selectedModelPlacement);
            saveModelPlacements();
        }
        
        function testModelPlacement() {
            if (!selectedModelPlacement) return;
            // Reload the model
            loadModelPlacementModel(selectedModelPlacement);
        }
        
        function duplicateCurrentModel() {
            if (!selectedModelPlacement) return;
            duplicateModelPlacement(selectedModelPlacement);
        }
        
        function deleteCurrentModel() {
            if (!selectedModelPlacement) return;
            if (confirm('Delete this model placement?')) {
                deleteModelPlacement(selectedModelPlacement);
            }
        }
        
        function copyModelPlacementData() {
            if (!selectedModelPlacement) return;
            
            const data = {
                id: selectedModelPlacement.id,
                position: {
                    x: selectedModelPlacement.position.x,
                    y: selectedModelPlacement.position.y,
                    z: selectedModelPlacement.position.z
                },
                rotation: {
                    x: selectedModelPlacement.rotation.x,
                    y: selectedModelPlacement.rotation.y,
                    z: selectedModelPlacement.rotation.z
                },
                scale: selectedModelPlacement.scale,
                modelPath: selectedModelPlacement.modelPath,
                animLoop: selectedModelPlacement.animLoop
            };
            
            const jsonString = JSON.stringify(data, null, 4);
            
            // Copy to clipboard
            navigator.clipboard.writeText(jsonString).then(() => {
                // Visual feedback - find the button that was clicked
                const buttons = document.querySelectorAll('button');
                let btn = null;
                buttons.forEach(b => {
                    if (b.textContent.includes('Copy Data')) {
                        btn = b;
                    }
                });
                
                if (btn) {
                    const originalText = btn.textContent;
                    btn.textContent = 'âœ“ Copied!';
                    btn.style.background = '#00ff00';
                    trackedSetTimeout(() => {
                        btn.textContent = originalText;
                        btn.style.background = '#00aa00';
                    }, 2000);
                }
            }).catch(err => {
                alert('Failed to copy: ' + err);
            });
        }
        
        // ===== END MODEL PLACEMENT MENU FUNCTIONS =====
        
        // ===== CHAIN COLUMN MENU FUNCTIONS =====
        
        function openChainColumnMenu(column, x, y) {
            selectedChainColumn = column;
            
            const menu = document.getElementById('chainColumnMenu');
            
            // Update input fields
            updateChainColumnMenuFields();
            
            // Position menu near click
            menu.style.left = Math.min(x, window.innerWidth - 360) + 'px';
            menu.style.top = Math.min(y, window.innerHeight - 600) + 'px';
            menu.style.display = 'block';
        }
        
        function closeChainColumnMenu() {
            document.getElementById('chainColumnMenu').style.display = 'none';
            selectedChainColumn = null;
        }
        
        function updateChainColumnMenuFields() {
            if (!selectedChainColumn) return;
            
            document.getElementById('chainColPosX').value = selectedChainColumn.x.toFixed(1);
            document.getElementById('chainColPosY').value = selectedChainColumn.y.toFixed(1);
            document.getElementById('chainColPosZ').value = selectedChainColumn.z.toFixed(1);
            document.getElementById('chainColRotation').value = selectedChainColumn.rotation.toFixed(2);
            document.getElementById('chainColLength').value = selectedChainColumn.chainLength;
            document.getElementById('chainColColorMode').value = selectedChainColumn.colorMode;
            document.getElementById('chainColDirection').value = selectedChainColumn.direction || 'up';
            document.getElementById('chainColEnabled').checked = selectedChainColumn.enabled;
            
            // Show/hide single color select
            const singleColorDiv = document.getElementById('chainColSingleColorDiv');
            if (selectedChainColumn.colorMode === 'single') {
                singleColorDiv.style.display = 'block';
                // Set the current single color
                if (selectedChainColumn.singleColor) {
                    const colorKey = Object.keys(LinkType).find(key => LinkType[key] === selectedChainColumn.singleColor);
                    document.getElementById('chainColSingleColor').value = colorKey || 'ZEC_A';
                }
            } else {
                singleColorDiv.style.display = 'none';
            }
        }
        
        function onChainColumnPositionChange() {
            if (!selectedChainColumn) return;
            
            const newX = parseFloat(document.getElementById('chainColPosX').value);
            const newY = parseFloat(document.getElementById('chainColPosY').value);
            const newZ = parseFloat(document.getElementById('chainColPosZ').value);
            
            if (!isNaN(newX)) selectedChainColumn.x = newX;
            if (!isNaN(newY)) selectedChainColumn.y = newY;
            if (!isNaN(newZ)) selectedChainColumn.z = newZ;
            
            // Rebuild the chain column with new position
            rebuildChainColumn(selectedChainColumn);
        }
        
        function onChainColumnRotationChange() {
            if (!selectedChainColumn) return;
            
            const newRotation = parseFloat(document.getElementById('chainColRotation').value);
            
            if (!isNaN(newRotation)) {
                selectedChainColumn.rotation = newRotation;
                rebuildChainColumn(selectedChainColumn);
            }
        }
        
        function onChainColumnLengthChange() {
            if (!selectedChainColumn) return;
            
            const newLength = parseInt(document.getElementById('chainColLength').value);
            
            if (!isNaN(newLength)) {
                selectedChainColumn.chainLength = newLength;
                rebuildChainColumn(selectedChainColumn);
            }
        }
        
        function onChainColumnColorModeChange() {
            if (!selectedChainColumn) return;
            
            const colorMode = document.getElementById('chainColColorMode').value;
            selectedChainColumn.colorMode = colorMode;
            
            // Show/hide single color selector
            updateChainColumnMenuFields();
            
            rebuildChainColumn(selectedChainColumn);
        }
        
        function onChainColumnSingleColorChange() {
            if (!selectedChainColumn) return;
            
            const colorKey = document.getElementById('chainColSingleColor').value;
            selectedChainColumn.singleColor = LinkType[colorKey];
            
            rebuildChainColumn(selectedChainColumn);
        }
        
        function onChainColumnDirectionChange() {
            if (!selectedChainColumn) return;
            
            const direction = document.getElementById('chainColDirection').value;
            selectedChainColumn.direction = direction;
            
            // Update the chain object in cornerChains
            const chainObj = cornerChains.find(c => c.column.id === selectedChainColumn.id);
            if (chainObj) {
                chainObj.direction = direction;
            }
        }
        
        function onChainColumnEnabledChange() {
            if (!selectedChainColumn) return;
            
            const enabled = document.getElementById('chainColEnabled').checked;
            selectedChainColumn.enabled = enabled;
            
            rebuildChainColumn(selectedChainColumn);
        }
        
        function rebuildChainColumn(column) {
            // Find the chain in cornerChains
            const chainIndex = cornerChains.findIndex(c => c.column.id === column.id);
            if (chainIndex === -1) return;
            
            const chain = cornerChains[chainIndex];
            
            // Remove old links
            chain.links.forEach(link => {
                disposeLinkMesh(link);
            });
            
            // Remove old tube
            const tubeIndex = cornerTubes.findIndex(t => {
                // Find tube at this position (approximate match)
                return Math.abs(t.position.x - column.x) < 0.1 && Math.abs(t.position.z - column.z) < 0.1;
            });
            if (tubeIndex !== -1) {
                scene.remove(cornerTubes[tubeIndex]);
                cornerTubes[tubeIndex].geometry.dispose();
                cornerTubes[tubeIndex].material.dispose();
                cornerTubes.splice(tubeIndex, 1);
            }
            
            // Remove box and arrows
            if (column.box) {
                scene.remove(column.box);
                column.box.geometry.dispose();
                column.box.material.dispose();
            }
            column.arrows.forEach(arrow => {
                disposeArrowHelper(arrow);
            });
            column.arrows = [];
            
            if (!column.enabled) {
                // Just remove, don't rebuild
                cornerChains.splice(chainIndex, 1);
                return;
            }
            
            // Rebuild tube
            const tubeHeight = GRID_HEIGHT;
            const tubeRadius = 0.3;
            const actualTubeHeight = Math.abs(tubeHeight + column.chainLength);
            
            const tubeGeometry = new THREE.CylinderGeometry(tubeRadius, tubeRadius, actualTubeHeight, 16, 1, true);
            const tubeMaterial = new THREE.MeshBasicMaterial({
                color: 0x1B2836,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            
            const tube = new THREE.Mesh(tubeGeometry, tubeMaterial);
            tube.position.set(column.x, actualTubeHeight / 2, column.z);
            tube.rotation.y = column.rotation;
            tube.frustumCulled = false;
            scene.add(tube);
            cornerTubes.push(tube);
            
            // Rebuild chain links
            const chainLinks = [];
            const numLinks = GRID_HEIGHT + 5 + column.chainLength;
            const startY = column.y;
            
            for (let i = 0; i < numLinks; i++) {
                let linkType;
                
                if (column.colorMode === 'single' && column.singleColor !== null) {
                    linkType = column.singleColor;
                } else {
                    const linkTypes = [LinkType.ZEC_A, LinkType.ZEC_B, LinkType.ZEC_C, LinkType.ZEC_D];
                    linkType = linkTypes[Math.floor(Math.random() * linkTypes.length)];
                }
                
                const link = createLinkMesh(linkType);
                link.position.set(column.x, startY + i, column.z);
                
                if (i % 2 === 1) {
                    link.rotation.y = Math.PI / 2;
                }
                
                link.rotation.y += column.rotation;
                
                scene.add(link);
                chainLinks.push(link);
            }
            
            // Recreate box and arrows
            createChainColumnBox(column);
            
            // Update chain object
            chain.links = chainLinks;
            chain.colorMode = column.colorMode;
            chain.singleColor = column.singleColor;
            chain.direction = column.direction || 'up';
        }
        
        function moveChainColumn(column, axis, sign) {
            column[axis] += sign * 2.0;
            
            // Update box position
            if (column.box) {
                column.box.position.set(column.x, column.y + 3, column.z);
                
                // Update arrow positions
                const directions = [
                    { offset: new THREE.Vector3(3, 0, 0) },
                    { offset: new THREE.Vector3(-3, 0, 0) },
                    { offset: new THREE.Vector3(0, 3, 0) },
                    { offset: new THREE.Vector3(0, -3, 0) },
                    { offset: new THREE.Vector3(0, 0, 3) },
                    { offset: new THREE.Vector3(0, 0, -3) }
                ];
                
                column.arrows.forEach((arrow, i) => {
                    arrow.position.copy(column.box.position.clone().add(directions[i].offset));
                });
            }
            
            // Rebuild to update position
            rebuildChainColumn(column);
        }
        
        function deleteChainColumn(column) {
            // Find the chain in cornerChains
            const chainIndex = cornerChains.findIndex(c => c.column.id === column.id);
            if (chainIndex !== -1) {
                const chain = cornerChains[chainIndex];
                
                // Remove links
                chain.links.forEach(link => {
                    disposeLinkMesh(link);
                });
                
                cornerChains.splice(chainIndex, 1);
            }
            
            // Remove tube
            const tubeIndex = cornerTubes.findIndex(t => {
                return Math.abs(t.position.x - column.x) < 0.1 && Math.abs(t.position.z - column.z) < 0.1;
            });
            if (tubeIndex !== -1) {
                scene.remove(cornerTubes[tubeIndex]);
                cornerTubes[tubeIndex].geometry.dispose();
                cornerTubes[tubeIndex].material.dispose();
                cornerTubes.splice(tubeIndex, 1);
            }
            
            // Remove box and arrows
            if (column.box) {
                scene.remove(column.box);
                column.box.geometry.dispose();
                column.box.material.dispose();
            }
            column.arrows.forEach(arrow => {
                disposeArrowHelper(arrow);
            });
            
            // Remove from array
            const columnIndex = decorativeChainColumns.findIndex(c => c.id === column.id);
            if (columnIndex !== -1) {
                decorativeChainColumns.splice(columnIndex, 1);
            }
            
            closeChainColumnMenu();
        }
        
        function duplicateChainColumn(column) {
            const newColumn = {
                id: chainColumnIdCounter++,
                x: column.x + 2,
                y: column.y,
                z: column.z,
                rotation: column.rotation,
                colorMode: column.colorMode,
                singleColor: column.singleColor,
                chainLength: column.chainLength,
                direction: column.direction,
                enabled: column.enabled,
                box: null,
                arrows: []
            };
            
            decorativeChainColumns.push(newColumn);
            
            if (newColumn.enabled) {
                // Build the new column from scratch
                const tubeHeight = GRID_HEIGHT;
                const tubeRadius = 0.3;
                const actualTubeHeight = Math.abs(tubeHeight + newColumn.chainLength);
                
                // Create tube
                const tubeGeometry = new THREE.CylinderGeometry(tubeRadius, tubeRadius, actualTubeHeight, 16, 1, true);
                const tubeMaterial = new THREE.MeshBasicMaterial({
                    color: 0x1B2836,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide
                });
                
                const tube = new THREE.Mesh(tubeGeometry, tubeMaterial);
                tube.position.set(newColumn.x, actualTubeHeight / 2, newColumn.z);
                tube.rotation.y = newColumn.rotation;
                tube.frustumCulled = false;
                scene.add(tube);
                cornerTubes.push(tube);
                
                // Create chain links
                const chainLinks = [];
                const numLinks = GRID_HEIGHT + 5 + newColumn.chainLength;
                const startY = newColumn.y;
                
                for (let i = 0; i < numLinks; i++) {
                    let linkType;
                    
                    if (newColumn.colorMode === 'single' && newColumn.singleColor !== null) {
                        linkType = newColumn.singleColor;
                    } else {
                        const linkTypes = [LinkType.ZEC_A, LinkType.ZEC_B, LinkType.ZEC_C, LinkType.ZEC_D];
                        linkType = linkTypes[Math.floor(Math.random() * linkTypes.length)];
                    }
                    
                    const link = createLinkMesh(linkType);
                    link.position.set(newColumn.x, startY + i, newColumn.z);
                    
                    if (i % 2 === 1) {
                        link.rotation.y = Math.PI / 2;
                    }
                    
                    link.rotation.y += newColumn.rotation;
                    
                    scene.add(link);
                    chainLinks.push(link);
                }
                
                // Create box and arrows
                createChainColumnBox(newColumn);
                
                // Add to cornerChains
                cornerChains.push({
                    links: chainLinks,
                    column: newColumn,
                    colorMode: newColumn.colorMode,
                    singleColor: newColumn.singleColor,
                    direction: newColumn.direction || 'up'
                });
            }
        }
        
        function deleteCurrentChainColumn() {
            if (!selectedChainColumn) return;
            if (confirm('Delete this chain column?')) {
                deleteChainColumn(selectedChainColumn);
            }
        }
        
        function duplicateCurrentChainColumn() {
            if (!selectedChainColumn) return;
            duplicateChainColumn(selectedChainColumn);
        }
        
        function copyChainColumnData() {
            if (!selectedChainColumn) return;
            
            const data = {
                id: selectedChainColumn.id,
                x: selectedChainColumn.x,
                y: selectedChainColumn.y,
                z: selectedChainColumn.z,
                rotation: selectedChainColumn.rotation,
                colorMode: selectedChainColumn.colorMode,
                singleColor: selectedChainColumn.singleColor,
                chainLength: selectedChainColumn.chainLength,
                direction: selectedChainColumn.direction,
                enabled: selectedChainColumn.enabled
            };
            
            const jsonString = JSON.stringify(data, null, 4);
            
            navigator.clipboard.writeText(jsonString).then(() => {
                const buttons = document.querySelectorAll('button');
                let btn = null;
                buttons.forEach(b => {
                    if (b.textContent.includes('Copy Data')) {
                        btn = b;
                    }
                });
                
                if (btn) {
                    const originalText = btn.textContent;
                    btn.textContent = 'âœ“ Copied!';
                    btn.style.background = '#00ff00';
                    trackedSetTimeout(() => {
                        btn.textContent = originalText;
                        btn.style.background = '#00aa00';
                    }, 2000);
                }
            }).catch(err => {
                alert('Failed to copy: ' + err);
            });
        }
        
        function updateChainColumnBoxVisibility() {
            decorativeChainColumns.forEach(column => {
                if (column.box) {
                    column.box.visible = settings.showHitboxes;
                }
                if (column.arrows) {
                    column.arrows.forEach(arrow => {
                        arrow.visible = settings.showHitboxes;
                    });
                }
            });
        }
        
        // ===== END CHAIN COLUMN MENU FUNCTIONS =====
        
        // Mouse wheel zoom
        window.addEventListener('wheel', (event) => {
            event.preventDefault();
            const zoomSpeed = 0.5;
            cameraDistance += event.deltaY > 0 ? zoomSpeed : -zoomSpeed;
            cameraDistance = Math.max(minCameraDistance, Math.min(maxCameraDistance, cameraDistance));
            updateCameraPosition();
        }, { passive: false });
        
        // Middle mouse button to reset camera zoom
        window.addEventListener('mousedown', (event) => {
            if (event.button === 1) { // Middle mouse button
                event.preventDefault();
                cameraDistance = baseCameraDistance;
                updateCameraPosition();
            }
        });
        
        function init() {
            // Setup renderer
            const canvas = document.getElementById('renderCanvas');
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x0A0E12, 1);
            
            // Enable shadow mapping
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Soft shadows
            
            // Setup scene
            scene = new THREE.Scene();
            // No fog - we're indoors
            
            // Setup camera
            camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.01, 1000);
            updateCameraPosition();
            
            // Load chain link model
            loadChainLinkModel();
            loadTableModel();
            loadZookoModel();
            loadCyberAxeModel();
            loadZancasModel();
            loadNateModel();
            
            // Initialize grid
            for (let x = 0; x < GRID_WIDTH; x++) {
                grid[x] = [];
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    grid[x][y] = [];
                    for (let z = 0; z < GRID_DEPTH; z++) {
                        grid[x][y][z] = null;
                    }
                }
            }
            
            // Create cube frame and grid
            createCubeFrame();
            createGridLines();
            createColumnTubes();
            createFloorIndicators();
            createRoom();
            createFloorCells(); // Create 6x6 floor cell animation system
            
            
            // Setup lighting
            // Main key light - warm, softer intensity
            keyLight = new THREE.DirectionalLight(0xFFFFFF, 0.8);
            keyLight.position.set(5, 20, 8);
            keyLight.castShadow = true;
            keyLight.shadow.mapSize.width = 2048;
            keyLight.shadow.mapSize.height = 2048;
            keyLight.shadow.camera.near = 0.5;
            keyLight.shadow.camera.far = 100;
            keyLight.shadow.camera.left = -40;
            keyLight.shadow.camera.right = 40;
            keyLight.shadow.camera.top = 40;
            keyLight.shadow.camera.bottom = -40;
            keyLight.shadow.bias = -0.0001;
            scene.add(keyLight);
            
            // Fill light - cool tone, reduced intensity
            fillLight = new THREE.DirectionalLight(0xBBDDFF, 0.3);
            fillLight.position.set(-8, 10, -5);
            scene.add(fillLight);
            
            // Ambient light - soft overall illumination
            ambientLight = new THREE.AmbientLight(0x404855, 0.5);
            scene.add(ambientLight);
            
            // Rim light for character separation
            rimLight = new THREE.DirectionalLight(0xFFFFFF, 0.4);
            rimLight.position.set(0, 5, -15);
            scene.add(rimLight);
            
            // Player position light - soft spotlight from camera position
            playerLight = new THREE.SpotLight(0xFFFFFF, 15, 37.5, Math.PI / 3, 1.5, 1.8);
            playerLight.position.set(0, 0, 0); // Will be updated by updateCameraPosition()
            playerLight.target.position.set(GRID_WIDTH / 2, cameraHeight, GRID_DEPTH / 2);
            playerLight.castShadow = false;
            scene.add(playerLight);
            scene.add(playerLight.target);
            
            // Update camera position again to position playerLight correctly
            updateCameraPosition();
            
            // Chain light - bright white light that follows the falling chain
            chainLight = new THREE.PointLight(0xFFFFFF, 2.0, 10);
            chainLight.position.set(3, 10, 3);
            scene.add(chainLight);
            
            // Corner lights - DISABLED (replaced by playerLight)
            // const cornerLightIntensity = 1.5;
            // const cornerLightDistance = 15;
            // const cornerLightHeight = 1;
            
            // Front-left corner
            // const cornerLight1 = new THREE.PointLight(0xFFFFFF, cornerLightIntensity, cornerLightDistance);
            // cornerLight1.position.set(-0.75, cornerLightHeight, -0.75);
            // scene.add(cornerLight1);
            
            // Front-right corner
            // const cornerLight2 = new THREE.PointLight(0xFFFFFF, cornerLightIntensity, cornerLightDistance);
            // cornerLight2.position.set(GRID_WIDTH + 0.75, cornerLightHeight, -0.75);
            // scene.add(cornerLight2);
            
            // Back-left corner
            // const cornerLight3 = new THREE.PointLight(0xFFFFFF, cornerLightIntensity, cornerLightDistance);
            // cornerLight3.position.set(-0.75, cornerLightHeight, GRID_DEPTH + 0.75);
            // scene.add(cornerLight3);
            
            // Back-right corner
            // const cornerLight4 = new THREE.PointLight(0xFFFFFF, cornerLightIntensity, cornerLightDistance);
            // cornerLight4.position.set(GRID_WIDTH + 0.75, cornerLightHeight, GRID_DEPTH + 0.75);
            // scene.add(cornerLight4);
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Handle keyboard input
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);
            window.addEventListener('click', onMouseClick);
            window.addEventListener('mousemove', onMouseMove);
            
            // ===== GAMEPAD SUPPORT =====
            // Handle gamepad connections
            window.addEventListener('gamepadconnected', onGamepadConnected);
            window.addEventListener('gamepaddisconnected', onGamepadDisconnected);
            // ===== END GAMEPAD SUPPORT =====
            
            // Load saved data
            loadSettings();
            loadHighScores();
            initializeAchievements();
            loadParticlePlacements();
            loadModelPlacements();
            
            // Preload floor animation atlases
            const atlasLoader = new THREE.TextureLoader();
            atlasLoader.load('effect/atlas_f.png', (texture) => {
                texture.magFilter = THREE.LinearFilter;
                texture.minFilter = THREE.LinearMipMapLinearFilter;
                floorAtlasF = texture;
            });
            atlasLoader.load('effect/atlas_g.png', (texture) => {
                texture.magFilter = THREE.LinearFilter;
                texture.minFilter = THREE.LinearMipMapLinearFilter;
                floorAtlasG = texture;
            });
            
            // ===== AI PLAYER =====
            // Update AI indicator after DOM is ready
            trackedSetTimeout(() => {
                if (document.getElementById('aiIndicator')) {
                    document.getElementById('aiIndicator').style.display = settings.aiEnabled ? 'block' : 'none';
                }
            }, 0);
            // ===== END AI PLAYER =====
            
            // Initialize compass
            updateCompass();
            
            // Start render loop
            animate();
        }
        
        function createCubeFrame() {
            const frameGeometry = new THREE.BoxGeometry(GRID_WIDTH, GRID_HEIGHT, GRID_DEPTH);
            const frameMaterial = new THREE.MeshPhongMaterial({
                color: 0x0D1218,
                transparent: true,
                opacity: 0.1,
                side: THREE.DoubleSide
            });
            const frameMesh = new THREE.Mesh(frameGeometry, frameMaterial);
            // Center the frame: grid goes from 0.5 to GRID_WIDTH+0.5, center at (GRID_WIDTH/2) + 0.5 in Y
            frameMesh.position.set(GRID_WIDTH / 2, (GRID_HEIGHT / 2) + 0.5, GRID_DEPTH / 2);
            scene.add(frameMesh);
            
            // Add edges
            const edges = new THREE.EdgesGeometry(frameGeometry);
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x1B2836, linewidth: 2 });
            const lineSegments = new THREE.LineSegments(edges, lineMaterial);
            lineSegments.position.copy(frameMesh.position);
            scene.add(lineSegments);
        }
        
        function createColumnTubes() {
            // Create a transparent tube for each column in the grid
            for (let x = 0; x < GRID_WIDTH; x++) {
                for (let z = 0; z < GRID_DEPTH; z++) {
                    // Create cylinder geometry (tube) from y=0.5 to top of grid
                    const tubeHeight = GRID_HEIGHT - 0.5; // Shorten by 0.5 to start at floor indicator
                    const tubeRadius = 0.05; // Thin like a straw
                    
                    const tubeGeometry = new THREE.CylinderGeometry(
                        tubeRadius, 
                        tubeRadius, 
                        tubeHeight, 
                        8, // radial segments - fewer since it's so thin
                        1,  // height segments
                        false // NOT open ended - solid caps
                    );
                    
                    const tubeMaterial = new THREE.MeshBasicMaterial({
                        color: 0x00FFFF,
                        side: THREE.DoubleSide
                    });
                    
                    const tube = new THREE.Mesh(tubeGeometry, tubeMaterial);
                    
                    // Position tube - cylinder center is at midpoint, starting from y=0.5
                    tube.position.set(x + 0.5, (tubeHeight / 2) + 0.5, z + 0.5);
                    
                    // Disable frustum culling so tubes are always rendered
                    tube.frustumCulled = false;
                    
                    // Store reference with grid coordinates
                    tube.userData = {
                        gridX: x,
                        gridZ: z,
                        originalOpacity: 0.3
                    };
                    
                    scene.add(tube);
                    columnTubes.push(tube);
                }
            }
        }
        
        function createFloorIndicators() {
            // Create a glowing floor plane for each grid position
            for (let x = 0; x < GRID_WIDTH; x++) {
                for (let z = 0; z < GRID_DEPTH; z++) {
                    const planeGeometry = new THREE.PlaneGeometry(1, 1);
                    const planeMaterial = new THREE.MeshBasicMaterial({
                        color: 0x00FFFF,
                        side: THREE.DoubleSide
                    });
                    
                    const plane = new THREE.Mesh(planeGeometry, planeMaterial);
                    
                    // Position on floor, rotate to be horizontal
                    plane.position.set(x + 0.5, 0.5, z + 0.5); // At same height as bottom link center
                    plane.rotation.x = -Math.PI / 2; // Rotate to lay flat
                    
                    plane.userData = { gridX: x, gridZ: z };
                    plane.visible = false; // Start hidden
                    
                    scene.add(plane);
                    floorIndicators.push(plane);
                }
            }
        }
        
        // Decorative chain column templates
        let chainColumnIdCounter = 0;
        const decorativeChainColumns = [
            { id: chainColumnIdCounter++, x: -0.75, y: -4, z: -0.75, rotation: 0, colorMode: 'random', singleColor: null, chainLength: 0, direction: 'up', enabled: true },  // Front-left corner
            { id: chainColumnIdCounter++, x: GRID_WIDTH + 0.75, y: -4, z: -0.75, rotation: 0, colorMode: 'random', singleColor: null, chainLength: 0, direction: 'up', enabled: true },  // Front-right corner
            { id: chainColumnIdCounter++, x: -0.75, y: -4, z: GRID_DEPTH + 0.75, rotation: 0, colorMode: 'random', singleColor: null, chainLength: 0, direction: 'up', enabled: true },  // Back-left corner
            { id: chainColumnIdCounter++, x: GRID_WIDTH + 0.75, y: -4, z: GRID_DEPTH + 0.75, rotation: 0, colorMode: 'random', singleColor: null, chainLength: 0, direction: 'up', enabled: true },  // Back-right corner
            { id: chainColumnIdCounter++, x: -34, y: -0.5, z: -31, rotation: 0, colorMode: 'single', singleColor: LinkType.ZEC_D, chainLength: -6, direction: 'up', enabled: true },  // Red up column
            { id: chainColumnIdCounter++, x: -34.5, y: -0.5, z: -30, rotation: 0, colorMode: 'random', singleColor: null, chainLength: -6, direction: 'down', enabled: true },  // Random color down column
            { id: chainColumnIdCounter++, x: -34, y: -0.5, z: -28.5, rotation: 0, colorMode: 'single', singleColor: LinkType.ZEC_C, chainLength: -6, direction: 'up', enabled: true },  // Green up column
            { id: chainColumnIdCounter++, x: -28.5, y: -0.5, z: 40.5, rotation: 0, colorMode: 'random', singleColor: null, chainLength: -6, direction: 'down', enabled: true },  // Random down column
            { id: chainColumnIdCounter++, x: -29.5, y: -0.5, z: 40.5, rotation: 0, colorMode: 'single', singleColor: LinkType.ZEC_B, chainLength: -6, direction: 'up', enabled: true }  // Blue up column
        ];

        function createCornerFeedTubes() {
            const tubeHeight = GRID_HEIGHT;
            const tubeRadius = 0.3;
            
            decorativeChainColumns.forEach((column, index) => {
                if (!column.enabled) return;
                
                // Calculate tube height based on chainLength modifier
                const actualTubeHeight = Math.abs(tubeHeight + column.chainLength);
                
                // Create tube
                const tubeGeometry = new THREE.CylinderGeometry(
                    tubeRadius,
                    tubeRadius,
                    actualTubeHeight,
                    16,
                    1,
                    true // Open ended
                );
                
                const tubeMaterial = new THREE.MeshBasicMaterial({
                    color: 0x1B2836,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide
                });
                
                const tube = new THREE.Mesh(tubeGeometry, tubeMaterial);
                tube.position.set(column.x, actualTubeHeight / 2, column.z);
                tube.rotation.y = column.rotation;
                tube.frustumCulled = false;
                scene.add(tube);
                cornerTubes.push(tube);
                
                // Create chain links inside tube (going from bottom to top)
                const chainLinks = [];
                const linkSpacing = 1; // Same as falling chains
                
                // Calculate number of links based on chainLength modifier
                const numLinks = GRID_HEIGHT + 5 + column.chainLength;
                const startY = column.y; // Use Y from template
                
                for (let i = 0; i < numLinks; i++) {
                    let linkType;
                    
                    if (column.colorMode === 'single' && column.singleColor !== null) {
                        // Use single color
                        linkType = column.singleColor;
                    } else {
                        // Random color
                        const linkTypes = [LinkType.ZEC_A, LinkType.ZEC_B, LinkType.ZEC_C, LinkType.ZEC_D];
                        linkType = linkTypes[Math.floor(Math.random() * linkTypes.length)];
                    }
                    
                    const link = createLinkMesh(linkType);
                    
                    // Position from startY upward
                    link.position.set(column.x, startY + i, column.z);
                    
                    // Alternate rotation for chain effect (same as falling chains)
                    if (i % 2 === 1) {
                        link.rotation.y = Math.PI / 2;
                    }
                    
                    // Apply column rotation
                    link.rotation.y += column.rotation;
                    
                    scene.add(link);
                    chainLinks.push(link);
                }
                
                // Create management box and arrows for this column
                createChainColumnBox(column);
                
                cornerChains.push({
                    links: chainLinks,
                    column: column,
                    colorMode: column.colorMode,
                    singleColor: column.singleColor,
                    direction: column.direction || 'up'
                });
            });
        }
        
        function createChainColumnBox(column) {
            // Create box at center height
            const boxGeometry = new THREE.BoxGeometry(2, 2, 2);
            const boxMaterial = new THREE.MeshBasicMaterial({
                color: 0xffaa00,
                wireframe: true,
                transparent: true,
                opacity: 0.7
            });
            const box = new THREE.Mesh(boxGeometry, boxMaterial);
            box.position.set(column.x, column.y + 3, column.z);
            box.userData.chainColumnId = column.id;
            box.userData.isChainColumnBox = true;
            box.visible = settings.showHitboxes;
            scene.add(box);
            column.box = box;
            
            // Create arrows for movement
            const arrowLength = 3.0;
            const arrowColor = 0xffaa00;
            const directions = [
                { dir: new THREE.Vector3(1, 0, 0), offset: new THREE.Vector3(3, 0, 0), axis: 'x', sign: 1 },
                { dir: new THREE.Vector3(-1, 0, 0), offset: new THREE.Vector3(-3, 0, 0), axis: 'x', sign: -1 },
                { dir: new THREE.Vector3(0, 1, 0), offset: new THREE.Vector3(0, 3, 0), axis: 'y', sign: 1 },
                { dir: new THREE.Vector3(0, -1, 0), offset: new THREE.Vector3(0, -3, 0), axis: 'y', sign: -1 },
                { dir: new THREE.Vector3(0, 0, 1), offset: new THREE.Vector3(0, 0, 3), axis: 'z', sign: 1 },
                { dir: new THREE.Vector3(0, 0, -1), offset: new THREE.Vector3(0, 0, -3), axis: 'z', sign: -1 }
            ];
            
            column.arrows = [];
            directions.forEach(d => {
                const arrow = new THREE.ArrowHelper(d.dir, box.position.clone().add(d.offset), arrowLength, arrowColor, 1.0, 0.6);
                arrow.userData.chainColumnId = column.id;
                arrow.userData.isChainColumnArrow = true;
                arrow.userData.axis = d.axis;
                arrow.userData.sign = d.sign;
                arrow.visible = settings.showHitboxes;
                scene.add(arrow);
                column.arrows.push(arrow);
            });
        }
        
        function loadChainLinkModel() {
            const loader = new THREE.GLTFLoader();
            let loadedCount = 0;
            const totalModels = 4;
            
            function checkAllLoaded() {
                loadedCount++;
                if (loadedCount === totalModels) {
                    modelLoaded = true;
                    // Create corner feed tubes after all models are loaded
                    createCornerFeedTubes();
                }
            }
            
            // Load yellow chain
            loader.load('models/chain_yellow_a.glb', function(gltf) {
                chainModelYellow = gltf.scene;
                chainModelYellow.scale.set(1.25, 1.25, 1.25);
                chainModelYellow.traverse((child) => {
                    if (child.isMesh && child.material) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        
                        // Create HQ material (clone from original)
                        const hqMat = child.material.clone();
                        if (hqMat.metalness !== undefined) hqMat.metalness = 0.7;
                        if (hqMat.roughness !== undefined) hqMat.roughness = 0.1;
                        hqMat.emissiveIntensity = 0.1;
                        materialsHQ.yellow = hqMat;
                        
                        // Create LQ material (MeshBasicMaterial with texture)
                        const lqMat = new THREE.MeshBasicMaterial({
                            color: 0xF2C94C,
                            map: child.material.map, // Preserve texture/logo
                            transparent: child.material.transparent,
                            opacity: child.material.opacity
                        });
                        materialsLQ.yellow = lqMat;
                        
                        // Set current material to HQ
                        child.material = hqMat;
                    }
                });
                checkAllLoaded();
            });
            
            // Load blue chain
            loader.load('models/chain_blue_a.glb', function(gltf) {
                chainModelBlue = gltf.scene;
                chainModelBlue.scale.set(1.25, 1.25, 1.25);
                chainModelBlue.traverse((child) => {
                    if (child.isMesh && child.material) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        
                        // Create HQ material (clone from original)
                        const hqMat = child.material.clone();
                        if (hqMat.metalness !== undefined) hqMat.metalness = 0.7;
                        if (hqMat.roughness !== undefined) hqMat.roughness = 0.1;
                        hqMat.emissiveIntensity = 0.1;
                        materialsHQ.blue = hqMat;
                        
                        // Create LQ material (MeshBasicMaterial with texture)
                        const lqMat = new THREE.MeshBasicMaterial({
                            color: 0x2D9CDB,
                            map: child.material.map, // Preserve texture/logo
                            transparent: child.material.transparent,
                            opacity: child.material.opacity
                        });
                        materialsLQ.blue = lqMat;
                        
                        // Set current material to HQ
                        child.material = hqMat;
                    }
                });
                checkAllLoaded();
            });
            
            // Load green chain
            loader.load('models/chain_green_a.glb', function(gltf) {
                chainModelGreen = gltf.scene;
                chainModelGreen.scale.set(1.25, 1.25, 1.25);
                chainModelGreen.traverse((child) => {
                    if (child.isMesh && child.material) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        
                        // Create HQ material (clone from original)
                        const hqMat = child.material.clone();
                        if (hqMat.metalness !== undefined) hqMat.metalness = 0.7;
                        if (hqMat.roughness !== undefined) hqMat.roughness = 0.1;
                        hqMat.emissiveIntensity = 0.1;
                        materialsHQ.green = hqMat;
                        
                        // Create LQ material (MeshBasicMaterial with texture)
                        const lqMat = new THREE.MeshBasicMaterial({
                            color: 0x27AE60,
                            map: child.material.map, // Preserve texture/logo
                            transparent: child.material.transparent,
                            opacity: child.material.opacity
                        });
                        materialsLQ.green = lqMat;
                        
                        // Set current material to HQ
                        child.material = hqMat;
                    }
                });
                checkAllLoaded();
            });
            
            // Load red chain
            loader.load('models/chain_red_a.glb', function(gltf) {
                chainModelRed = gltf.scene;
                chainModelRed.scale.set(1.25, 1.25, 1.25);
                chainModelRed.traverse((child) => {
                    if (child.isMesh && child.material) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        
                        // Create HQ material (clone from original)
                        const hqMat = child.material.clone();
                        if (hqMat.metalness !== undefined) hqMat.metalness = 0.7;
                        if (hqMat.roughness !== undefined) hqMat.roughness = 0.1;
                        hqMat.emissiveIntensity = 0.1;
                        materialsHQ.red = hqMat;
                        
                        // Create LQ material (MeshBasicMaterial with texture)
                        const lqMat = new THREE.MeshBasicMaterial({
                            color: 0xEB5757,
                            map: child.material.map, // Preserve texture/logo
                            transparent: child.material.transparent,
                            opacity: child.material.opacity
                        });
                        materialsLQ.red = lqMat;
                        
                        // Set current material to HQ
                        child.material = hqMat;
                    }
                });
                checkAllLoaded();
            });
        }
        
        function loadTableModel() {
            const loader = new THREE.GLTFLoader();
            loader.load(
                'models/Zcash_GameTable_A.glb',
                function(gltf) {
                    tableModel = gltf.scene;
                    tableModelLoaded = true;
                    tableModel.scale.set(10, 10, 10);
                    tableModel.position.set(GRID_WIDTH / 2, -9.5, GRID_DEPTH / 2);
                    tableModel.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            // Invert colors to make table dark instead of white
                            if (child.material) {
                                child.material = child.material.clone(); // Clone to avoid affecting other instances
                                child.material.color.setHex(0x0A0E12); // Dark blue-grey
                                if (child.material.emissive) {
                                    child.material.emissive.setHex(0x000000); // No emissive
                                }
                            }
                        }
                    });
                    scene.add(tableModel);
                }
            );
        }
        
        function loadZookoModel() {
            const loader = new THREE.GLTFLoader();
            loader.load(
                'people/zooko_a.glb',
                function(gltf) {
                    zookoModel = gltf.scene;
                    zookoLoaded = true;
                    
                    // Position Zooko in the room (adjust as needed)
                    zookoModel.position.set(-10, -9.25, -10);
                    zookoModel.rotation.y = Math.PI / 4; // Face toward center
                    zookoModel.scale.set(15, 15, 15);
                    
                    // Enable shadows and adjust skin materials
                    zookoModel.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            child.frustumCulled = false; // Keep in render list when changing views
                            
                            // Reduce shininess on skin materials
                            if (child.material && child.material.name) {
                                const matName = child.material.name.toLowerCase();
                                if (matName.includes('skin') || matName.includes('face') || matName.includes('head') || matName.includes('body')) {
                                    child.material.roughness = 0.9; // More matte
                                    child.material.metalness = 0.0; // Not metallic
                                }
                            }
                        }
                        if (child.isBone || child.type === 'Bone') {
                            const boneName = child.name.toLowerCase();
                            if (boneName.includes('head')) {
                                zookoHeadBone = child;
                            }
                        }
                    });
                    
                    // Create click box around Zooko
                    const boxGeometry = new THREE.BoxGeometry(5, 22, 5);
                    const boxMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xff0000,
                        wireframe: true,
                        transparent: true,
                        opacity: 0.5
                    });
                    zookoClickBox = new THREE.Mesh(boxGeometry, boxMaterial);
                    zookoClickBox.position.copy(zookoModel.position);
                    zookoClickBox.position.y += 12; // Offset up to center on Zooko
                    zookoClickBox.visible = settings.showHitboxes; // Use setting for visibility
                    scene.add(zookoClickBox);
                    
                    // Setup animation mixer if animations exist
                    if (gltf.animations && gltf.animations.length > 0) {
                        zookoMixer = new THREE.AnimationMixer(zookoModel);
                        // Play the first animation (idle) in loop
                        zookoIdleAction = zookoMixer.clipAction(gltf.animations[0]);
                        zookoIdleAction.play();
                        
                        // Spawn shield particle at head during idle with looping
                        function spawnZookoHeadShield() {
                            if (zookoHeadBone) {
                                zookoHeadBone.getWorldPosition(_boneTempHeadPos);
                                spawnParticleEffect('effect/zooko_shield.json', 
                                    _boneTempHeadPos.x + zookoHeadOffset.x, 
                                    _boneTempHeadPos.y + zookoHeadOffset.y, 
                                    _boneTempHeadPos.z + zookoHeadOffset.z, {
                                    spawnMode: 'world',
                                    rotation: { x: 0, y: 0, z: 0 },
                                    startDelay: 0,
                                    parentBone: zookoHeadBone,
                                    parentModel: zookoModel,
                                    boneOffset: zookoHeadOffset
                                });
                                // Loop: respawn at emitDuration (1.1s = 1100ms)
                                trackedSetTimeout(spawnZookoHeadShield, 1100);
                            }
                        }
                        trackedSetTimeout(spawnZookoHeadShield, 100);
                        
                        // Spawn hat particle at head during idle with looping
                        function spawnZookoHat() {
                            if (zookoHeadBone) {
                                zookoHeadBone.getWorldPosition(_boneTempHeadPos);
                                spawnParticleEffect('effect/zooko_hat.json', 
                                    _boneTempHeadPos.x + zookoHatOffset.x, 
                                    _boneTempHeadPos.y + zookoHatOffset.y, 
                                    _boneTempHeadPos.z + zookoHatOffset.z, {
                                    spawnMode: 'world',
                                    rotation: { x: 0, y: 0, z: 0 },
                                    startDelay: 0,
                                    parentBone: zookoHeadBone,
                                    parentModel: zookoModel,
                                    boneOffset: zookoHatOffset
                                });
                                // Loop: respawn at emitDuration (1.1s = 1100ms)
                                trackedSetTimeout(spawnZookoHat, 1100);
                            }
                        }
                        trackedSetTimeout(spawnZookoHat, 100);
                        
                        // Load the special animation
                        const specialLoader = new THREE.GLTFLoader();
                        specialLoader.load('people/zooko_a_special.glb', function(specialGltf) {
                            if (specialGltf.animations && specialGltf.animations.length > 0) {
                                zookoSpecialClip = specialGltf.animations[0];
                                zookoSpecialAction = zookoMixer.clipAction(zookoSpecialClip);
                                zookoSpecialAction.setLoop(THREE.LoopOnce);
                                zookoSpecialAction.clampWhenFinished = true;
                            }
                        });
                    }
                    
                    scene.add(zookoModel);
                }
            );
        }
        
        function loadCyberAxeModel() {
            const loader = new THREE.GLTFLoader();
            loader.load(
                'people/cyberaxe_a.glb',
                function(gltf) {
                    cyberAxeModel = gltf.scene;
                    cyberAxeLoaded = true;
                    
                    // Position CyberAxe across from Zooko (diagonal opposite corner)
                    cyberAxeModel.position.set(25, -8.25, 25);
                    cyberAxeModel.rotation.y = cyberAxeBaseRotation; // Face toward center
                    cyberAxeModel.scale.set(14, 14, 14);
                    
                    // Enable shadows and adjust skin materials
                    cyberAxeModel.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            child.frustumCulled = false; // Keep in render list when changing views
                            
                            // Reduce shininess on skin materials
                            if (child.material && child.material.name) {
                                const matName = child.material.name.toLowerCase();
                                if (matName.includes('skin') || matName.includes('face') || matName.includes('head') || matName.includes('body')) {
                                    child.material.roughness = 0.9; // More matte
                                    child.material.metalness = 0.0; // Not metallic
                                }
                            }
                        }
                        if (child.isBone || child.type === 'Bone') {
                            const boneName = child.name.toLowerCase();
                            if (boneName.includes('hand') && boneName.includes('r')) {
                                cyberAxeHandBone = child;
                            }
                            if (boneName.includes('hand') && boneName.includes('l')) {
                                cyberAxeLeftHandBone = child;
                            }
                            if (boneName.includes('spine') && boneName.includes('1')) {
                                cyberAxeChestBone = child;
                            }
                        }
                    });
                    
                    // Create click box around CyberAxe
                    const boxGeometry = new THREE.BoxGeometry(5, 22, 5);
                    const boxMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0x00ffff,
                        wireframe: true,
                        transparent: true,
                        opacity: 0.5
                    });
                    cyberAxeClickBox = new THREE.Mesh(boxGeometry, boxMaterial);
                    cyberAxeClickBox.position.copy(cyberAxeModel.position);
                    cyberAxeClickBox.position.y += 12; // Offset up to center on CyberAxe
                    cyberAxeClickBox.visible = settings.showHitboxes; // Use setting for visibility
                    scene.add(cyberAxeClickBox);
                    
                    // Setup animation mixer if animations exist
                    if (gltf.animations && gltf.animations.length > 0) {
                        cyberAxeMixer = new THREE.AnimationMixer(cyberAxeModel);
                        // Play the first animation (idle) in loop
                        cyberAxeIdleAction = cyberAxeMixer.clipAction(gltf.animations[0]);
                        cyberAxeIdleAction.play();
                        
                        // Spawn shield particle at chest during idle with looping
                        function spawnCyberAxeChestShield() {
                            if (cyberAxeChestBone) {
                                cyberAxeChestBone.getWorldPosition(_boneTempHeadPos);
                                spawnParticleEffect('effect/cyberaxe_shield.json', 
                                    _boneTempHeadPos.x + cyberAxeChestOffset.x, 
                                    _boneTempHeadPos.y + cyberAxeChestOffset.y, 
                                    _boneTempHeadPos.z + cyberAxeChestOffset.z, {
                                    spawnMode: 'world',
                                    rotation: { x: 0, y: 0, z: 0 },
                                    startDelay: 0,
                                    parentBone: cyberAxeChestBone,
                                    parentModel: cyberAxeModel,
                                    boneOffset: cyberAxeChestOffset
                                });
                                // Loop: respawn at emitDuration (1.1s = 1100ms)
                                trackedSetTimeout(spawnCyberAxeChestShield, 1100);
                            }
                        }
                        trackedSetTimeout(spawnCyberAxeChestShield, 100);
                        
                        // Load the special animation
                        const specialLoader = new THREE.GLTFLoader();
                        specialLoader.load('people/cyberaxe_a_special.glb', function(specialGltf) {
                            if (specialGltf.animations && specialGltf.animations.length > 0) {
                                cyberAxeSpecialClip = specialGltf.animations[0];
                                cyberAxeSpecialAction = cyberAxeMixer.clipAction(cyberAxeSpecialClip);
                                cyberAxeSpecialAction.setLoop(THREE.LoopOnce);
                                cyberAxeSpecialAction.clampWhenFinished = true;
                            }
                        });
                    }
                    
                    scene.add(cyberAxeModel);
                }
            );
        }
        
        function loadZancasModel() {
            const loader = new THREE.GLTFLoader();
            loader.load(
                'people/zancas_a.glb',
                function(gltf) {
                    zancasModel = gltf.scene;
                    zancasLoaded = true;
                    
                    // Position Zancas in the room (opposite corner from Zooko)
                    zancasModel.position.set(34, -9, -30);
                    zancasModel.rotation.y = zancasBaseRotation; // Face toward center
                    zancasModel.scale.set(15, 15, 15);
                    
                    // Enable shadows and adjust skin materials, find hand bone
                    zancasModel.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            child.frustumCulled = false; // Keep in render list when changing views
                            
                            // Reduce shininess on skin materials
                            if (child.material && child.material.name) {
                                const matName = child.material.name.toLowerCase();
                                if (matName.includes('skin') || matName.includes('face') || matName.includes('head') || matName.includes('body')) {
                                    child.material.roughness = 0.9; // More matte
                                    child.material.metalness = 0.0; // Not metallic
                                }
                            }
                        }
                        if (child.isBone || child.type === 'Bone') {
                            const boneName = child.name.toLowerCase();
                            if (boneName.includes('hand') && boneName.includes('r')) {
                                zancasHandBone = child;
                            }
                            if (boneName.includes('hand') && boneName.includes('l')) {
                                zancasLeftHandBone = child;
                            }
                        }
                    });
                    
                    // Create click box around Zancas
                    const boxGeometry = new THREE.BoxGeometry(10, 10, 10);
                    const boxMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0x00ff00,
                        wireframe: true,
                        transparent: true,
                        opacity: 0.5
                    });
                    zancasClickBox = new THREE.Mesh(boxGeometry, boxMaterial);
                    zancasClickBox.position.copy(zancasModel.position);
                    zancasClickBox.position.y += 5; // Offset up to center on Zancas
                    zancasClickBox.visible = settings.showHitboxes; // Use setting for visibility
                    scene.add(zancasClickBox);
                    
                    // Setup animation mixer if animations exist
                    if (gltf.animations && gltf.animations.length > 0) {
                        zancasMixer = new THREE.AnimationMixer(zancasModel);
                        // Play the first animation (idle) in loop
                        zancasIdleAction = zancasMixer.clipAction(gltf.animations[0]);
                        zancasIdleAction.play();
                        
                        // Load the special animation
                        const specialLoader = new THREE.GLTFLoader();
                        specialLoader.load('people/zancas_a_special.glb', function(specialGltf) {
                            if (specialGltf.animations && specialGltf.animations.length > 0) {
                                zancasSpecialClip = specialGltf.animations[0];
                                zancasSpecialAction = zancasMixer.clipAction(zancasSpecialClip);
                                zancasSpecialAction.setLoop(THREE.LoopOnce);
                                zancasSpecialAction.clampWhenFinished = true;
                            }
                        });
                    }
                    
                    scene.add(zancasModel);
                }
            );
        }
        
        function playZancasSpecialAnimation() {
            if (!zancasSpecialAction || !zancasIdleAction) {
                return;
            }
            
            // Check if another special is already active
            if (zookoSpecialActive || nateSpecialActive || cyberAxeSpecialActive) {
                return;
            }
            
            // Check if charged
            if (zancasCharge < 100) {
                return;
            }
            
            // Consume charge
            zancasCharge = 0;
            updateSpecialAbilityBars();
            
            // Trigger the special effect
            triggerZancasSpecialEffect();
            
            // Store original position
            const originalPos = zancasModel.position.clone();
            
            // Move to special position and rotate
            zancasModel.position.set(zancasSpecialPosition.x, zancasSpecialPosition.y, zancasSpecialPosition.z);
            zancasModel.rotation.y = zancasSpecialRotation;
            
            // Reset loop counter
            zancasSpecialLoopCount = 0;
            
            // Show notification
            const notif = document.createElement('div');
            notif.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, rgba(86, 204, 242, 0.2), rgba(47, 128, 237, 0.2));
                color: white;
                padding: 30px 50px;
                border-radius: 20px;
                font-weight: 700;
                font-size: 36px;
                box-shadow: 0 10px 40px rgba(86, 204, 242, 0.6);
                backdrop-filter: blur(10px);
                z-index: 1000;
                animation: zookoSpecial 2s ease-out forwards;
            `;
            notif.textContent = 'Zancas Special!';
            document.body.appendChild(notif);
            
            trackedSetTimeout(() => notif.remove(), 2000);
            
            // Stop idle and play special
            zancasIdleAction.stop();
            zancasSpecialAction.reset();
            zancasSpecialAction.play();
            
            // Listen for animation finish
            const onFinished = (e) => {
                if (e.action === zancasSpecialAction) {
                    // Play once, then return to idle
                    zancasSpecialAction.stop();
                    zancasIdleAction.reset();
                    zancasIdleAction.play();
                    // Move back to original position and rotation
                    zancasModel.position.copy(originalPos);
                    zancasModel.rotation.y = zancasBaseRotation;
                    zancasMixer.removeEventListener('finished', onFinished);
                }
            };
            zancasMixer.addEventListener('finished', onFinished);
        }
        
        function triggerZancasSpecialEffect() {
            if (zancasSpecialActive) return; // Prevent multiple activations
            
            zancasSpecialActive = true;
            
            // Increment sandblasting charge by 25%
            sandblastingCharge = Math.min(100, sandblastingCharge + 25);
            updateSandblastingBar();
            
            // Check if sandblasting should trigger
            if (sandblastingCharge >= 100) {
                trackedSetTimeout(() => {
                    triggerSandblastingEvent();
                }, 2000); // Trigger after special completes
            }
            
            // Spawn particle effect in camera view (same as Zooko) with 1 second delay
            spawnParticleEffect('effect/zancas_special.json', 8, -1, 0, {
                spawnMode: 'camera',
                rotation: { x: 0, y: 0, z: 0 },
                startDelay: 1
            });
            
            // Spawn hand-tracking orb particles at Zancas's right hand
            if (zancasHandBone) {
                zancasHandBone.getWorldPosition(_boneTempHeadPos);
                spawnParticleEffect('effect/zancas_special_orb.json', 
                    _boneTempHeadPos.x + zancasHandOffset.x, 
                    _boneTempHeadPos.y + zancasHandOffset.y, 
                    _boneTempHeadPos.z + zancasHandOffset.z, {
                    spawnMode: 'world',
                    rotation: { x: 0, y: 0, z: 0 },
                    startDelay: 0,
                    parentBone: zancasHandBone,
                    parentModel: zancasModel,
                    boneOffset: zancasHandOffset
                });
            }
            
            // Spawn hand-tracking orb particles at Zancas's left hand
            if (zancasLeftHandBone) {
                zancasLeftHandBone.getWorldPosition(_boneTempHeadPos);
                spawnParticleEffect('effect/zancas_special_orb_left.json', 
                    _boneTempHeadPos.x + zancasLeftHandOffset.x, 
                    _boneTempHeadPos.y + zancasLeftHandOffset.y, 
                    _boneTempHeadPos.z + zancasLeftHandOffset.z, {
                    spawnMode: 'world',
                    rotation: { x: 0, y: 0, z: 0 },
                    startDelay: 0,
                    parentBone: zancasLeftHandBone,
                    parentModel: zancasModel,
                    boneOffset: zancasLeftHandOffset
                });
            }
            
            // Count all block types in the grid
            const typeCounts = {};
            for (let x = 0; x < GRID_WIDTH; x++) {
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    for (let z = 0; z < GRID_DEPTH; z++) {
                        if (grid[x][y][z] !== null) {
                            const typeName = grid[x][y][z].type.name;
                            typeCounts[typeName] = (typeCounts[typeName] || 0) + 1;
                        }
                    }
                }
            }
            
            // Find the two most common types
            const sortedTypes = Object.entries(typeCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 2)
                .map(entry => entry[0]);
            
            // If less than 2 types exist, exit
            if (sortedTypes.length === 0) {
                zancasSpecialActive = false;
                return;
            }
            
            // Slow down time
            currentTimeScale = slowTimeScale;
            
            // Collect all blocks of the two most common types
            const blocksToTransform = [];
            for (let x = 0; x < GRID_WIDTH; x++) {
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    for (let z = 0; z < GRID_DEPTH; z++) {
                        if (grid[x][y][z] !== null && sortedTypes.includes(grid[x][y][z].type.name)) {
                            blocksToTransform.push({ x, y, z, block: grid[x][y][z] });
                        }
                    }
                }
            }
            
            // Transform blocks with staggered timing over a few seconds
            const totalDuration = 3000; // 3 seconds total
            const delayPerBlock = totalDuration / Math.max(blocksToTransform.length, 1);
            
            blocksToTransform.forEach((item, index) => {
                trackedSetTimeout(() => {
                    const { x, y, z, block } = item;
                    if (grid[x][y][z] && grid[x][y][z] === block) {
                        
                        // Spawn particle effect at block position (50% chance)
                        if (Math.random() < 0.5) {
                            spawnParticleEffect('effect/zancas_special_break.json', x + 0.5, y + 1.0, z + 0.5, {
                                spawnMode: 'world',
                                rotation: { x: 0, y: 0, z: 0 },
                                startDelay: 0
                            });
                        }
                        
                        // Transform block to gold (ZEC_A)
                        grid[x][y][z].type = LinkType.ZEC_A;
                        
                        // Note: Mesh color unchanged - already uses pre-colored model
                    }
                }, index * delayPerBlock);
            });
            
            // Restore normal time after transformations complete
            trackedSetTimeout(() => {
                currentTimeScale = normalTimeScale;
                zancasSpecialActive = false;
            }, totalDuration + 500);
        }
        
        function createSmokeEffect(x, y, z) {
            const particleCount = 15;
            const particles = [];
            
            for (let i = 0; i < particleCount; i++) {
                const geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                const material = new THREE.MeshPhongMaterial({
                    color: 0xCCCCCC,
                    emissive: 0x888888,
                    emissiveIntensity: 0.3,
                    transparent: true,
                    opacity: 0.7
                });
                
                const particle = new THREE.Mesh(geometry, material);
                particle.position.set(x, y, z);
                
                // Random velocity - slower and more upward than explosion
                const speed = 0.02 + Math.random() * 0.03;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI * 0.5; // Bias upward
                
                particle.userData = {
                    velocity: {
                        x: Math.sin(phi) * Math.cos(theta) * speed,
                        y: Math.abs(Math.cos(phi) * speed) * 1.5, // More upward movement
                        z: Math.sin(phi) * Math.sin(theta) * speed
                    },
                    lifetime: 0,
                    maxLifetime: 1.2 // Longer lifetime for smoke
                };
                
                scene.add(particle);
                particles.push(particle);
            }
            
            // Animate smoke particles
            const animateSmoke = () => {
                let allDead = true;
                
                particles.forEach(particle => {
                    particle.userData.lifetime += 0.016; // ~60fps
                    
                    if (particle.userData.lifetime < particle.userData.maxLifetime) {
                        allDead = false;
                        
                        // Update position
                        particle.position.x += particle.userData.velocity.x;
                        particle.position.y += particle.userData.velocity.y;
                        particle.position.z += particle.userData.velocity.z;
                        
                        // Fade out and grow slightly
                        const progress = particle.userData.lifetime / particle.userData.maxLifetime;
                        particle.material.opacity = 0.7 * (1 - progress);
                        particle.scale.setScalar(1 + progress * 0.5);
                        
                        // Slow down over time
                        particle.userData.velocity.x *= 0.98;
                        particle.userData.velocity.y *= 0.98;
                        particle.userData.velocity.z *= 0.98;
                    }
                });
                
                if (!allDead) {
                    const frameId = requestAnimationFrame(animateSmoke);
                    activeAnimationFrames.push(frameId);
                } else {
                    // Clean up
                    particles.forEach(particle => {
                        scene.remove(particle);
                        particle.geometry.dispose();
                        particle.material.dispose();
                    });
                }
            };
            
            animateSmoke();
        }
        
        function loadNateModel() {
            const loader = new THREE.GLTFLoader();
            loader.load(
                'people/nate_a.glb',
                function(gltf) {
                    nateModel = gltf.scene;
                    nateLoaded = true;
                    
                    // Position Nate in the room
                    nateModel.position.set(-30, -5, 34);
                    nateModel.rotation.y = nateBaseRotation; // Face toward center
                    nateModel.scale.set(15, 15, 15);
                    
                    // Enable shadows and adjust skin materials
                    nateModel.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            child.frustumCulled = false; // Keep in render list when changing views
                            
                            // Adjust ALL materials for Nate - make whiter and more matte
                            if (child.material) {
                                child.material.roughness = 1.0; // Fully matte
                                child.material.metalness = 0.0; // Not metallic
                                
                                // Aggressively lighten the base color - much more white
                                if (child.material.color) {
                                    const currentColor = child.material.color;
                                    // Much stronger blend toward white (60% white)
                                    child.material.color.setRGB(
                                        currentColor.r * 0.4 + 0.6,
                                        currentColor.g * 0.4 + 0.6,
                                        currentColor.b * 0.4 + 0.6
                                    );
                                }
                                
                                // Force update
                                child.material.needsUpdate = true;
                            }
                        }
                    });
                    
                    // Create click box around Nate
                    const boxGeometry = new THREE.BoxGeometry(5, 18, 5);
                    const boxMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xffff00,
                        wireframe: true,
                        transparent: true,
                        opacity: 0.5
                    });
                    nateClickBox = new THREE.Mesh(boxGeometry, boxMaterial);
                    nateClickBox.position.copy(nateModel.position);
                    nateClickBox.position.y += 24; // Offset up to center on Nate
                    nateClickBox.visible = settings.showHitboxes; // Use setting for visibility
                    scene.add(nateClickBox);
                    
                    // Setup animation mixer if animations exist
                    if (gltf.animations && gltf.animations.length > 0) {
                        nateMixer = new THREE.AnimationMixer(nateModel);
                        // Play the first animation (idle) in loop
                        nateIdleAction = nateMixer.clipAction(gltf.animations[0]);
                        nateIdleAction.play();
                        
                        // Load the special animation
                        const specialLoader = new THREE.GLTFLoader();
                        specialLoader.load('people/nate_a_special.glb', function(specialGltf) {
                            if (specialGltf.animations && specialGltf.animations.length > 0) {
                                nateSpecialClip = specialGltf.animations[0];
                                nateSpecialAction = nateMixer.clipAction(nateSpecialClip);
                                nateSpecialAction.setLoop(THREE.LoopOnce);
                                nateSpecialAction.clampWhenFinished = true;
                            }
                        });
                    }
                    
                    scene.add(nateModel);
                }
            );
        }
        
        function playNateSpecialAnimation() {
            if (!nateSpecialAction || !nateIdleAction) {
                return;
            }
            
            // Check if another special is already active
            if (zookoSpecialActive || zancasSpecialActive || cyberAxeSpecialActive) {
                return;
            }
            
            // Check if charged
            if (nateCharge < 100) {
                return;
            }
            
            // Consume charge
            nateCharge = 0;
            updateSpecialAbilityBars();
            
            // Trigger the special effect
            triggerNateSpecialEffect();
            
            // Store original position
            const originalPos = nateModel.position.clone();
            
            // Move to special position and rotate
            nateModel.position.set(nateSpecialPosition.x, nateSpecialPosition.y, nateSpecialPosition.z);
            nateModel.rotation.y = nateSpecialRotation;
            
            // Reset loop counter
            nateSpecialLoopCount = 0;
            
            // Show notification
            const notif = document.createElement('div');
            notif.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, rgba(242, 153, 74, 0.2), rgba(242, 201, 76, 0.2));
                color: white;
                padding: 30px 50px;
                border-radius: 20px;
                font-weight: 700;
                font-size: 36px;
                box-shadow: 0 10px 40px rgba(242, 153, 74, 0.6);
                backdrop-filter: blur(10px);
                z-index: 1000;
                animation: zookoSpecial 2s ease-out forwards;
            `;
            notif.textContent = 'Nate Special!';
            document.body.appendChild(notif);
            
            trackedSetTimeout(() => notif.remove(), 2000);
            
            // Stop idle and play special
            nateIdleAction.stop();
            nateSpecialAction.reset();
            nateSpecialAction.play();
            
            // Listen for animation finish
            const onFinished = (e) => {
                if (e.action === nateSpecialAction) {
                    nateSpecialLoopCount++;
                    
                    // Loop 4 times total
                    if (nateSpecialLoopCount < 4) {
                        nateSpecialAction.reset();
                        nateSpecialAction.play();
                    } else {
                        // After 4 loops, return to idle
                        nateSpecialAction.stop();
                        nateIdleAction.reset();
                        nateIdleAction.play();
                        // Move back to original position and rotation
                        nateModel.position.copy(originalPos);
                        nateModel.rotation.y = nateBaseRotation;
                        nateMixer.removeEventListener('finished', onFinished);
                    }
                }
            };
            nateMixer.addEventListener('finished', onFinished);
        }
        
        function triggerNateSpecialEffect() {
            if (nateSpecialActive) return; // Prevent multiple activations
            
            nateSpecialActive = true;
            
            // Increment sandblasting charge by 25%
            sandblastingCharge = Math.min(100, sandblastingCharge + 25);
            updateSandblastingBar();
            
            // Check if sandblasting should trigger
            if (sandblastingCharge >= 100) {
                trackedSetTimeout(() => {
                    triggerSandblastingEvent();
                }, 2000); // Trigger after special completes
            }
            
            // Spawn particle effect in camera view (distance: 8, vertical: 0, horizontal: 0)
            spawnParticleEffect('effect/nate_special.json', 8, -1.5, 0, {
                rotation: { x: 0, y: 0, z: 0 },
                startDelay: 0
            });
            
            // Slow down time
            currentTimeScale = slowTimeScale;
            
            // FIRST: Destroy all broken/glowing links before tornado starts
            const brokenLinksToDestroy = [];
            brokenLinks.forEach(key => {
                const [x, y, z] = key.split(',').map(Number);
                if (grid[x][y][z] !== null) {
                    brokenLinksToDestroy.push({ x, y, z, key });
                }
            });
            
            // Destroy broken links and award points
            brokenLinksToDestroy.forEach(({ x, y, z, key }) => {
                const link = grid[x][y][z];
                if (link) {
                    // Remove from scene
                    disposeLinkMesh(link.mesh);
                    // Remove from grid
                    grid[x][y][z] = null;
                    // Award points (100 per broken link)
                    score += 100;
                    // Remove from brokenLinks set
                    brokenLinks.delete(key);
                }
            });
            
            // Update HUD if we destroyed any broken links
            if (brokenLinksToDestroy.length > 0) {
                updateHUD();
            }
            
            // Collect all blocks currently on the board (after destroying broken links)
            const allBlocks = [];
            for (let x = 0; x < GRID_WIDTH; x++) {
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    for (let z = 0; z < GRID_DEPTH; z++) {
                        if (grid[x][y][z] !== null) {
                            allBlocks.push({
                                x, y, z,
                                block: grid[x][y][z]
                            });
                        }
                    }
                }
            }
            
            // If no blocks, exit
            if (allBlocks.length === 0) {
                currentTimeScale = normalTimeScale;
                nateSpecialActive = false;
                return;
            }
            
            // Shuffle blocks array for random movement order
            for (let i = allBlocks.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [allBlocks[i], allBlocks[j]] = [allBlocks[j], allBlocks[i]];
            }
            
            // Tornado parameters - faster and shorter
            const movesPerBlock = 4; // Each block moves 4 times
            const blocksPerWave = 5; // Move 5 blocks at once for more chaos
            const moveInterval = 75; // 75ms between waves for 3-4 second duration
            
            let moveWave = 0;
            const totalWaves = Math.ceil((allBlocks.length * movesPerBlock) / blocksPerWave);
            
            const tornadoInterval = trackedSetInterval(() => {
                if (moveWave >= totalWaves) {
                    trackedClearInterval(tornadoInterval);
                    
                    // Reset all block rotations to 0 or 90 degrees
                    for (let x = 0; x < GRID_WIDTH; x++) {
                        for (let y = 0; y < GRID_HEIGHT; y++) {
                            for (let z = 0; z < GRID_DEPTH; z++) {
                                if (grid[x][y][z] !== null && grid[x][y][z].mesh) {
                                    // Calculate which link in the chain this is based on y position
                                    const chainY = y % 2;
                                    // Alternate 0 and 90 degrees for interlocking chain links
                                    grid[x][y][z].mesh.rotation.y = chainY === 1 ? Math.PI / 2 : 0;
                                    grid[x][y][z].mesh.rotation.x = 0;
                                    grid[x][y][z].mesh.rotation.z = 0;
                                }
                            }
                        }
                    }
                    
                    // Apply gravity after tornado
                    trackedSetTimeout(() => {
                        applyGravity();
                        
                        // Restore normal time
                        trackedSetTimeout(() => {
                            currentTimeScale = normalTimeScale;
                            nateSpecialActive = false;
                        }, 500);
                    }, 200);
                    return;
                }
                
                // Move multiple blocks at once for tornado effect
                for (let i = 0; i < blocksPerWave; i++) {
                    const blockIndex = (moveWave * blocksPerWave + i) % allBlocks.length;
                    const currentBlockData = allBlocks[blockIndex];
                    
                    // Find current position in grid
                    let foundX = -1, foundY = -1, foundZ = -1;
                    for (let x = 0; x < GRID_WIDTH; x++) {
                        for (let y = 0; y < GRID_HEIGHT; y++) {
                            for (let z = 0; z < GRID_DEPTH; z++) {
                                if (grid[x][y][z] === currentBlockData.block) {
                                    foundX = x;
                                    foundY = y;
                                    foundZ = z;
                                    break;
                                }
                            }
                            if (foundX !== -1) break;
                        }
                        if (foundX !== -1) break;
                    }
                    
                    if (foundX !== -1) {
                        // Find adjacent empty positions (including diagonals for more chaotic movement)
                        const adjacentPositions = [];
                        for (let dx = -1; dx <= 1; dx++) {
                            for (let dz = -1; dz <= 1; dz++) {
                                if (dx === 0 && dz === 0) continue;
                                
                                const newX = foundX + dx;
                                const newZ = foundZ + dz;
                                
                                if (newX >= 0 && newX < GRID_WIDTH && 
                                    newZ >= 0 && newZ < GRID_DEPTH &&
                                    foundY >= 0 && foundY < GRID_HEIGHT &&
                                    grid[newX][foundY][newZ] === null) {
                                    adjacentPositions.push({ x: newX, y: foundY, z: newZ });
                                }
                            }
                        }
                        
                        // Move to a random adjacent empty position
                        if (adjacentPositions.length > 0) {
                            const targetPos = adjacentPositions[Math.floor(Math.random() * adjacentPositions.length)];
                            
                            // Spawn particle effect at block position before moving (25% chance)
                            if (Math.random() < 0.25) {
                                spawnParticleEffect('effect/nate_special_break.json', foundX + 0.5, foundY + 1.0, foundZ + 0.5, {
                                    spawnMode: 'world',
                                    rotation: { x: 0, y: 0, z: 0 },
                                    startDelay: 0
                                });
                            }
                            
                            // Move the block in the grid
                            const block = grid[foundX][foundY][foundZ];
                            grid[foundX][foundY][foundZ] = null;
                            grid[targetPos.x][targetPos.y][targetPos.z] = block;
                            
                            // Animate the mesh movement
                            if (block.mesh) {
                                const startPos = {
                                    x: block.mesh.position.x,
                                    y: block.mesh.position.y,
                                    z: block.mesh.position.z
                                };
                                const endPos = {
                                    x: targetPos.x + 0.5,
                                    y: targetPos.y + 0.5,
                                    z: targetPos.z + 0.5
                                };
                                
                                const animDuration = 40; // Faster movements
                                const startTime = Date.now();
                                
                                const animateMove = () => {
                                    const elapsed = Date.now() - startTime;
                                    const progress = Math.min(elapsed / animDuration, 1);
                                    
                                    block.mesh.position.x = startPos.x + (endPos.x - startPos.x) * progress;
                                    block.mesh.position.y = startPos.y + (endPos.y - startPos.y) * progress;
                                    block.mesh.position.z = startPos.z + (endPos.z - startPos.z) * progress;
                                    
                                    // Add rotation for tornado spin effect
                                    block.mesh.rotation.y += 0.15;
                                    
                                    if (progress < 1) {
                                        const frameId = requestAnimationFrame(animateMove);
                                        activeAnimationFrames.push(frameId);
                                    }
                                };
                                
                                animateMove();
                            }
                        }
                    }
                }
                
                moveWave++;
            }, moveInterval);
        }
        
        function playZookoSpecialAnimation() {
            if (!zookoSpecialAction || !zookoIdleAction) {
                return;
            }
            
            // Check if another special is already active
            if (nateSpecialActive || zancasSpecialActive || cyberAxeSpecialActive) {
                return;
            }
            
            // Check if charged
            if (zookoCharge < 100) {
                return;
            }
            
            // Consume charge
            zookoCharge = 0;
            updateSpecialAbilityBars();
            
            // Trigger the special effect
            triggerZookoSpecialEffect();
            
            // Show notification
            const notif = document.createElement('div');
            notif.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, rgba(155, 81, 224, 0.2), rgba(187, 107, 217, 0.2));
                color: white;
                padding: 30px 50px;
                border-radius: 20px;
                font-weight: 700;
                font-size: 36px;
                box-shadow: 0 10px 40px rgba(155, 81, 224, 0.6);
                backdrop-filter: blur(10px);
                z-index: 1000;
                animation: zookoSpecial 2s ease-out forwards;
            `;
            notif.textContent = 'Zooko Special!';
            document.body.appendChild(notif);
            
            trackedSetTimeout(() => notif.remove(), 2000);
            
            // Stop idle and play special
            zookoIdleAction.stop();
            zookoSpecialAction.reset();
            zookoSpecialAction.play();
            
            // Listen for animation finish
            const onFinished = (e) => {
                if (e.action === zookoSpecialAction) {
                    // Stop special and restart idle
                    zookoSpecialAction.stop();
                    zookoIdleAction.reset();
                    zookoIdleAction.play();
                    zookoMixer.removeEventListener('finished', onFinished);
                }
            };
            zookoMixer.addEventListener('finished', onFinished);
        }
        
        // Rogue Government Sandblasting Event
        function triggerSandblastingEvent() {
            if (sandblastingActive) return;
            
            sandblastingActive = true;
            
            // Clear any ongoing CyberAxe flicker timeouts to prevent interference
            cyberAxeFlickerTimeouts.forEach(id => trackedClearTimeout(id));
            cyberAxeFlickerTimeouts = [];
            
            // Clear CyberAxe wall flash interval to prevent interference
            if (cyberAxeFlashInterval) {
                trackedClearInterval(cyberAxeFlashInterval);
                cyberAxeFlashInterval = null;
            }
            
            // Clear CyberAxe cleanup timeout to prevent lights turning back on
            if (cyberAxeCleanupTimeout) {
                trackedClearTimeout(cyberAxeCleanupTimeout);
                cyberAxeCleanupTimeout = null;
            }
            
            // Add blink animation to sandblasting bar container
            const sandblastingBarContainer = document.getElementById('sandblastingBarContainer');
            sandblastingBarContainer.style.animation = 'sandblastingBlink 0.5s ease-in-out infinite';
            
            // Reset charge
            sandblastingCharge = 0;
            updateSandblastingBar();
            
            // Turn off all lights for dramatic effect
            const originalKeyIntensity = keyLight.intensity;
            const originalFillIntensity = fillLight.intensity;
            const originalAmbientIntensity = ambientLight.intensity;
            const originalRimIntensity = rimLight.intensity;
            
            keyLight.intensity = 0;
            fillLight.intensity = 0;
            ambientLight.intensity = 0.05; // Very dim ambient
            rimLight.intensity = 0;
            
            // Dim wall emissives by 90%
            const originalWallEmissives = [];
            roomWalls.forEach(wall => {
                if (wall.material && wall.material.emissiveIntensity !== undefined) {
                    originalWallEmissives.push(wall.material.emissiveIntensity);
                    wall.material.emissiveIntensity *= 0.1; // Reduce to 10% (90% dimmer)
                }
            });
            
            // Determine number of links to drop based on level
            let numLinks;
            if (level < 50) {
                numLinks = 50;
            } else if (level >= 50 && level < 100) {
                numLinks = 75;
            } else if (level >= 100 && level < 250) {
                numLinks = 100;
            } else if (level >= 250 && level < 500) {
                numLinks = 125;
            } else if (level >= 500 && level < 1000) {
                numLinks = 150;
            } else { // level >= 1000
                numLinks = 200;
            }
            
            const totalDuration = 7000; // 7 seconds
            const delayPerLink = totalDuration / numLinks;
            
            // Drop single links from random columns
            for (let i = 0; i < numLinks; i++) {
                trackedSetTimeout(() => {
                    // Random column position
                    const spawnX = Math.floor(Math.random() * GRID_WIDTH);
                    const spawnZ = Math.floor(Math.random() * GRID_DEPTH);
                    
                    // Check if there's already a falling sandblasting link at this X,Z position
                    const existingLink = window.sandblastingLinks?.find(link => 
                        link.x === spawnX && link.z === spawnZ && link.y > 1
                    );
                    
                    // Skip spawning if there's already a falling link in this column
                    if (existingLink) return;
                    
                    // Random link type
                    const linkTypes = [LinkType.ZEC_A, LinkType.ZEC_B, LinkType.ZEC_C, LinkType.ZEC_D];
                    const randomType = linkTypes[Math.floor(Math.random() * linkTypes.length)];
                    
                    // Create single falling link mesh
                    const mesh = createLinkMesh(randomType);
                    const spawnY = 24; // Top of grid
                    mesh.position.set(spawnX + 0.5, spawnY + 0.5, spawnZ + 0.5);
                    
                    // Rotate every other link 90 degrees
                    const rotation = (i % 2 === 0) ? 0 : Math.PI / 2;
                    mesh.rotation.y = rotation;
                    
                    scene.add(mesh);
                    
                    // Track this as a simple falling object
                    const fallingLink = {
                        mesh: mesh,
                        type: randomType,
                        x: spawnX,
                        y: spawnY,
                        z: spawnZ,
                        velocity: 0,
                        rotation: rotation
                    };
                    
                    // Add to scene and let gravity handle it
                    // We'll add it to a tracking array
                    if (!window.sandblastingLinks) {
                        window.sandblastingLinks = [];
                    }
                    window.sandblastingLinks.push(fallingLink);
                    
                }, i * delayPerLink);
            }
            
            // Restore lights after all links have dropped and settled
            trackedSetTimeout(() => {
                // Restore lights to default values
                keyLight.intensity = DEFAULT_KEY_LIGHT;
                fillLight.intensity = DEFAULT_FILL_LIGHT;
                ambientLight.intensity = DEFAULT_AMBIENT_LIGHT;
                rimLight.intensity = DEFAULT_RIM_LIGHT;
                
                // Restore wall emissives to default
                roomWalls.forEach(wall => {
                    if (wall.material && wall.material.emissiveIntensity !== undefined) {
                        wall.material.emissiveIntensity = DEFAULT_WALL_EMISSIVE;
                    }
                });
                
                // Remove blink animation from sandblasting bar container
                sandblastingBarContainer.style.animation = '';
                
                sandblastingActive = false;
                
                // Cleanup any remaining sandblasting links that didn't settle
                if (window.sandblastingLinks && window.sandblastingLinks.length > 0) {
                    window.sandblastingLinks.forEach(link => {
                        // Remove from scene if still floating
                        disposeLinkMesh(link.mesh);
                    });
                    window.sandblastingLinks = [];
                }
            }, totalDuration + 4000); // Keep lights off for entire drop duration + 4 seconds for settling
        }
        
        function triggerZookoSpecialEffect() {
            if (zookoSpecialActive) return; // Prevent multiple activations
            
            zookoSpecialActive = true;
            
            // Increment sandblasting charge by 25%
            sandblastingCharge = Math.min(100, sandblastingCharge + 25);
            updateSandblastingBar();
            
            // Check if sandblasting should trigger
            if (sandblastingCharge >= 100) {
                trackedSetTimeout(() => {
                    triggerSandblastingEvent();
                }, 2000); // Trigger after special completes
            }
            
            // Spawn particle effect in camera view (distance: 8, vertical: 0, horizontal: 0)
            spawnParticleEffect('effect/zooko_special.json', 8, -1, 0, {
                rotation: { x: 0, y: 0, z: 0 },
                startDelay: 0
            });
            
            // Count all block types in the grid
            const typeCounts = {};
            for (let x = 0; x < GRID_WIDTH; x++) {
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    for (let z = 0; z < GRID_DEPTH; z++) {
                        if (grid[x][y][z] !== null) {
                            const typeName = grid[x][y][z].type.name;
                            typeCounts[typeName] = (typeCounts[typeName] || 0) + 1;
                        }
                    }
                }
            }
            
            // Find the most common type
            let mostCommonType = null;
            let maxCount = 0;
            for (const [typeName, count] of Object.entries(typeCounts)) {
                if (count > maxCount) {
                    maxCount = count;
                    mostCommonType = typeName;
                }
            }
            
            // If no blocks or no most common type, exit
            if (!mostCommonType || maxCount === 0) {
                zookoSpecialActive = false;
                return;
            }
            
            // Slow down time
            currentTimeScale = slowTimeScale;
            
            // Collect all blocks of the most common type
            const blocksToDestroy = [];
            for (let x = 0; x < GRID_WIDTH; x++) {
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    for (let z = 0; z < GRID_DEPTH; z++) {
                        if (grid[x][y][z] !== null && grid[x][y][z].type.name === mostCommonType) {
                            blocksToDestroy.push({ x, y, z, block: grid[x][y][z] });
                        }
                    }
                }
            }
            
            // Destroy blocks with staggered timing over a few seconds
            const totalDuration = 5000; // 5 seconds total
            const delayPerBlock = totalDuration / Math.max(blocksToDestroy.length, 1);
            
            blocksToDestroy.forEach((item, index) => {
                trackedSetTimeout(() => {
                    const { x, y, z, block } = item;
                    if (grid[x][y][z] && grid[x][y][z] === block) {
                        // Create explosion effect
                        if (block.mesh) {
                            
                            // Spawn link break particle effect at block position (world coordinates)
                            spawnParticleEffect('effect/zooko_special_break.json', x + 0.5, y + 1.0, z + 0.5, {
                                spawnMode: 'world',
                                rotation: { x: 0, y: 0, z: 0 },
                                startDelay: 0
                            });
                            
                            if (block.mesh) {
                                scene.remove(block.mesh);
                                // Dispose cloned materials
                                block.mesh.traverse(child => {
                                    if (child.isMesh && child.material) {
                                        child.material.dispose();
                                    }
                                });
                            }
                        }
                        grid[x][y][z] = null;
                    }
                }, index * delayPerBlock);
            });
            
            // After all explosions, apply gravity and restore time
            trackedSetTimeout(() => {
                applyGravity();
                
                // Restore normal time after gravity settles
                trackedSetTimeout(() => {
                    currentTimeScale = normalTimeScale;
                    zookoSpecialActive = false;
                    
                    // Restart Zooko idle particle loops
                    if (zookoHeadBone) {
                        trackedSetTimeout(() => {
                            function restartZookoShield() {
                                if (zookoHeadBone && !zookoSpecialActive) {
                                    zookoHeadBone.getWorldPosition(_boneTempHeadPos);
                                    spawnParticleEffect('effect/zooko_shield.json', 
                                        _boneTempHeadPos.x + zookoHeadOffset.x, 
                                        _boneTempHeadPos.y + zookoHeadOffset.y, 
                                        _boneTempHeadPos.z + zookoHeadOffset.z, {
                                        spawnMode: 'world',
                                        rotation: { x: 0, y: 0, z: 0 },
                                        startDelay: 0,
                                        parentBone: zookoHeadBone,
                                        parentModel: zookoModel,
                                        boneOffset: zookoHeadOffset
                                    });
                                    trackedSetTimeout(restartZookoShield, 1100);
                                }
                            }
                            function restartZookoHat() {
                                if (zookoHeadBone && !zookoSpecialActive) {
                                    zookoHeadBone.getWorldPosition(_boneTempHeadPos);
                                    spawnParticleEffect('effect/zooko_hat.json', 
                                        _boneTempHeadPos.x + zookoHatOffset.x, 
                                        _boneTempHeadPos.y + zookoHatOffset.y, 
                                        _boneTempHeadPos.z + zookoHatOffset.z, {
                                        spawnMode: 'world',
                                        rotation: { x: 0, y: 0, z: 0 },
                                        startDelay: 0,
                                        parentBone: zookoHeadBone,
                                        parentModel: zookoModel,
                                        boneOffset: zookoHatOffset
                                    });
                                    trackedSetTimeout(restartZookoHat, 1100);
                                }
                            }
                            restartZookoShield();
                            restartZookoHat();
                        }, 100);
                    }
                }, 500);
            }, totalDuration + 100);
        }
        
        function playCyberAxeSpecialAnimation() {
            if (!cyberAxeSpecialAction || !cyberAxeIdleAction) {
                return;
            }
            
            // Check if another special is already active
            if (zookoSpecialActive || nateSpecialActive || zancasSpecialActive) {
                return;
            }
            
            if (cyberaxeCharge < 100) {
                return;
            }
            
            cyberaxeCharge = 0;
            updateSpecialAbilityBars();
            
            // Clear instant drop to prevent fast falling during special
            instantDrop = false;
            
            // Rotate CyberAxe to face the wall for execution
            if (cyberAxeModel) {
                cyberAxeModel.rotation.y = cyberAxeSpecialRotation;
            }
            
            // Trigger the special effect
            triggerCyberAxeSpecialEffect();
            
            // Show notification
            const notif = document.createElement('div');
            notif.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, rgba(0, 255, 255, 0.2), rgba(0, 191, 255, 0.2));
                color: white;
                padding: 30px 50px;
                border-radius: 20px;
                font-weight: 700;
                font-size: 36px;
                box-shadow: 0 10px 40px rgba(0, 255, 255, 0.6);
                backdrop-filter: blur(10px);
                z-index: 1000;
                animation: zookoSpecial 2s ease-out forwards;
            `;
            notif.textContent = 'CyberAxe Node Overload!';
            document.body.appendChild(notif);
            
            trackedSetTimeout(() => notif.remove(), 2000);
            
            // Stop idle and play special
            cyberAxeIdleAction.stop();
            cyberAxeSpecialAction.reset();
            cyberAxeSpecialAction.play();
            
            // Listen for animation finish
            const onFinished = (e) => {
                if (e.action === cyberAxeSpecialAction) {
                    // Stop special and restart idle
                    cyberAxeSpecialAction.stop();
                    cyberAxeIdleAction.reset();
                    cyberAxeIdleAction.play();
                    
                    // Rotate back to base rotation
                    if (cyberAxeModel) {
                        cyberAxeModel.rotation.y = cyberAxeBaseRotation;
                    }
                    
                    cyberAxeMixer.removeEventListener('finished', onFinished);
                }
            };
            cyberAxeMixer.addEventListener('finished', onFinished);
        }
        
        function triggerCyberAxeSpecialEffect() {
            if (cyberAxeSpecialActive) return;
            
            cyberAxeSpecialActive = true;
            
            // If no chain exists, wait for one to spawn
            if (!fallingChain) {
                const waitForChain = trackedSetInterval(() => {
                    if (fallingChain) {
                        trackedClearInterval(waitForChain);
                        executeCyberAxeSpecial();
                    }
                }, 50); // Check every 50ms
                return;
            }
            
            executeCyberAxeSpecial();
        }
        
        function executeCyberAxeSpecial() {
            // Increment sandblasting charge by 25%
            sandblastingCharge = Math.min(100, sandblastingCharge + 25);
            updateSandblastingBar();
            
            // Check if sandblasting should trigger
            if (sandblastingCharge >= 100) {
                trackedSetTimeout(() => {
                    triggerSandblastingEvent();
                }, 7000); // Trigger after CyberAxe special completes (5s + 2s buffer)
            }
            
            // Spawn hand-tracking electric particle at CyberAxe's right hand
            if (cyberAxeHandBone) {
                cyberAxeHandBone.getWorldPosition(_boneTempHeadPos);
                spawnParticleEffect('effect/cyberaxe_electric.json', 
                    _boneTempHeadPos.x + cyberAxeHandOffset.x, 
                    _boneTempHeadPos.y + cyberAxeHandOffset.y, 
                    _boneTempHeadPos.z + cyberAxeHandOffset.z, {
                    spawnMode: 'world',
                    rotation: { x: 0, y: 0, z: 0 },
                    startDelay: 0,
                    parentBone: cyberAxeHandBone,
                    parentModel: cyberAxeModel,
                    boneOffset: cyberAxeHandOffset
                });
            }
            
            // Spawn hand-tracking electric particle at CyberAxe's left hand
            if (cyberAxeLeftHandBone) {
                cyberAxeLeftHandBone.getWorldPosition(_boneTempHeadPos);
                spawnParticleEffect('effect/cyberaxe_electric_left.json', 
                    _boneTempHeadPos.x + cyberAxeLeftHandOffset.x, 
                    _boneTempHeadPos.y + cyberAxeLeftHandOffset.y, 
                    _boneTempHeadPos.z + cyberAxeLeftHandOffset.z, {
                    spawnMode: 'world',
                    rotation: { x: 0, y: 0, z: 0 },
                    startDelay: 0,
                    parentBone: cyberAxeLeftHandBone,
                    parentModel: cyberAxeModel,
                    boneOffset: cyberAxeLeftHandOffset
                });
            }
            
            // Freeze the falling chain at current position
            const frozenChainY = fallingChain.y;
            
            // Slow down time
            currentTimeScale = slowTimeScale;
            
            // Function to toggle lights
            const toggleLights = (on) => {
                if (on) {
                    keyLight.intensity = DEFAULT_KEY_LIGHT;
                    fillLight.intensity = DEFAULT_FILL_LIGHT;
                    ambientLight.intensity = DEFAULT_AMBIENT_LIGHT;
                    rimLight.intensity = DEFAULT_RIM_LIGHT;
                } else {
                    keyLight.intensity = 0;
                    fillLight.intensity = 0;
                    ambientLight.intensity = 0;
                    rimLight.intensity = 0;
                }
            };
            
            // Initial lights off
            toggleLights(false);
            
            // Random light flickers during effect
            const flickerPattern = [200, 400, 600, 1200, 1400, 2000, 2100]; // Random times to toggle
            cyberAxeFlickerTimeouts = []; // Clear any previous timeouts
            flickerPattern.forEach(time => {
                const timeout1 = trackedSetTimeout(() => toggleLights(false), time);
                const timeout2 = trackedSetTimeout(() => toggleLights(true), time + 100); // On after 100ms
                cyberAxeFlickerTimeouts.push(timeout1, timeout2);
                activeTimeouts.push(timeout1, timeout2);
            });
            
            const laserDuration = 5000; // 5 seconds of laser fire
            const laserInterval = aiEnabled ? 400 : 200; // Fire laser every 400ms in AI mode, 200ms normal
            let laserCount = 0;
            const maxLasers = laserDuration / laserInterval;
            
            // Fire first laser immediately
            if (fallingChain) {
                fireLaserBlast(fallingChain.x, fallingChain.z);
                laserCount++;
            }
            
            // Flash the room walls and lights smoothly
            let flashPhase = 0;
            cyberAxeFlashInterval = trackedSetInterval(() => {
                flashPhase += 0.1;
                const intensity = Math.sin(flashPhase * Math.PI * 2) * 0.3 + 0.5; // Oscillate between 0.2 and 0.8 (darker)
                
                // Flash walls with reduced brightness
                roomWalls.forEach(wall => {
                    if (wall.material) {
                        wall.material.emissiveIntensity = intensity * 0.6; // Darker overall
                    }
                });
                
            }, 50); // Faster update for smooth animation
            
            // Fire lasers repeatedly
            const laserTimer = trackedSetInterval(() => {
                if (laserCount >= maxLasers) {
                    trackedClearInterval(laserTimer);
                    
                    // Continue flashing lights for 3 more seconds
                    cyberAxeCleanupTimeout = trackedSetTimeout(() => {
                        trackedClearInterval(cyberAxeFlashInterval);
                        cyberAxeFlashInterval = null;
                        cyberAxeCleanupTimeout = null;
                        
                        // Clear any remaining flicker timeouts
                        cyberAxeFlickerTimeouts.forEach(id => trackedClearTimeout(id));
                        cyberAxeFlickerTimeouts = [];
                        
                        // Restore wall brightness to default
                        roomWalls.forEach(wall => {
                            if (wall.material) {
                                wall.material.emissiveIntensity = DEFAULT_WALL_EMISSIVE;
                            }
                        });
                        
                        // Restore lights to default
                        toggleLights(true);
                    }, 3000);
                    activeTimeouts.push(cyberAxeCleanupTimeout);
                    
                    // Unfreeze chain and restore time immediately
                    cyberAxeSpecialActive = false;
                    currentTimeScale = normalTimeScale;
                    chainVelocity = 0; // Reset velocity after freeze
                    
                    // Restart CyberAxe chest shield particle loop
                    if (cyberAxeChestBone) {
                        trackedSetTimeout(() => {
                            function restartCyberAxeShield() {
                                if (cyberAxeChestBone && !cyberAxeSpecialActive) {
                                    cyberAxeChestBone.getWorldPosition(_boneTempHeadPos);
                                    spawnParticleEffect('effect/cyberaxe_shield.json', 
                                        _boneTempHeadPos.x + cyberAxeChestOffset.x, 
                                        _boneTempHeadPos.y + cyberAxeChestOffset.y, 
                                        _boneTempHeadPos.z + cyberAxeChestOffset.z, {
                                        spawnMode: 'world',
                                        rotation: { x: 0, y: 0, z: 0 },
                                        startDelay: 0,
                                        parentBone: cyberAxeChestBone,
                                        parentModel: cyberAxeModel,
                                        boneOffset: cyberAxeChestOffset
                                    });
                                    trackedSetTimeout(restartCyberAxeShield, 1100);
                                }
                            }
                            restartCyberAxeShield();
                        }, 100);
                    }
                    
                    // Apply gravity
                    applyGravity();
                    
                    // Spawn new chain if needed
                    if (!fallingChain) {
                        spawnChain();
                    }
                    return;
                }
                
                // Only fire laser if chain still exists
                if (fallingChain) {
                    // Fire laser down the falling chain column
                    fireLaserBlast(fallingChain.x, fallingChain.z);
                }
                laserCount++;
            }, laserInterval);
        }
        
        function fireLaserBlast(x, z) {
            // Create small purple tube down the center
            const tubeGeometry = new THREE.CylinderGeometry(0.15, 0.15, GRID_HEIGHT + 20, 8);
            const tubeMaterial = new THREE.MeshBasicMaterial({
                color: 0x9D00FF // Purple
            });
            const tube = new THREE.Mesh(tubeGeometry, tubeMaterial);
            tube.position.set(x + 0.5, GRID_HEIGHT / 2, z + 0.5);
            scene.add(tube);
            
            // Create yellow particles around the tube
            createLaserParticles(x + 0.5, GRID_HEIGHT + 5, z + 0.5);
            
            // Create descending shockwave rings
            createShockwaveRings(x + 0.5, z + 0.5);
            
            // Remove tube after effect
            trackedSetTimeout(() => {
                scene.remove(tube);
                tubeGeometry.dispose();
                tubeMaterial.dispose();
            }, 300);
            
            // Destroy blocks in this column from top to bottom
            for (let y = GRID_HEIGHT - 1; y >= 0; y--) {
                if (grid[x][y][z] !== null) {
                    const block = grid[x][y][z];
                    
                    // Create explosion effect
                    trackedSetTimeout(() => {
                        if (grid[x][y][z] && grid[x][y][z] === block) {
                            if (block.mesh) {
                                scene.remove(block.mesh);
                                // Dispose cloned materials
                                block.mesh.traverse(child => {
                                    if (child.isMesh && child.material) {
                                        child.material.dispose();
                                    }
                                });
                            }
                            grid[x][y][z] = null;
                            
                            // Remove from broken links if present
                            const posKey = `${x},${y},${z}`;
                            brokenLinks.delete(posKey);
                            
                            score += 10; // Award points for each block destroyed
                        }
                    }, (GRID_HEIGHT - y) * 20); // Stagger explosions from top to bottom
                }
            }
            
            updateHUD();
        }
        
        function createLaserParticles(x, y, z) {
            // Create yellow particles in a cylinder around the tube
            const particleCount = 30;
            const particles = [];
            
            for (let i = 0; i < particleCount; i++) {
                const geometry = new THREE.SphereGeometry(0.08, 4, 4);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0xFFFF00 // Yellow
                });
                const particle = new THREE.Mesh(geometry, material);
                
                // Position particles in a cylinder around the center tube
                const angle = (i / particleCount) * Math.PI * 2;
                const radius = 0.3 + Math.random() * 0.2; // Around the tube
                const height = Math.random() * (GRID_HEIGHT + 10);
                
                particle.position.set(
                    x + Math.cos(angle) * radius,
                    height,
                    z + Math.sin(angle) * radius
                );
                
                // Downward velocity
                particle.velocity = {
                    x: Math.cos(angle) * 0.02,
                    y: -0.5, // Fall down quickly
                    z: Math.sin(angle) * 0.02
                };
                
                scene.add(particle);
                particles.push(particle);
            }
            
            // Animate particles falling
            let life = 1.0;
            const animateParticles = () => {
                life -= 0.03;
                
                if (life > 0) {
                    particles.forEach(particle => {
                        particle.position.x += particle.velocity.x;
                        particle.position.y += particle.velocity.y;
                        particle.position.z += particle.velocity.z;
                    });
                    const frameId = requestAnimationFrame(animateParticles);
                    activeAnimationFrames.push(frameId);
                } else {
                    particles.forEach(particle => {
                        scene.remove(particle);
                        particle.geometry.dispose();
                        particle.material.dispose();
                    });
                }
            };
            
            animateParticles();
        }
        
        function createShockwaveRings(x, z) {
            // Create multiple shockwave rings that pulse down the column
            const ringCount = 8;
            const ringDelay = 50; // ms between each ring spawn
            
            for (let i = 0; i < ringCount; i++) {
                trackedSetTimeout(() => {
                    createSingleShockwave(x, z);
                }, i * ringDelay);
            }
        }
        
        function createSingleShockwave(x, z) {
            // Create a torus (ring) shockwave
            const ringGeometry = new THREE.TorusGeometry(0.15, 0.025, 8, 16);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: 0x00FFFF // Cyan shockwave
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.position.set(x, GRID_HEIGHT + 10, z);
            ring.rotation.x = Math.PI / 2; // Orient horizontally
            scene.add(ring);
            
            // Animate ring moving down and expanding
            let yPos = GRID_HEIGHT + 10;
            let radius = 0.15;
            const animateRing = () => {
                yPos -= 0.8; // Move down quickly
                radius += 0.015; // Expand slightly
                
                ring.position.y = yPos;
                ring.scale.set(radius / 0.15, radius / 0.15, 1);
                
                if (yPos > -5) {
                    const frameId = requestAnimationFrame(animateRing);
                    activeAnimationFrames.push(frameId);
                } else {
                    scene.remove(ring);
                    ringGeometry.dispose();
                    ringMaterial.dispose();
                }
            };
            
            animateRing();
        }
        
        function createRoom() {
            const wallDistance = 35; // Increased from 20 to 35 for more spacious room
            const wallHeight = GRID_HEIGHT + 12; // Add 12 units extra height for taller room
            const roomWidth = GRID_WIDTH + wallDistance * 2;
            const roomDepth = GRID_DEPTH + wallDistance * 2;
            const wallThickness = 0.5;
            const roomFloorOffset = -8; // Move room floor down to -8
            
            // North Wall (Blue) - behind when viewing from south
            const northWallTexture = new THREE.TextureLoader().load('walls/wall_n.png');
            const northWall = new THREE.Mesh(
                new THREE.BoxGeometry(roomWidth, wallHeight, wallThickness),
                new THREE.MeshPhongMaterial({ 
                    map: northWallTexture,
                    emissiveMap: northWallTexture,
                    emissive: 0xffffff,
                    emissiveIntensity: 0.5,
                    side: THREE.DoubleSide 
                })
            );
            northWall.position.set(GRID_WIDTH / 2, roomFloorOffset + wallHeight / 2, GRID_DEPTH + wallDistance);
            scene.add(northWall);
            roomWalls.push(northWall);
            
            // South Wall (Red)
            const southWallTexture = new THREE.TextureLoader().load('walls/wall_s.png');
            const southWall = new THREE.Mesh(
                new THREE.BoxGeometry(roomWidth, wallHeight, wallThickness),
                new THREE.MeshPhongMaterial({ 
                    map: southWallTexture,
                    emissiveMap: southWallTexture,
                    emissive: 0xffffff,
                    emissiveIntensity: 0.5,
                    side: THREE.DoubleSide 
                })
            );
            southWall.position.set(GRID_WIDTH / 2, roomFloorOffset + wallHeight / 2, -wallDistance);
            scene.add(southWall);
            roomWalls.push(southWall);
            
            // East Wall (Green)
            const eastWallTexture = new THREE.TextureLoader().load('walls/wall_e.png');
            const eastWall = new THREE.Mesh(
                new THREE.BoxGeometry(wallThickness, wallHeight, roomDepth),
                new THREE.MeshPhongMaterial({ 
                    map: eastWallTexture,
                    emissiveMap: eastWallTexture,
                    emissive: 0xffffff,
                    emissiveIntensity: 0.5,
                    side: THREE.DoubleSide 
                })
            );
            eastWall.position.set(GRID_WIDTH + wallDistance, roomFloorOffset + wallHeight / 2, GRID_DEPTH / 2);
            scene.add(eastWall);
            roomWalls.push(eastWall);
            
            // West Wall (Yellow)
            const westWallTexture = new THREE.TextureLoader().load('walls/wall_w.png');
            const westWall = new THREE.Mesh(
                new THREE.BoxGeometry(wallThickness, wallHeight, roomDepth),
                new THREE.MeshPhongMaterial({ 
                    map: westWallTexture,
                    emissiveMap: westWallTexture,
                    emissive: 0xffffff,
                    emissiveIntensity: 0.5,
                    side: THREE.DoubleSide 
                })
            );
            westWall.position.set(-wallDistance, roomFloorOffset + wallHeight / 2, GRID_DEPTH / 2);
            scene.add(westWall);
            roomWalls.push(westWall);
            
            // Floor (Dark Gray)
            const floorTexture = new THREE.TextureLoader().load('walls/floor_a.png');
            floorTexture.minFilter = THREE.LinearFilter;
            floorTexture.magFilter = THREE.LinearFilter;
            const floor = new THREE.Mesh(
                new THREE.BoxGeometry(roomWidth, wallThickness, roomDepth),
                new THREE.MeshPhongMaterial({ 
                    map: floorTexture,
                    emissiveMap: floorTexture,
                    emissive: 0xffffff,
                    emissiveIntensity: 0.5,
                    side: THREE.DoubleSide 
                })
            );
            floor.position.set(GRID_WIDTH / 2, roomFloorOffset - wallThickness / 2, GRID_DEPTH / 2);
            floor.receiveShadow = true; // Receive shadows from models
            scene.add(floor);
            roomWalls.push(floor);
            
            // Ceiling (Darker Gray)
            const ceiling = new THREE.Mesh(
                new THREE.BoxGeometry(roomWidth, wallThickness, roomDepth),
                new THREE.MeshPhongMaterial({ 
                    color: 0x0D1218,
                    emissive: 0x000000,
                    emissiveIntensity: 0.05,
                    side: THREE.DoubleSide 
                })
            );
            ceiling.position.set(GRID_WIDTH / 2, roomFloorOffset + wallHeight + wallThickness / 2, GRID_DEPTH / 2);
            scene.add(ceiling);
        }
        
        function createFloorCells() {
            // FORCE recreate BOX geometry every time
            floorCellGeometry = new THREE.BoxGeometry(0.9, 0.01, 0.9);
            
            // Position at floor level
            const floorY = 0.5; // Half height above floor
            
            // Create 6x6 grid of floor cell planes
            for (let x = 0; x < GRID_WIDTH; x++) {
                for (let z = 0; z < GRID_DEPTH; z++) {
                    // Create material for this cell (will be reused/updated during animations)
                    const material = new THREE.MeshBasicMaterial({
                        color: 0xFF00FF,
                        transparent: true,
                        opacity: 0.0,
                        side: THREE.DoubleSide,
                        depthWrite: true,
                        depthTest: false
                    });
                    
                    // Create mesh
                    const mesh = new THREE.Mesh(floorCellGeometry, material);
                    
                    // Position at grid cell center
                    mesh.position.set(x + 0.5, floorY, z + 0.5);
                    
                    // Render order: floor cells first
                    mesh.renderOrder = -100;
                    
                    // Disable frustum culling
                    mesh.frustumCulled = false;
                    
                    // Store grid coordinates
                    mesh.userData.gridX = x;
                    mesh.userData.gridZ = z;
                    mesh.userData.cellIndex = x + z * GRID_WIDTH;
                    
                    // Add to scene and tracking array
                    scene.add(mesh);
                    floorCells.push(mesh);
                    floorCellMaterials.push(material);
                }
            }
        }
        
        function createGridLines() {
            const tableHeight = -1.2; // Position table top at -1.2 (below grid floor at y=0)
            const tableTopThickness = 0.2;
            const tableWidth = GRID_WIDTH + 4;
            const tableDepth = GRID_DEPTH + 4;
            const legWidth = 0.6;
            const legHeight = 6.8; // Legs reach from floor (-8) to table top (-1.2)
            
            // Table Top (Wood brown)
            const tableTop = new THREE.Mesh(
                new THREE.BoxGeometry(tableWidth, tableTopThickness, tableDepth),
                new THREE.MeshPhongMaterial({ 
                    color: 0x5D4E37,
                    emissive: 0x2a1f1a,
                    emissiveIntensity: 0.1,
                    shininess: 30
                })
            );
            tableTop.position.set(GRID_WIDTH / 2, tableHeight - tableTopThickness / 2, GRID_DEPTH / 2);
            scene.add(tableTop);
            
            // Add edge highlighting to table top
            const topEdges = new THREE.EdgesGeometry(tableTop.geometry);
            const topEdgeMaterial = new THREE.LineBasicMaterial({ color: 0x3d2e27, linewidth: 2 });
            const topEdgeLines = new THREE.LineSegments(topEdges, topEdgeMaterial);
            topEdgeLines.position.copy(tableTop.position);
            scene.add(topEdgeLines);
            
            // Table Legs (4 corners)
            const legMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x4A3C2C,
                emissive: 0x1a130c,
                emissiveIntensity: 0.1,
                shininess: 20
            });
            
            const legPositions = [
                [tableWidth / 2 - 0.8, tableDepth / 2 - 0.8],   // Front-right
                [-tableWidth / 2 + 0.8, tableDepth / 2 - 0.8],  // Front-left
                [tableWidth / 2 - 0.8, -tableDepth / 2 + 0.8],  // Back-right
                [-tableWidth / 2 + 0.8, -tableDepth / 2 + 0.8]  // Back-left
            ];
            
            legPositions.forEach(([offsetX, offsetZ]) => {
                const leg = new THREE.Mesh(
                    new THREE.BoxGeometry(legWidth, legHeight, legWidth),
                    legMaterial
                );
                leg.position.set(
                    GRID_WIDTH / 2 + offsetX,
                    -8 + legHeight / 2, // Start from room floor at -8
                    GRID_DEPTH / 2 + offsetZ
                );
                scene.add(leg);
            });
        }
        
        function createGridLines() {
            const gridMaterial = new THREE.LineBasicMaterial({ 
                color: 0x233142, 
                transparent: true, 
                opacity: 0.3 
            });
            
            // Horizontal lines (XZ plane)
            for (let y = 0; y <= GRID_HEIGHT; y++) {
                for (let x = 0; x <= GRID_WIDTH; x++) {
                    const points = [];
                    points.push(new THREE.Vector3(x, y, 0));
                    points.push(new THREE.Vector3(x, y, GRID_DEPTH));
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const line = new THREE.Line(geometry, gridMaterial);
                    scene.add(line);
                }
                
                for (let z = 0; z <= GRID_DEPTH; z++) {
                    const points = [];
                    points.push(new THREE.Vector3(0, y, z));
                    points.push(new THREE.Vector3(GRID_WIDTH, y, z));
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const line = new THREE.Line(geometry, gridMaterial);
                    scene.add(line);
                }
            }
        }
        
        function updateCameraPosition() {
            const centerX = GRID_WIDTH / 2;
            const centerZ = GRID_DEPTH / 2;
            
            // Calculate dynamic camera height based on zoom (lower when zoomed in)
            const zoomFactor = (cameraDistance - minCameraDistance) / (maxCameraDistance - minCameraDistance);
            const minHeight = 6.5; // Camera height when fully zoomed in
            const maxHeight = 9.0; // Camera height when fully zoomed out
            const defaultHeight = 8.5; // Camera height at default zoom (baseCameraDistance)
            
            // Use default height when at base distance, otherwise interpolate in two segments
            let dynamicHeight;
            if (cameraDistance === baseCameraDistance) {
                dynamicHeight = defaultHeight;
            } else if (cameraDistance < baseCameraDistance) {
                // Interpolate between min and default
                const factor = (cameraDistance - minCameraDistance) / (baseCameraDistance - minCameraDistance);
                dynamicHeight = minHeight + (defaultHeight - minHeight) * factor;
            } else {
                // Interpolate between default and max
                const factor = (cameraDistance - baseCameraDistance) / (maxCameraDistance - baseCameraDistance);
                dynamicHeight = defaultHeight + (maxHeight - defaultHeight) * factor;
            }
            
            // Set FOV based on zoom level
            const minFOV = 75; // FOV when fully zoomed in
            const maxFOV = 35; // FOV when fully zoomed out
            const defaultFOV = 45; // FOV at default zoom
            
            if (cameraDistance === minCameraDistance) {
                // Fully zoomed in
                camera.fov = minFOV;
            } else if (cameraDistance === baseCameraDistance) {
                // Default zoom
                camera.fov = defaultFOV;
            } else if (cameraDistance === maxCameraDistance) {
                // Fully zoomed out
                camera.fov = maxFOV;
            } else if (cameraDistance < baseCameraDistance) {
                // Interpolate between min and default
                const factor = (cameraDistance - minCameraDistance) / (baseCameraDistance - minCameraDistance);
                camera.fov = minFOV + (defaultFOV - minFOV) * factor;
            } else {
                // Interpolate between default and max
                const factor = (cameraDistance - baseCameraDistance) / (maxCameraDistance - baseCameraDistance);
                camera.fov = defaultFOV + (maxFOV - defaultFOV) * factor;
            }
            camera.updateProjectionMatrix();
            
            if (isTopDownView) {
                // Top-down view - directly above the center of the grid
                camera.position.set(centerX, topDownHeight, centerZ);
                camera.lookAt(centerX, 0, centerZ);
                // Disable player light in top-down view
                if (playerLight) playerLight.intensity = 0;
            } else {
                // Standard side views
                switch(currentChair) {
                    case 0: // North (looking -Z)
                        camera.position.set(centerX, dynamicHeight, GRID_DEPTH + cameraDistance);
                        if (playerLight) playerLight.position.set(centerX, dynamicHeight, GRID_DEPTH + cameraDistance);
                        break;
                    case 1: // East (looking -X)
                        camera.position.set(GRID_WIDTH + cameraDistance, dynamicHeight, centerZ);
                        if (playerLight) playerLight.position.set(GRID_WIDTH + cameraDistance, dynamicHeight, centerZ);
                        break;
                    case 2: // South (looking +Z)
                        camera.position.set(centerX, dynamicHeight, -cameraDistance);
                        if (playerLight) playerLight.position.set(centerX, dynamicHeight, -cameraDistance);
                        break;
                    case 3: // West (looking +X)
                        camera.position.set(-cameraDistance, dynamicHeight, centerZ);
                        if (playerLight) playerLight.position.set(-cameraDistance, dynamicHeight, centerZ);
                        break;
                }
                
                camera.lookAt(centerX, dynamicHeight, centerZ);
                // Enable player light in side views (if lights are enabled)
                if (playerLight && lightsEnabled) playerLight.intensity = 8.0;
            }
            
            updateCompass();
        }
        
        function updateCompass() {
            // Update active direction label
            const directions = ['N', 'E', 'S', 'W'];
            document.querySelectorAll('.compassDirection').forEach((el, index) => {
                if (index === currentChair) {
                    el.classList.add('active');
                } else {
                    el.classList.remove('active');
                }
            });
            
            // Update top-down button state
            const topDownBtn = document.getElementById('topDownButton');
            if (isTopDownView) {
                topDownBtn.classList.add('active');
            } else {
                topDownBtn.classList.remove('active');
            }
            
            // Rotate needle to point in viewing direction
            const needle = document.querySelector('.compassNeedle');
            const rotation = currentChair * 90; // 0Â° = North, 90Â° = East, 180Â° = South, 270Â° = West
            needle.style.transform = `translate(-50%, -85%) rotate(${rotation}deg)`;
        }
        
        function switchToView(viewIndex) {
            if (isTopDownView) {
                isTopDownView = false;
            }
            currentChair = viewIndex;
            updateCameraPosition();
        }
        
        function switchToTopDown() {
            isTopDownView = !isTopDownView;
            updateCameraPosition();
        }
        
        function startGame(startingLevel = 1, preFillGrid = false) {
            if (!modelLoaded) return;
            
            // Clear the grid and remove all existing blocks
            for (let x = 0; x < GRID_WIDTH; x++) {
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    for (let z = 0; z < GRID_DEPTH; z++) {
                        if (grid[x][y][z] !== null) {
                            scene.remove(grid[x][y][z].mesh);
                            // Dispose cloned materials
                            grid[x][y][z].mesh.traverse(child => {
                                if (child.isMesh && child.material) {
                                    child.material.dispose();
                                }
                            });
                            grid[x][y][z] = null;
                        }
                    }
                }
            }
            
            // Clear falling chain if it exists
            if (fallingChain) {
                fallingChain.links.forEach(link => disposeLinkMesh(link));
                fallingChain = null;
            }
            
            // Clear broken links
            brokenLinks.clear();
            
            // MEMORY LEAK FIX: Cancel all active animation loops
            activeAnimationFrames.forEach(id => cancelAnimationFrame(id));
            activeAnimationFrames = [];
            
            // MEMORY LEAK FIX: Clear all active timeouts and intervals
            activeTimeouts.forEach(id => trackedClearTimeout(id));
            activeTimeouts = [];
            activeIntervals.forEach(id => trackedClearInterval(id));
            activeIntervals = [];
            
            // MEMORY LEAK FIX: Clear particle effects array and dispose particles
            particleEffects.forEach(effect => {
                if (effect.particles) {
                    effect.particles.forEach(particle => {
                        scene.remove(particle.mesh);
                        if (particle.mesh.geometry) particle.mesh.geometry.dispose();
                        if (particle.mesh.material) particle.mesh.material.dispose();
                    });
                }
            });
            particleEffects = [];
            
            // MEMORY LEAK FIX: Clear all placement intervals
            particlePlacements.forEach(placement => {
                if (placement.loopInterval) {
                    trackedClearInterval(placement.loopInterval);
                    placement.loopInterval = null;
                }
            });
            
            // Restart looping particle placements
            particlePlacements.forEach(placement => {
                if (placement.enabled && placement.loop) {
                    startLoopingParticle(placement);
                }
            });
            
            // Reset floor cell animations
            floorAnimationTime = 0;
            floorCells.forEach(cell => {
                if (cell.material) {
                    cell.material.opacity = 0;
                    cell.material.map = null;
                    cell.material.needsUpdate = true;
                }
            });
            
            // Calculate starting score based on level (level - 1) * 1000
            const startingScore = (startingLevel - 1) * 1000;
            
            // Reset game state
            document.getElementById('titleScreen').style.display = 'none';
            currentState = GameState.PLAYING;
            chainReadyToGlow = false;
            score = startingScore;
            level = startingLevel;
            startLevel = startingLevel;
            usedAI = false; // Reset AI usage tracking
            combo = 1.0;
            floorClearBonusAwarded = false;
            consensusCleared = 0;
            chainVelocity = 0;
            spawnScheduled = false;
            gameStartTime = Date.now(); // Start SPM tracking
            pauseStartTime = null; // Reset pause tracking
            totalPausedTime = 0; // Reset total paused time
            scorePerMinute = 0;
            hyperModeLevel = 0;
            hyperModeEndTime = 0;
            zookoCharge = 0; // Reset special charges
            nateCharge = 0;
            
            // Show controls button hint for level 1 normal start
            if (startingLevel === 1) {
                const controlsBtn = document.getElementById('controlsBtn');
                const tooltip = document.getElementById('controlsHintTooltip');
                controlsBtn.classList.add('hint');
                tooltip.classList.add('show');
                tooltip.style.display = 'block';
                trackedSetTimeout(() => {
                    controlsBtn.classList.remove('hint');
                    tooltip.classList.remove('show');
                    trackedSetTimeout(() => { tooltip.style.display = 'none'; }, 500);
                }, 10000); // Stop blinking after 10 seconds
            }
            zancasCharge = 0;
            cyberaxeCharge = 0;
            sandblastingCharge = 0; // Reset sandblasting charge
            sandblastingActive = false;
            if (window.sandblastingLinks) {
                window.sandblastingLinks.forEach(link => disposeLinkMesh(link.mesh));
                window.sandblastingLinks = [];
            }
            updateSpecialAbilityBars();
            updateSandblastingBar();
            
            // Set notification flags based on starting level
            level10NotificationShown = startingLevel >= 10;
            level20NotificationShown = startingLevel >= 20;
            level50NotificationShown = startingLevel >= 50;
            glowingLinksGuideShown = startingLevel >= 50;
            
            // If AI is enabled, skip all tutorial notifications
            if (settings.aiEnabled) {
                level10NotificationShown = true;
                level20NotificationShown = true;
                level50NotificationShown = true;
                glowingLinksGuideShown = true;
            }
            
            // Reset stats
            stats = {
                chainsPlaced: 0,
                clustersCleared: 0,
                cascadesTriggered: 0,
                fastDropsUsed: 0,
                typesClearedSet: new Set(),
                maxComboReached: 1.0,
                combo5xCount: 0,
                startTime: Date.now(),
                consecutiveClears: 0,
                veilMoves: 0
            };
            
            // Pre-fill grid if requested
            if (preFillGrid) {
                fillGridWithRandomLinks();
            }
            
            // Initialize chain preview queue
            initializeChainQueue();
            
            updateHUD();
        }
        
        // Function to pre-fill grid with random links (3-6 rows from bottom)
        function fillGridWithRandomLinks() {
            const baseTypes = [LinkType.ZEC_A, LinkType.ZEC_B, LinkType.ZEC_C, LinkType.ZEC_D];
            const numRows = 3 + Math.floor(Math.random() * 4); // 3-6 rows
            
            for (let y = 0; y < numRows; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    for (let z = 0; z < GRID_DEPTH; z++) {
                        // 70% chance to place a link (some gaps for variety)
                        if (Math.random() < 0.7) {
                            const linkType = baseTypes[Math.floor(Math.random() * baseTypes.length)];
                            const mesh = createLinkMesh(linkType);
                            
                            // Position mesh at grid location
                            mesh.position.set(x + 0.5, y + 0.5, z + 0.5);
                            
                            // Apply rotation (alternating pattern for chain links)
                            const rotation = (y % 2 === 1) ? Math.PI / 2 : 0;
                            mesh.rotation.y = rotation;
                            
                            // Add to scene
                            scene.add(mesh);
                            
                            // Add to grid
                            grid[x][y][z] = {
                                type: linkType,
                                mesh: mesh,
                                rotation: rotation
                            };
                        }
                    }
                }
            }
        }
        
        // Wrapper function for pre-filled start
        function startGameWithPreFill() { startGame(1, true); }
        
        // Wrapper functions for skip buttons
        function startGameAtLevel10() { startGame(10); }
        function startGameAtLevel50() { startGame(50); }
        function startGameAtLevel100() { startGame(100); }
        function startGameAtLevel1000() { startGame(1000); }
        function startGameAtLevel10000() { startGame(10000); }
        
        function showSettings() {
            document.getElementById('overlay').style.display = 'block';
            document.getElementById('settingsPanel').style.display = 'block';
            
            // Load current settings
            document.getElementById('showHitboxes').checked = settings.showHitboxes;
            document.getElementById('autoRestart').checked = settings.autoRestart;
            document.getElementById('aiEnabled').checked = settings.aiEnabled;
        }
        
        function showSettingsFromPause() {
            // Hide pause screen first
            document.getElementById('pauseScreen').style.display = 'none';
            // Show settings
            showSettings();
        }
        
        function updateSettings() {
            settings.showHitboxes = document.getElementById('showHitboxes').checked;
            settings.autoRestart = document.getElementById('autoRestart').checked;
            settings.aiEnabled = document.getElementById('aiEnabled').checked;
            
            // Update placement box visibility
            updatePlacementBoxVisibility();
            updateModelPlacementBoxVisibility();
            updateChainColumnBoxVisibility();
            
            // ===== AI PLAYER =====
            aiState.enabled = settings.aiEnabled;
            if (settings.aiEnabled && currentState === GameState.PLAYING) {
                usedAI = true; // Mark that AI was used during this game
                // Mark all tutorial notifications as shown when AI is enabled
                level10NotificationShown = true;
                level20NotificationShown = true;
                level50NotificationShown = true;
                glowingLinksGuideShown = true;
            }
            // Reset AI drop speed when turning off AI
            if (!settings.aiEnabled && instantDrop) {
                instantDrop = false;
            }
            document.getElementById('aiIndicator').style.display = settings.aiEnabled ? 'block' : 'none';
            // ===== END AI PLAYER =====
            
            // Update hitbox visibility
            if (zookoClickBox) {
                zookoClickBox.visible = settings.showHitboxes;
            }
            if (cyberAxeClickBox) {
                cyberAxeClickBox.visible = settings.showHitboxes;
            }
            if (zancasClickBox) {
                zancasClickBox.visible = settings.showHitboxes;
            }
            if (nateClickBox) {
                nateClickBox.visible = settings.showHitboxes;
            }
            
            saveSettings();
        }
        
        function clearHighScores() {
            localStorage.removeItem(STORAGE_KEYS.HIGH_SCORES);
            localStorage.removeItem(STORAGE_KEYS.GAME_HISTORY);
            highScores = [];
            console.log('High scores and game history cleared!');
            
            // Show brief notification
            const bonusMsg = document.getElementById('bonusMessage');
            const bonusText = document.getElementById('bonusText');
            bonusText.textContent = 'âœ“ HIGH SCORES CLEARED!';
            bonusMsg.style.display = 'block';
            
            // Hide notification after 2 seconds
            trackedSetTimeout(() => {
                bonusMsg.style.display = 'none';
            }, 2000);
            
            // Close settings panel
            closeAllPanels();
        }
        
        function showAchievements() {
            document.getElementById('overlay').style.display = 'block';
            document.getElementById('achievementsPanel').style.display = 'block';
            
            const list = document.getElementById('achievementsList');
            list.innerHTML = '';
            
            const tiers = ['easier', 'easy', 'mid', 'mid-hard', 'very-hard'];
            const tierNames = {
                'easier': 'Easier',
                'easy': 'Easy',
                'mid': 'Medium',
                'mid-hard': 'Med-Hard',
                'very-hard': 'V-Hard'
            };
            
            tiers.forEach(tier => {
                const tierSection = document.createElement('div');
                tierSection.style.cssText = 'margin-bottom: 15px;';
                
                const tierHeader = document.createElement('div');
                tierHeader.style.cssText = 'display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; padding-bottom: 6px; border-bottom: 2px solid #2A9D8F;';
                
                const tierTitle = document.createElement('h3');
                tierTitle.textContent = tierNames[tier];
                tierTitle.style.cssText = 'color: #2A9D8F; margin: 0; font-size: 16px; font-weight: 800; text-transform: uppercase; letter-spacing: 1px;';
                
                const tierAchievements = achievements.filter(a => a.tier === tier);
                const unlockedCount = tierAchievements.filter(a => a.unlocked).length;
                
                const progress = document.createElement('span');
                progress.textContent = `${unlockedCount}/${tierAchievements.length}`;
                progress.style.cssText = 'color: #BFD1E0; font-size: 13px; font-weight: 700;';
                
                tierHeader.appendChild(tierTitle);
                tierHeader.appendChild(progress);
                tierSection.appendChild(tierHeader);
                
                const grid = document.createElement('div');
                grid.style.cssText = 'display: grid; grid-template-columns: repeat(6, 1fr); gap: 6px;';
                
                tierAchievements.forEach(achievement => {
                    const item = document.createElement('div');
                    item.className = 'achievementItem' + (achievement.unlocked ? ' unlocked' : '');
                    
                    item.innerHTML = `
                        <div style="width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 14px; flex-shrink: 0; background: ${achievement.unlocked ? '#2A9D8F' : '#141B22'}; color: #fff; border: 2px solid ${achievement.unlocked ? '#4ECDC4' : '#26313B'};">
                            ${achievement.unlocked ? 'âœ“' : 'ðŸ”’'}
                        </div>
                        <div style="flex: 1; min-width: 0;">
                            <div style="font-size: 12px; font-weight: 700; margin-bottom: 2px; color: ${achievement.unlocked ? '#4ECDC4' : '#D4E3F0'}; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${achievement.name}</div>
                            <div style="font-size: 10px; color: #89A0B4; line-height: 1.3; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;">${achievement.desc}</div>
                        </div>
                    `;
                    
                    grid.appendChild(item);
                });
                
                tierSection.appendChild(grid);
                list.appendChild(tierSection);
            });
            
            const totalUnlocked = achievements.filter(a => a.unlocked).length;
            const summary = document.createElement('div');
            summary.style.cssText = 'margin-top: 15px; padding-top: 12px; border-top: 2px solid #2A9D8F; text-align: center; font-size: 16px; font-weight: 700; color: #4ECDC4;';
            summary.textContent = `${totalUnlocked}/50 Unlocked`;
            list.appendChild(summary);
        }
        
        function showAbout() {
            document.getElementById('overlay').style.display = 'block';
            document.getElementById('aboutPanel').style.display = 'block';
        }
        
        function showHowToPlay() {
            document.getElementById('overlay').style.display = 'block';
            document.getElementById('howToPlayPanel').style.display = 'block';
        }
        
        function closeHowToPlay() {
            document.getElementById('overlay').style.display = 'none';
            document.getElementById('howToPlayPanel').style.display = 'none';
        }
        
        function showHighScores() {
            document.getElementById('overlay').style.display = 'block';
            document.getElementById('highScoresPanel').style.display = 'block';
            
            const list = document.getElementById('highScoresList');
            list.innerHTML = '';
            
            // Create 2-column layout container
            const container = document.createElement('div');
            container.style.cssText = 'display: grid; grid-template-columns: 1fr 1fr; gap: 25px;';
            
            // Left column: Top 10 High Scores
            const leftColumn = document.createElement('div');
            const topTitle = document.createElement('h3');
            topTitle.textContent = 'Top 10 High Scores';
            topTitle.style.cssText = 'color: #F2C94C; margin: 0 0 12px 0; font-size: 18px; text-align: center; font-weight: 800; text-transform: uppercase; letter-spacing: 1px;';
            leftColumn.appendChild(topTitle);
            
            const topScores = JSON.parse(localStorage.getItem(STORAGE_KEYS.HIGH_SCORES) || '[]');
            if (topScores.length === 0) {
                const noData = document.createElement('div');
                noData.textContent = 'No high scores yet!';
                noData.style.cssText = 'color: #89A0B4; padding: 20px; text-align: center; font-size: 14px;';
                leftColumn.appendChild(noData);
            } else {
                let displayIndex = 1;
                topScores.slice(0, 10).forEach((game) => {
                    if (!game.time || !game.scorePerMinute) return;
                    const item = document.createElement('div');
                    item.style.cssText = 'background: rgba(10, 14, 18, 0.5); padding: 8px 12px; margin: 5px 0; border-radius: 6px; font-family: JetBrains Mono, monospace; border: 1px solid #26313B; transition: all 0.2s;';
                    const minutes = Math.floor(game.time / 60);
                    const seconds = game.time % 60;
                    
                    let startIcon = '';
                    const sl = game.startLevel || 1;
                    if (sl === 1) startIcon = 'ðŸŸ¢';
                    else if (sl === 10) startIcon = 'ðŸ”µ';
                    else if (sl === 50) startIcon = 'ðŸŸ ';
                    else if (sl === 100) startIcon = 'ðŸ”´';
                    else if (sl === 1000) startIcon = 'ðŸŸ£';
                    else if (sl === 10000) startIcon = 'ðŸŸ¡';
                    else startIcon = 'âšª';
                    
                    const aiBadge = game.usedAI ? ' ðŸ¤–' : '';
                    
                    item.innerHTML = `
                        <div style="display: flex; justify-content: space-between; color: #D4E3F0; font-size: 13px; margin-bottom: 3px;">
                            <span>#${displayIndex} ${startIcon}${aiBadge}</span>
                            <span style="color: #F2C94C; font-weight: 700;">${game.score.toLocaleString()}</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; color: #89A0B4; font-size: 11px;">
                            <span>Lv ${game.level}</span>
                            <span>${minutes}:${seconds.toString().padStart(2, '0')}</span>
                            <span>${game.scorePerMinute.toLocaleString()}/min</span>
                        </div>
                    `;
                    item.addEventListener('mouseenter', () => {
                        item.style.transform = 'translateX(3px)';
                        item.style.borderColor = '#F2C94C';
                        item.style.background = 'rgba(20, 27, 34, 0.8)';
                    });
                    item.addEventListener('mouseleave', () => {
                        item.style.transform = 'translateX(0)';
                        item.style.borderColor = '#26313B';
                        item.style.background = 'rgba(10, 14, 18, 0.5)';
                    });
                    leftColumn.appendChild(item);
                    displayIndex++;
                });
            }
            
            // Right column: Last 5 Games
            const rightColumn = document.createElement('div');
            const recentTitle = document.createElement('h3');
            recentTitle.textContent = 'Last 5 Games';
            recentTitle.style.cssText = 'color: #2D9CDB; margin: 0 0 12px 0; font-size: 18px; text-align: center; font-weight: 800; text-transform: uppercase; letter-spacing: 1px;';
            rightColumn.appendChild(recentTitle);
            
            const gameHistory = JSON.parse(localStorage.getItem(STORAGE_KEYS.GAME_HISTORY) || '[]');
            if (gameHistory.length === 0) {
                const noData = document.createElement('div');
                noData.textContent = 'No game history yet!';
                noData.style.cssText = 'color: #89A0B4; padding: 20px; text-align: center; font-size: 14px;';
                rightColumn.appendChild(noData);
            } else {
                let displayIndex = 1;
                gameHistory.forEach((game) => {
                    if (!game.time || !game.scorePerMinute) return;
                    const item = document.createElement('div');
                    item.style.cssText = 'background: rgba(10, 14, 18, 0.5); padding: 10px 14px; margin: 6px 0; border-radius: 6px; font-family: JetBrains Mono, monospace; border: 1px solid #26313B; transition: all 0.2s;';
                    const minutes = Math.floor(game.time / 60);
                    const seconds = game.time % 60;
                    
                    let startIcon = '';
                    const sl = game.startLevel || 1;
                    if (sl === 1) startIcon = 'ðŸŸ¢';
                    else if (sl === 10) startIcon = 'ðŸ”µ';
                    else if (sl === 50) startIcon = 'ðŸŸ ';
                    else if (sl === 100) startIcon = 'ðŸ”´';
                    else if (sl === 1000) startIcon = 'ðŸŸ£';
                    else if (sl === 10000) startIcon = 'ðŸŸ¡';
                    else startIcon = 'âšª';
                    
                    const aiBadge = game.usedAI ? ' ðŸ¤–' : '';
                    
                    item.innerHTML = `
                        <div style="display: flex; justify-content: space-between; color: #2D9CDB; font-size: 14px; margin-bottom: 4px; font-weight: 700;">
                            <span>Game ${displayIndex} ${startIcon}${aiBadge}</span>
                            <span style="color: #F2C94C;">${game.score.toLocaleString()}</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; color: #89A0B4; font-size: 12px;">
                            <span>Level ${game.level}</span>
                            <span>${minutes}:${seconds.toString().padStart(2, '0')}</span>
                            <span>${game.scorePerMinute.toLocaleString()}/min</span>
                        </div>
                    `;
                    item.addEventListener('mouseenter', () => {
                        item.style.transform = 'translateX(3px)';
                        item.style.borderColor = '#2D9CDB';
                        item.style.background = 'rgba(20, 27, 34, 0.8)';
                    });
                    item.addEventListener('mouseleave', () => {
                        item.style.transform = 'translateX(0)';
                        item.style.borderColor = '#26313B';
                        item.style.background = 'rgba(10, 14, 18, 0.5)';
                    });
                    rightColumn.appendChild(item);
                    displayIndex++;
                });
            }
            
            container.appendChild(leftColumn);
            container.appendChild(rightColumn);
            list.appendChild(container);
        }
        
        function closeAllPanels() {
            document.getElementById('overlay').style.display = 'none';
            document.getElementById('settingsPanel').style.display = 'none';
            document.getElementById('highScoresPanel').style.display = 'none';
            document.getElementById('achievementsPanel').style.display = 'none';
            document.getElementById('aboutPanel').style.display = 'none';
            
            // If game is paused, show pause screen again
            if (currentState === GameState.PAUSED) {
                document.getElementById('pauseScreen').style.display = 'flex';
            }
        }
        
        function showLevel10Notification() {
            if (level10NotificationShown) return; // Only show once
            level10NotificationShown = true;
            
            // Pause the game
            const wasPaused = currentState === GameState.PAUSED;
            if (!wasPaused && currentState === GameState.PLAYING) {
                currentState = GameState.PAUSED;
            }
            
            // Show notification
            document.getElementById('level10Notification').style.display = 'block';
        }
        
        function closeLevel10Notification() {
            document.getElementById('level10Notification').style.display = 'none';
            
            // Resume game
            if (currentState === GameState.PAUSED) {
                currentState = GameState.PLAYING;
            }
        }
        
        function showGlowingLinksGuide() {
            if (glowingLinksGuideShown || startLevel > 1) return; // Only show once and only if started at level 1
            glowingLinksGuideShown = true;
            
            // Pause the game
            const wasPaused = currentState === GameState.PAUSED;
            if (!wasPaused && currentState === GameState.PLAYING) {
                currentState = GameState.PAUSED;
            }
            
            // Show notification
            document.getElementById('glowingLinksGuide').style.display = 'block';
        }
        
        function closeGlowingLinksGuide() {
            document.getElementById('glowingLinksGuide').style.display = 'none';
            
            // Resume game
            if (currentState === GameState.PAUSED) {
                currentState = GameState.PLAYING;
            }
        }
        
        function showLevel20Notification() {
            if (level20NotificationShown) return; // Only show once
            level20NotificationShown = true;
            
            // Pause the game
            const wasPaused = currentState === GameState.PAUSED;
            if (!wasPaused && currentState === GameState.PLAYING) {
                currentState = GameState.PAUSED;
            }
            
            // Show notification
            document.getElementById('level20Notification').style.display = 'block';
        }
        
        function closeLevel20Notification() {
            document.getElementById('level20Notification').style.display = 'none';
            
            // Resume game
            if (currentState === GameState.PAUSED) {
                currentState = GameState.PLAYING;
            }
        }
        
        function showLevel50Notification() {
            if (level50NotificationShown) return; // Only show once
            level50NotificationShown = true;
            
            // Pause the game
            const wasPaused = currentState === GameState.PAUSED;
            if (!wasPaused && currentState === GameState.PLAYING) {
                currentState = GameState.PAUSED;
            }
            
            // Show notification
            document.getElementById('level50Notification').style.display = 'block';
        }
        
        function closeLevel50Notification() {
            document.getElementById('level50Notification').style.display = 'none';
            
            // Resume game
            if (currentState === GameState.PAUSED) {
                currentState = GameState.PLAYING;
            }
        }
        
        function skipAllHints() {
            // Mark all notifications as shown so they never appear again
            level10NotificationShown = true;
            level20NotificationShown = true;
            level50NotificationShown = true;
            glowingLinksGuideShown = true;
            
            // Close all visible notifications
            document.getElementById('level10Notification').style.display = 'none';
            document.getElementById('level20Notification').style.display = 'none';
            document.getElementById('level50Notification').style.display = 'none';
            document.getElementById('glowingLinksGuide').style.display = 'none';
            
            // Resume game if it was paused
            if (currentState === GameState.PAUSED) {
                currentState = GameState.PLAYING;
            }
            
            console.log('All hints skipped');
        }
        
        function pauseGame() {
            if (currentState === GameState.PLAYING) {
                currentState = GameState.PAUSED;
                pauseStartTime = Date.now(); // Track when pause started
                document.getElementById('pauseScreen').style.display = 'flex';
            }
        }
        
        function resumeGame() {
            if (currentState === GameState.PAUSED) {
                currentState = GameState.PLAYING;
                // Add pause duration to total paused time
                if (pauseStartTime) {
                    totalPausedTime += Date.now() - pauseStartTime;
                    pauseStartTime = null;
                }
                document.getElementById('pauseScreen').style.display = 'none';
                lastUpdateTime = Date.now(); // Reset timing to prevent jumps
            }
        }
        
        function restartFromPause() {
            saveHighScore(score, level);
            checkAchievements();
            
            document.getElementById('pauseScreen').style.display = 'none';
            startGame();
        }
        
        function quitToMenu() {
            saveHighScore(score, level);
            checkAchievements();
            
            document.getElementById('pauseScreen').style.display = 'none';
            document.getElementById('titleScreen').style.display = 'flex';
            currentState = GameState.MENU;
            
            // Clean up falling chain if exists
            if (fallingChain) {
                fallingChain.links.forEach(mesh => disposeLinkMesh(mesh));
                fallingChain = null;
            }
        }
        
        function updateHUD() {
            document.getElementById('scoreValue').textContent = score.toLocaleString();
            document.getElementById('levelValue').textContent = level;
            document.getElementById('comboValue').textContent = 'Ã—' + combo.toFixed(1);
            document.getElementById('consensusValue').textContent = consensusCleared.toLocaleString();
            
            // Calculate and display current drop speed (no cap!)
            const baseSpeed = 0.15;
            const levelScaling = baseSpeed + (level - 1) * 0.004; // Scales infinitely
            document.getElementById('dropSpeedValue').textContent = levelScaling.toFixed(2) + 'Ã—';
            
            // Calculate and display Score Per Minute (excluding paused time)
            if (gameStartTime) {
                const totalElapsedTime = Date.now() - gameStartTime;
                const activePlayTime = totalElapsedTime - totalPausedTime;
                const elapsedMinutes = activePlayTime / 60000;
                scorePerMinute = elapsedMinutes > 0 ? Math.floor(score / elapsedMinutes) : 0;
                
                const spmElement = document.getElementById('spmValue');
                if (spmElement) {
                    spmElement.textContent = scorePerMinute.toLocaleString();
                }
            } else {
                // No game started yet, ensure display shows 0
                const spmElement = document.getElementById('spmValue');
                if (spmElement) {
                    spmElement.textContent = '0';
                }
            }
            
            if (combo > 1.0) {
                document.getElementById('comboDisplay').style.display = 'block';
            } else {
                document.getElementById('comboDisplay').style.display = 'none';
            }
            
            // Level progression based on score
            const newLevel = Math.floor(score / 1000) + 1; // No cap - goes to max int
            if (newLevel > level) {
                const oldLevel = level;
                level = newLevel;
                checkAchievements();
                
                // Show level 10 notification when reaching or passing level 10
                if (oldLevel < 10 && level >= 10 && !level10NotificationShown) {
                    showLevel10Notification();
                }
                
                // Show level 20 notification when reaching or passing level 20
                if (oldLevel < 20 && level >= 20 && !level20NotificationShown) {
                    showLevel20Notification();
                }
                
                // Show level 50 notification when reaching or passing level 50
                if (oldLevel < 50 && level >= 50 && !level50NotificationShown) {
                    showLevel50Notification();
                }
            }
        }
        
        function updateSpecialAbilityBars() {
            // Update visual bars (vertical fill from bottom)
            document.getElementById('zookoBar').style.height = zookoCharge + '%';
            document.getElementById('nateBar').style.height = nateCharge + '%';
            document.getElementById('zancasBar').style.height = zancasCharge + '%';
            document.getElementById('cyberaxeBar').style.height = cyberaxeCharge + '%';
            
            // Check if any special is active
            const anySpecialActive = zookoSpecialActive || nateSpecialActive || zancasSpecialActive || cyberAxeSpecialActive;
            
            // Add/remove ready class for blinking highlight
            const zookoIcon = document.getElementById('zookoIcon');
            const nateIcon = document.getElementById('nateIcon');
            const zancasIcon = document.getElementById('zancasIcon');
            const cyberaxeIcon = document.getElementById('cyberaxeIcon');
            
            if (zookoIcon) {
                if (zookoCharge >= 100) zookoIcon.classList.add('ready');
                else zookoIcon.classList.remove('ready');
                // Disable if another special is active
                if (anySpecialActive && !zookoSpecialActive) zookoIcon.classList.add('disabled');
                else zookoIcon.classList.remove('disabled');
            }
            if (nateIcon) {
                if (nateCharge >= 100) nateIcon.classList.add('ready');
                else nateIcon.classList.remove('ready');
                // Disable if another special is active
                if (anySpecialActive && !nateSpecialActive) nateIcon.classList.add('disabled');
                else nateIcon.classList.remove('disabled');
            }
            if (zancasIcon) {
                if (zancasCharge >= 100) zancasIcon.classList.add('ready');
                else zancasIcon.classList.remove('ready');
                // Disable if another special is active
                if (anySpecialActive && !zancasSpecialActive) zancasIcon.classList.add('disabled');
                else zancasIcon.classList.remove('disabled');
            }
            if (cyberaxeIcon) {
                if (cyberaxeCharge >= 100) cyberaxeIcon.classList.add('ready');
                else cyberaxeIcon.classList.remove('ready');
                // Disable if another special is active
                if (anySpecialActive && !cyberAxeSpecialActive) cyberaxeIcon.classList.add('disabled');
                else cyberaxeIcon.classList.remove('disabled');
            }
        }
        
        function updateSandblastingBar() {
            const barFill = document.getElementById('sandblastingBarFill');
            const percentText = document.getElementById('sandblastingPercent');
            
            if (barFill) {
                barFill.style.height = sandblastingCharge + '%';
            }
            if (percentText) {
                percentText.textContent = Math.floor(sandblastingCharge) + '%';
            }
        }
        
        function addSpecialCharge(blockType, amount = 10) {
            // Add charge based on block type cleared
            // ZEC-A = Gold (Nate)
            // ZEC-B = Blue (CyberAxe)
            // ZEC-C = Green (Zancas)
            // ZEC-D = Red (Zooko)
            
            const typeName = blockType.name || blockType; // Handle both object and string
            
            if (typeName === 'ZEC-A') { // Gold
                nateCharge = Math.min(100, nateCharge + amount);
            } else if (typeName === 'ZEC-B') { // Blue
                cyberaxeCharge = Math.min(100, cyberaxeCharge + amount);
            } else if (typeName === 'ZEC-C') { // Green
                zancasCharge = Math.min(100, zancasCharge + amount);
            } else if (typeName === 'ZEC-D') { // Red
                zookoCharge = Math.min(100, zookoCharge + amount);
            }
            
            updateSpecialAbilityBars();
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function onKeyDown(e) {
            keys[e.key.toLowerCase()] = true;
            
            // P key to create new particle placement (dev tool)
            if (e.key.toLowerCase() === 'p' && settings.showHitboxes) {
                createParticlePlacement();
                e.preventDefault();
                return;
            }
            
            // M key to create new model placement (dev tool)
            if (e.key.toLowerCase() === 'm' && settings.showHitboxes) {
                createModelPlacement();
                e.preventDefault();
                return;
            }
            
            if (currentState !== GameState.PLAYING) return;
            
            // Camera rotation
            if (e.key.toLowerCase() === 'q') {
                rotateCamera(-1);
            } else if (e.key.toLowerCase() === 'e') {
                rotateCamera(1);
            }
            
            // Toggle top-down view with T key
            if (e.key.toLowerCase() === 't') {
                switchToTopDown();
                e.preventDefault();
            }
            
            // Reset camera zoom to default with R key
            if (e.key.toLowerCase() === 'r') {
                cameraDistance = baseCameraDistance;
                updateCameraPosition();
                e.preventDefault();
            }
            
            // Reset camera zoom to default with R key
            if (e.key.toLowerCase() === 'r') {
                cameraDistance = baseCameraDistance;
                updateCameraPosition();
                e.preventDefault();
            }
            
            // Piece rotation with arrow keys
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                rotatePiece(e.key);
                e.preventDefault();
            }
            
            // Fast drop / Instant drop
            if (e.key === ' ') {
                const currentTime = Date.now();
                const timeSinceLastSpace = currentTime - lastSpaceTime;
                
                // Double-tap detected - instant drop
                if (timeSinceLastSpace < doubleTapThreshold && timeSinceLastSpace > 0) {
                    instantDrop = true;
                    fastDrop = false; // Override normal fast drop
                } else {
                    // Single tap - fast drop
                    fastDrop = true;
                    instantDrop = false;
                }
                
                lastSpaceTime = currentTime;
                stats.fastDropsUsed++;
                if (stats.fastDropsUsed >= 10) unlockAchievement('fast_drop');
                e.preventDefault();
            }
            
            // Flip chain with Shift key
            if (e.key === 'Shift') {
                flipChain();
                e.preventDefault();
            }
            
            // Pause
            if (e.key === 'Escape') {
                pauseGame();
                e.preventDefault();
            }
            
            // Character special moves (only during gameplay, not in menus)
            if (e.key === '1' && document.activeElement.tagName !== 'INPUT') {
                playZookoSpecialAnimation();
                e.preventDefault();
            }
            if (e.key === '2' && document.activeElement.tagName !== 'INPUT') {
                playNateSpecialAnimation();
                e.preventDefault();
            }
            if (e.key === '3' && document.activeElement.tagName !== 'INPUT') {
                playZancasSpecialAnimation();
                e.preventDefault();
            }
            if (e.key === '4' && document.activeElement.tagName !== 'INPUT') {
                playCyberAxeSpecialAnimation();
                e.preventDefault();
            }
            
            // Cheat: Charge all specials to full with + key
            if (e.key === '+' || e.key === '=') {
                zookoCharge = 100;
                nateCharge = 100;
                zancasCharge = 100;
                cyberaxeCharge = 100;
                updateSpecialAbilityBars();
                e.preventDefault();
            }
        }
        
        function onKeyUp(e) {
            keys[e.key.toLowerCase()] = false;
            
            if (e.key === ' ') {
                fastDrop = false;
                instantDrop = false;
            }
        }
        
        // ===== GAMEPAD FUNCTIONS =====
        function onGamepadConnected(e) {
            gamepadConnected = true;
            gamepadIndex = e.gamepad.index;
            console.log(`ðŸŽ® Gamepad connected: ${e.gamepad.id}`);
            
            // Show notification to user
            if (typeof showNotification === 'function') {
                showNotification(`ðŸŽ® Controller Connected: ${e.gamepad.id.substring(0, 30)}`, 3000);
            }
        }
        
        function onGamepadDisconnected(e) {
            if (e.gamepad.index === gamepadIndex) {
                gamepadConnected = false;
                gamepadIndex = null;
                gamepadButtonStates = {};
                console.log('ðŸŽ® Gamepad disconnected');
                
                if (typeof showNotification === 'function') {
                    showNotification('ðŸŽ® Controller Disconnected', 2000);
                }
            }
        }
        
        function updateGamepad() {
            if (!gamepadConnected || gamepadIndex === null) return;
            
            const now = Date.now();
            if (now - lastGamepadUpdate < gamepadUpdateInterval) return;
            lastGamepadUpdate = now;
            
            const gamepads = navigator.getGamepads();
            const gamepad = gamepads[gamepadIndex];
            
            if (!gamepad) return;
            
            // Process buttons
            gamepad.buttons.forEach((button, index) => {
                const wasPressed = gamepadButtonStates[index] || false;
                const isPressed = button.pressed;
                
                // Button just pressed (rising edge)
                if (isPressed && !wasPressed) {
                    handleGamepadButtonPress(index);
                }
                
                // Button just released (falling edge)
                if (!isPressed && wasPressed) {
                    handleGamepadButtonRelease(index);
                }
                
                gamepadButtonStates[index] = isPressed;
            });
            
            // Process left analog stick for WASD movement (ONLY if gamepad is being used)
            if (currentState === GameState.PLAYING) {
                const leftX = gamepad.axes[GamepadAxes.LEFT_X];
                const leftY = gamepad.axes[GamepadAxes.LEFT_Y];
                
                // Right analog stick for camera zoom
                const rightY = gamepad.axes[GamepadAxes.RIGHT_Y];
                const zoomDeadzone = 0.3;
                if (Math.abs(rightY) > zoomDeadzone) {
                    const zoomSpeed = 0.15;
                    cameraDistance += rightY * zoomSpeed;
                    cameraDistance = Math.max(minCameraDistance, Math.min(maxCameraDistance, cameraDistance));
                    updateCameraPosition();
                }
                
                // Determine current analog stick state
                const currentAnalogState = {
                    up: leftY < -gamepadAxisDeadzone,
                    down: leftY > gamepadAxisDeadzone,
                    left: leftX < -gamepadAxisDeadzone,
                    right: leftX > gamepadAxisDeadzone
                };
                
                // Only trigger movement on RISING EDGE (when stick crosses deadzone threshold)
                // Reset WASD keys first
                keys['w'] = false;
                keys['a'] = false;
                keys['s'] = false;
                keys['d'] = false;
                
                // Trigger movement only when direction just became active (edge detection)
                if (currentAnalogState.up && !lastAnalogState.up) {
                    keys['w'] = true;
                }
                if (currentAnalogState.down && !lastAnalogState.down) {
                    keys['s'] = true;
                }
                if (currentAnalogState.left && !lastAnalogState.left) {
                    keys['a'] = true;
                }
                if (currentAnalogState.right && !lastAnalogState.right) {
                    keys['d'] = true;
                }
                
                // Update last analog state
                lastAnalogState = currentAnalogState;
            }
        }
        
        function handleGamepadButtonPress(buttonIndex) {
            // ===== SETTINGS PANEL NAVIGATION (Check first - highest priority) =====
            const settingsPanel = document.getElementById('settingsPanel');
            if (settingsPanel && settingsPanel.style.display === 'block') {
                // X button - Clear High Scores
                if (buttonIndex === GamepadButtons.X) {
                    clearHighScores();
                    return;
                }
                // B button - Close
                else if (buttonIndex === GamepadButtons.B) {
                    closeAllPanels();
                    return;
                }
                // Block all other menu inputs when settings is open
                return;
            }
            // ===== END SETTINGS PANEL NAVIGATION =====
            
            // ===== HOW TO PLAY PANEL NAVIGATION =====
            const howToPlayPanel = document.getElementById('howToPlayPanel');
            if (howToPlayPanel && howToPlayPanel.style.display === 'block') {
                // B button or SELECT button - Close
                if (buttonIndex === GamepadButtons.B || buttonIndex === GamepadButtons.SELECT) {
                    closeHowToPlay();
                    return;
                }
                // Block all other menu inputs when how to play panel is open
                return;
            }
            // ===== END HOW TO PLAY PANEL NAVIGATION =====
            
            // ===== ABOUT PANEL NAVIGATION =====
            const aboutPanel = document.getElementById('aboutPanel');
            if (aboutPanel && aboutPanel.style.display === 'block') {
                // B button - Close
                if (buttonIndex === GamepadButtons.B) {
                    closeAllPanels();
                    return;
                }
                // Block all other menu inputs when about panel is open
                return;
            }
            // ===== END ABOUT PANEL NAVIGATION =====
            
            // ===== HIGH SCORES PANEL NAVIGATION =====
            const highScoresPanel = document.getElementById('highScoresPanel');
            if (highScoresPanel && highScoresPanel.style.display === 'block') {
                // B button - Close
                if (buttonIndex === GamepadButtons.B) {
                    closeAllPanels();
                    return;
                }
                // Block all other menu inputs when high scores panel is open
                return;
            }
            // ===== END HIGH SCORES PANEL NAVIGATION =====
            
            // ===== ACHIEVEMENTS PANEL NAVIGATION =====
            const achievementsPanel = document.getElementById('achievementsPanel');
            if (achievementsPanel && achievementsPanel.style.display === 'block') {
                // B button - Close
                if (buttonIndex === GamepadButtons.B) {
                    closeAllPanels();
                    return;
                }
                // Block all other menu inputs when achievements panel is open
                return;
            }
            // ===== END ACHIEVEMENTS PANEL NAVIGATION =====
            
            // ===== HINT POPUP NAVIGATION =====
            const level10Notification = document.getElementById('level10Notification');
            const glowingLinksGuide = document.getElementById('glowingLinksGuide');
            const level20Notification = document.getElementById('level20Notification');
            const level50Notification = document.getElementById('level50Notification');
            
            const anyHintVisible = (level10Notification && level10Notification.style.display === 'block') ||
                                   (glowingLinksGuide && glowingLinksGuide.style.display === 'block') ||
                                   (level20Notification && level20Notification.style.display === 'block') ||
                                   (level50Notification && level50Notification.style.display === 'block');
            
            if (anyHintVisible) {
                // A button - Got It (close current hint)
                if (buttonIndex === GamepadButtons.A) {
                    if (level10Notification && level10Notification.style.display === 'block') {
                        closeLevel10Notification();
                    } else if (glowingLinksGuide && glowingLinksGuide.style.display === 'block') {
                        closeGlowingLinksGuide();
                    } else if (level20Notification && level20Notification.style.display === 'block') {
                        closeLevel20Notification();
                    } else if (level50Notification && level50Notification.style.display === 'block') {
                        closeLevel50Notification();
                    }
                    return;
                }
                // Y button - Skip All Hints
                else if (buttonIndex === GamepadButtons.Y) {
                    skipAllHints();
                    return;
                }
                // Block all other inputs when hint popup is open
                return;
            }
            // ===== END HINT POPUP NAVIGATION =====
            
            // ===== MENU NAVIGATION =====
            if (currentState === GameState.MENU) {
                // A button - Start Game
                if (buttonIndex === GamepadButtons.A) {
                    startGame();
                    return;
                }
                // Start button - Settings
                else if (buttonIndex === GamepadButtons.START) {
                    showSettings();
                    return;
                }
                // SELECT button - How to Play
                else if (buttonIndex === GamepadButtons.SELECT) {
                    showHowToPlay();
                    return;
                }
                // X button - High Scores
                else if (buttonIndex === GamepadButtons.X) {
                    showHighScores();
                    return;
                }
                // Y button - Achievements
                else if (buttonIndex === GamepadButtons.Y) {
                    showAchievements();
                    return;
                }
                // B button - About/Donate
                else if (buttonIndex === GamepadButtons.B) {
                    showAbout();
                    return;
                }
                // D-Pad UP - Start with Pre-filled Grid
                else if (buttonIndex === GamepadButtons.DPAD_UP) {
                    startGameWithPreFill();
                    return;
                }
                // D-Pad LEFT - Skip to Level 10
                else if (buttonIndex === GamepadButtons.DPAD_LEFT) {
                    startGameAtLevel10();
                    return;
                }
                // D-Pad RIGHT - Skip to Level 50
                else if (buttonIndex === GamepadButtons.DPAD_RIGHT) {
                    startGameAtLevel50();
                    return;
                }
                // D-Pad DOWN - Skip to Level 100
                else if (buttonIndex === GamepadButtons.DPAD_DOWN) {
                    startGameAtLevel100();
                    return;
                }
            }
            // ===== END MENU NAVIGATION =====
            
            // ===== PAUSE MENU NAVIGATION =====
            if (currentState === GameState.PAUSED) {
                // A button - Resume
                if (buttonIndex === GamepadButtons.A) {
                    resumeGame();
                    return;
                }
                // B button - Resume (also works)
                else if (buttonIndex === GamepadButtons.B) {
                    resumeGame();
                    return;
                }
                // X button - Restart
                else if (buttonIndex === GamepadButtons.X) {
                    restartFromPause();
                    return;
                }
                // Y button - Settings
                else if (buttonIndex === GamepadButtons.Y) {
                    showSettingsFromPause();
                    return;
                }
                // Select button - Quit to Menu
                else if (buttonIndex === GamepadButtons.SELECT) {
                    quitToMenu();
                    return;
                }
            }
            // ===== END PAUSE MENU NAVIGATION =====
            
            // A button - Close hints/notifications OR Fast drop
            if (buttonIndex === GamepadButtons.A) {
                // Check if any notification/hint is visible and close it
                const level10 = document.getElementById('level10Notification');
                const level20 = document.getElementById('level20Notification');
                const level50 = document.getElementById('level50Notification');
                const glowingLinks = document.getElementById('glowingLinksGuide');
                
                if (level10 && level10.style.display === 'block') {
                    closeLevel10Notification();
                    return;
                }
                if (level20 && level20.style.display === 'block') {
                    closeLevel20Notification();
                    return;
                }
                if (level50 && level50.style.display === 'block') {
                    closeLevel50Notification();
                    return;
                }
                if (glowingLinks && glowingLinks.style.display === 'block') {
                    closeGlowingLinksGuide();
                    return;
                }
                
                // If no hints visible and playing, do fast drop
                if (currentState === GameState.PLAYING) {
                    const currentTime = Date.now();
                    const timeSinceLastSpace = currentTime - lastSpaceTime;
                    
                    if (timeSinceLastSpace < doubleTapThreshold && timeSinceLastSpace > 0) {
                        instantDrop = true;
                        fastDrop = false;
                    } else {
                        fastDrop = true;
                        instantDrop = false;
                    }
                    
                    lastSpaceTime = currentTime;
                    stats.fastDropsUsed++;
                    if (stats.fastDropsUsed >= 10) unlockAchievement('fast_drop');
                }
            }
            
            // B button - Rotate piece (cycles through rotations) - same as ARROW KEYS
            else if (buttonIndex === GamepadButtons.B && currentState === GameState.PLAYING) {
                rotatePiece('ArrowRight');
            }
            
            // Y button - Flip chain - same as SHIFT
            else if (buttonIndex === GamepadButtons.Y && currentState === GameState.PLAYING) {
                flipChain();
            }
            
            // LB - Rotate camera left - same as Q
            else if (buttonIndex === GamepadButtons.LB && currentState === GameState.PLAYING) {
                rotateCamera(-1);
            }
            
            // RB - Rotate camera right - same as E
            else if (buttonIndex === GamepadButtons.RB && currentState === GameState.PLAYING) {
                rotateCamera(1);
            }
            
            // D-Pad UP - Zooko Special (key 1)
            else if (buttonIndex === GamepadButtons.DPAD_UP && currentState === GameState.PLAYING) {
                playZookoSpecialAnimation();
            }
            
            // D-Pad DOWN - Nate Special (key 2)
            else if (buttonIndex === GamepadButtons.DPAD_DOWN && currentState === GameState.PLAYING) {
                playNateSpecialAnimation();
            }
            
            // D-Pad LEFT - Zancas Special (key 3)
            else if (buttonIndex === GamepadButtons.DPAD_LEFT && currentState === GameState.PLAYING) {
                playZancasSpecialAnimation();
            }
            
            // D-Pad RIGHT - CyberAxe Special (key 4)
            else if (buttonIndex === GamepadButtons.DPAD_RIGHT && currentState === GameState.PLAYING) {
                playCyberAxeSpecialAnimation();
            }
            
            // Start button - Pause
            else if (buttonIndex === GamepadButtons.START) {
                if (currentState === GameState.PLAYING) {
                    pauseGame();
                } else if (currentState === GameState.PAUSED) {
                    resumeGame();
                }
            }
            
            // Select button - Toggle top-down view - same as T
            else if (buttonIndex === GamepadButtons.SELECT && currentState === GameState.PLAYING) {
                switchToTopDown();
            }
            
            // R3 button - Reset camera zoom to default
            else if (buttonIndex === GamepadButtons.R3 && currentState === GameState.PLAYING) {
                cameraDistance = baseCameraDistance;
                updateCameraPosition();
            }
            
            // X button - unused (reserved for future feature)
            // L3 button - unused
            // R3 button - unused
        }
        
        function handleGamepadButtonRelease(buttonIndex) {
            // A button release - stop fast drop
            if (buttonIndex === GamepadButtons.A) {
                fastDrop = false;
                instantDrop = false;
            }
        }
        // ===== END GAMEPAD FUNCTIONS =====
        
        function rotateCamera(direction) {
            currentChair = (currentChair + direction + 4) % 4;
            updateCameraPosition();
            unlockAchievement('rotate_view');
        }
        
        function toggleTopDownView() {
            isTopDownView = !isTopDownView;
            updateCameraPosition();
        }
        
        function onMouseClick(event) {
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            
            // Check for particle placement boxes and arrows (when hitboxes are visible)
            if (settings.showHitboxes) {
                // Check model placements first
                const modelPlacementObjects = [];
                modelPlacements.forEach(placement => {
                    if (placement.box && placement.box.visible) {
                        modelPlacementObjects.push(placement.box);
                    }
                    placement.arrows.forEach(arrow => {
                        if (arrow.visible) {
                            modelPlacementObjects.push(arrow.cone);
                        }
                    });
                });
                
                const modelPlacementIntersects = raycaster.intersectObjects(modelPlacementObjects, true);
                if (modelPlacementIntersects.length > 0) {
                    const obj = modelPlacementIntersects[0].object;
                    
                    // Check if it's a model arrow
                    let isArrow = false;
                    let arrowData = null;
                    modelPlacements.forEach(placement => {
                        placement.arrows.forEach(arrow => {
                            if (arrow.cone === obj) {
                                isArrow = true;
                                arrowData = { placement, arrow };
                            }
                        });
                    });
                    
                    if (isArrow && arrowData) {
                        // Move model placement in arrow direction
                        moveModelPlacement(arrowData.placement, arrowData.arrow.userData.axis, arrowData.arrow.userData.sign);
                        if (selectedModelPlacement && selectedModelPlacement.id === arrowData.placement.id) {
                            updateModelPlacementMenuFields();
                        }
                        return;
                    }
                    
                    // Check if it's a model box
                    if (obj.userData.isModelPlacementBox) {
                        const placement = modelPlacements.find(p => p.id === obj.userData.modelPlacementId);
                        if (placement) {
                            openModelPlacementMenu(placement, event.clientX, event.clientY);
                            return;
                        }
                    }
                }
                
                // Check chain column placements
                const chainColumnObjects = [];
                decorativeChainColumns.forEach(column => {
                    if (column.box && column.box.visible) {
                        chainColumnObjects.push(column.box);
                    }
                    if (column.arrows) {
                        column.arrows.forEach(arrow => {
                            if (arrow.visible) {
                                chainColumnObjects.push(arrow.cone);
                            }
                        });
                    }
                });
                
                const chainColumnIntersects = raycaster.intersectObjects(chainColumnObjects, true);
                if (chainColumnIntersects.length > 0) {
                    const obj = chainColumnIntersects[0].object;
                    
                    // Check if it's a chain column arrow
                    let isArrow = false;
                    let arrowData = null;
                    decorativeChainColumns.forEach(column => {
                        if (column.arrows) {
                            column.arrows.forEach(arrow => {
                                if (arrow.cone === obj) {
                                    isArrow = true;
                                    arrowData = { column, arrow };
                                }
                            });
                        }
                    });
                    
                    if (isArrow && arrowData) {
                        // Move chain column in arrow direction
                        moveChainColumn(arrowData.column, arrowData.arrow.userData.axis, arrowData.arrow.userData.sign);
                        if (selectedChainColumn && selectedChainColumn.id === arrowData.column.id) {
                            updateChainColumnMenuFields();
                        }
                        return;
                    }
                    
                    // Check if it's a chain column box
                    if (obj.userData.isChainColumnBox) {
                        const column = decorativeChainColumns.find(c => c.id === obj.userData.chainColumnId);
                        if (column) {
                            openChainColumnMenu(column, event.clientX, event.clientY);
                            return;
                        }
                    }
                }
                
                // Check particle placements
                const placementObjects = [];
                particlePlacements.forEach(placement => {
                    if (placement.box && placement.box.visible) {
                        placementObjects.push(placement.box);
                    }
                    placement.arrows.forEach(arrow => {
                        if (arrow.visible) {
                            placementObjects.push(arrow.cone);
                        }
                    });
                });
                
                const placementIntersects = raycaster.intersectObjects(placementObjects, true);
                if (placementIntersects.length > 0) {
                    const obj = placementIntersects[0].object;
                    
                    // Check if it's an arrow
                    let isArrow = false;
                    let arrowData = null;
                    particlePlacements.forEach(placement => {
                        placement.arrows.forEach(arrow => {
                            if (arrow.cone === obj) {
                                isArrow = true;
                                arrowData = { placement, arrow };
                            }
                        });
                    });
                    
                    if (isArrow && arrowData) {
                        // Move placement in arrow direction
                        movePlacement(arrowData.placement, arrowData.arrow.userData.axis, arrowData.arrow.userData.sign);
                        if (selectedPlacement && selectedPlacement.id === arrowData.placement.id) {
                            updatePlacementMenuPosition();
                        }
                        return;
                    }
                    
                    // Check if it's a box
                    if (obj.userData.isPlacementBox) {
                        const placement = particlePlacements.find(p => p.id === obj.userData.placementId);
                        if (placement) {
                            openPlacementMenu(placement, event.clientX, event.clientY);
                            return;
                        }
                    }
                }
            }
            
            // Check if Zooko was clicked first (works in any state)
            if (zookoClickBox) {
                const zookoIntersects = raycaster.intersectObject(zookoClickBox, false);
                
                if (zookoIntersects.length > 0) {
                    playZookoSpecialAnimation();
                    return; // Don't check for broken links if Zooko was clicked
                }
            }
            
            // Check if CyberAxe was clicked
            if (cyberAxeClickBox) {
                const cyberAxeIntersects = raycaster.intersectObject(cyberAxeClickBox, false);
                
                if (cyberAxeIntersects.length > 0) {
                    playCyberAxeSpecialAnimation();
                    return; // Don't check for broken links if CyberAxe was clicked
                }
            }
            
            // Check if Zancas was clicked
            if (zancasClickBox) {
                const zancasIntersects = raycaster.intersectObject(zancasClickBox, false);
                
                if (zancasIntersects.length > 0) {
                    playZancasSpecialAnimation();
                    return; // Don't check for broken links if Zancas was clicked
                }
            }
            
            // Check if Nate was clicked
            if (nateClickBox) {
                const nateIntersects = raycaster.intersectObject(nateClickBox, false);
                
                if (nateIntersects.length > 0) {
                    playNateSpecialAnimation();
                    return; // Don't check for broken links if Nate was clicked
                }
            }
            
            if (currentState !== GameState.PLAYING) return;
            
            // Build array of only broken link meshes (exclude grid lines)
            const brokenLinkMeshes = [];
            const meshToCoords = new Map();
            const keysToRemove = [];
            
            brokenLinks.forEach(key => {
                const [x, y, z] = key.split(',').map(Number);
                if (grid[x][y][z] && grid[x][y][z].mesh) {
                    brokenLinkMeshes.push(grid[x][y][z].mesh);
                    meshToCoords.set(grid[x][y][z].mesh, [x, y, z]);
                } else {
                    // Clean up stale entries
                    keysToRemove.push(key);
                }
            });
            
            // Remove stale entries from brokenLinks
            keysToRemove.forEach(key => brokenLinks.delete(key));
            
            // Only raycast against broken link meshes
            const intersects = raycaster.intersectObjects(brokenLinkMeshes, true);
            
            if (intersects.length > 0) {
                // Find which broken link was clicked
                let targetMesh = intersects[0].object;
                while (targetMesh.parent && !meshToCoords.has(targetMesh)) {
                    targetMesh = targetMesh.parent;
                }
                
                const coords = meshToCoords.get(targetMesh);
                if (coords) {
                    destroyBrokenLink(coords[0], coords[1], coords[2]);
                }
            }
        }
        function onMouseMove(event) {
            if (currentState !== GameState.PLAYING) {
                document.body.classList.remove('targeting');
                return;
            }
            
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            
            // Build array of only broken link meshes
            const brokenLinkMeshes = [];
            
            brokenLinks.forEach(key => {
                const [x, y, z] = key.split(',').map(Number);
                if (grid[x][y][z] && grid[x][y][z].mesh) {
                    brokenLinkMeshes.push(grid[x][y][z].mesh);
                }
            });
            
            // Check if hovering over any broken link
            const intersects = raycaster.intersectObjects(brokenLinkMeshes, true);
            
            if (intersects.length > 0) {
                document.body.classList.add('targeting');
            } else {
                document.body.classList.remove('targeting');
            }
        }
        
        function destroyBrokenLink(x, y, z) {
            const link = grid[x][y][z];
            if (!link) return;
            
            disposeLinkMesh(link.mesh);
            grid[x][y][z] = null;
            brokenLinks.delete(`${x},${y},${z}`);
            
            applyGravity();
        }
        
        function rotatePiece(key) {
            if (!fallingChain) return;
            
            const rotation = fallingChain.rotation || 0;
            
            switch(key) {
                case 'ArrowLeft':
                    fallingChain.rotation = (rotation - 90) % 360;
                    break;
                case 'ArrowRight':
                    fallingChain.rotation = (rotation + 90) % 360;
                    break;
                case 'ArrowUp':
                case 'ArrowDown':
                    break;
            }
            
            // Apply rotation to meshes, preserving alternating link pattern
            fallingChain.links.forEach((mesh, i) => {
                const baseRotation = (fallingChain.rotation * Math.PI / 180);
                const alternateRotation = (i % 2 === 1) ? (Math.PI / 2) : 0;
                mesh.rotation.y = baseRotation + alternateRotation;
            });
        }
        
        function createLinkMesh(linkType) {
            // Select the appropriate model based on link type name
            let modelToClone;
            let materialKey;
            switch(linkType.name) {
                case 'ZEC-A':
                    modelToClone = chainModelYellow;
                    materialKey = 'yellow';
                    break;
                case 'ZEC-B':
                    modelToClone = chainModelBlue;
                    materialKey = 'blue';
                    break;
                case 'ZEC-C':
                    modelToClone = chainModelGreen;
                    materialKey = 'green';
                    break;
                case 'ZEC-D':
                    modelToClone = chainModelRed;
                    materialKey = 'red';
                    break;
                default:
                    modelToClone = chainModelYellow;
                    materialKey = 'yellow';
            }
            
            // Clone the model geometry only
            const mesh = modelToClone.clone();
            
            // Assign shared material (no cloning)
            const sharedMaterial = highQualityMode ? materialsHQ[materialKey] : materialsLQ[materialKey];
            mesh.traverse((child) => {
                if (child.isMesh && child.material) {
                    // Replace with shared material
                    child.material = sharedMaterial;
                }
            });
            
            // Render order: links render on top of floor cells
            mesh.renderOrder = 100;
            
            return mesh;
        }
        
        // Properly dispose of link mesh to prevent memory leaks
        function disposeLinkMesh(mesh) {
            if (!mesh) return;
            
            scene.remove(mesh);
            
            mesh.traverse((child) => {
                if (child.isMesh) {
                    // Dispose geometry (shared across clones, but Three.js ref-counts it)
                    if (child.geometry) {
                        child.geometry.dispose();
                    }
                    
                    // Dispose material (unique per clone from createLinkMesh)
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(mat => mat.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                }
            });
        }
        
        // Properly dispose of ArrowHelper - must dispose cone and line children
        function disposeArrowHelper(arrow) {
            if (!arrow) return;
            
            scene.remove(arrow);
            
            // ArrowHelper has cone and line children with their own geometries/materials
            if (arrow.cone) {
                if (arrow.cone.geometry) arrow.cone.geometry.dispose();
                if (arrow.cone.material) arrow.cone.material.dispose();
            }
            if (arrow.line) {
                if (arrow.line.geometry) arrow.line.geometry.dispose();
                if (arrow.line.material) arrow.line.material.dispose();
            }
        }
        
        // Advanced particle effect system (JSON-based)
        function loadParticleEffectFromJSON(jsonPath, callback) {
            fetch(jsonPath)
                .then(response => response.text())
                .then(text => {
                    const config = JSON.parse(text);
                    if (callback) callback(config);
                })
                .catch(err => {});
        }
        
        // Helper function to spawn a particle effect
        // Use spawnMode: 'world' for absolute position, 'camera' for relative to camera view (DEFAULT)
        function spawnParticleEffect(jsonPath, x, y, z, options = {}) {
                    if (!particlesEnabled) return; // Don't spawn particles if disabled
                    loadParticleEffectFromJSON(jsonPath, (config) => {
                let finalX = x, finalY = y, finalZ = z;
                
                // Default to camera positioning
                const spawnMode = options.spawnMode || 'camera';
                if (spawnMode === 'camera') {
                    camera.getWorldDirection(_spawnTempCamDir);
                    // x = distance from camera, y = vertical offset, z = horizontal offset
                    _spawnTempSpawnPos.copy(camera.position)
                        .add(_spawnTempCamDir.multiplyScalar(x));
                    finalX = _spawnTempSpawnPos.x + z;
                    finalY = _spawnTempSpawnPos.y + y;
                    finalZ = _spawnTempSpawnPos.z;
                }
                
                const effect = createParticleEffect(config, {
                    position: { x: finalX, y: finalY, z: finalZ },
                    rotation: options.rotation || { x: 0, y: 0, z: 0 },
                    startDelay: options.startDelay || 0,
                    parentBone: options.parentBone,
                    parentModel: options.parentModel,
                    boneOffset: options.boneOffset,
                    colorOverride: options.colorOverride
                });
                playParticleEffect(effect);
            });
        }
        
        function createParticleEffect(config, options = {}) {
            const effect = {
                config: config,
                particles: [],
                emissionTimer: 0,
                particleAccumulator: 0,
                isEmitting: false,
                isPlaying: false,
                position: options.position || { x: 0, y: 0, z: 0 },
                rotation: options.rotation || { x: 0, y: 0, z: 0 },
                startDelay: options.startDelay || 0,
                delayTimer: 0,
                started: false,
                textureReady: false,
                parentBone: options.parentBone || null,
                parentModel: options.parentModel || null,
                colorOverride: options.colorOverride || null,
                boneOffset: options.boneOffset || null
            };
            
            // Load texture if needed
            if (config.atlasPath) {
                if (particleEffectTextures[config.atlasPath]) {
                    effect.textureReady = true;
                } else {
                    const loader = new THREE.TextureLoader();
                    loader.load(config.atlasPath, (texture) => {
                        texture.magFilter = THREE.LinearFilter;
                        texture.minFilter = THREE.LinearMipMapLinearFilter;
                        particleEffectTextures[config.atlasPath] = texture;
                        effect.textureReady = true;
                    });
                }
            } else {
                effect.textureReady = true;
            }
            
            particleEffects.push(effect);
            return effect;
        }
        
        function playParticleEffect(effect) {
            effect.isPlaying = true;
            effect.isEmitting = true;
            effect.emissionTimer = 0;
            effect.particleAccumulator = 0;
            effect.delayTimer = 0;
            effect.started = false;
        }
        
        function stopParticleEffect(effect) {
            effect.isPlaying = false;
            effect.isEmitting = false;
            effect.particles.forEach(particle => {
                if (particle.mesh) {
                    scene.remove(particle.mesh);
                    // Dispose geometry and material
                    if (particle.mesh.geometry) particle.mesh.geometry.dispose();
                    if (particle.mesh.material) {
                        // Only dispose cloned textures, not shared ones
                        if (particle.isTextureCloned && particle.mesh.material.map) {
                            particle.mesh.material.map.dispose();
                        }
                        particle.mesh.material.dispose();
                    }
                }
            });
            effect.particles = [];
        }
        
        function updateParticleEffects(deltaTime) {
            particleEffects.forEach(effect => {
                if (!effect.isPlaying) return;
                
                // Wait for texture to be ready
                if (!effect.textureReady) return;
                
                // Handle start delay
                if (!effect.started) {
                    effect.delayTimer += deltaTime;
                    if (effect.delayTimer >= effect.startDelay) {
                        effect.started = true;
                    } else {
                        return;
                    }
                }
                
                const config = effect.config;
                
                // Emit particles
                if (effect.isEmitting) {
                    effect.emissionTimer += deltaTime;
                    
                    if (effect.emissionTimer <= config.emitDuration) {
                        effect.particleAccumulator += config.emissionRate * deltaTime;
                        
                        while (effect.particleAccumulator >= 1 && effect.particles.length < config.particleCount) {
                            createEffectParticle(effect);
                            effect.particleAccumulator -= 1;
                        }
                    } else {
                        effect.isEmitting = false;
                    }
                }
                
                // Update effect position from parent bone if set
                if (effect.parentBone && effect.parentModel) {
                    effect.parentBone.getWorldPosition(_boneTempWorldPos);
                    
                    // Apply bone rotation to offset
                    if (effect.boneOffset) {
                        _boneTempOffsetVec.set(
                            effect.boneOffset.x,
                            effect.boneOffset.y,
                            effect.boneOffset.z
                        );
                        effect.parentBone.getWorldQuaternion(_boneTempWorldQuat);
                        _boneTempOffsetVec.applyQuaternion(_boneTempWorldQuat);
                        
                        effect.position.x = _boneTempWorldPos.x + _boneTempOffsetVec.x;
                        effect.position.y = _boneTempWorldPos.y + _boneTempOffsetVec.y;
                        effect.position.z = _boneTempWorldPos.z + _boneTempOffsetVec.z;
                    } else {
                        effect.position.x = _boneTempWorldPos.x;
                        effect.position.y = _boneTempWorldPos.y;
                        effect.position.z = _boneTempWorldPos.z;
                    }
                }
                
                // Update particles
                effect.particles.forEach(particle => {
                    particle.life += deltaTime;
                    
                    if (particle.life >= config.lifetime) {
                        if (particle.mesh) {
                            scene.remove(particle.mesh);
                            // Dispose geometry and material
                            if (particle.mesh.geometry) particle.mesh.geometry.dispose();
                            if (particle.mesh.material) {
                                // Only dispose cloned textures, not shared ones
                                if (particle.isTextureCloned && particle.mesh.material.map) {
                                    particle.mesh.material.map.dispose();
                                }
                                particle.mesh.material.dispose();
                            }
                        }
                        particle.dead = true;
                        return;
                    }
                    
                    const lifeProgress = particle.life / config.lifetime;
                    
                    // Update velocity
                    particle.velocity.x += particle.turbulence.x * deltaTime;
                    particle.velocity.y += particle.turbulence.y * deltaTime;
                    particle.velocity.z += particle.turbulence.z * deltaTime;
                    particle.velocity.y += config.gravity * deltaTime;
                    
                    // Update position (offset from effect position)
                    particle.offset.x += particle.velocity.x * deltaTime;
                    particle.offset.y += particle.velocity.y * deltaTime;
                    particle.offset.z += particle.velocity.z * deltaTime;
                    
                    // Set absolute position (effect position + offset)
                    particle.mesh.position.x = effect.position.x + particle.offset.x;
                    particle.mesh.position.y = effect.position.y + particle.offset.y;
                    particle.mesh.position.z = effect.position.z + particle.offset.z;
                    
                    // Update size
                    const size = config.sizeStart + (config.sizeEnd - config.sizeStart) * lifeProgress;
                    if (config.particleType === 'sprite' || config.faceCamera) {
                        particle.mesh.scale.set(size, size, 1);
                    } else {
                        particle.mesh.scale.set(size, size, 1);
                    }
                    
                    // Update color
                    particle.mesh.material.color.copy(particle.startColor).lerp(particle.endColor, lifeProgress);
                    
                    // Update opacity
                    const opacity = config.opacityStart + (config.opacityEnd - config.opacityStart) * lifeProgress;
                    particle.mesh.material.opacity = opacity;
                    
                    // Update rotation
                    if (particle.rotationSpeed !== 0) {
                        particle.rotation += particle.rotationSpeed * deltaTime;
                        if (config.particleType !== 'sprite' && !config.faceCamera) {
                            particle.mesh.rotation.z = particle.rotation;
                        }
                    }
                    
                    // Face camera if needed (for planes)
                    if (config.particleType === 'plane' && config.faceCamera) {
                        particle.mesh.lookAt(camera.position);
                    }
                });
                
                // Remove dead particles
                effect.particles = effect.particles.filter(p => !p.dead);
                
                // Stop effect when no particles left and emission done
                if (!effect.isEmitting && effect.particles.length === 0) {
                    effect.isPlaying = false;
                }
            });
            
            // Remove finished effects
            particleEffects = particleEffects.filter(e => e.isPlaying || e.particles.length > 0);
        }
        
        function createEffectParticle(effect) {
            const config = effect.config;
            
            // Get texture
            let texture = particleEffectTextures[config.atlasPath];
            if (!texture) {
                return;
            }
            
            // Only clone texture if UV manipulation is needed, otherwise share the base texture
            let textureToUse;
            let isTextureCloned = false;
            if (config.uvStartX !== undefined) {
                // Clone for UV manipulation
                textureToUse = texture.clone();
                textureToUse.needsUpdate = true;
                textureToUse.offset.set(config.uvStartX, config.uvStartY);
                textureToUse.repeat.set(
                    config.uvEndX - config.uvStartX,
                    config.uvEndY - config.uvStartY
                );
                isTextureCloned = true;
            } else {
                // Share base texture (no cloning needed)
                textureToUse = texture;
                isTextureCloned = false;
            }
            
            // Create material
            let material;
            const blendMode = config.blendMode || 'normal';
            const blending = blendMode === 'additive' ? THREE.AdditiveBlending : THREE.NormalBlending;
            
            // Parse colors - use color override if provided, otherwise use config colors
            const colorStart = new THREE.Color(effect.colorOverride?.colorStart || config.colorStart);
            const colorEnd = new THREE.Color(effect.colorOverride?.colorEnd || config.colorEnd);
            
            // Create mesh based on type
            let mesh;
            const particleType = config.particleType || 'sprite';
            const faceCamera = config.faceCamera !== undefined ? config.faceCamera : true;
            const doubleSided = config.doubleSided !== undefined ? config.doubleSided : true;
            
            if (particleType === 'sprite' || faceCamera) {
                material = new THREE.SpriteMaterial({
                    map: textureToUse,
                    color: colorStart,
                    transparent: true,
                    opacity: config.opacityStart,
                    blending: blending,
                    depthTest: true,
                    depthWrite: false,
                    fog: false
                });
                mesh = new THREE.Sprite(material);
                mesh.scale.set(config.sizeStart, config.sizeStart, 1);
            } else {
                const geometry = new THREE.PlaneGeometry(1, 1);
                material = new THREE.MeshBasicMaterial({
                    map: textureToUse,
                    color: colorStart,
                    transparent: true,
                    opacity: config.opacityStart,
                    blending: blending,
                    side: doubleSided ? THREE.DoubleSide : THREE.FrontSide,
                    depthTest: true,
                    depthWrite: false,
                    fog: false
                });
                mesh = new THREE.Mesh(geometry, material);
                mesh.scale.set(config.sizeStart, config.sizeStart, 1);
            }
            
            // Set initial position based on emission shape (matching editor)
            const emissionShape = config.emissionShape || 'point';
            let offsetX = 0, offsetY = 0, offsetZ = 0;
            
            switch(emissionShape) {
                case 'point':
                    // Default: offsetX/Y/Z = 0
                    break;
                case 'sphere':
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const radius = Math.random();
                    offsetX = radius * Math.sin(phi) * Math.cos(theta);
                    offsetY = radius * Math.sin(phi) * Math.sin(theta);
                    offsetZ = radius * Math.cos(phi);
                    break;
                case 'box':
                    offsetX = (Math.random() - 0.5) * 4;
                    offsetY = 2;
                    offsetZ = (Math.random() - 0.5) * 4;
                    break;
                case 'cone':
                    const angle = Math.random() * Math.PI * 2;
                    const coneRadius = Math.random() * 0.5;
                    offsetX = coneRadius * Math.cos(angle);
                    offsetY = 0;
                    offsetZ = coneRadius * Math.sin(angle);
                    break;
                case 'ring':
                    const ringAngle = Math.random() * Math.PI * 2;
                    const ringRadius = 1 + Math.random() * 0.3;
                    offsetX = ringRadius * Math.cos(ringAngle);
                    offsetY = 0;
                    offsetZ = ringRadius * Math.sin(ringAngle);
                    break;
            }
            
            mesh.position.set(
                effect.position.x + offsetX,
                effect.position.y + offsetY,
                effect.position.z + offsetZ
            );
            
            // Apply effect rotation
            mesh.rotation.x = effect.rotation.x;
            mesh.rotation.y = effect.rotation.y;
            mesh.rotation.z = effect.rotation.z;
            
            // Calculate velocity (matching particle editor)
            const spreadRad = (config.spread * Math.PI) / 180;
            const theta = (Math.random() - 0.5) * spreadRad; // Horizontal spread
            const phi = (Math.random() - 0.5) * spreadRad; // Vertical spread

            // Base direction (normalized) with velocity magnitude
            const baseVelX = config.velocityDirX || 0;
            const baseVelY = config.velocityDirY || 0;
            const baseVelZ = config.velocityDirZ || 0;
            
            // Add spread randomness
            const velX = baseVelX + Math.sin(theta) * config.velocity;
            const velY = baseVelY + Math.sin(phi) * config.velocity;
            const velZ = baseVelZ + Math.cos(theta) * config.velocity;
            
            const velocity = { x: velX, y: velY, z: velZ };
            
            // Add turbulence
            const turbulence = {
                x: (Math.random() - 0.5) * config.turbulence,
                y: (Math.random() - 0.5) * config.turbulence,
                z: (Math.random() - 0.5) * config.turbulence
            };
            
            // Calculate initial rotation
            const spawnRotationRad = ((config.spawnRotation || 0) * Math.PI) / 180;
            const initialRotation = config.randomRotation ? Math.random() * Math.PI * 2 : spawnRotationRad;
            const rotSpeed = config.randomRotationSpeed ? config.rotationSpeed * (Math.random() - 0.5) : config.rotationSpeed;
            
            // Apply initial rotation to mesh
            if (!faceCamera) {
                mesh.rotation.z = initialRotation;
            }
            
            scene.add(mesh);
            
            effect.particles.push({
                mesh: mesh,
                velocity: velocity,
                turbulence: turbulence,
                offset: { x: offsetX, y: offsetY, z: offsetZ },
                life: 0,
                dead: false,
                startColor: colorStart.clone(),
                endColor: colorEnd.clone(),
                rotation: initialRotation,
                rotationSpeed: rotSpeed || config.rotationSpeed || 0,
                isTextureCloned: isTextureCloned
            });
        }
        
        function flipChain() {
            if (!fallingChain || fallingChain.length < 2) return; // Need at least 2 links to flip
            
            // Swap the linkTypes array - reverse first and last element
            const temp = fallingChain.linkTypes[0];
            fallingChain.linkTypes[0] = fallingChain.linkTypes[fallingChain.length - 1];
            fallingChain.linkTypes[fallingChain.length - 1] = temp;
            
            // If encrypted chain, also swap actualLinkTypes
            if (fallingChain.isEncrypted && fallingChain.actualLinkTypes.length > 0) {
                const tempActual = fallingChain.actualLinkTypes[0];
                fallingChain.actualLinkTypes[0] = fallingChain.actualLinkTypes[fallingChain.length - 1];
                fallingChain.actualLinkTypes[fallingChain.length - 1] = tempActual;
            }
            
            // Swap the visual meshes (top and bottom)
            const topMesh = fallingChain.links[0];
            const bottomMesh = fallingChain.links[fallingChain.length - 1];
            
            // Swap in array
            fallingChain.links[0] = bottomMesh;
            fallingChain.links[fallingChain.length - 1] = topMesh;
            
            // Note: Models are already pre-colored, no material changes needed
            
            // Update positions to match new order
            for (let i = 0; i < fallingChain.links.length; i++) {
                fallingChain.links[i].position.y = fallingChain.y - i + 0.5;
            }
        }
        
        function generateChainData() {
            // Determine chain length - check if any special chain type has custom length
            let chainLength = Math.floor(Math.random() * 3) + 2; // Default 2-4 links
            const baseTypes = [LinkType.ZEC_A, LinkType.ZEC_B, LinkType.ZEC_C, LinkType.ZEC_D];
            
            // Check each special chain type from highest level to lowest
            let specialChainConfig = null;
            for (let i = CHAIN_TYPE_CONFIGS.length - 1; i >= 0; i--) {
                const config = CHAIN_TYPE_CONFIGS[i];
                if (level >= config.level && Math.random() < config.spawnRate) {
                    specialChainConfig = config;
                    if (config.lengthRange) {
                        const [min, max] = config.lengthRange;
                        chainLength = Math.floor(Math.random() * (max - min + 1)) + min;
                    }
                    break;
                }
            }
            
            const randomType = baseTypes[Math.floor(Math.random() * baseTypes.length)];
            
            const chainData = {
                length: chainLength,
                baseType: randomType,
                linkTypes: [],
                isEncrypted: false,
                isGlowing: false,
                actualLinkTypes: []
            };
            
            // Apply special chain logic if applicable
            if (specialChainConfig) {
                const tempChain = { linkTypes: [], isEncrypted: false, isGlowing: false, actualLinkTypes: [] };
                specialChainConfig.customLogic(tempChain, chainLength, baseTypes);
                chainData.linkTypes = tempChain.linkTypes;
                chainData.isEncrypted = tempChain.isEncrypted;
                chainData.isGlowing = tempChain.isGlowing;
                chainData.actualLinkTypes = tempChain.actualLinkTypes;
            } else {
                // Normal chain - all same type
                for (let i = 0; i < chainLength; i++) {
                    chainData.linkTypes.push(randomType);
                }
            }
            
            return chainData;
        }
        
        function initializeChainQueue() {
            chainQueue = [];
            for (let i = 0; i < 3; i++) {
                chainQueue.push(generateChainData());
            }
            updateChainPreview();
        }
        
        function updateChainPreview() {
            for (let i = 0; i < 3; i++) {
                const previewElement = document.getElementById(`preview${i + 1}`);
                if (!previewElement || !chainQueue[i]) continue;
                
                previewElement.innerHTML = '';
                const chainData = chainQueue[i];
                
                // Display chain from top to bottom
                for (let j = 0; j < chainData.linkTypes.length; j++) {
                    const link = document.createElement('div');
                    link.className = 'chainPreviewLink';
                    
                    const linkType = chainData.linkTypes[j];
                    if (chainData.isEncrypted) {
                        // Show as gray for encrypted
                        link.style.background = '#444444';
                    } else if (chainData.isGlowing) {
                        // Show as white for glowing
                        link.style.background = '#FFFFFF';
                        link.style.boxShadow = '0 0 10px rgba(255, 255, 255, 0.8)';
                    } else {
                        // Show actual color from preview mapping
                        link.style.background = PREVIEW_COLORS[linkType.name] || '#FFFFFF';
                    }
                    
                    previewElement.appendChild(link);
                }
            }
        }
        
        function spawnNewChain() {
            // Get next chain from queue
            const chainData = chainQueue.shift();
            chainQueue.push(generateChainData());
            updateChainPreview();
            
            const chainLength = chainData.length;
            
            // Randomize spawn position across the grid
            const spawnX = Math.floor(Math.random() * GRID_WIDTH);
            const spawnZ = Math.floor(Math.random() * GRID_DEPTH);
            
            // Spawn in the extended area - bottom link at y=20 (safely inside extended grid)
            // With grid now at height 25, spawning at 20 gives 5 blocks of clearance above
            // Top link position = 20 + (chainLength - 1)
            const bottomLinkY = 20;  // Fixed spawn height for bottom link
            const topLinkY = bottomLinkY + (chainLength - 1);
            
            fallingChain = {
                links: [],
                type: chainData.baseType,
                linkTypes: chainData.linkTypes,
                isEncrypted: chainData.isEncrypted,
                isGlowing: chainData.isGlowing,
                actualLinkTypes: chainData.actualLinkTypes,
                x: spawnX,
                y: topLinkY,  // Position so bottom link starts at y=20
                z: spawnZ,
                rotation: 0,
                length: chainLength
            };
            
            // Check if spawn position is blocked (game over)
            // Only check positions within the actual grid
            for (let i = 0; i < chainLength; i++) {
                const y = fallingChain.y - i;
                if (y >= 0 && y < GRID_HEIGHT) {
                    if (grid[fallingChain.x][y][fallingChain.z] !== null) {
                        gameOver();
                        return;
                    }
                }
            }
            
            // Create visual meshes
            for (let i = 0; i < chainLength; i++) {
                // Get the link type from the linkTypes array (already set by customLogic or normal logic)
                const linkType = fallingChain.linkTypes[i] || fallingChain.type;
                
                const mesh = createLinkMesh(linkType);
                mesh.position.set(
                    fallingChain.x + 0.5,
                    fallingChain.y - i + 0.5,
                    fallingChain.z + 0.5
                );
                
                // No material modifications - models are already colored
                
                // Alternate 90Â° rotation on Y-axis for interlocking chain links
                if (i % 2 === 1) {
                    mesh.rotation.y = Math.PI / 2; // 90 degrees for odd-numbered links
                }
                
                scene.add(mesh);
                fallingChain.links.push(mesh);
            }
            
            chainVelocity = 0;
            hasLogged = false;  // Reset logging flag for new chain
            
            // Chain is ready to glow
            chainReadyToGlow = true;
        }
        
        function gameOver() {
            currentState = GameState.GAMEOVER;
            saveHighScore(score, level);
            checkAchievements();
            
            const playTime = (Date.now() - stats.startTime) / 1000;
            if (playTime >= 300) unlockAchievement('play_5min');
            
            trackedSetTimeout(() => {
                if (settings.autoRestart) {
                    // Auto restart if setting is enabled
                    startGame();
                } else {
                    // Show confirmation dialog
                    if (confirm(`GAME OVER!\n\nScore: ${score.toLocaleString()}\nLevel: ${level}\n\nPlay again?`)) {
                        startGame();
                    } else {
                        document.getElementById('titleScreen').style.display = 'flex';
                        currentState = GameState.MENU;
                    }
                }
            }, 500);
        }
        
        function updateFallingChain(deltaTime) {
            if (!fallingChain) return;
            
            // Freeze chain during CyberAxe special
            if (cyberAxeSpecialActive) {
                return; // Don't update position while special is active
            }
            
            // Calculate level-based drop speed scaling - NO CAP!
            // Level 1: 0.15Ã— (very slow, beginner friendly)
            // Level 10: 0.186Ã—
            // Level 50: 0.346Ã—
            // Level 100: 0.546Ã—
            // Level 250: 1.146Ã—
            // Level 1000: 4.146Ã—
            // Level 10000: 40.146Ã—
            // Level 100000: 400.146Ã— (impossibly fast!)
            // Will eventually become unplayable - this is intentional!
            const baseSpeed = 0.15; // Much slower starting speed
            const levelScaling = baseSpeed + (level - 1) * 0.004; // No cap - scales forever!
            
            // Apply gravity with different speeds
            let gravityMultiplier;
            if (instantDrop && !cyberAxeSpecialActive) {
                gravityMultiplier = 20; // Super fast drop (AI or player double-tap space)
            } else if (fastDrop) {
                gravityMultiplier = levelScaling * 2.5; // Fast drop scales with level (2.5x normal)
            } else {
                gravityMultiplier = levelScaling; // Normal speed scales with level
            }
            
            chainVelocity += gravity * gravityMultiplier * deltaTime;
            
            const movement = chainVelocity * deltaTime;
            const newY = fallingChain.y - movement;
            
            // Check collisions for all links
            let canFall = true;
            let stopAtY = newY;
            let collisionReason = "none";
            
            for (let i = 0; i < fallingChain.length; i++) {
                const linkY = newY - i;
                const gridY = Math.floor(linkY);
                
                // Check ground collision - if this link would be at or below grid floor
                if (gridY < 0 || linkY < 0.5) {
                    canFall = false;
                    stopAtY = fallingChain.length - 0.5;
                    collisionReason = `ground (link ${i} at gridY ${gridY})`;
                    break;
                }
                
                // Check block collision (only if within grid bounds)
                if (gridY >= 0 && gridY < GRID_HEIGHT) {
                    if (fallingChain.x >= 0 && fallingChain.x < GRID_WIDTH &&
                        fallingChain.z >= 0 && fallingChain.z < GRID_DEPTH) {
                        
                        if (grid[fallingChain.x][gridY][fallingChain.z] !== null) {
                            canFall = false;
                            stopAtY = gridY + 1 + i;
                            collisionReason = `block at [${fallingChain.x},${gridY},${fallingChain.z}] (link ${i})`;
                            break;
                        }
                    }
                }
            }
            
            if (canFall) {
                // Continue falling
                fallingChain.y = newY;
                hasLogged = false;  // Reset logging when falling
                
                // Spawn drop effect particle every 1/4 second while falling
                const now = Date.now();
                if (now - lastDropEffectTime >= 250) {
                    lastDropEffectTime = now;
                    
                    // Determine drop effect color based on chain type
                    let dropEffectFile = 'effect/drop_effect_a.json'; // Default
                    if (fallingChain.linkTypes && fallingChain.linkTypes.length > 0) {
                        // Use the type of the first link for multi-type chains
                        const firstLinkType = fallingChain.linkTypes[0];
                        if (firstLinkType.name === 'ZEC-A') {
                            dropEffectFile = 'effect/drop_effect_yellow.json';
                        } else if (firstLinkType.name === 'ZEC-B') {
                            dropEffectFile = 'effect/drop_effect_blue.json';
                        } else if (firstLinkType.name === 'ZEC-C') {
                            dropEffectFile = 'effect/drop_effect_green.json';
                        } else if (firstLinkType.name === 'ZEC-D') {
                            dropEffectFile = 'effect/drop_effect_red.json';
                        }
                    } else if (fallingChain.type) {
                        // Single-type chain
                        if (fallingChain.type.name === 'ZEC-A') {
                            dropEffectFile = 'effect/drop_effect_yellow.json';
                        } else if (fallingChain.type.name === 'ZEC-B') {
                            dropEffectFile = 'effect/drop_effect_blue.json';
                        } else if (fallingChain.type.name === 'ZEC-C') {
                            dropEffectFile = 'effect/drop_effect_green.json';
                        } else if (fallingChain.type.name === 'ZEC-D') {
                            dropEffectFile = 'effect/drop_effect_red.json';
                        }
                    }
                    
                    // Spawn at bottom of chain
                    spawnParticleEffect(dropEffectFile, 
                        fallingChain.x + 0.5, 
                        fallingChain.y - 0.5, 
                        fallingChain.z + 0.5, 
                        {
                            spawnMode: 'world',
                            rotation: { x: 0, y: 0, z: 0 },
                            startDelay: 0
                        }
                    );
                }
            } else {
                // Hit something - lock immediately
                chainReadyToGlow = false;
                fallingChain.y = stopAtY;
                chainVelocity = 0;
                
                lockChain();
                return;  // Exit early - chain is now null
            }
            
            // Update visual positions
            for (let i = 0; i < fallingChain.links.length; i++) {
                fallingChain.links[i].position.y = fallingChain.y - i + 0.5;
            }
        }
        
        function checkCollision() {
            const bottomY = Math.floor(fallingChain.y - fallingChain.length + 1);
            if (bottomY < 0) return true;
            
            for (let i = 0; i < fallingChain.length; i++) {
                const y = Math.floor(fallingChain.y - i);
                if (y >= 0 && y < GRID_HEIGHT) {
                    if (grid[fallingChain.x][y][fallingChain.z] !== null) {
                        return true;
                    }
                }
            }
            return false;
        }
        
        function decryptLink(mesh, linkType, x, y, z, delay) {
            // Create decryption particles effect
            trackedSetTimeout(() => {
                // Spawn decryption particles
                const particleCount = 20;
                const particles = [];
                
                for (let i = 0; i < particleCount; i++) {
                    const geometry = new THREE.BoxGeometry(0.08, 0.08, 0.08);
                    const material = new THREE.MeshPhongMaterial({
                        color: 0xFFFFFF, // Simple white particles
                        transparent: true,
                        opacity: 1.0
                    });
                    
                    const particle = new THREE.Mesh(geometry, material);
                    particle.position.set(x, y, z);
                    
                    // Spiral outward pattern
                    const angle = (i / particleCount) * Math.PI * 2;
                    const radius = 0.02;
                    const speed = 0.03 + Math.random() * 0.02;
                    
                    particle.userData = {
                        velocity: {
                            x: Math.cos(angle) * speed,
                            y: 0.02 + Math.random() * 0.03,
                            z: Math.sin(angle) * speed
                        },
                        lifetime: 0,
                        maxLifetime: 0.8,
                        rotationSpeed: (Math.random() - 0.5) * 0.3
                    };
                    
                    scene.add(particle);
                    particles.push(particle);
                }
                
                // Animate particles
                const animateDecryptParticles = () => {
                    let allDead = true;
                    
                    particles.forEach(particle => {
                        particle.userData.lifetime += 0.016;
                        
                        if (particle.userData.lifetime < particle.userData.maxLifetime) {
                            allDead = false;
                            
                            // Update position
                            particle.position.x += particle.userData.velocity.x;
                            particle.position.y += particle.userData.velocity.y;
                            particle.position.z += particle.userData.velocity.z;
                            
                            // Rotate
                            particle.rotation.x += particle.userData.rotationSpeed;
                            particle.rotation.y += particle.userData.rotationSpeed;
                            
                            // Fade out
                            const progress = particle.userData.lifetime / particle.userData.maxLifetime;
                            particle.material.opacity = 1.0 - progress;
                            
                            // Slow down
                            particle.userData.velocity.x *= 0.98;
                            particle.userData.velocity.z *= 0.98;
                            particle.userData.velocity.y -= 0.002;
                        } else {
                            scene.remove(particle);
                            // Dispose geometry and material to prevent memory leak
                            if (particle.geometry) particle.geometry.dispose();
                            if (particle.material) particle.material.dispose();
                        }
                    });
                    
                    if (!allDead) {
                        const frameId = requestAnimationFrame(animateDecryptParticles);
                        activeAnimationFrames.push(frameId);
                    }
                };
                
                animateDecryptParticles();
                
                // No color animation during decryption - models are already colored
                // Just wait for particles to finish
            }, delay);
        }
        
        function lockChain() {
            // Safety check - ensure fallingChain exists and has valid links
            if (!fallingChain || !fallingChain.links || fallingChain.links.length === 0) {
                fallingChain = null;
                return;
            }
            
            // Determine what we hit - floor or another chain
            const bottomLinkY = Math.floor(fallingChain.y - fallingChain.length + 1);
            let hitFloor = false;
            let hitChain = false;
            
            if (bottomLinkY === 0) {
                hitFloor = true;
            } else {
                // Check if we collided with another chain
                for (let i = 0; i < fallingChain.length; i++) {
                    const y = Math.floor(fallingChain.y - i);
                    if (y > 0 && y < GRID_HEIGHT) {
                        if (grid[fallingChain.x][y - 1][fallingChain.z] !== null) {
                            hitChain = true;
                            break;
                        }
                    }
                }
            }
            
            // Play appropriate sound
            if (hitFloor) {
                // Sound removed
            } else if (hitChain) {
                // Sound removed
            }
            
            // Lock each link to grid
            for (let i = 0; i < fallingChain.length; i++) {
                const linkY = fallingChain.y - i;
                const gridY = Math.floor(linkY);
                
                if (gridY >= 0 && gridY < GRID_HEIGHT) {
                    // Link is within grid bounds - place it
                    if (grid[fallingChain.x][gridY][fallingChain.z] === null) {
                        // Safety check - ensure link exists and has rotation
                        if (fallingChain.links[i] && fallingChain.links[i].rotation) {
                            const linkRotation = fallingChain.links[i].rotation.y;
                            
                            // Decode encrypted links when they land
                            let linkType;
                            if (fallingChain.isEncrypted && fallingChain.actualLinkTypes[i]) {
                                // Reveal the actual type with animation
                                linkType = fallingChain.actualLinkTypes[i];
                                const mesh = fallingChain.links[i];
                                const x = fallingChain.x + 0.5;
                                const y = gridY + 0.5;
                                const z = fallingChain.z + 0.5;
                                // Stagger the decryption - each link decrypts 200ms after the previous
                                const delay = i * 200;
                                decryptLink(mesh, linkType, x, y, z, delay);
                            } else {
                                // Use individual link type for multi-chains or normal type
                                linkType = fallingChain.linkTypes && fallingChain.linkTypes[i] 
                                    ? fallingChain.linkTypes[i] 
                                    : fallingChain.type;
                            }
                            
                            // Add special charge for this link (1 point per link)
                            addSpecialCharge(linkType, 1);
                            
                            grid[fallingChain.x][gridY][fallingChain.z] = {
                                type: linkType,
                                mesh: fallingChain.links[i],
                                rotation: linkRotation
                            };
                            // Snap mesh to exact grid position
                            fallingChain.links[i].position.y = gridY + 0.5;
                            
                            // If this is a glowing chain, mark the link as broken (clickable)
                            if (fallingChain.isGlowing) {
                                const posKey = `${fallingChain.x},${gridY},${fallingChain.z}`;
                                brokenLinks.add(posKey);
                                // The visual glow is already applied, just ensure it stays glowing
                            }
                        }
                    } else {
                        // Position occupied, remove this link (shouldn't happen but safety check)
                        if (fallingChain.links[i]) {
                            disposeLinkMesh(fallingChain.links[i]);
                        }
                    }
                } else if (gridY >= GRID_HEIGHT) {
                    // Link is above grid - this means game over condition
                    // Chain locked while still partially outside playfield
                    if (fallingChain.links[i]) {
                        disposeLinkMesh(fallingChain.links[i]);
                    }
                    gameOver();
                    return;
                } else {
                    // Link is below grid (shouldn't happen with proper collision)
                    if (fallingChain.links[i]) {
                        disposeLinkMesh(fallingChain.links[i]);
                    }
                }
            }
            
            // Chain is now fully locked in grid
            fallingChain = null;
            stats.chainsPlaced++;
            
            // Reset floor clear bonus flag if any block was placed on the floor
            for (let x = 0; x < GRID_WIDTH; x++) {
                for (let z = 0; z < GRID_DEPTH; z++) {
                    if (grid[x][0][z] !== null) {
                        floorClearBonusAwarded = false;
                        break;
                    }
                }
                if (!floorClearBonusAwarded) break;
            }
            
            // Check for consensus
            checkConsensus();
            
            // Schedule spawn of new chain (with delay to prevent immediate re-spawn)
            spawnScheduled = true;
            trackedSetTimeout(() => {
                spawnScheduled = false;
                if (currentState === GameState.PLAYING) {
                    spawnNewChain();
                }
            }, 500);
        }
        
        function checkConsensus() {
            const threshold = Math.max(6, level < 11 ? 4 : level < 41 ? 5 : 6);
            const visited = new Set();
            let clustersToRemove = [];
            
            // Scan grid for clusters
            for (let x = 0; x < GRID_WIDTH; x++) {
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    for (let z = 0; z < GRID_DEPTH; z++) {
                        const key = `${x},${y},${z}`;
                        if (!visited.has(key) && grid[x][y][z] !== null) {
                            const cluster = findCluster(x, y, z, grid[x][y][z].type, visited);
                            if (cluster.length >= threshold) {
                                clustersToRemove.push(cluster);
                            }
                        }
                    }
                }
            }
            
            if (clustersToRemove.length > 0) {
                // Wait 1 second before clearing, then wait for staggered removal to complete
                trackedSetTimeout(() => {
                    const maxDelay = Math.max(...clustersToRemove.map(c => c.length)) * 50;
                    clustersToRemove.forEach(cluster => clearCluster(cluster));
                    updateCombo();
                    // Wait for all blocks to be removed before applying gravity
                    trackedSetTimeout(() => {
                        applyGravity();
                        // Check for floor clear bonus after gravity settles
                        trackedSetTimeout(() => {
                            checkFloorClear();
                        }, 300);
                    }, maxDelay + 100);
                }, 1000);
            } else {
                resetCombo();
            }
        }
        
        function checkFloorClear() {
            // Skip if bonus already awarded or game not in playing state
            if (floorClearBonusAwarded || currentState !== GameState.PLAYING) return;
            
            // Check if floor (y=0) is completely empty
            let floorIsEmpty = true;
            for (let x = 0; x < GRID_WIDTH; x++) {
                for (let z = 0; z < GRID_DEPTH; z++) {
                    if (grid[x][0][z] !== null) {
                        floorIsEmpty = false;
                        break;
                    }
                }
                if (!floorIsEmpty) break;
            }
            
            // Award bonus if floor is clear
            if (floorIsEmpty) {
                floorClearBonusAwarded = true;
                score += 10000;
                updateHUD();
                // Bonus for clearing floor removed (was music-related)
                
                // Show bonus message
                const bonusMsg = document.getElementById('bonusMessage');
                const bonusText = document.getElementById('bonusText');
                const bonusScore = document.getElementById('bonusScore');
                
                bonusText.textContent = 'ðŸ”¥ FLOOR CLEAR! ðŸ”¥';
                bonusScore.textContent = '+10,000';
                bonusMsg.style.display = 'block';
                
                // Hide after 3 seconds
                trackedSetTimeout(() => {
                    bonusMsg.style.display = 'none';
                }, 3000);
                
                unlockAchievement('floor_clear');
            }
        }
        
        function findCluster(x, y, z, type, visited) {
            const cluster = [];
            const queue = [[x, y, z]];
            const key = (x, y, z) => `${x},${y},${z}`;
            
            // First pass: identify all positions in this cluster
            const tempVisited = new Set();
            const tempQueue = [[x, y, z]];
            const allPositions = [];
            
            while (tempQueue.length > 0) {
                const [cx, cy, cz] = tempQueue.shift();
                const k = key(cx, cy, cz);
                
                if (tempVisited.has(k)) continue;
                if (cx < 0 || cx >= GRID_WIDTH) continue;
                if (cy < 0 || cy >= GRID_HEIGHT) continue;
                if (cz < 0 || cz >= GRID_DEPTH) continue;
                if (grid[cx][cy][cz] === null) continue;
                if (grid[cx][cy][cz].type.name !== type.name) continue;
                
                tempVisited.add(k);
                allPositions.push([cx, cy, cz]);
                
                const neighbors = [
                    [cx+1, cy, cz], [cx-1, cy, cz],
                    [cx, cy+1, cz], [cx, cy-1, cz],
                    [cx, cy, cz+1], [cx, cy, cz-1]
                ];
                
                neighbors.forEach(([nx, ny, nz]) => {
                    if (nx >= 0 && nx < GRID_WIDTH && ny >= 0 && ny < GRID_HEIGHT && nz >= 0 && nz < GRID_DEPTH) {
                        if (grid[nx][ny][nz] !== null && grid[nx][ny][nz].type.name === type.name) {
                            tempQueue.push([nx, ny, nz]);
                        }
                    }
                });
            }
            
            // Check if ANY link in this cluster touches the floor
            const clusterTouchesFloor = allPositions.some(([px, py, pz]) => py === 0);
            
            // If any broken links in this cluster touch the floor, destroy them automatically
            if (clusterTouchesFloor) {
                allPositions.forEach(([px, py, pz]) => {
                    const posKey = key(px, py, pz);
                    if (brokenLinks.has(posKey) && py === 0) {
                        // Destroy this broken link since it reached the floor
                        const link = grid[px][py][pz];
                        if (link) {
                            disposeLinkMesh(link.mesh);
                            grid[px][py][pz] = null;
                            brokenLinks.delete(posKey);
                        }
                    }
                });
            }
            
            // Second pass: build cluster with rotation validation
            while (queue.length > 0) {
                const [cx, cy, cz] = queue.shift();
                const k = key(cx, cy, cz);
                
                if (visited.has(k)) continue;
                if (cx < 0 || cx >= GRID_WIDTH) continue;
                if (cy < 0 || cy >= GRID_HEIGHT) continue;
                if (cz < 0 || cz >= GRID_DEPTH) continue;
                if (grid[cx][cy][cz] === null) continue;
                if (grid[cx][cy][cz].type.name !== type.name) continue;
                
                visited.add(k);
                cluster.push([cx, cy, cz]);
                
                const neighbors = [
                    [cx+1, cy, cz], [cx-1, cy, cz],
                    [cx, cy+1, cz], [cx, cy-1, cz],
                    [cx, cy, cz+1], [cx, cy, cz-1]
                ];
                
                neighbors.forEach(([nx, ny, nz]) => {
                    if (nx >= 0 && nx < GRID_WIDTH && ny >= 0 && ny < GRID_HEIGHT && nz >= 0 && nz < GRID_DEPTH) {
                        if (grid[nx][ny][nz] !== null && grid[nx][ny][nz].type.name === type.name) {
                            const isVerticalNeighbor = (nx === cx && nz === cz);
                            
                            // Skip rotation check if this cluster touches the floor
                            if (isVerticalNeighbor && !clusterTouchesFloor && !checkRotationAlignment(cx, cy, cz, nx, ny, nz)) {
                                const currentKey = key(cx, cy, cz);
                                const neighborKey = key(nx, ny, nz);
                                brokenLinks.add(currentKey);
                                brokenLinks.add(neighborKey);
                                markLinkAsBroken(cx, cy, cz);
                                markLinkAsBroken(nx, ny, nz);
                            } else {
                                queue.push([nx, ny, nz]);
                            }
                        }
                    }
                });
            }
            
            return cluster;
        }
        
        function checkRotationAlignment(x1, y1, z1, x2, y2, z2) {
            const link1 = grid[x1][y1][z1];
            const link2 = grid[x2][y2][z2];
            if (!link1 || !link2 || link1.rotation === undefined || link2.rotation === undefined) return true;
            
            // Only validate vertical connections (up/down in same column)
            if (x1 !== x2 || z1 !== z2) {
                return true; // Horizontal connections are always valid
            }
            
            // Don't validate if either link doesn't exist (shouldn't happen, but safety check)
            if (!link1.mesh || !link2.mesh) {
                return true;
            }
            
            const rot1 = Math.round((link1.rotation / (Math.PI / 2)) % 4);
            const rot2 = Math.round((link2.rotation / (Math.PI / 2)) % 4);
            
            return (rot1 + rot2) % 2 === 1;
        }
        
        function markLinkAsBroken(x, y, z) {
            const link = grid[x][y][z];
            if (!link || !link.mesh) {
                // If link doesn't exist, remove from broken links set
                brokenLinks.delete(`${x},${y},${z}`);
                return;
            }
            
            // Note: No visual change - model keeps original color
            
            // Show guide on first broken link (only if started at level 1)
            if (!glowingLinksGuideShown && startLevel === 1) {
                showGlowingLinksGuide();
            }
        }
        
        function updateSandblastingLinks(deltaTime) {
            if (!window.sandblastingLinks || window.sandblastingLinks.length === 0) return;
            
            const gravity = 9.81;
            const baseSpeed = 0.15;
            const levelScaling = baseSpeed + (level - 1) * 0.004;
            
            for (let i = window.sandblastingLinks.length - 1; i >= 0; i--) {
                const link = window.sandblastingLinks[i];
                
                // Apply gravity
                link.velocity += gravity * levelScaling * deltaTime;
                const newY = link.y - (link.velocity * deltaTime);
                
                // Check collision with floor or blocks
                const bottomY = Math.floor(newY);
                
                if (bottomY <= 0 || (bottomY > 0 && grid[link.x][bottomY - 1][link.z] !== null)) {
                    // Lock in place
                    const finalY = bottomY <= 0 ? 0 : bottomY;
                    
                    // Check if grid position is already occupied
                    if (finalY >= 0 && finalY < GRID_HEIGHT && grid[link.x][finalY][link.z] === null) {
                        // Place in grid only if position is empty
                        grid[link.x][finalY][link.z] = {
                            type: link.type,
                            mesh: link.mesh,
                            rotation: link.rotation
                        };
                        
                        // Update mesh position to grid position
                        link.mesh.position.set(link.x + 0.5, finalY + 0.5, link.z + 0.5);
                    } else {
                        // Position occupied or out of bounds - remove link
                        disposeLinkMesh(link.mesh);
                    }
                    
                    // Remove from tracking array
                    window.sandblastingLinks.splice(i, 1);
                    
                    // Check for matches after placement
                    trackedSetTimeout(() => {
                        checkConsensus();
                    }, 100);
                } else {
                    // Update position
                    link.y = newY;
                    link.mesh.position.y = newY + 0.5;
                }
            }
        }
        
        function clearCluster(cluster) {
            // Track cluster size for achievements
            if (cluster.length >= 5) unlockAchievement('clear_size_5');
            if (cluster.length >= 8) unlockAchievement('clear_size_8');
            if (cluster.length >= 12) unlockAchievement('clear_size_12');
            if (cluster.length >= 20) unlockAchievement('clear_size_20');
            if (cluster.length >= 30) unlockAchievement('clear_size_30');
            
            // Track consensus cleared
            consensusCleared += cluster.length;
            
            // Calculate score
            const cellScore = cluster.length * 10;
            const totalScore = Math.floor(cellScore * combo);
            score += totalScore;
            
            // Find center point of cluster
            let centerX = 0, centerY = 0, centerZ = 0;
            cluster.forEach(([x, y, z]) => {
                centerX += x;
                centerY += y;
                centerZ += z;
            });
            centerX /= cluster.length;
            centerY /= cluster.length;
            centerZ /= cluster.length;
            
            // Sort cluster by distance from center
            const sortedCluster = cluster.slice().sort((a, b) => {
                const distA = Math.sqrt(Math.pow(a[0] - centerX, 2) + Math.pow(a[1] - centerY, 2) + Math.pow(a[2] - centerZ, 2));
                const distB = Math.sqrt(Math.pow(b[0] - centerX, 2) + Math.pow(b[1] - centerY, 2) + Math.pow(b[2] - centerZ, 2));
                return distA - distB;
            });
            
            // Remove meshes with staggered timing and play musical notes
            sortedCluster.forEach(([x, y, z], index) => {
                trackedSetTimeout(() => {
                    if (grid[x][y][z]) {
                        stats.typesClearedSet.add(grid[x][y][z].type.name);
                        if (grid[x][y][z].mesh) {
                            scene.remove(grid[x][y][z].mesh);
                            // Dispose cloned materials
                            grid[x][y][z].mesh.traverse(child => {
                                if (child.isMesh && child.material) {
                                    child.material.dispose();
                                }
                            });
                        }
                    }
                    grid[x][y][z] = null;
                }, index * 50);
            });
            
            stats.clustersCleared++;
            stats.consecutiveClears++;
            
            unlockAchievement('first_clear');
            
            updateHUD();
            checkAchievements();
        }
        
        function updateCombo() {
            const now = Date.now();
            if (now - lastClearTime < 2000) {
                const oldCombo = combo;
                combo = Math.min(5.0, combo + 0.5);
                
                // Spawn combo particle effect based on combo multiplier
                if (combo > oldCombo && combo >= 1.0) {
                    // Determine number of particles based on combo (1x = 1 particle, 2x = 2, etc.)
                    const numParticles = Math.floor(combo * 2); // 1.0x=2, 1.5x=3, 2.0x=4, etc.
                    
                    // Available combo effects (combo_a through combo_v = 22 effects)
                    const comboEffects = [
                        'combo_a', 'combo_b', 'combo_c', 'combo_d', 'combo_e', 'combo_f',
                        'combo_g', 'combo_h', 'combo_i', 'combo_j', 'combo_k', 'combo_l',
                        'combo_m', 'combo_n', 'combo_o', 'combo_p', 'combo_q', 'combo_r',
                        'combo_s', 'combo_t', 'combo_u', 'combo_v'
                    ];
                    
                    // Spawn particles
                    for (let i = 0; i < numParticles; i++) {
                        // Random position above the grid
                        const randomX = Math.random() * GRID_WIDTH;
                        const randomY = 12 + Math.random() * 8; // Between 12 and 20 units high
                        const randomZ = Math.random() * GRID_DEPTH;
                        
                        // Randomly select one of the combo effects
                        const randomEffect = comboEffects[Math.floor(Math.random() * comboEffects.length)];
                        
                        // Generate random start and end colors
                        const randomColorStart = '#' + Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0');
                        const randomColorEnd = '#' + Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0');
                        
                        spawnParticleEffect(
                            `effect/${randomEffect}.json`,
                            randomX,
                            randomY,
                            randomZ,
                            { 
                                spawnMode: 'world', 
                                rotation: { x: 0, y: 0, z: 0 },
                                colorOverride: {
                                    colorStart: randomColorStart,
                                    colorEnd: randomColorEnd
                                }
                            }
                        );
                    }
                }
            } else {
                combo = 1.5;
            }
            lastClearTime = now;
            
            // Track max combo
            if (combo > stats.maxComboReached) {
                stats.maxComboReached = combo;
            }
            if (combo >= 5.0) {
                stats.combo5xCount++;
            }
        }
        
        function resetCombo() {
            const now = Date.now();
            if (now - lastClearTime > 2000) {
                combo = 1.0;
                stats.consecutiveClears = 0;
            }
        }
        
        function applyGravity() {
            // Compact each column downward
            let anyMoved = false;
            const movingBlocks = [];
            
            for (let x = 0; x < GRID_WIDTH; x++) {
                for (let z = 0; z < GRID_DEPTH; z++) {
                    let writeIndex = 0;
                    for (let y = 0; y < GRID_HEIGHT; y++) {
                        if (grid[x][y][z] !== null) {
                            if (y !== writeIndex) {
                                const block = grid[x][y][z];
                                const oldY = y;
                                const newY = writeIndex;
                                
                                // Move in grid
                                grid[x][writeIndex][z] = block;
                                grid[x][y][z] = null;
                                
                                // Store for animation
                                movingBlocks.push({
                                    block: block,
                                    mesh: block.mesh,
                                    startY: oldY + 0.5,
                                    endY: newY + 0.5,
                                    x: x,
                                    y: newY,
                                    z: z
                                });
                                
                                // Clear broken link status when block moves
                                const oldKey = `${x},${oldY},${z}`;
                                const newKey = `${x},${writeIndex},${z}`;
                                if (brokenLinks.has(oldKey)) {
                                    brokenLinks.delete(oldKey);
                                    brokenLinks.add(newKey);
                                }
                                
                                anyMoved = true;
                            }
                            writeIndex++;
                        }
                    }
                }
            }
            
            // Animate falling blocks
            if (movingBlocks.length > 0) {
                const duration = 200; // ms
                const startTime = Date.now();
                
                const animateFall = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    movingBlocks.forEach(({mesh, startY, endY}) => {
                        mesh.position.y = startY + (endY - startY) * progress;
                    });
                    
                    if (progress < 1) {
                        const frameId = requestAnimationFrame(animateFall);
                        activeAnimationFrames.push(frameId);
                    } else {
                        // Ensure final positions are exact
                        movingBlocks.forEach(({mesh, endY}) => {
                            mesh.position.y = endY;
                        });
                        
                        // Check for glowing links that landed on floor and auto-destroy them
                        trackedSetTimeout(() => {
                            checkAndDestroyFloorGlowingLinks();
                        }, 50);
                        
                        // Check for cascades after animation completes
                        if (anyMoved) {
                            stats.cascadesTriggered++;
                            trackedSetTimeout(() => {
                                checkConsensus();
                            }, 100);
                        }
                    }
                };
                
                animateFall();
            } else if (anyMoved) {
                // No animation needed but still check cascades
                stats.cascadesTriggered++;
                trackedSetTimeout(() => {
                    checkConsensus();
                }, 100);
            }
        }
        
        function checkAndDestroyFloorGlowingLinks() {
            // Check all positions on the floor (y=0) for glowing links
            let foundGlowing = false;
            
            for (let x = 0; x < GRID_WIDTH; x++) {
                for (let z = 0; z < GRID_DEPTH; z++) {
                    const posKey = `${x},0,${z}`;
                    if (brokenLinks.has(posKey) && grid[x][0][z] !== null) {
                        foundGlowing = true;
                        // Destroy this glowing link
                        const link = grid[x][0][z];
                        disposeLinkMesh(link.mesh);
                        grid[x][0][z] = null;
                        brokenLinks.delete(posKey);
                        score += 100; // Award points
                    }
                }
            }
            
            // If we destroyed any glowing links, update HUD and apply gravity again
            if (foundGlowing) {
                updateHUD();
                trackedSetTimeout(() => {
                    applyGravity(); // This will cascade - more glowing links may fall
                }, 150);
            }
        }
        
        function animate() {
            mainAnimationFrameId = requestAnimationFrame(animate);
            
            // ===== GAMEPAD POLLING =====
            updateGamepad();
            // ===== END GAMEPAD POLLING =====
            
            // Update performance counter
            frameCount++;
            const now = Date.now();
            if (now - lastFpsUpdate >= 1000) {
                currentFps = Math.round(frameCount * 1000 / (now - lastFpsUpdate));
                frameCount = 0;
                lastFpsUpdate = now;
                
                // Update FPS display
                document.getElementById('fpsValue').textContent = currentFps;
                
                // Update memory display (if available)
                if (performance.memory) {
                    const memoryMB = Math.round(performance.memory.usedJSHeapSize / 1048576);
                    document.getElementById('memoryValue').textContent = memoryMB + ' MB';
                }
                
                // Update particle count
                let totalParticles = 0;
                particleEffects.forEach(effect => {
                    totalParticles += effect.particles.length;
                });
                document.getElementById('particleCount').textContent = totalParticles;
            }
            
            // Always update character animations (even in menu)
            const deltaTime = (now - lastUpdateTime) / 1000;
            lastUpdateTime = now;
            
            // Only update animations if enabled
            if (animationsEnabled) {
                // Update Zooko animation
                if (zookoMixer) {
                    zookoMixer.update(deltaTime);
                }
                
                // Update CyberAxe animation
                if (cyberAxeMixer) {
                    cyberAxeMixer.update(deltaTime);
                }
                
                // Update Zancas animation
                if (zancasMixer) {
                    zancasMixer.update(deltaTime);
                }
                
                // Update Nate animation
                if (nateMixer) {
                    nateMixer.update(deltaTime);
                }
                
                // Update model placement animations
                modelPlacements.forEach(placement => {
                    if (placement.mixer) {
                        placement.mixer.update(deltaTime);
                    }
                });
            }
            
            // Update column tubes FIRST - before any gameplay logic
            updateColumnTubes();
            
            // Update grid visual effects
            applyGridEffect();
            
            // Update floor cell animations
            updateFloorCells();
            
            // Update particle effects
            updateParticleEffects(deltaTime);
            
            // Update corner feed tube animations (only if animations enabled)
            if (animationsEnabled) {
                updateCornerChains(deltaTime);
            }
            
            if (currentState === GameState.PLAYING) {
                const gameplayDeltaTime = deltaTime * currentTimeScale;
                
                // Update HUD continuously during gameplay
                updateHUD();
                
                // Spawn first chain if needed (but not if spawn is already scheduled)
                if (!fallingChain && !spawnScheduled) {
                    spawnNewChain();
                }
                
                // ===== AI PLAYER =====
                if (aiState.enabled) {
                    aiExecuteMove();
                }
                // ===== END AI PLAYER =====
                
                // Update falling chain
                updateFallingChain(gameplayDeltaTime);
                
                // Update sandblasting links
                updateSandblastingLinks(gameplayDeltaTime);
                
                // Handle movement input
                handleMovement(gameplayDeltaTime);
            }
            
            // Update chain light position to follow falling chain
            if (fallingChain && fallingChain.links && fallingChain.links.length > 0) {
                const topLink = fallingChain.links[0];
                chainLight.position.set(
                    topLink.position.x,
                    topLink.position.y + 2,
                    topLink.position.z
                );
            }
            
            // Update LED pulse effect on walls
            updateLEDPulse();
            
            // TEST: Loop particle effect
            // testParticleTimer += deltaTime * 1000;
            // if (testParticleTimer >= testParticleInterval) {
            //     testParticleTimer = 0;
            //     spawnParticleEffect('effect/zancas_special.json', 10, 5, 0, {
            //         spawnMode: 'world',
            //         rotation: { x: 0, y: 0, z: 0 },
            //         startDelay: 0
            //     });
            // }
            
            renderer.render(scene, camera);
        }
        
        function updateLEDPulse() {
            // Skip wall pulsing during sandblasting or if disabled
            if (sandblastingActive || !wallEmissiveEnabled) return;
            
            // Slow smooth pulse using sine wave
            // Complete cycle every 4 seconds (frequency = 0.25 Hz)
            const time = Date.now() * 0.001; // Convert to seconds
            const pulseValue = Math.sin(time * Math.PI * 0.5) * 0.5 + 0.5; // Oscillate between 0 and 1
            const intensity = 0.3 + (pulseValue * 0.3); // Vary between 0.3 and 0.6
            
            // Apply to all room walls with emissive materials
            roomWalls.forEach(wall => {
                if (wall.material && wall.material.emissiveIntensity !== undefined) {
                    wall.material.emissiveIntensity = intensity;
                }
            });
        }
        
        function updateCornerChains(deltaTime) {
            const scrollSpeed = 1.5; // Units per second
            const linkSpacing = 1.0; // Links are 1 unit apart
            const baseResetThreshold = GRID_HEIGHT; // When link reaches top of grid
            const baseResetPosition = -4; // Starting position below floor
            
            cornerChains.forEach((chain) => {
                // Calculate wrapping range based on column's chainLength and Y
                const chainLength = chain.column.chainLength || 0;
                const direction = chain.direction || 'up';
                const directionMultiplier = direction === 'up' ? 1 : -1;
                
                // For upward: reset at top threshold, wrap to bottom
                // For downward: reset at bottom threshold, wrap to top
                const resetThreshold = direction === 'up' ? baseResetThreshold + chainLength : chain.column.y;
                const resetPosition = direction === 'up' ? chain.column.y : baseResetThreshold + chainLength;
                
                // Move all links in specified direction
                chain.links.forEach((link) => {
                    link.position.y += scrollSpeed * deltaTime * directionMultiplier;
                    
                    // When link goes past threshold, wrap it to the other end
                    const pastThreshold = direction === 'up' ? link.position.y > resetThreshold : link.position.y < resetThreshold;
                    
                    if (pastThreshold) {
                        // Calculate how far past threshold we went
                        const overshoot = direction === 'up' ? link.position.y - resetThreshold : resetThreshold - link.position.y;
                        // Reset to opposite end plus the overshoot to maintain continuity
                        link.position.y = direction === 'up' ? resetPosition + overshoot : resetPosition - overshoot;
                        
                        // Change color based on colorMode
                        let newType;
                        if (chain.colorMode === 'single' && chain.singleColor !== null) {
                            newType = chain.singleColor;
                        } else {
                            const linkTypes = [LinkType.ZEC_A, LinkType.ZEC_B, LinkType.ZEC_C, LinkType.ZEC_D];
                            newType = linkTypes[Math.floor(Math.random() * linkTypes.length)];
                        }
                        
                        // Note: No material changes - models are pre-colored
                    }
                });
            });
        }
        
        // ===== AI PLAYER LOGIC (FOR TESTING - CAN BE REMOVED LATER) =====
        function aiMakeDecision() {
            if (!fallingChain) return;
            
            let bestScore = -Infinity;
            let bestX = fallingChain.x;
            let bestZ = fallingChain.z;
            let bestRotation = 0;
            
            // Try all positions and rotations
            for (let x = 0; x < GRID_WIDTH; x++) {
                for (let z = 0; z < GRID_DEPTH; z++) {
                    for (let rotation = 0; rotation < 4; rotation++) {
                        const score = aiEvaluatePosition(x, z, rotation);
                        if (score > bestScore) {
                            bestScore = score;
                            bestX = x;
                            bestZ = z;
                            bestRotation = rotation;
                        }
                    }
                }
            }
            
            aiState.targetX = bestX;
            aiState.targetZ = bestZ;
            aiState.targetRotation = bestRotation;
            aiState.hasDecided = true;
        }
        
        function aiEvaluatePosition(x, z, rotation) {
            let score = 0;
            
            // Find lowest Y position this chain would land
            let landY = 0;
            for (let y = 0; y < GRID_HEIGHT; y++) {
                if (grid[x][y][z] !== null) {
                    landY = y + 1;
                    break;
                }
            }
            
            // Prefer lower positions (faster to place)
            score += (GRID_HEIGHT - landY) * 10;
            
            // Check for matches below
            if (landY > 0 && grid[x][landY - 1][z] !== null) {
                const chainType = fallingChain.type;
                const belowType = grid[x][landY - 1][z].type;
                if (chainType === belowType) {
                    score += 100; // Big bonus for matching
                }
            }
            
            // Check for matches around
            const neighbors = [
                [x + 1, z], [x - 1, z], [x, z + 1], [x, z - 1]
            ];
            neighbors.forEach(([nx, nz]) => {
                if (nx >= 0 && nx < GRID_WIDTH && nz >= 0 && nz < GRID_DEPTH) {
                    if (grid[nx][landY][nz] !== null) {
                        if (grid[nx][landY][nz].type === fallingChain.type) {
                            score += 50;
                        }
                    }
                }
            });
            
            // Avoid stacking too high
            if (landY > GRID_HEIGHT * 0.7) {
                score -= 200;
            }
            
            // Random variation to make it less predictable
            score += Math.random() * 10;
            
            return score;
        }
        
        function aiExecuteMove() {
            if (!aiState.enabled || !fallingChain || currentState !== GameState.PLAYING) return;
            
            const now = Date.now();
            // Slow down AI movement during CyberAxe special
            const effectiveMoveDelay = cyberAxeSpecialActive ? aiState.moveDelay * 3 : aiState.moveDelay;
            if (now < aiState.nextMoveTime) return;
            
            // Make decision if haven't yet
            if (!aiState.hasDecided) {
                aiMakeDecision();
            }
            
            // Execute moves to reach target
            if (aiState.hasDecided) {
                // Rotate if needed (convert rotation count to degrees)
                const targetDegrees = aiState.targetRotation * 90;
                const currentDegrees = (fallingChain.rotation || 0);
                if (currentDegrees !== targetDegrees) {
                    rotatePiece('ArrowRight'); // Rotate once
                    aiState.nextMoveTime = now + effectiveMoveDelay;
                    return;
                }
                
                // Move to target position
                if (Math.floor(fallingChain.x) !== aiState.targetX || Math.floor(fallingChain.z) !== aiState.targetZ) {
                    const dx = aiState.targetX - Math.floor(fallingChain.x);
                    const dz = aiState.targetZ - Math.floor(fallingChain.z);
                    
                    if (dx !== 0) {
                        tryMove(dx > 0 ? 1 : -1, 0);
                    } else if (dz !== 0) {
                        tryMove(0, dz > 0 ? 1 : -1);
                    }
                    aiState.nextMoveTime = now + effectiveMoveDelay;
                } else {
                    // At target position - drop it!
                    // Only set instantDrop if AI is actually enabled AND no special is active
                    if (aiState.enabled && !cyberAxeSpecialActive) {
                        instantDrop = true;
                    }
                    aiState.hasDecided = false; // Reset for next chain
                }
            }
        }
        // ===== END AI PLAYER LOGIC =====
        
        function updateColumnTubes() {
            // Hide all tubes and floor indicators
            columnTubes.forEach(tube => {
                tube.visible = false;
            });
            floorIndicators.forEach(indicator => {
                indicator.visible = false;
            });
            
            // Only show and glow tube when chain is ready
            if (fallingChain && chainReadyToGlow) {
                const chainX = Math.floor(fallingChain.x);
                const chainZ = Math.floor(fallingChain.z);
                
                // Find the tube at this position
                const activeTube = columnTubes.find(tube => 
                    tube.userData.gridX === chainX && tube.userData.gridZ === chainZ
                );
                
                if (activeTube && laserLineEnabled) {
                    activeTube.visible = true;
                    activeTube.material.color.setHex(laserLineColor); // Custom laser color
                }
                
                // Find and show the floor indicator
                const activeFloor = floorIndicators.find(indicator =>
                    indicator.userData.gridX === chainX && indicator.userData.gridZ === chainZ
                );
                
                if (activeFloor && floorHintEnabled) {
                    activeFloor.visible = true;
                    activeFloor.material.color.setHex(floorHintColor); // Custom floor hint color
                }
            }
        }
        
        function handleMovement(deltaTime) {
            if (!fallingChain) return;
            
            // DAS/ARR handling for smooth movement
            const moveKeys = {
                w: getMovementVector().forward,
                s: getMovementVector().back,
                a: getMovementVector().left,
                d: getMovementVector().right
            };
            
            let moveX = 0, moveZ = 0;
            
            // Add BOTH x and z components from each key
            if (keys['w']) {
                moveX += moveKeys.w.x;
                moveZ += moveKeys.w.z;
            }
            if (keys['s']) {
                moveX += moveKeys.s.x;
                moveZ += moveKeys.s.z;
            }
            if (keys['a']) {
                moveX += moveKeys.a.x;
                moveZ += moveKeys.a.z;
            }
            if (keys['d']) {
                moveX += moveKeys.d.x;
                moveZ += moveKeys.d.z;
            }
            
            if (moveX !== 0 || moveZ !== 0) {
                if (dasTimer <= 0) {
                    tryMove(moveX, moveZ);
                    dasTimer = DAS_DELAY;
                    arrTimer = ARR_DELAY;
                } else {
                    dasTimer -= deltaTime * 1000;
                    if (dasTimer <= 0) {
                        if (arrTimer <= 0) {
                            tryMove(moveX, moveZ);
                            arrTimer = ARR_DELAY;
                        } else {
                            arrTimer -= deltaTime * 1000;
                        }
                    }
                }
            } else {
                dasTimer = 0;
                arrTimer = 0;
            }
        }
        
        function getMovementVector() {
            // For top-down view, use absolute directions
            if (isTopDownView) {
                return {
                    forward: { x: 0, z: -1 },  // W: move up (north, -Z)
                    back: { x: 0, z: 1 },      // S: move down (south, +Z)
                    left: { x: -1, z: 0 },     // A: move left (west, -X)
                    right: { x: 1, z: 0 }      // D: move right (east, +X)
                };
            }
            
            // Map WASD to movement based on current camera chair
            // Remember: camera is LOOKING AT the grid from outside
            switch(currentChair) {
                case 0: // North (camera at +Z looking toward -Z)
                    return {
                        forward: { x: 0, z: -1 },  // W: move toward camera (north)
                        back: { x: 0, z: 1 },      // S: move away from camera (south)
                        left: { x: -1, z: 0 },     // A: move left (west)
                        right: { x: 1, z: 0 }      // D: move right (east)
                    };
                case 1: // East (camera at +X looking toward -X)
                    return {
                        forward: { x: -1, z: 0 },  // W: move toward camera (east)
                        back: { x: 1, z: 0 },      // S: move away from camera (west)
                        left: { x: 0, z: 1 },      // A: move left (south)
                        right: { x: 0, z: -1 }     // D: move right (north)
                    };
                case 2: // South (camera at -Z looking toward +Z)
                    return {
                        forward: { x: 0, z: 1 },   // W: move toward camera (south)
                        back: { x: 0, z: -1 },     // S: move away from camera (north)
                        left: { x: 1, z: 0 },      // A: move left (east)
                        right: { x: -1, z: 0 }     // D: move right (west)
                    };
                case 3: // West (camera at -X looking toward +X)
                    return {
                        forward: { x: 1, z: 0 },   // W: move toward camera (west)
                        back: { x: -1, z: 0 },     // S: move away from camera (east)
                        left: { x: 0, z: -1 },     // A: move left (north)
                        right: { x: 0, z: 1 }      // D: move right (south)
                    };
            }
        }
        
        function tryMove(dx, dz) {
            const newX = fallingChain.x + dx;
            const newZ = fallingChain.z + dz;
            
            // Check bounds
            if (newX < 0 || newX >= GRID_WIDTH) return;
            if (newZ < 0 || newZ >= GRID_DEPTH) return;
            
            // Check collision at new position
            for (let i = 0; i < fallingChain.length; i++) {
                const y = Math.floor(fallingChain.y - i);
                if (y >= 0 && y < GRID_HEIGHT) {
                    if (grid[newX][y][newZ] !== null) {
                        return;
                    }
                }
            }
            
            // Move successful
            fallingChain.x = newX;
            fallingChain.z = newZ;
            
            // Update mesh positions
            for (let i = 0; i < fallingChain.length; i++) {
                fallingChain.links[i].position.x = newX + 0.5;
                fallingChain.links[i].position.z = newZ + 0.5;
            }
        }
        
        
        // Initialize on load
        window.addEventListener('load', init);
    </script>
</body>
</html>
