<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TUNNELS OF PRIVACY - Dungeon Crawler v0.2.35</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet" media="print" onload="this.media='all'; this.onload=null;">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #0A0E12 0%, #1A1E2A 100%);
            color: #E9F0F7;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            cursor: default;
        }
        
        #gameContainer {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #titleScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 14, 18, 0.95);
            z-index: 100;
            pointer-events: none;
        }
        
        #dungeonMenuScreen {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0A0E12 0%, #1A1E2A 100%);
            z-index: 100;
        }
        
        #battleScreen {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a0f2e 0%, #0f0a1e 100%);
            z-index: 100;
        }
        
        #battleCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: calc(100% - 180px);
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        #battleNotification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(46, 204, 113, 0.95), rgba(39, 174, 96, 0.95));
            border: 4px solid #27AE60;
            border-radius: 12px;
            padding: 40px 60px;
            font-family: 'Inter', sans-serif;
            font-size: 48px;
            font-weight: 900;
            color: #FFFFFF;
            text-shadow: 0 4px 8px rgba(0, 0, 0, 0.6);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
            z-index: 1000;
            display: none;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 4px;
            animation: notificationPulse 0.5s ease-out;
        }
        
        @keyframes notificationPulse {
            0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        
        #battleEnemyCards {
            position: absolute;
            top: 20px;
            left: 20px;
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
            max-width: 160px;
            z-index: 10;
        }
        
        #battleEnemyCards.twoColumns {
            grid-template-columns: 1fr 1fr;
            max-width: 330px;
        }
        
        .battleEnemyCard {
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            border: 2px solid #E74C3C;
            border-radius: 8px;
            padding: 8px;
            width: 140px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .battleEnemyCard.boss {
            border-color: #8B45FF;
            box-shadow: 0 0 15px rgba(139, 69, 255, 0.4);
        }
        
        .battleEnemyCard.targetable {
            border-color: #FFD700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
            animation: cardPulse 1s infinite;
        }
        
        .battleEnemyCard:hover.targetable {
            transform: scale(1.05);
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.8);
        }
        
        @keyframes cardPulse {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.6); }
            50% { box-shadow: 0 0 30px rgba(255, 215, 0, 0.9); }
        }
        
        .battleEnemyCard.dead {
            opacity: 0.4;
            cursor: not-allowed;
            filter: grayscale(100%);
        }
        
        .battleEnemyPortrait {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-size: cover;
            background-position: center;
            border: 2px solid #E74C3C;
            margin: 0 auto 6px auto;
            box-shadow: 0 0 10px rgba(231, 76, 60, 0.4);
        }
        
        .battleEnemyCard.boss .battleEnemyPortrait {
            border-color: #8B45FF;
            box-shadow: 0 0 10px rgba(139, 69, 255, 0.4);
        }
        
        .battleEnemyName {
            font-family: 'Inter', sans-serif;
            font-size: 10px;
            font-weight: 700;
            text-align: center;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #E74C3C;
        }
        
        .battleEnemyCard.boss .battleEnemyName {
            color: #8B45FF;
        }
        
        .battleEnemyStat {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: #BFD1E0;
            text-align: center;
            margin: 2px 0;
        }
        
        #battleUI {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 180px;
            background: linear-gradient(180deg, rgba(10, 14, 18, 0) 0%, rgba(10, 14, 18, 0.95) 20%, rgba(10, 14, 18, 0.98) 100%);
            display: flex;
            flex-direction: row;
            align-items: flex-end;
            justify-content: center;
            padding: 15px;
            gap: 15px;
        }
        
        #battleUILeft {
            display: flex;
            flex-direction: row;
            gap: 10px;
            flex-shrink: 0;
        }
        
        #battleUICenter {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            gap: 10px;
        }
        
        #battleUIRight {
            display: flex;
            flex-direction: row;
            gap: 10px;
            flex-shrink: 0;
        }
        
        .battleHeroCard {
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            border: 2px solid #2A9D8F;
            border-radius: 8px;
            padding: 8px;
            width: 140px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
        }
        
        .battleHeroCard.active {
            border-color: #F2C94C;
            box-shadow: 0 0 20px rgba(242, 201, 76, 0.6);
        }
        
        .battleHeroPortrait {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-size: cover;
            background-position: center;
            border: 2px solid #2A9D8F;
            margin: 0 auto 6px auto;
            box-shadow: 0 0 10px rgba(42, 157, 143, 0.4);
        }
        
        .battleHeroName {
            font-family: 'Inter', sans-serif;
            font-size: 11px;
            font-weight: 700;
            text-align: center;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .battleHeroStat {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: #BFD1E0;
            text-align: center;
            margin: 2px 0;
        }
        
        #battleTurnInfo {
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            color: #F2C94C;
            text-shadow: 0 0 10px rgba(242, 201, 76, 0.5);
            margin-bottom: 5px;
        }
        
        #battleActions {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 5px;
            width: 100%;
            max-width: 700px;
        }
        
        .battleButton {
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            border: 2px solid #2A9D8F;
            color: #E9F0F7;
            font-family: 'Inter', sans-serif;
            font-size: 10px;
            font-weight: 600;
            padding: 6px 4px;
            border-radius: 6px;
            cursor: pointer;
            pointer-events: all;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .battleButton:hover:not(:disabled) {
            background: linear-gradient(135deg, rgba(42, 157, 143, 0.3), rgba(42, 157, 143, 0.2));
            border-color: #3DBAA3;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(42, 157, 143, 0.4);
        }
        
        .battleButton:active:not(:disabled) {
            transform: translateY(0px) scale(0.95);
            box-shadow: 0 2px 8px rgba(42, 157, 143, 0.6);
        }
        
        .battleButton:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        .battleButton.attack-weak { border-color: #3498DB; }
        .battleButton.attack-weak:hover:not(:disabled) { 
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.3), rgba(52, 152, 219, 0.2));
            border-color: #5DADE2;
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
        }
        
        .battleButton.attack-strong { border-color: #E74C3C; }
        .battleButton.attack-strong:hover:not(:disabled) { 
            background: linear-gradient(135deg, rgba(231, 76, 60, 0.3), rgba(231, 76, 60, 0.2));
            border-color: #EC7063;
            box-shadow: 0 6px 20px rgba(231, 76, 60, 0.4);
        }
        
        .battleButton.special { border-color: #F39C12; }
        .battleButton.special:hover:not(:disabled) { 
            background: linear-gradient(135deg, rgba(243, 156, 18, 0.3), rgba(243, 156, 18, 0.2));
            border-color: #F8C471;
            box-shadow: 0 6px 20px rgba(243, 156, 18, 0.4);
        }
        
        .battleButton.defend { border-color: #27AE60; }
        .battleButton.defend:hover:not(:disabled) { 
            background: linear-gradient(135deg, rgba(39, 174, 96, 0.3), rgba(39, 174, 96, 0.2));
            border-color: #52BE80;
            box-shadow: 0 6px 20px rgba(39, 174, 96, 0.4);
        }
        
        .battleButton.heal { border-color: #9B59B6; }
        .battleButton.heal:hover:not(:disabled) { 
            background: linear-gradient(135deg, rgba(155, 89, 182, 0.3), rgba(155, 89, 182, 0.2));
            border-color: #AF7AC5;
            box-shadow: 0 6px 20px rgba(155, 89, 182, 0.4);
        }
        
        .battleButton.swap { border-color: #3498DB; }
        .battleButton.swap:hover:not(:disabled) { 
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.3), rgba(52, 152, 219, 0.2));
            border-color: #5DADE2;
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
        }
        
        .battleButton.taunt { border-color: #E67E22; }
        .battleButton.taunt:hover:not(:disabled) { 
            background: linear-gradient(135deg, rgba(230, 126, 34, 0.3), rgba(230, 126, 34, 0.2));
            border-color: #F39C12;
            box-shadow: 0 6px 20px rgba(230, 126, 34, 0.4);
        }
        
        .battleButton.retreat { border-color: #95A5A6; }
        .battleButton.retreat:hover:not(:disabled) { 
            background: linear-gradient(135deg, rgba(149, 165, 166, 0.3), rgba(149, 165, 166, 0.2));
            border-color: #BDC3C7;
            box-shadow: 0 6px 20px rgba(149, 165, 166, 0.4);
        }
        
        #pauseScreen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 14, 18, 0.98);
            z-index: 1000;
            pointer-events: all;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        #pauseTitle {
            font-size: 72px;
            font-weight: 900;
            color: #8B45FF;
            text-shadow: 0 0 40px rgba(139, 69, 255, 0.6);
            margin-bottom: 40px;
            letter-spacing: 8px;
        }
        
        #storyIntroBackground {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.3;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            transition: opacity 2s ease-in-out;
        }
        
        #title {
            display: none;
        }
        
        #subtitle {
            display: none;
        }
        
        /* Center Column - Main Menu Buttons */
        #menuButtonsCenter {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            pointer-events: none;
        }
        
        .menuButton {
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            border: 2px solid #2A9D8F;
            color: #E9F0F7;
            font-family: 'Inter', sans-serif;
            font-size: 18px;
            font-weight: 700;
            padding: 14px 40px;
            margin: 8px;
            cursor: pointer;
            transition: all 0.2s;
            border-radius: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
            width: 380px;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: all;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
        }
        
        .menuButton:hover {
            background: linear-gradient(135deg, rgba(20, 27, 34, 0.95), rgba(42, 157, 143, 0.2));
            box-shadow: 0 6px 25px rgba(42, 157, 143, 0.4);
            transform: translateY(-2px);
            border-color: #4ECDC4;
        }
        
        .menuButton:active {
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.98), rgba(15, 19, 24, 0.95));
            transform: translateY(0px);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }
        
        .menuButton:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .portalButton {
            background: linear-gradient(135deg, rgba(139, 69, 255, 0.4), rgba(139, 69, 255, 0.3));
            border-color: #8B45FF;
        }
        
        .portalButton:hover {
            background: linear-gradient(135deg, rgba(139, 69, 255, 0.6), rgba(139, 69, 255, 0.5));
            border-color: #A45FFF;
            box-shadow: 0 5px 20px rgba(139, 69, 255, 0.5);
        }
        
        /* Left Column - Hero Stats (Title Screen) */
        #heroStats {
            position: absolute;
            left: 60px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(20, 27, 34, 0.8);
            border: 2px solid #26313B;
            border-radius: 12px;
            padding: 25px;
            width: 320px;
            pointer-events: all;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
        }
        
        /* Hero Cards in Corners (Dungeon Menu) */
        .dungeonHeroCard {
            position: absolute;
            background: linear-gradient(135deg, rgba(39, 174, 96, 0.1), rgba(39, 174, 96, 0.05));
            border: 1px solid #27AE60;
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            width: 160px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
        }
        
        #dungeonZooko { top: 20px; left: 20px; border-color: #EB5757; box-shadow: 0 0 15px rgba(235, 87, 87, 0.3); }
        #dungeonNate { bottom: 80px; left: 20px; border-color: #F2C94C; box-shadow: 0 0 15px rgba(242, 201, 76, 0.3); }
        #dungeonZancas { top: 20px; right: 20px; border-color: #27AE60; box-shadow: 0 0 15px rgba(39, 174, 96, 0.3); }
        #dungeonCyberAxe { bottom: 80px; right: 20px; border-color: #2E86DE; box-shadow: 0 0 15px rgba(46, 134, 222, 0.3); }
        
        .heroRow {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 12px;
        }
        
        .heroCard {
            background: linear-gradient(135deg, rgba(39, 174, 96, 0.1), rgba(39, 174, 96, 0.05));
            border: 1px solid #27AE60;
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            position: relative;
        }
        
        .heroPortrait {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            margin: 0 auto 8px auto;
            background-size: cover;
            background-position: center;
            border: 2px solid #27AE60;
            box-shadow: 0 0 10px rgba(39, 174, 96, 0.4);
        }
        
        .heroName {
            font-weight: 700;
            font-size: 14px;
            color: #F2C94C;
            margin-bottom: 8px;
        }
        
        .heroStat {
            font-size: 11px;
            color: #ffffff;
            margin: 2px 0;
            font-family: 'JetBrains Mono', monospace;
            font-weight: 700;
        }
        
        #versionDisplay {
            position: absolute;
            bottom: 20px;
            right: 20px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: #5A7A8F;
        }
        
        .comingSoon {
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            border-color: #EB5757;
            color: #EB5757;
        }
        
        .comingSoon:hover {
            background: linear-gradient(135deg, rgba(235, 87, 87, 0.2), rgba(235, 87, 87, 0.1));
            box-shadow: 0 6px 25px rgba(235, 87, 87, 0.4);
            transform: translateY(-2px);
            border-color: #FF6B6B;
        }
        
        /* Center Column - Level Display (at top of center buttons) */
        #dungeonLevelDisplay {
            text-align: center;
            padding: 15px;
            background: linear-gradient(135deg, rgba(139, 69, 255, 0.2), rgba(75, 0, 130, 0.2));
            border: 2px solid #8B45FF;
            border-radius: 10px;
            width: 380px;
            pointer-events: none;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            margin-bottom: 20px;
        }
        
        /* Music Ticker */
        #musicTicker {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(42, 157, 143, 0.3);
            border: 2px solid #2A9D8F;
            border-radius: 8px;
            overflow: hidden;
            width: 400px;
            max-width: 25%;
            z-index: 500;
            pointer-events: auto;
            transition: left 0.3s ease, transform 0.3s ease;
        }
        
        /* Move ticker to bottom left during battle */
        #musicTicker.battleActive {
            left: 10px;
            transform: translateX(0);
        }
        
        #musicTickerWrapper {
            display: flex;
            width: fit-content;
            animation: scrollTicker 30s linear infinite;
        }
        
        #musicTicker:hover #musicTickerWrapper {
            animation-duration: 60s;
        }
        
        .tickerText {
            color: #F2C94C;
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            font-weight: 700;
            white-space: nowrap;
            padding-right: 100px;
        }
        
        @keyframes scrollTicker {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }
        
        /* Music Control Panel - Bottom of Screen Above Ticker */
        #musicControls {
            position: fixed;
            bottom: 65px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            border: 2px solid #2A9D8F;
            border-radius: 8px;
            padding: 12px;
            min-width: 240px;
            max-width: 25%;
            pointer-events: auto;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8);
            z-index: 500;
            transition: left 0.3s ease, transform 0.3s ease;
        }
        
        /* Move controls to bottom left during battle or hero selection */
        #musicControls.battleActive,
        #musicControls.heroSelectionActive {
            left: 10px;
            transform: translateX(0);
        }
        
        .musicControlTitle {
            margin: 0 0 10px 0;
            color: #2A9D8F;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            text-align: center;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .musicButton {
            padding: 8px 16px;
            background: linear-gradient(135deg, rgba(42, 157, 143, 0.4), rgba(42, 157, 143, 0.3));
            border: 2px solid #2A9D8F;
            color: #F2C94C;
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            font-weight: bold;
            margin: 3px 0;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 6px;
            width: 100%;
            text-align: center;
        }
        
        .musicButton:hover {
            background: linear-gradient(135deg, rgba(42, 157, 143, 0.6), rgba(42, 157, 143, 0.5));
            border-color: #2ECC71;
        }
        
        .musicButton:active {
            transform: translateY(1px);
        }
        
        .volumeControl {
            margin: 10px 0 0 0;
        }
        
        .volumeLabel {
            color: #BFD1E0;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            display: block;
            margin-bottom: 4px;
        }
        
        .volumeSlider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(139, 69, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }
        
        .volumeSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #8B45FF;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(139, 69, 255, 0.5);
        }
        
        .volumeSlider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #8B45FF;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 5px rgba(139, 69, 255, 0.5);
        }
        
        #overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 14, 18, 0.9);
            z-index: 150;
            pointer-events: all;
        }
        
        #settingsPanel {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            border: 2px solid #2A9D8F;
            border-radius: 12px;
            padding: 25px;
            max-width: 450px;
            width: auto;
            z-index: 1100;
            pointer-events: all;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
        }
        
        .panelTitle {
            font-size: 28px;
            font-weight: 900;
            color: #2A9D8F;
            margin-bottom: 20px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .settingRow {
            margin: 20px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .settingLabel {
            font-size: 18px;
            color: #E9F0F7;
        }
        
        input[type="range"] {
            width: 200px;
        }
        
        /* Loading Screen Styles */
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }
        
        @keyframes slowBlink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
    </style>
</head>
<body>
    <!-- Loading Modal -->
    <div id="loadingModal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.95); display: flex; align-items: center; justify-content: center; z-index: 10000;">
        <div style="background: linear-gradient(135deg, #1a2332 0%, #0d1218 100%); padding: 40px 60px; border-radius: 15px; border: 2px solid #8B45FF; box-shadow: 0 10px 50px rgba(139, 69, 255, 0.5); text-align: center; min-width: 500px;">
            <div style="font-size: 48px; margin-bottom: 20px; animation: pulse 1.5s ease-in-out infinite;">üè∞</div>
            <div style="font-size: 24px; font-weight: bold; color: #8B45FF; margin-bottom: 10px;">TUNNELS OF PRIVACY</div>
            <div style="font-size: 14px; color: #F2C94C; margin-bottom: 15px; font-style: italic;">A Dungeon Crawler Adventure</div>
            <div id="loadingNote" style="font-size: 12px; color: #BFD1E0; margin-bottom: 20px; line-height: 1.5;">Loading assets... This may take a moment on first visit</div>
            
            <!-- Category breakdown -->
            <div style="margin-bottom: 15px; text-align: left; font-size: 13px; color: #BFD1E0;">
                <div id="loadingArt" style="margin-bottom: 5px;">üé® Art: <span style="color: #8B45FF; font-weight: bold;">0/0</span></div>
                <div id="loadingSound" style="margin-bottom: 5px;">üîä Sound: <span style="color: #8B45FF; font-weight: bold;">0/0</span></div>
            </div>
            
            <!-- Overall progress -->
            <div id="loadingIndicator" style="font-size: 18px; color: #2ECC71; margin-bottom: 20px; font-weight: bold;">0%</div>
            
            <div style="width: 100%; height: 30px; background: rgba(139, 69, 255, 0.2); border-radius: 15px; overflow: hidden; border: 1px solid #8B45FF;">
                <div id="loadingBar" style="height: 100%; width: 0%; background: linear-gradient(90deg, #8B45FF, #2ECC71); transition: width 0.3s ease; border-radius: 15px; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 14px;"></div>
            </div>
            
            <!-- Click to Play prompt (hidden until ready) -->
            <div id="clickToPlayPrompt" style="display: none; margin-top: 30px; font-size: 24px; color: #2ECC71; font-weight: bold; animation: slowBlink 2s ease-in-out infinite; cursor: pointer;">
                <div style="margin-bottom: 10px;">üéÆ CLICK TO ENTER üéÆ</div>
                <div style="font-size: 14px; color: #89A0B4;">
                    <span style="display: inline-block; padding: 5px 10px; background: rgba(52, 152, 219, 0.3); border-radius: 5px; margin-right: 5px;">MOUSE</span>
                    or
                    <span style="display: inline-block; padding: 5px 10px; background: rgba(46, 204, 113, 0.3); border-radius: 5px; margin-left: 5px;">üéÆ A</span>
                </div>
            </div>
        </div>
    </div>
    
    <div id="gameContainer">
        <!-- Dungeon Menu Screen -->
        <div id="dungeonMenuScreen">
            <!-- Hero Cards in Corners -->
            <div class="dungeonHeroCard" id="dungeonZooko">
                <div class="heroPortrait" style="background-image: url('people/zooko_a_head_compressed.png'); border-color: #EB5757; box-shadow: 0 0 10px rgba(235, 87, 87, 0.4);"></div>
                <div class="heroName" style="color: #EB5757;">ZOOKO</div>
                <div class="heroStat" style="color: #ff6b6b; font-size: 12px; margin: 4px 0;">HP: <span id="dzooko-hp">0</span>/<span id="dzooko-maxhp">0</span></div>
                <div class="heroStat" style="color: #F2C94C; font-size: 11px; margin: 2px 0;">XP: <span id="dzooko-xp">0</span></div>
                <div class="heroStat">STR: <span id="dzooko-str">0</span>  INT: <span id="dzooko-int">0</span></div>
                <div class="heroStat">DEX: <span id="dzooko-dex">0</span>  WIS: <span id="dzooko-wis">0</span></div>
                <div class="heroStat">CON: <span id="dzooko-con">0</span>  CHA: <span id="dzooko-cha">0</span></div>
            </div>
            
            <div class="dungeonHeroCard" id="dungeonNate">
                <div class="heroPortrait" style="background-image: url('people/Nate_a_head_compressed.png'); border-color: #F2C94C; box-shadow: 0 0 10px rgba(242, 201, 76, 0.4);"></div>
                <div class="heroName" style="color: #F2C94C;">NATE</div>
                <div class="heroStat" style="color: #ff6b6b; font-size: 12px; margin: 4px 0;">HP: <span id="dnate-hp">0</span>/<span id="dnate-maxhp">0</span></div>
                <div class="heroStat" style="color: #F2C94C; font-size: 11px; margin: 2px 0;">XP: <span id="dnate-xp">0</span></div>
                <div class="heroStat">STR: <span id="dnate-str">0</span>  INT: <span id="dnate-int">0</span></div>
                <div class="heroStat">DEX: <span id="dnate-dex">0</span>  WIS: <span id="dnate-wis">0</span></div>
                <div class="heroStat">CON: <span id="dnate-con">0</span>  CHA: <span id="dnate-cha">0</span></div>
            </div>
            
            <div class="dungeonHeroCard" id="dungeonZancas">
                <div class="heroPortrait" style="background-image: url('people/Zancas_a_head_compressed.png'); border-color: #27AE60; box-shadow: 0 0 10px rgba(39, 174, 96, 0.4);"></div>
                <div class="heroName" style="color: #27AE60;">ZANCAS</div>
                <div class="heroStat" style="color: #ff6b6b; font-size: 12px; margin: 4px 0;">HP: <span id="dzancas-hp">0</span>/<span id="dzancas-maxhp">0</span></div>
                <div class="heroStat" style="color: #F2C94C; font-size: 11px; margin: 2px 0;">XP: <span id="dzancas-xp">0</span></div>
                <div class="heroStat">STR: <span id="dzancas-str">0</span>  INT: <span id="dzancas-int">0</span></div>
                <div class="heroStat">DEX: <span id="dzancas-dex">0</span>  WIS: <span id="dzancas-wis">0</span></div>
                <div class="heroStat">CON: <span id="dzancas-con">0</span>  CHA: <span id="dzancas-cha">0</span></div>
            </div>
            
            <div class="dungeonHeroCard" id="dungeonCyberAxe">
                <div class="heroPortrait" style="background-image: url('people/cyberaxe_a_head_compressed.png'); border-color: #2E86DE; box-shadow: 0 0 10px rgba(46, 134, 222, 0.4);"></div>
                <div class="heroName" style="color: #2E86DE;">CYBERAXE</div>
                <div class="heroStat" style="color: #ff6b6b; font-size: 12px; margin: 4px 0;">HP: <span id="dcyberaxe-hp">0</span>/<span id="dcyberaxe-maxhp">0</span></div>
                <div class="heroStat" style="color: #F2C94C; font-size: 11px; margin: 2px 0;">XP: <span id="dcyberaxe-xp">0</span></div>
                <div class="heroStat">STR: <span id="dcyberaxe-str">0</span>  INT: <span id="dcyberaxe-int">0</span></div>
                <div class="heroStat">DEX: <span id="dcyberaxe-dex">0</span>  WIS: <span id="dcyberaxe-wis">0</span></div>
                <div class="heroStat">CON: <span id="dcyberaxe-con">0</span>  CHA: <span id="dcyberaxe-cha">0</span></div>
            </div>
            
            <!-- Center Menu -->
            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); display: flex; flex-direction: column; align-items: center; gap: 12px;">
                <div style="text-align: center; padding: 15px; background: linear-gradient(135deg, rgba(139, 69, 255, 0.2), rgba(75, 0, 130, 0.2)); border: 2px solid #8B45FF; border-radius: 10px; width: 380px; backdrop-filter: blur(10px); box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4); margin-bottom: 10px;">
                    <div style="color: #BFD1E0; font-size: 14px; margin-bottom: 5px;">Dungeon Menu</div>
                    <div style="color: #F2C94C; font-size: 28px; font-weight: 900; text-shadow: 0 0 20px rgba(242, 201, 76, 0.5);">LEVEL <span id="dungeonMenuLevel">1</span></div>
                </div>
                
                <button class="menuButton" onclick="startBattle()">EXPLORE LEVEL</button>
                <button class="menuButton comingSoon" disabled>ENTER LEVEL STORE<br><span style="font-size: 12px; font-weight: 400;">(If Found)</span></button>
                <button class="menuButton">INVENTORY</button>
                <button class="menuButton">REST / SLEEP</button>
            </div>
        </div>
        
        <!-- Battle Screen -->
        <div id="battleScreen">
            <canvas id="battleCanvas"></canvas>
            
            <!-- Battle Notification Banner -->
            <div id="battleNotification">ROOM CLEARED!</div>
            
            <!-- Enemy Cards (Left Side) -->
            <div id="battleEnemyCards">
                <!-- Populated dynamically by updateBattleEnemyCards() -->
            </div>
            
            <div id="battleUI">
                <!-- Left Hero Cards: Zooko & Nate -->
                <div id="battleUILeft">
                    <div class="battleHeroCard" id="battleCardZooko">
                        <div class="battleHeroPortrait" style="background-image: url('people/zooko_a_head_compressed.png'); border-color: #F2C94C;"></div>
                        <div class="battleHeroName" style="color: #F2C94C;">ZOOKO</div>
                        <div class="battleHeroStat" style="color: #ff6b6b;">HP: <span id="bzooko-hp">30</span>/<span id="bzooko-maxhp">30</span></div>
                        <div class="battleHeroStat">AC: <span id="bzooko-ac">12</span></div>
                        <div class="battleHeroStat" style="color: #FFD700;">XP: <span id="bzooko-xp">0</span></div>
                        <div class="battleHeroStat" style="color: #ff1744; font-size: 14px;" id="bzooko-heals">‚ù§Ô∏è ‚ù§Ô∏è</div>
                    </div>
                    <div class="battleHeroCard" id="battleCardNate">
                        <div class="battleHeroPortrait" style="background-image: url('people/Nate_a_head_compressed.png'); border-color: #E74C3C;"></div>
                        <div class="battleHeroName" style="color: #E74C3C;">NATE</div>
                        <div class="battleHeroStat" style="color: #ff6b6b;">HP: <span id="bnate-hp">28</span>/<span id="bnate-maxhp">30</span></div>
                        <div class="battleHeroStat">AC: <span id="bnate-ac">14</span></div>
                        <div class="battleHeroStat" style="color: #FFD700;">XP: <span id="bnate-xp">0</span></div>
                        <div class="battleHeroStat" style="color: #ff1744; font-size: 14px;" id="bnate-heals">‚ù§Ô∏è ‚ù§Ô∏è</div>
                    </div>
                </div>
                
                <!-- Center Action Bar -->
                <div id="battleUICenter">
                    <div id="battleTurnInfo">ZOOKO'S TURN</div>
                    <div id="multiplayerStatus" style="display: none; background: rgba(42, 157, 143, 0.3); border: 2px solid #2A9D8F; border-radius: 5px; padding: 5px 10px; font-size: 11px; color: #2A9D8F; margin-bottom: 8px; text-align: center;">
                        üéÆ <span id="mpStatusText">Multiplayer</span>
                    </div>
                    <div id="diceRollDisplay" style="display: none; background: rgba(0,0,0,0.9); color: #FFD700; padding: 12px; border-radius: 8px; font-size: 18px; font-weight: bold; text-align: center; margin-bottom: 10px; border: 2px solid #FFD700;"></div>
                    <div id="battleActions">
                        <button class="battleButton attack-weak" onclick="battleAction('light')">‚öî LIGHT</button>
                        <button class="battleButton attack-strong" id="battleHeavyBtn" onclick="battleAction('heavy')">‚ö° HEAVY</button>
                        <button class="battleButton special" id="battleSpecialBtn" onclick="battleAction('special')">‚ú® SPECIAL</button>
                        <button class="battleButton defend" onclick="battleAction('defend')">üõ° DEFEND</button>
                        <button class="battleButton swap" onclick="battleAction('swap')">üîÑ SWAP</button>
                        <button class="battleButton taunt" onclick="battleAction('taunt')">üó£ TAUNT</button>
                        <button class="battleButton heal" onclick="battleAction('heal')">üíö HEAL</button>
                        <button class="battleButton" id="battleSkipBtn" onclick="battleAction('skip')">‚è≠ SKIP</button>
                        <button class="battleButton" onclick="battleAction('talk')">üí¨ TALK</button>
                        <button class="battleButton retreat" onclick="battleAction('retreat')">üèÉ RETREAT</button>
                    </div>
                </div>
                
                <!-- Right Hero Cards: Zancas & CyberAxe -->
                <div id="battleUIRight">
                    <div class="battleHeroCard" id="battleCardZancas">
                        <div class="battleHeroPortrait" style="background-image: url('people/Zancas_a_head_compressed.png'); border-color: #27AE60;"></div>
                        <div class="battleHeroName" style="color: #27AE60;">ZANCAS</div>
                        <div class="battleHeroStat" style="color: #ff6b6b;">HP: <span id="bzancas-hp">24</span>/<span id="bzancas-maxhp">26</span></div>
                        <div class="battleHeroStat">AC: <span id="bzancas-ac">15</span></div>
                        <div class="battleHeroStat" style="color: #FFD700;">XP: <span id="bzancas-xp">0</span></div>
                        <div class="battleHeroStat" style="color: #ff1744; font-size: 14px;" id="bzancas-heals">‚ù§Ô∏è ‚ù§Ô∏è</div>
                    </div>
                    <div class="battleHeroCard" id="battleCardCyberAxe">
                        <div class="battleHeroPortrait" style="background-image: url('people/cyberaxe_a_head_compressed.png'); border-color: #2E86DE;"></div>
                        <div class="battleHeroName" style="color: #2E86DE;">CYBERAXE</div>
                        <div class="battleHeroStat" style="color: #ff6b6b;">HP: <span id="bcyberaxe-hp">32</span>/<span id="bcyberaxe-maxhp">35</span></div>
                        <div class="battleHeroStat">AC: <span id="bcyberaxe-ac">15</span></div>
                        <div class="battleHeroStat" style="color: #FFD700;">XP: <span id="bcyberaxe-xp">0</span></div>
                        <div class="battleHeroStat" style="color: #ff1744; font-size: 14px;" id="bcyberaxe-heals">‚ù§Ô∏è ‚ù§Ô∏è</div>
                    </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="titleScreen">
            <!-- Story Intro Background Animation -->
            <div id="storyIntroBackground"></div>
            
            <div id="title">TUNNELS OF PRIVACY</div>
            <div id="subtitle">A Dungeon Crawler Adventure</div>
            
            <!-- Center Column - Level Display, Menu Buttons, Music Controls -->
            <div id="menuButtonsCenter">
                <div id="dungeonLevelDisplay">
                    <div style="color: #BFD1E0; font-size: 14px; margin-bottom: 5px;">Current Dungeon Depth</div>
                    <div style="color: #F2C94C; font-size: 36px; font-weight: 900; text-shadow: 0 0 20px rgba(242, 201, 76, 0.5);">LEVEL <span id="dungeonLevel">1</span></div>
                </div>
                
                <button id="startAdventureBtn" class="menuButton" onclick="startAdventure()">START ADVENTURE<span style="display: inline-block; width: 26px; height: 26px; background: #27AE60; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">A</span></button>
                <button id="continueBtn" class="menuButton comingSoon" disabled onclick="continueGame()">CONTINUE<span style="display: inline-block; width: 26px; height: 26px; background: #EB5757; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">A</span></button>
                <button class="menuButton" onclick="showLoadSave()">LOAD SAVE FILE<span style="display: inline-block; width: 26px; height: 26px; background: #3498DB; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">B</span></button>
                <button class="menuButton" onclick="showSettings()">SETTINGS<span style="display: inline-block; width: 26px; height: 26px; background: #2A9D8F; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">Y</span></button>
                <button class="menuButton portalButton" onclick="exitPortal()">EXIT PORTAL<br><span style="font-size: 10px; font-weight: 400;">(Return to Arcade)</span><span style="display: inline-block; padding: 4px 10px; background: #8B45FF; border-radius: 5px; margin-left: 10px; font-weight: bold; color: white; font-size: 12px;">BACK</span></button>
            </div>
            
            <div id="versionDisplay">Tunnels of Privacy v0.2.37 ‚Ä¢ Portal System Active</div>
            
            <!-- Multiplayer Controls (Bottom Right) -->
            <div style="position: absolute; bottom: 20px; right: 20px; display: flex; flex-direction: column; gap: 10px; align-items: flex-end; pointer-events: all; z-index: 100;">
                <!-- Create Room Button -->
                <button class="menuButton" onclick="createMultiplayerRoom()" style="padding: 10px 20px; font-size: 14px; margin: 0; pointer-events: all; background: linear-gradient(135deg, rgba(42, 157, 143, 0.4), rgba(42, 157, 143, 0.3)); border-color: #2A9D8F; white-space: nowrap;">üéÆ CREATE ROOM</button>
                
                <!-- Join Room -->
                <div style="display: flex; gap: 8px; align-items: center;">
                    <input type="text" id="titleJoinCode" placeholder="CODE" maxlength="6" onkeypress="if(event.key==='Enter') quickJoinRoom()" style="width: 140px; padding: 8px 10px; background: rgba(0,0,0,0.7); border: 2px solid #2A9D8F; border-radius: 5px; color: #F2C94C; font-size: 14px; text-align: center; letter-spacing: 2px; font-family: 'JetBrains Mono', monospace; text-transform: uppercase; pointer-events: all;">
                    <button class="menuButton" onclick="quickJoinRoom()" style="padding: 8px 12px; font-size: 13px; margin: 0; pointer-events: all; white-space: nowrap;">JOIN</button>
                </div>
            </div>
        </div>
        
        <!-- Network Debug Panel -->
        <div id="networkDebugPanel" style="display: none; position: fixed; top: 10px; right: 10px; width: 400px; max-height: 500px; overflow-y: auto; background: rgba(10, 14, 18, 0.95); border: 2px solid #2A9D8F; border-radius: 8px; padding: 15px; z-index: 150; font-family: 'JetBrains Mono', monospace; font-size: 11px;">
            <div style="font-size: 14px; font-weight: bold; color: #2A9D8F; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center;">
                <span>üåê NETWORK DEBUG</span>
                <button onclick="toggleNetworkDebug()" style="background: #EB5757; border: none; border-radius: 3px; color: white; padding: 3px 8px; cursor: pointer; font-size: 10px;">‚úï</button>
            </div>
            
            <div style="margin-bottom: 10px; padding: 8px; background: rgba(0,0,0,0.5); border-radius: 5px;">
                <div style="color: #89A0B4; margin-bottom: 5px;">Connection Status:</div>
                <div id="debugConnStatus" style="color: #F2C94C; font-weight: bold;">Disconnected</div>
            </div>
            
            <div style="margin-bottom: 10px; padding: 8px; background: rgba(0,0,0,0.5); border-radius: 5px;">
                <div style="color: #89A0B4; margin-bottom: 5px;">Room State:</div>
                <div id="debugRoomState" style="color: #2A9D8F;">No room</div>
            </div>
            
            <div style="margin-bottom: 10px;">
                <div style="color: #89A0B4; margin-bottom: 5px; display: flex; justify-content: space-between;">
                    <span>Message Log (Last 20):</span>
                    <button onclick="clearDebugLog()" style="background: #E74C3C; border: none; border-radius: 3px; color: white; padding: 2px 6px; cursor: pointer; font-size: 9px;">CLEAR</button>
                </div>
                <div id="debugMessageLog" style="max-height: 300px; overflow-y: auto; background: rgba(0,0,0,0.7); border: 1px solid #2A9D8F; border-radius: 5px; padding: 8px;"></div>
            </div>
        </div>
        
        <!-- Music Control Panel - Bottom Above Ticker (OUTSIDE titleScreen so always visible) -->
        <div id="musicControls">
            <h3 class="musicControlTitle">üéµ Music Controls</h3>
            
            <!-- Playback Controls -->
            <div style="display: flex; gap: 6px; justify-content: center; margin-bottom: 12px;">
                <button onclick="musicPrevious()" class="musicButton" style="padding: 8px 12px; width: auto;">‚èÆ</button>
                <button id="musicPlayPauseBtn" onclick="musicPlayPause()" class="musicButton" style="padding: 8px 16px; border-color: #F2C94C; width: auto;">‚ñ∂</button>
                <button onclick="musicNext()" class="musicButton" style="padding: 8px 12px; width: auto;">‚è≠</button>
            </div>
            
            <!-- Volume Control -->
            <div style="margin-bottom: 12px;">
                <label style="color: #BFD1E0; font-family: 'JetBrains Mono', monospace; font-size: 10px; display: block; margin-bottom: 4px; text-align: center;">Volume:</label>
                <div style="display: flex; align-items: center; gap: 8px; justify-content: center;">
                    <input type="range" class="volumeSlider" id="volumeSlider" min="1" max="150" value="75" oninput="updateVolume()" style="flex: 1; max-width: 200px;">
                    <span id="volumeSliderValue" style="color: #2D9CDB; font-family: 'JetBrains Mono', monospace; font-size: 10px; font-weight: bold; min-width: 30px; text-align: right;">75</span>
                </div>
            </div>
        </div>
        
        <!-- Music Ticker (OUTSIDE titleScreen so always visible) -->
        <div id="musicTicker">
            <div id="musicTickerWrapper">
                <span class="tickerText" id="musicTickerText1">‚ô´ Theme Song ‚ô´</span>
                <span class="tickerText" id="musicTickerText2">‚ô´ Theme Song ‚ô´</span>
            </div>
        </div>
    </div>
    
    <!-- Pause Screen -->
    <div id="pauseScreen">
        <div id="pauseTitle">PAUSED</div>
        <button class="menuButton" onclick="resumeGame()">RESUME<span style="display: inline-block; width: 26px; height: 26px; background: #E74C3C; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">B</span></button>
        <button class="menuButton" onclick="saveGameFromPause()" style="background: linear-gradient(135deg, rgba(46, 134, 222, 0.4), rgba(46, 134, 222, 0.3)); border-color: #3498DB;">SAVE GAME<span style="display: inline-block; width: 26px; height: 26px; background: #3498DB; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">üíæ</span></button>
        <button class="menuButton" onclick="downloadSaveFile()" style="background: linear-gradient(135deg, rgba(39, 174, 96, 0.4), rgba(39, 174, 96, 0.3)); border-color: #27AE60;">SAVE GAME FILE<span style="display: inline-block; width: 26px; height: 26px; background: #27AE60; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">‚¨á</span></button>
        <button class="menuButton" onclick="showSettingsFromPause()">SETTINGS<span style="display: inline-block; width: 26px; height: 26px; background: #F39C12; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">Y</span></button>
        <button class="menuButton" id="hostControlsBtn" onclick="showHostControls()" style="display: none; background: linear-gradient(135deg, rgba(42, 157, 143, 0.4), rgba(42, 157, 143, 0.3)); border-color: #2A9D8F;">HOST CONTROLS<span style="display: inline-block; width: 26px; height: 26px; background: #2A9D8F; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">üéÆ</span></button>
        <button class="menuButton" onclick="quitToMenu()">QUIT TO MENU<span style="display: inline-block; padding: 4px 10px; background: #555; border-radius: 5px; margin-left: 10px; font-weight: bold; color: white; font-size: 12px;">‚óÄ</span></button>
    </div>
    
    <!-- Hero Selection Modal (Multiplayer) -->
    <div id="heroSelectionModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.95); z-index: 300; pointer-events: all;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; max-width: 1000px; width: 95%;">
            <div style="color: #2A9D8F; font-size: 32px; font-weight: 900; margin-bottom: 15px; text-shadow: 0 0 20px rgba(42, 157, 143, 0.5);">SELECT YOUR HERO</div>
            
            <!-- Player Name Input -->
            <div style="margin-bottom: 15px;">
                <input type="text" id="playerNameInput" placeholder="Enter your name..." maxlength="20" style="width: 300px; padding: 10px 15px; background: rgba(0,0,0,0.7); border: 2px solid #2A9D8F; border-radius: 5px; color: #F2C94C; font-size: 16px; text-align: center; font-family: 'JetBrains Mono', monospace;" oninput="updatePlayerName()">
            </div>
            
            <!-- Room Info Bar -->
            <div style="margin-bottom: 20px; display: flex; justify-content: center; align-items: center; gap: 20px; flex-wrap: wrap;">
                <div style="background: rgba(42, 157, 143, 0.2); padding: 8px 16px; border-radius: 8px; border: 2px solid #2A9D8F;">
                    <span style="color: #89A0B4; font-size: 11px; margin-right: 8px;">ROOM:</span>
                    <span id="heroSelectionCode" style="color: #F2C94C; font-size: 18px; font-weight: bold; letter-spacing: 3px; font-family: 'JetBrains Mono', monospace;">------</span>
                    <button onclick="toggleRoomCodeVisibility()" style="background: none; border: none; color: #2A9D8F; cursor: pointer; font-size: 14px; margin-left: 8px; padding: 0;">üëÅ</button>
                </div>
                <div style="background: rgba(42, 157, 143, 0.2); padding: 8px 16px; border-radius: 8px; border: 2px solid #2A9D8F;">
                    <span style="color: #89A0B4; font-size: 11px; margin-right: 8px;">PLAYERS:</span>
                    <span id="playerCountDisplay" style="color: #F2C94C; font-size: 18px; font-weight: bold;">1/4</span>
                </div>
            </div>
            
            <!-- Connected Players List -->
            <div id="connectedPlayersList" style="margin-bottom: 20px; padding: 15px; background: rgba(0,0,0,0.5); border-radius: 8px; border: 2px solid #2A9D8F; max-height: 120px; overflow-y: auto;">
                <div style="color: #89A0B4; font-size: 12px; margin-bottom: 10px; text-transform: uppercase;">Connected Players:</div>
                <div id="playersListContent" style="display: flex; flex-wrap: wrap; gap: 10px; justify-content: center;">
                    <!-- Dynamically populated -->
                </div>
            </div>
            
            <div id="heroSelectionGrid" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; margin-bottom: 20px;">
                <!-- Zooko -->
                <div class="heroSelectCard" data-hero="zooko" onclick="selectHero('zooko')" style="cursor: pointer; padding: 20px; background: linear-gradient(135deg, rgba(242, 201, 76, 0.2), rgba(242, 201, 76, 0.1)); border: 3px solid #F2C94C; border-radius: 12px; transition: all 0.3s;">
                    <div style="width: 120px; height: 120px; margin: 0 auto 15px; background-image: url('people/zooko_a_head_compressed.png'); background-size: cover; background-position: center; border-radius: 50%; border: 3px solid #F2C94C;"></div>
                    <div style="color: #F2C94C; font-size: 18px; font-weight: bold;">ZOOKO</div>
                    <div class="heroPlayerLabel" style="display: none; color: #2A9D8F; font-size: 11px; margin-top: 5px; font-style: italic;"></div>
                    <div class="heroTakenLabel" style="display: none; color: #EB5757; font-size: 12px; margin-top: 5px;">TAKEN</div>
                </div>
                <!-- Nate -->
                <div class="heroSelectCard" data-hero="nate" onclick="selectHero('nate')" style="cursor: pointer; padding: 20px; background: linear-gradient(135deg, rgba(231, 76, 60, 0.2), rgba(231, 76, 60, 0.1)); border: 3px solid #E74C3C; border-radius: 12px; transition: all 0.3s;">
                    <div style="width: 120px; height: 120px; margin: 0 auto 15px; background-image: url('people/Nate_a_head_compressed.png'); background-size: cover; background-position: center; border-radius: 50%; border: 3px solid #E74C3C;"></div>
                    <div style="color: #E74C3C; font-size: 18px; font-weight: bold;">NATE</div>
                    <div class="heroPlayerLabel" style="display: none; color: #2A9D8F; font-size: 11px; margin-top: 5px; font-style: italic;"></div>
                    <div class="heroTakenLabel" style="display: none; color: #EB5757; font-size: 12px; margin-top: 5px;">TAKEN</div>
                </div>
                <!-- Zancas -->
                <div class="heroSelectCard" data-hero="zancas" onclick="selectHero('zancas')" style="cursor: pointer; padding: 20px; background: linear-gradient(135deg, rgba(39, 174, 96, 0.2), rgba(39, 174, 96, 0.1)); border: 3px solid #27AE60; border-radius: 12px; transition: all 0.3s;">
                    <div style="width: 120px; height: 120px; margin: 0 auto 15px; background-image: url('people/Zancas_a_head_compressed.png'); background-size: cover; background-position: center; border-radius: 50%; border: 3px solid #27AE60;"></div>
                    <div style="color: #27AE60; font-size: 18px; font-weight: bold;">ZANCAS</div>
                    <div class="heroPlayerLabel" style="display: none; color: #2A9D8F; font-size: 11px; margin-top: 5px; font-style: italic;"></div>
                    <div class="heroTakenLabel" style="display: none; color: #EB5757; font-size: 12px; margin-top: 5px;">TAKEN</div>
                </div>
                <!-- CyberAxe -->
                <div class="heroSelectCard" data-hero="cyberaxe" onclick="selectHero('cyberaxe')" style="cursor: pointer; padding: 20px; background: linear-gradient(135deg, rgba(46, 134, 222, 0.2), rgba(46, 134, 222, 0.1)); border: 3px solid #2E86DE; border-radius: 12px; transition: all 0.3s;">
                    <div style="width: 120px; height: 120px; margin: 0 auto 15px; background-image: url('people/cyberaxe_a_head_compressed.png'); background-size: cover; background-position: center; border-radius: 50%; border: 3px solid #2E86DE;"></div>
                    <div style="color: #2E86DE; font-size: 18px; font-weight: bold;">CYBERAXE</div>
                    <div class="heroPlayerLabel" style="display: none; color: #2A9D8F; font-size: 11px; margin-top: 5px; font-style: italic;"></div>
                    <div class="heroTakenLabel" style="display: none; color: #EB5757; font-size: 12px; margin-top: 5px;">TAKEN</div>
                </div>
            </div>
            <div id="heroWaitingMessage" style="color: #89A0B4; font-size: 14px; margin-bottom: 15px;">Click heroes to select. Players can select multiple heroes.</div>
            <div id="gameStartOptions" style="display: none; margin-bottom: 15px;">
                <div style="color: #F2C94C; font-size: 16px; margin-bottom: 15px; font-weight: bold;">All heroes selected! Choose how to start:</div>
                <div style="display: flex; flex-direction: column; gap: 10px; max-width: 400px; margin: 0 auto;">
                    <button class="menuButton" onclick="continueGame()" style="padding: 15px; font-size: 14px; background: linear-gradient(135deg, rgba(42, 157, 143, 0.4), rgba(42, 157, 143, 0.3)); border-color: #2A9D8F;">CONTINUE</button>
                    <button class="menuButton" onclick="loadSaveGame()" style="padding: 15px; font-size: 14px; background: linear-gradient(135deg, rgba(46, 134, 222, 0.4), rgba(46, 134, 222, 0.3)); border-color: #2E86DE;">LOAD SAVE GAME</button>
                    <button class="menuButton" onclick="startNewAdventure()" style="padding: 15px; font-size: 14px; background: linear-gradient(135deg, rgba(242, 201, 76, 0.4), rgba(242, 201, 76, 0.3)); border-color: #F2C94C;">START NEW ADVENTURE</button>
                    <div style="color: #EB5757; font-size: 12px; font-style: italic; margin-top: 5px;">‚ö† Starting new adventure replaces local save</div>
                </div>
            </div>
            <div style="display: flex; gap: 15px; justify-content: center;">
                <button class="menuButton" onclick="cancelHeroSelection()" style="padding: 12px 30px; font-size: 14px; background: linear-gradient(135deg, rgba(235, 87, 87, 0.4), rgba(235, 87, 87, 0.3)); border-color: #EB5757;">BACK</button>
            </div>
        </div>
    </div>
    
    <!-- Host Controls Panel -->
    <div id="hostControlsPanel" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9)); border: 2px solid #2A9D8F; border-radius: 12px; padding: 25px; max-width: 500px; width: 85vw; z-index: 300; pointer-events: all; box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8); backdrop-filter: blur(10px);">
        <div class="panelTitle" style="color: #2A9D8F;">üéÆ HOST CONTROLS</div>
        <div id="playerList" style="margin: 20px 0; max-height: 300px; overflow-y: auto;">
            <!-- Dynamically populated -->
        </div>
        <div style="display: flex; gap: 10px; margin-top: 20px;">
            <button class="menuButton" onclick="changeRoomCodeFromPanel()" style="flex: 1; padding: 10px; font-size: 13px;">CHANGE CODE</button>
            <button class="menuButton" onclick="closeHostControls()" style="flex: 1; padding: 10px; font-size: 13px; background: linear-gradient(135deg, rgba(235, 87, 87, 0.4), rgba(235, 87, 87, 0.3)); border-color: #EB5757;">CLOSE</button>
        </div>
    </div>
    
    <!-- Confirmation Modal -->
    <div id="confirmationModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); z-index: 400; pointer-events: all;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; background: linear-gradient(135deg, rgba(26, 26, 46, 0.95), rgba(13, 13, 26, 0.95)); border: 3px solid #F2C94C; border-radius: 15px; padding: 40px 60px; box-shadow: 0 10px 50px rgba(0, 0, 0, 0.9);">
            <div id="confirmationTitle" style="color: #F2C94C; font-size: 28px; font-weight: 900; margin-bottom: 20px; text-shadow: 0 0 15px rgba(242, 201, 76, 0.5); text-transform: uppercase; letter-spacing: 2px;">CONFIRM ACTION</div>
            <div id="confirmationMessage" style="color: #89A0B4; font-size: 16px; margin-bottom: 30px; line-height: 1.5;">Are you sure?</div>
            <div style="display: flex; gap: 20px; justify-content: center;">
                <button onclick="confirmModalAction(true)" style="padding: 12px 30px; font-size: 16px; font-weight: bold; background: linear-gradient(135deg, rgba(46, 204, 113, 0.4), rgba(39, 174, 96, 0.4)); border: 2px solid #27AE60; border-radius: 8px; color: #FFFFFF; cursor: pointer; text-transform: uppercase; letter-spacing: 1px; transition: all 0.2s;">YES</button>
                <button onclick="confirmModalAction(false)" style="padding: 12px 30px; font-size: 16px; font-weight: bold; background: linear-gradient(135deg, rgba(231, 76, 60, 0.4), rgba(192, 57, 43, 0.4)); border: 2px solid #E74C3C; border-radius: 8px; color: #FFFFFF; cursor: pointer; text-transform: uppercase; letter-spacing: 1px; transition: all 0.2s;">CANCEL</button>
            </div>
        </div>
    </div>
    
    <!-- Overlay for modal panels -->
    <div id="overlay" onclick="closeAllPanels()"></div>
    
    <!-- Settings Panel -->
    <div id="settingsPanel">
        <div class="panelTitle">SETTINGS</div>
        
        <!-- Music Controls -->
        <div class="settingRow" style="margin-bottom: 10px;">
            <span class="settingLabel" style="font-size: 16px;">Music Enabled</span>
            <input type="checkbox" id="musicEnabled" checked onchange="updateSettings()">
        </div>
        
        <div class="settingRow" style="margin-bottom: 15px;">
            <span class="settingLabel" style="font-size: 16px;">Music Volume</span>
            <input type="range" id="musicVolume" min="1" max="150" value="75" oninput="updateSettings()" style="width: 150px;">
            <span id="musicVolumeValue" style="margin-left: 8px; font-weight: bold; color: #2D9CDB; font-size: 14px;">75</span>
        </div>
        
        <!-- Hitbox Toggle -->
        <div class="settingRow" style="margin-bottom: 15px;">
            <span class="settingLabel" style="font-size: 16px;">Show Hitboxes</span>
            <input type="checkbox" id="showHitboxes" onchange="updateSettings()">
        </div>
        
        <!-- Network Debug Toggle -->
        <div class="settingRow" style="margin-bottom: 15px;">
            <span class="settingLabel" style="font-size: 16px;">Network Debug</span>
            <input type="checkbox" id="networkDebug" onchange="toggleNetworkDebug()">
        </div>
        
        <div style="margin: 10px 0; padding: 10px; background: rgba(42, 157, 143, 0.1); border-radius: 5px; font-size: 11px; color: #89A0B4;">
            üí° Settings are saved independently for Tunnels of Privacy
        </div>
        
        <button class="menuButton" onclick="clearCache()" style="margin-top: 15px; width: 100%; padding: 12px; font-size: 14px; background: linear-gradient(135deg, rgba(235, 87, 87, 0.4), rgba(235, 87, 87, 0.3)); border-color: #EB5757;">CLEAR CACHE<span style="display: inline-block; width: 26px; height: 26px; background: #EB5757; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">X</span></button>
        <button class="menuButton" onclick="closeAllPanels()" style="margin-top: 15px; width: 100%; padding: 12px; font-size: 14px;">CLOSE<span style="display: inline-block; width: 26px; height: 26px; background: #E74C3C; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">B</span></button>
        
        <div style="display: block; width: 100%; margin-top: 15px; padding: 10px 0; text-align: center; font-family: 'JetBrains Mono', monospace; font-size: 11px; color: #5A7A8F; border-top: 1px solid rgba(255, 255, 255, 0.1);">
            Tunnels of Privacy v0.2.37
        </div>
    </div>
    
    <!-- Load Save Panel -->
    <div id="loadSavePanel" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9)); border: 2px solid #3498DB; border-radius: 12px; padding: 25px; max-width: 600px; width: 85vw; z-index: 200; pointer-events: all; box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8); backdrop-filter: blur(10px);">
        <div class="panelTitle" style="color: #3498DB;">LOAD SAVE FILE</div>
        
        <div style="margin: 15px 0; padding: 15px; background: rgba(52, 152, 219, 0.1); border-radius: 8px; border: 1px solid rgba(52, 152, 219, 0.3);">
            <div style="color: #BFD1E0; font-family: 'JetBrains Mono', monospace; font-size: 12px; margin-bottom: 10px;">
                üì• Import save file from arcade game or previous dungeon run
            </div>
            <input type="file" id="saveFileInput" accept=".json" style="display: block; width: 100%; padding: 10px; background: rgba(10, 14, 18, 0.8); border: 2px solid #3498DB; border-radius: 6px; color: #E9F0F7; font-family: 'JetBrains Mono', monospace; font-size: 12px; cursor: pointer; margin-bottom: 10px;">
            <button class="menuButton" onclick="loadSaveFile()" style="width: 100%; margin: 0;">LOAD FILE<span style="display: inline-block; width: 26px; height: 26px; background: #27AE60; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">A</span></button>
        </div>
        
        <div style="margin: 15px 0; padding: 10px; background: rgba(241, 196, 15, 0.1); border-radius: 5px; font-size: 11px; color: #89A0B4;">
            üí° You can export save files from the arcade game's settings menu. This allows you to continue your adventure with the same hero stats and progress.
        </div>
        
        <button class="menuButton" onclick="closeAllPanels()" style="margin-top: 15px; width: 100%; padding: 12px; font-size: 14px;">CLOSE<span style="display: inline-block; width: 26px; height: 26px; background: #E74C3C; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">B</span></button>
    </div>

    <script>
        // Portal System - localStorage keys with "top_" prefix
        const STORAGE_KEYS = {
            SETTINGS: 'top_tunnels_settings',
            SHARED_SAVE: 'top_shared_save'
        };
        
        const GAME_VERSION = 'v0.2.37';
        
        // ===== MULTIPLAYER STATE =====
        let multiplayerState = {
            enabled: false,
            role: null, // 'host' or 'client'
            roomCode: null,
            ws: null,
            myHeroes: [], // Array of hero names this player controls
            myPlayerId: null,
            playerName: 'Player',
            playerHeroes: {}, // { hero_name: { playerId, playerName } }
            connectedPlayers: [], // [ { id, hero, name } ]
            isReconnecting: false
        };
        
        // ===== GAMEPAD SUPPORT =====
        let gamepadConnected = false;
        let gamepadIndex = null;
        let gamepadButtonStates = {};
        let gamepadAxisDeadzone = 0.25;
        let lastGamepadUpdate = 0;
        const gamepadUpdateInterval = 16; // ~60Hz polling
        
        // Button mapping (standard gamepad layout)
        const GamepadButtons = {
            A: 0,           // Bottom face button (A on Xbox, X on PlayStation)
            B: 1,           // Right face button (B on Xbox, Circle on PlayStation)
            X: 2,           // Left face button (X on Xbox, Square on PlayStation)
            Y: 3,           // Top face button (Y on Xbox, Triangle on PlayStation)
            LB: 4,          // Left bumper
            RB: 5,          // Right bumper
            LT: 6,          // Left trigger
            RT: 7,          // Right trigger
            SELECT: 8,      // Select/Back/Share
            START: 9,       // Start/Menu/Options
            L3: 10,         // Left stick button
            R3: 11,         // Right stick button
            DPAD_UP: 12,
            DPAD_DOWN: 13,
            DPAD_LEFT: 14,
            DPAD_RIGHT: 15
        };
        
        // Axis mapping
        const GamepadAxes = {
            LEFT_X: 0,
            LEFT_Y: 1,
            RIGHT_X: 2,
            RIGHT_Y: 3
        };
        // ===== END GAMEPAD SUPPORT =====
        
        // Music System
        let currentMusic = null;
        let musicEnabled = true;
        let musicVolume = 75; // Music volume (1-150)
        let musicStarted = false;
        let currentTrackIndex = 0;
        
        // Asset loading tracking
        let assetsToLoad = 0;
        let assetsLoaded = 0;
        let artTotal = 0;
        let artLoaded = 0;
        let audioTotal = 0;
        let audioLoaded = 0;
        let allAssetsReady = false;
        
        // Ticker facts system
        let tickerFacts = [];
        let currentTickerFact = '';
        
        // Game state
        let isPaused = false;
        let currentScreen = 'title'; // 'title', 'dungeonMenu', 'exploration'
        
        // Load ticker facts from JSON file
        fetch('ticker_facts.json')
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                tickerFacts = data.facts;
                
                // Pick initial random fact
                if (tickerFacts.length > 0) {
                    currentTickerFact = tickerFacts[Math.floor(Math.random() * tickerFacts.length)];
                }
            })
            .catch(err => {});
        
        // ===== STORY INTRO BACKGROUND ANIMATION =====
        // intro_a.png is 8x16 atlas (128 frames) at 16fps
        let storyIntroCurrentFrame = 0;
        let storyIntroDirection = 1; // 1 = forward, -1 = backward (ping-pong)
        let storyIntroIntervalId = null;
        const INTRO_COLS = 8;
        const INTRO_ROWS = 16;
        const INTRO_TOTAL_FRAMES = 128;
        const INTRO_FPS = 16;
        
        function startStoryIntroAnimation() {
            const bgElement = document.getElementById('storyIntroBackground');
            if (!bgElement) return;
            
            // Use dungeon intro animation
            const imageFile = 'story/intro/intro_a.png';
            
            // Set intro_a atlas as background
            bgElement.style.backgroundImage = `url('${imageFile}')`;
            bgElement.style.backgroundSize = `${INTRO_COLS * 100}% ${INTRO_ROWS * 100}%`;
            bgElement.style.opacity = '1';
            
            // Start frame animation at 16fps
            const frameInterval = 1000 / INTRO_FPS; // ~62.5ms per frame
            storyIntroIntervalId = window.setInterval(() => {
                // Calculate current frame position in atlas
                const col = storyIntroCurrentFrame % INTRO_COLS;
                const row = Math.floor(storyIntroCurrentFrame / INTRO_COLS);
                
                // Set background position to show current frame
                const xPercent = (col / (INTRO_COLS - 1)) * 100;
                const yPercent = (row / (INTRO_ROWS - 1)) * 100;
                bgElement.style.backgroundPosition = `${xPercent}% ${yPercent}%`;
                
                // Advance frame with ping-pong
                storyIntroCurrentFrame += storyIntroDirection;
                
                // Reverse at boundaries (ping-pong mode)
                if (storyIntroCurrentFrame >= INTRO_TOTAL_FRAMES - 1) {
                    storyIntroCurrentFrame = INTRO_TOTAL_FRAMES - 1;
                    storyIntroDirection = -1;
                } else if (storyIntroCurrentFrame <= 0) {
                    storyIntroCurrentFrame = 0;
                    storyIntroDirection = 1;
                }
            }, frameInterval);
        }
        
        function stopStoryIntroAnimation() {
            if (storyIntroIntervalId) {
                window.clearInterval(storyIntroIntervalId);
                storyIntroIntervalId = null;
            }
        }
        // ===== END STORY INTRO BACKGROUND ANIMATION =====
        
        const themeTracks = [
            { file: 'music/theme_a.webm', name: 'Electric Coin Company' },
            { file: 'music/theme_b.webm', name: 'Zcash Foundation' },
            { file: 'music/theme_c_boss.webm', name: 'Proof of Work Battle' },
            { file: 'music/theme_d.webm', name: 'ZecWallet Lite' },
            { file: 'music/theme_e.webm', name: 'Private by Default' },
            { file: 'music/theme_f.webm', name: 'Halo Arc Dreams' },
            { file: 'music/theme_g.webm', name: 'Mining the Future' },
            { file: 'music/theme_h.webm', name: 'zkSNARK Symphony' },
            { file: 'music/theme_i.webm', name: 'Trusted Setup Ceremony' },
            { file: 'music/theme_j.webm', name: 'Shielded Sunset' }
        ];
        
        function loadMusic(trackData) {
            if (!musicEnabled) return;
            
            // Check if we're already playing this track
            if (currentMusic && currentMusic.src.endsWith(trackData.file)) {
                return; // Don't restart the same track
            }
            
            // Update music ticker with track name
            const tickerText1 = document.getElementById('musicTickerText1');
            const tickerText2 = document.getElementById('musicTickerText2');
            if (tickerText1 && tickerText2 && trackData.name) {
                // Pick a new random fact each time track changes
                if (tickerFacts.length > 0) {
                    currentTickerFact = tickerFacts[Math.floor(Math.random() * tickerFacts.length)];
                }
                
                const musicInfo = `‚ô´ Theme Song: ${trackData.name} ‚ô´`;
                
                // Combine music info with fun fact
                const finalText = currentTickerFact ? `${musicInfo}  ‚Ä¢  ${currentTickerFact}` : musicInfo;
                tickerText1.textContent = finalText;
                tickerText2.textContent = finalText;
            }
            
            // Use musicVolume divided by 100 (1-150 scale), clamped to max 1.0
            const volumeScale = Math.min(1.0, musicVolume / 100);
            
            // Create new audio element
            const newMusic = new Audio(trackData.file);
            newMusic.loop = false;
            newMusic.volume = 0; // Start silent
            
            // When song ends, play next random track
            newMusic.addEventListener('ended', () => {
                if (!musicEnabled) return;
                const randomTrack = themeTracks[Math.floor(Math.random() * themeTracks.length)];
                loadMusic(randomTrack);
            });
            
            // Fade in new track
            newMusic.play().then(() => {
                fadeMusic(newMusic, 0, volumeScale, 1000);
                musicStarted = true;
                updateMusicButton();
            }).catch(err => {
                console.log('Music autoplay blocked:', err);
            });
            
            // Fade out old track
            if (currentMusic) {
                const oldMusic = currentMusic;
                fadeMusic(oldMusic, oldMusic.volume, 0, 1000, () => {
                    oldMusic.pause();
                    oldMusic.src = '';
                });
            }
            
            currentMusic = newMusic;
        }
        
        function fadeMusic(audioElement, startVol, endVol, duration, callback) {
            const steps = 20;
            const stepTime = duration / steps;
            const volStep = (endVol - startVol) / steps;
            let currentStep = 0;
            
            const fadeInterval = setInterval(() => {
                currentStep++;
                const newVol = startVol + (volStep * currentStep);
                audioElement.volume = Math.max(0, Math.min(1, newVol));
                
                if (currentStep >= steps) {
                    clearInterval(fadeInterval);
                    audioElement.volume = Math.max(0, Math.min(1.5, endVol));
                    if (callback) callback();
                }
            }, stepTime);
        }
        
        // Music Control Functions
        function musicPlayPause() {
            const btn = document.getElementById('musicPlayPauseBtn');
            
            if (!currentMusic) {
                // No music loaded yet, start the music system
                musicEnabled = true;
                const randomTrack = themeTracks[Math.floor(Math.random() * themeTracks.length)];
                loadMusic(randomTrack);
                if (btn) btn.textContent = '‚è∏';
                return;
            }
            
            if (currentMusic.paused) {
                currentMusic.play().catch(err => console.log('Play error:', err));
                musicEnabled = true;
                if (btn) btn.textContent = '‚è∏';
            } else {
                currentMusic.pause();
                musicEnabled = false;
                if (btn) btn.textContent = '‚ñ∂';
            }
        }
        
        function musicPrevious() {
            if (currentMusic) {
                currentMusic.pause();
            }
            
            musicEnabled = true; // Enable music if it was paused
            const randomTrack = themeTracks[Math.floor(Math.random() * themeTracks.length)];
            loadMusic(randomTrack);
        }
        
        function musicNext() {
            if (currentMusic) {
                currentMusic.pause();
            }
            
            musicEnabled = true; // Enable music if it was paused
            const randomTrack = themeTracks[Math.floor(Math.random() * themeTracks.length)];
            loadMusic(randomTrack);
        }
        
        function updateMusicButton() {
            const btn = document.getElementById('musicPlayPauseBtn');
            if (btn) {
                if (currentMusic && !currentMusic.paused) {
                    btn.textContent = '‚è∏';
                } else {
                    btn.textContent = '‚ñ∂';
                }
            }
        }
        
        function updateVolume() {
            const slider = document.getElementById('volumeSlider');
            if (!slider) return;
            
            musicVolume = parseInt(slider.value);
            
            // Update settings object
            settings.musicVolume = musicVolume;
            
            // Update volume display
            const volumeDisplay = document.getElementById('volumeSliderValue');
            if (volumeDisplay) {
                volumeDisplay.textContent = musicVolume;
            }
            
            // Update settings panel slider if open
            const settingsSlider = document.getElementById('musicVolume');
            if (settingsSlider) {
                settingsSlider.value = musicVolume;
            }
            const settingsVolumeDisplay = document.getElementById('musicVolumeValue');
            if (settingsVolumeDisplay) {
                settingsVolumeDisplay.textContent = musicVolume;
            }
            
            if (currentMusic) {
                currentMusic.volume = Math.min(1.0, musicVolume / 100);
            }
            
            // Save to localStorage
            saveSettings();
        }
        
        // Settings System
        let settings = {
            musicEnabled: true,
            musicVolume: 75,
            showHitboxes: false
        };
        
        function showSettings() {
            document.getElementById('overlay').style.display = 'block';
            document.getElementById('settingsPanel').style.display = 'block';
            
            // Load current settings into UI
            document.getElementById('musicEnabled').checked = settings.musicEnabled;
            document.getElementById('musicVolume').value = settings.musicVolume;
            document.getElementById('musicVolumeValue').textContent = settings.musicVolume;
            document.getElementById('showHitboxes').checked = settings.showHitboxes;
        }
        
        function updateSettings() {
            // Read values from UI
            settings.musicEnabled = document.getElementById('musicEnabled').checked;
            settings.musicVolume = parseInt(document.getElementById('musicVolume').value);
            settings.showHitboxes = document.getElementById('showHitboxes').checked;
            
            // Update display
            document.getElementById('musicVolumeValue').textContent = settings.musicVolume;
            
            // Apply to game state
            musicEnabled = settings.musicEnabled;
            musicVolume = settings.musicVolume;
            
            // Re-render battle if active to show/hide hitboxes
            if (battleState.active) {
                renderBattle();
            }
            
            // Handle music enable/disable
            if (currentMusic) {
                if (musicEnabled) {
                    // Enable: Resume if paused
                    if (currentMusic.paused) {
                        currentMusic.play().catch(err => console.log('Play error:', err));
                    }
                    currentMusic.volume = Math.min(1.0, musicVolume / 100);
                } else {
                    // Disable: Pause music
                    currentMusic.pause();
                }
            }
            
            // Update volume slider in main controls
            const mainSlider = document.getElementById('volumeSlider');
            if (mainSlider) {
                mainSlider.value = musicVolume;
            }
            
            // Update play/pause button
            updateMusicButton();
            
            // Save to localStorage
            saveSettings();
        }
        
        function closeAllPanels() {
            document.getElementById('overlay').style.display = 'none';
            document.getElementById('settingsPanel').style.display = 'none';
            const loadSavePanel = document.getElementById('loadSavePanel');
            if (loadSavePanel) {
                loadSavePanel.style.display = 'none';
            }
        }
        
        function showLoadSave() {
            document.getElementById('overlay').style.display = 'block';
            const loadSavePanel = document.getElementById('loadSavePanel');
            if (loadSavePanel) {
                loadSavePanel.style.display = 'block';
            }
        }
        
        function loadSaveFile() {
            const fileInput = document.getElementById('saveFileInput');
            const file = fileInput.files[0];
            
            if (!file) {
                alert('Please select a save file first!');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const saveData = JSON.parse(e.target.result);
                    
                    // Validate save data structure
                    if (!saveData || !saveData.heroes) {
                        alert('Invalid save file format! Missing hero data.');
                        return;
                    }
                    
                    // Save to localStorage
                    if (saveSharedSave(saveData)) {
                        alert('Save file loaded successfully!');
                        
                        // Refresh hero displays
                        if (saveData.heroes.zooko) updateHeroDisplay('zooko', saveData.heroes.zooko);
                        if (saveData.heroes.nate) updateHeroDisplay('nate', saveData.heroes.nate);
                        if (saveData.heroes.zancas) updateHeroDisplay('zancas', saveData.heroes.zancas);
                        if (saveData.heroes.cyberaxe) updateHeroDisplay('cyberaxe', saveData.heroes.cyberaxe);
                        
                        // Update dungeon level if arcade state exists
                        if (saveData.arcadeState && saveData.arcadeState.level) {
                            document.getElementById('dungeonLevel').textContent = saveData.arcadeState.level;
                        }
                        
                        // Update title screen buttons
                        updateTitleScreenButtons();
                        
                        // Close panel
                        closeAllPanels();
                        
                        // Clear file input
                        fileInput.value = '';
                    } else {
                        alert('Failed to save the loaded data to localStorage.');
                    }
                } catch (error) {
                    alert('Error reading save file: ' + error.message);
                    console.error('Save file load error:', error);
                }
            };
            
            reader.onerror = function() {
                alert('Error reading file!');
            };
            
            reader.readAsText(file);
        }
        
        function saveSettings() {
            try {
                localStorage.setItem(STORAGE_KEYS.SETTINGS, JSON.stringify(settings));
            } catch (e) {
                console.error('Failed to save settings:', e);
            }
        }
        
        function loadSettings() {
            try {
                const saved = localStorage.getItem(STORAGE_KEYS.SETTINGS);
                if (saved) {
                    const loaded = JSON.parse(saved);
                    settings = { ...settings, ...loaded };
                    
                    // Apply to game state
                    musicEnabled = settings.musicEnabled;
                    musicVolume = settings.musicVolume;
                    
                    // Update main volume slider and display
                    const mainSlider = document.getElementById('volumeSlider');
                    if (mainSlider) {
                        mainSlider.value = musicVolume;
                    }
                    const volumeDisplay = document.getElementById('volumeSliderValue');
                    if (volumeDisplay) {
                        volumeDisplay.textContent = musicVolume;
                    }
                }
            } catch (e) {
                console.error('Failed to load settings:', e);
            }
        }
        
        // Load shared save and populate hero stats
        function loadSharedSave() {
            try {
                const saved = localStorage.getItem(STORAGE_KEYS.SHARED_SAVE);
                if (!saved) return null;
                
                const sharedSave = JSON.parse(saved);
                return migrateSharedSave(sharedSave);
            } catch (e) {
                console.error('Failed to load shared save:', e);
                return null;
            }
        }
        
        // Save shared save to localStorage
        function saveSharedSave(sharedSave) {
            try {
                const jsonString = JSON.stringify(sharedSave);
                localStorage.setItem(STORAGE_KEYS.SHARED_SAVE, jsonString);
                console.log('Shared save written. Size:', jsonString.length, 'bytes');
                return true;
            } catch (e) {
                console.error('Failed to save shared save:', e);
                return false;
            }
        }
        
        // Migrate shared save between versions
        function migrateSharedSave(sharedSave) {
            // Currently at version 1, no migrations needed yet
            return sharedSave;
        }
        
        // Creates default shared save with initial hero stats
        function createDefaultSharedSave() {
            return {
                saveVersion: 1,
                lastPlayed: Date.now(),
                arcadeState: null,
                dungeonState: {
                    currentLevel: 1,
                    inventory: [],
                    gold: 0,
                    questProgress: {
                        hasScepter: false,
                        hasReturned: false,
                        bossesDefeated: []
                    }
                },
                heroes: {
                    zooko: {
                        name: 'Zooko',
                        str: 8, dex: 11, con: 10, int: 15, wis: 13, cha: 9,
                        hp: 22, maxHp: 25, ac: 12, xp: 0, level: 1
                    },
                    nate: {
                        name: 'Nate',
                        str: 14, dex: 12, con: 13, int: 10, wis: 9, cha: 11,
                        hp: 28, maxHp: 30, ac: 14, xp: 0, level: 1
                    },
                    zancas: {
                        name: 'Zancas',
                        str: 10, dex: 15, con: 11, int: 12, wis: 14, cha: 8,
                        hp: 24, maxHp: 26, ac: 13, xp: 0, level: 1
                    },
                    cyberaxe: {
                        name: 'CyberAxe',
                        str: 16, dex: 10, con: 14, int: 8, wis: 11, cha: 10,
                        hp: 32, maxHp: 35, ac: 15, xp: 0, level: 1
                    }
                }
            };
        }
        
        // Clear cache - deletes all localStorage data and forces hard reload
        function clearCache() {
            if (confirm('This will delete ALL saved data including your progress. Are you sure?')) {
                try {
                    localStorage.removeItem(STORAGE_KEYS.SETTINGS);
                    localStorage.removeItem(STORAGE_KEYS.SHARED_SAVE);
                    
                    // Clear browser cache for images and assets
                    if ('caches' in window) {
                        caches.keys().then(function(names) {
                            for (let name of names) caches.delete(name);
                        });
                    }
                    
                    alert('Cache cleared! The page will reload with fresh assets.');
                    // Force hard reload (bypass cache)
                    location.reload(true);
                } catch (e) {
                    console.error('Clear cache error:', e);
                    alert('Error clearing cache: ' + e.message);
                }
            }
        }
        
        // Update title screen button states based on save existence
        function updateTitleScreenButtons() {
            const sharedSave = loadSharedSave();
            const startBtn = document.getElementById('startAdventureBtn');
            const continueBtn = document.getElementById('continueBtn');
            
            if (sharedSave && (sharedSave.arcadeState || sharedSave.dungeonState)) {
                // Has save - enable CONTINUE, disable START ADVENTURE
                continueBtn.disabled = false;
                continueBtn.classList.remove('comingSoon');
                startBtn.disabled = true;
                startBtn.style.opacity = '0.5';
                startBtn.style.cursor = 'not-allowed';
            } else {
                // No save - enable START ADVENTURE, disable CONTINUE
                startBtn.disabled = false;
                startBtn.style.opacity = '1';
                startBtn.style.cursor = 'pointer';
                continueBtn.disabled = true;
                continueBtn.classList.add('comingSoon');
            }
        }
        
        // Continue game - load from save
        function continueGame() {
            const sharedSave = loadSharedSave();
            if (!sharedSave) {
                alert('No save game found! Start a new adventure first.');
                return;
            }
            startAdventure();
        }
        
        // ===== BATTLE SYSTEM =====
        
        // Battle state
        let battleState = {
            active: false,
            won: false,
            currentTurn: 0,
            turnOrder: [],
            heroes: [],
            enemies: [],
            platforms: [],
            canvas: null,
            ctx: null,
            backgroundImage: null,
            backgroundPath: '',
            detectedPlatforms: [],
            targetingMode: false,
            pendingAction: null,
            swapTargetingMode: false,
            swapInitiator: null
        };
        
        // Start a battle encounter
        async function startBattle() {
            // Multiplayer clients cannot start battles - only host
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                showNotification('Only host can start battles', 'error');
                return;
            }
            
            // Switch to battle screen
            currentScreen = 'battle';
            document.getElementById('dungeonMenuScreen').style.display = 'none';
            document.getElementById('battleScreen').style.display = 'block';
            
            // If multiplayer host, notify clients
            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                sendWebSocketMessage({ type: 'game_start', screen: 'battle' });
            }
            
            // Move music controls and ticker to bottom left during battle
            document.getElementById('musicControls').classList.add('battleActive');
            document.getElementById('musicTicker').classList.add('battleActive');
            
            // Initialize canvas
            battleState.canvas = document.getElementById('battleCanvas');
            battleState.ctx = battleState.canvas.getContext('2d');
            
            // Set canvas size
            battleState.canvas.width = window.innerWidth;
            battleState.canvas.height = window.innerHeight - 180;
            
            // Multiplayer client: Wait for battle_init from host
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                showDiceRoll('Waiting for host to start battle...');
                return; // Don't generate battle - wait for host's battle_init message
            }
            
            // Load enemy data
            let bossesData = [];
            let mobsData = [];
            try {
                const bossResponse = await fetch('tunnelsofprivacy/bosses/bosses_data.json');
                bossesData = await bossResponse.json();
                const mobResponse = await fetch('tunnelsofprivacy/mobs/mobs_data.json');
                const mobObj = await mobResponse.json();
                mobsData = mobObj.mobs || [];
            } catch(e) {
                console.error('Failed to load enemy data:', e);
            }
            
            // Load shared save to get hero stats
            const sharedSave = loadSharedSave();
            
            // Setup heroes with sprites
            battleState.heroes = [
                { 
                    name: 'Zooko', 
                    hp: sharedSave?.heroes?.zooko?.hp ?? 30, 
                    maxHp: sharedSave?.heroes?.zooko?.maxHp ?? 30,
                    xp: sharedSave?.heroes?.zooko?.xp ?? 0,
                    healsRemaining: 2,
                    stats: sharedSave?.heroes?.zooko || {},
                    color: '#F2C94C',
                    x: 0, y: 0, platform: null, facing: 'center',
                    sprite: new Image(),
                    spritePath: 'tunnelsofprivacy/heros/zooko.png'
                },
                { 
                    name: 'Nate', 
                    hp: sharedSave?.heroes?.nate?.hp ?? 28, 
                    maxHp: sharedSave?.heroes?.nate?.maxHp ?? 30,
                    xp: sharedSave?.heroes?.nate?.xp ?? 0,
                    healsRemaining: 2,
                    stats: sharedSave?.heroes?.nate || {},
                    color: '#E74C3C',
                    x: 0, y: 0, platform: null, facing: 'center',
                    sprite: new Image(),
                    spritePath: 'tunnelsofprivacy/heros/nate.png'
                },
                { 
                    name: 'Zancas', 
                    hp: sharedSave?.heroes?.zancas?.hp ?? 24, 
                    maxHp: sharedSave?.heroes?.zancas?.maxHp ?? 26,
                    xp: sharedSave?.heroes?.zancas?.xp ?? 0,
                    healsRemaining: 2,
                    stats: sharedSave?.heroes?.zancas || {},
                    color: '#27AE60',
                    x: 0, y: 0, platform: null, facing: 'center',
                    sprite: new Image(),
                    spritePath: 'tunnelsofprivacy/heros/zancas.png'
                },
                { 
                    name: 'CyberAxe', 
                    hp: sharedSave?.heroes?.cyberaxe?.hp ?? 32, 
                    maxHp: sharedSave?.heroes?.cyberaxe?.maxHp ?? 35,
                    xp: sharedSave?.heroes?.cyberaxe?.xp ?? 0,
                    healsRemaining: 2,
                    stats: sharedSave?.heroes?.cyberaxe || {},
                    color: '#2E86DE',
                    x: 0, y: 0, platform: null, facing: 'center',
                    sprite: new Image(),
                    spritePath: 'tunnelsofprivacy/heros/cyberaxe.png'
                }
            ];
            
            // Load hero sprites with cache busting
            battleState.heroes.forEach(hero => {
                hero.sprite.onload = () => {
                    renderBattle(); // Re-render when each sprite loads
                };
                // Add timestamp to prevent caching
                hero.sprite.src = hero.spritePath + '?v=' + Date.now();
            });
            
            // Setup enemies from loaded data (level 2 for testing)
            battleState.enemies = [];
            
            // Add boss from level 2
            const boss = bossesData.find(b => b.mainLevel === 2);
            if (boss) {
                battleState.enemies.push({
                    name: boss.name,
                    hp: 20,
                    maxHp: 20,
                    ac: boss.stats.ac,
                    attackDamage: boss.stats.attackDamage,
                    speed: boss.stats.speed,
                    dex: boss.stats.initiative || 0,
                    hostile: boss.behavior?.hostile !== false,
                    color: '#8B45FF',
                    x: 0, y: 0, platform: null, facing: 'center',
                    sprite: new Image(),
                    spritePath: boss.spritePath,
                    isMob: false
                });
            }
            
            // Add 2 random hostile mobs
            const hostileMobs = mobsData.filter(m => m.behavior?.hostile);
            for (let i = 0; i < 2 && i < hostileMobs.length; i++) {
                const mob = hostileMobs[Math.floor(Math.random() * hostileMobs.length)];
                battleState.enemies.push({
                    name: mob.name,
                    hp: mob.stats.hp,
                    maxHp: mob.stats.maxHp,
                    ac: mob.stats.ac,
                    attackDamage: mob.stats.attackDamage,
                    speed: mob.stats.speed,
                    dex: 0,
                    hostile: mob.behavior?.hostile !== false,
                    color: '#5C3317',
                    x: 0, y: 0, platform: null, facing: 'center',
                    sprite: new Image(),
                    spritePath: mob.spritePath,
                    isMob: true
                });
            }
            
            // Load enemy sprites
            battleState.enemies.forEach(enemy => {
                enemy.sprite.onload = () => {
                    renderBattle();
                };
                enemy.sprite.src = enemy.spritePath + '?v=' + Date.now();
            });
            
            // Load random background from lvl1-10
            const backgroundOptions = [
                'backgrounds_lvl1 (8).png',
                'backgrounds_lvl1 (10).png',
                'backgrounds_lvl1 (12).png',
                'backgrounds_lvl1 (14).png',
                'backgrounds_lvl1 (15).png',
                'backgrounds_lvl1 (16).png'
            ];
            const randomBg = backgroundOptions[Math.floor(Math.random() * backgroundOptions.length)];
            battleState.backgroundPath = `tunnelsofprivacy/backgrounds/lvl1-10/${randomBg}`;
            battleState.backgroundImage = new Image();
            battleState.backgroundImage.onload = () => {
                // Only host runs floor scanning
                if (!multiplayerState.enabled || multiplayerState.role === 'host') {
                    // Run floor scanning to detect platforms
                    generateBattleLayout();
                    
                    // After layout is generated, send to clients
                    if (multiplayerState.enabled && multiplayerState.role === 'host') {
                        sendBattleInitToClients();
                    }
                }
                
                renderBattle();
            };
            battleState.backgroundImage.src = battleState.backgroundPath;
            
            // Calculate initiative for all combatants
            const allCombatants = [...battleState.heroes, ...battleState.enemies];
            allCombatants.forEach(c => {
                const dexMod = calculateModifier(c.stats?.dex || c.dex || 10);
                c.initiative = rollD20() + dexMod;
            });
            
            // Setup turn order sorted by initiative (highest first)
            battleState.turnOrder = allCombatants.sort((a, b) => b.initiative - a.initiative);
            battleState.currentTurn = 0;
            battleState.active = true;
            battleState.targetingMode = false;
            battleState.pendingAction = null;
            
            // Update UI
            updateBattleTurnInfo();
            updateBattleHeroCards();
            updateBattleEnemyCards();
            
            // Render initial state (will re-render when bg loads)
            renderBattle();
            
            // Start battle animation loop for continuous updates (targeting highlights, etc.)
            function battleAnimationLoop() {
                if (battleState.active) {
                    renderBattle();
                    requestAnimationFrame(battleAnimationLoop);
                }
            }
            battleAnimationLoop();
            
            // If first turn is AI, process it automatically
            const firstCombatant = battleState.turnOrder[0];
            if (!battleState.heroes.includes(firstCombatant)) {
                setTimeout(() => processAITurn(firstCombatant), 1500);
            }
        }
        
        // Send battle initialization data to clients (called after floor scanning completes)
        function sendBattleInitToClients() {
            const canvas = battleState.canvas;
            const battleData = {
                backgroundPath: battleState.backgroundPath,
                canvasWidth: canvas.width,
                canvasHeight: canvas.height,
                heroes: battleState.heroes.map(h => ({
                    name: h.name,
                    hp: h.hp,
                    maxHp: h.maxHp,
                    xp: h.xp,
                    healsRemaining: h.healsRemaining,
                    stats: h.stats,
                    x: h.x / canvas.width,
                    y: h.y / canvas.height,
                    platform: h.platform,
                    initiative: h.initiative,
                    spritePath: h.spritePath
                })),
                enemies: battleState.enemies.map(e => ({
                    name: e.name,
                    hp: e.hp,
                    maxHp: e.maxHp,
                    ac: e.ac,
                    attackDamage: e.attackDamage,
                    speed: e.speed,
                    dex: e.dex,
                    hostile: e.hostile,
                    x: e.x / canvas.width,
                    y: e.y / canvas.height,
                    platform: e.platform,
                    initiative: e.initiative,
                    spritePath: e.spritePath,
                    isMob: e.isMob
                })),
                turnOrder: battleState.turnOrder.map(c => c.name),
                currentTurn: battleState.currentTurn
            };
            sendWebSocketMessage({ type: 'battle_init', battleData: battleData });
        }

        
        // Detect platforms using multi-method approach
        function detectPlatforms() {
            if (!battleState.backgroundImage || !battleState.backgroundImage.complete) {
                return [];
            }
            
            const tempCanvas = document.createElement('canvas');
            const ctx = tempCanvas.getContext('2d');
            tempCanvas.width = battleState.backgroundImage.width;
            tempCanvas.height = battleState.backgroundImage.height;
            
            ctx.drawImage(battleState.backgroundImage, 0, 0);
            const imageData = ctx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            const data = imageData.data;
            
            const allPlatforms = [];
            
            // METHOD 1: Adaptive thresholding with local contrast
            const method1 = detectByAdaptiveThreshold(data, tempCanvas.width, tempCanvas.height);
            allPlatforms.push(...method1);
            
            // METHOD 2: Multi-angle edge detection
            const method2 = detectByMultiAngle(data, tempCanvas.width, tempCanvas.height);
            allPlatforms.push(...method2);
            
            // METHOD 3: Color clustering
            const method3 = detectByColorClustering(data, tempCanvas.width, tempCanvas.height);
            allPlatforms.push(...method3);
            
            // Score and rank all platforms
            const scored = allPlatforms.map(p => ({
                ...p,
                score: scorePlatform(p, data, tempCanvas.width, tempCanvas.height)
            }));
            
            // Filter minimum score and sort
            const valid = scored.filter(p => p.score > 0.3).sort((a, b) => b.score - a.score);
            
            // Scale to canvas size
            const scaleX = battleState.canvas.width / tempCanvas.width;
            const scaleY = battleState.canvas.height / tempCanvas.height;
            
            return valid.map(p => ({
                x: p.x * scaleX,
                y: p.y * scaleY,
                w: p.w * scaleX,
                h: p.h * scaleY,
                type: p.type,
                score: p.score,
                color: p.color
            }));
        }
        
        // Adaptive thresholding - find LIGHT horizontal floor areas using box scanning
        function detectByAdaptiveThreshold(data, width, height) {
            const platforms = [];
            const boxWidth = 150; // Scan boxes 150px wide
            const boxHeight = 50; // 50px tall boxes
            const boxStepX = 50; // Move box right by 50px
            const boxStepY = 25; // Move box down by 25px
            const minBrightness = 100;
            
            // Scan bottom 60% of image only
            for (let boxY = Math.floor(height * 0.6); boxY < height - boxHeight - 10; boxY += boxStepY) {
                for (let boxX = 0; boxX < width - boxWidth; boxX += boxStepX) {
                    // Sample the entire box
                    let boxBrightnessSum = 0;
                    let boxSamples = 0;
                    
                    for (let dy = 0; dy < boxHeight; dy += 5) {
                        for (let dx = 0; dx < boxWidth; dx += 5) {
                            const x = boxX + dx;
                            const y = boxY + dy;
                            const i = (y * width + x) * 4;
                            const brightness = (data[i] + data[i+1] + data[i+2]) / 3;
                            boxBrightnessSum += brightness;
                            boxSamples++;
                        }
                    }
                    
                    const avgBrightness = boxBrightnessSum / boxSamples;
                    
                    // Check if box is bright enough
                    if (avgBrightness > minBrightness) {
                        // Depth test: trace down to find distance to ground
                        const depthScore = calculateDepthScore(data, width, height, boxX, boxY, boxWidth, boxHeight, avgBrightness);
                        
                        // Only accept platforms with good depth scores (close to ground or at bottom)
                        if (depthScore > 0.5) {
                            platforms.push({
                                x: boxX, y: boxY, w: boxWidth, h: boxHeight,
                                type: 'adaptive', color: '#FF00FF',
                                depthScore: depthScore
                            });
                        }
                    }
                }
            }
            
            return platforms;
        }
        
        // Multi-angle edge detection - find LIGHT floor areas at various slopes using boxes
        function detectByMultiAngle(data, width, height) {
            const platforms = [];
            const angles = [0, 5, -5];
            const boxWidth = 150;
            const boxHeight = 50;
            const boxStepX = 50;
            const boxStepY = 30;
            const minBrightness = 100;
            
            angles.forEach(angle => {
                const rad = angle * Math.PI / 180;
                const tanAngle = Math.tan(rad);
                
                for (let baseY = Math.floor(height * 0.6); baseY < height - boxHeight - 10; baseY += boxStepY) {
                    for (let boxX = 0; boxX < width - boxWidth; boxX += boxStepX) {
                        const centerY = Math.floor(baseY + boxX * tanAngle);
                        if (centerY < 0 || centerY >= height - boxHeight - 10) continue;
                        
                        // Sample box at this position
                        let boxBrightnessSum = 0;
                        let boxSamples = 0;
                        
                        for (let dy = 0; dy < boxHeight; dy += 5) {
                            for (let dx = 0; dx < boxWidth; dx += 5) {
                                const x = boxX + dx;
                                const y = centerY + dy;
                                if (y >= height) continue;
                                const i = (y * width + x) * 4;
                                const brightness = (data[i] + data[i+1] + data[i+2]) / 3;
                                boxBrightnessSum += brightness;
                                boxSamples++;
                            }
                        }
                        
                        const avgBrightness = boxBrightnessSum / boxSamples;
                        
                        if (avgBrightness > minBrightness) {
                            // Depth test
                            const depthScore = calculateDepthScore(data, width, height, boxX, centerY, boxWidth, boxHeight, avgBrightness);
                            
                            if (depthScore > 0.5) {
                                platforms.push({
                                    x: boxX, y: centerY, w: boxWidth, h: boxHeight,
                                    type: 'angle', color: '#00FFFF',
                                    depthScore: depthScore
                                });
                            }
                        }
                    }
                }
            });
            
            return platforms;
        }
        
        // Color clustering - find LIGHT colored horizontal floor regions using boxes
        function detectByColorClustering(data, width, height) {
            const platforms = [];
            const boxWidth = 150;
            const boxHeight = 50;
            const boxStepX = 50;
            const boxStepY = 25;
            const colorTolerance = 60;
            const minBrightness = 100;
            
            for (let boxY = Math.floor(height * 0.6); boxY < height - boxHeight - 10; boxY += boxStepY) {
                for (let boxX = 0; boxX < width - boxWidth; boxX += boxStepX) {
                    // Sample box at this position
                    let avgR = 0, avgG = 0, avgB = 0;
                    let samples = 0;
                    
                    for (let dy = 0; dy < boxHeight; dy += 5) {
                        for (let dx = 0; dx < boxWidth; dx += 5) {
                            const x = boxX + dx;
                            const y = boxY + dy;
                            const i = (y * width + x) * 4;
                            avgR += data[i];
                            avgG += data[i+1];
                            avgB += data[i+2];
                            samples++;
                        }
                    }
                    
                    avgR /= samples;
                    avgG /= samples;
                    avgB /= samples;
                    const brightness = (avgR + avgG + avgB) / 3;
                    
                    // Only consider LIGHT boxes as potential floor
                    if (brightness > minBrightness) {
                        // Depth test
                        const depthScore = calculateDepthScore(data, width, height, boxX, boxY, boxWidth, boxHeight, brightness);
                        
                        if (depthScore > 0.5) {
                            platforms.push({
                                x: boxX, y: boxY, w: boxWidth, h: boxHeight,
                                type: 'cluster', color: '#00FF00',
                                depthScore: depthScore
                            });
                        }
                    }
                }
            }
            
            return platforms;
        }
        
        // Calculate depth score - traces downward to find distance to ground
        function calculateDepthScore(data, width, height, boxX, boxY, boxWidth, boxHeight, platformBrightness) {
            const centerX = boxX + Math.floor(boxWidth / 2);
            const startY = boxY + boxHeight;
            const maxDepth = 200; // Don't trace more than 200px down
            
            let distanceToGround = 0;
            let foundGround = false;
            
            // Trace straight down from center of platform
            for (let y = startY; y < Math.min(height, startY + maxDepth); y += 5) {
                const i = (y * width + centerX) * 4;
                const brightness = (data[i] + data[i+1] + data[i+2]) / 3;
                
                // Check for ground indicators:
                // 1. Hit bottom of image
                if (y >= height - 10) {
                    distanceToGround = y - startY;
                    foundGround = true;
                    break;
                }
                
                // 2. Hit much darker area (void/background)
                if (brightness < 50) {
                    distanceToGround = y - startY;
                    foundGround = true;
                    break;
                }
                
                // 3. Hit similar brightness (continuous support)
                if (Math.abs(brightness - platformBrightness) < 30) {
                    // Keep tracing, we're still on connected surface
                    continue;
                }
            }
            
            // If we traced all the way down without finding ground, it's floating
            if (!foundGround) {
                return 0;
            }
            
            // Score based on distance to ground
            // 0 distance (at bottom) = 1.0 score
            // 50px or more = 0.5 score (minimum acceptable)
            // >200px = rejected above
            const score = 1.0 - (distanceToGround / 400);
            return Math.max(0.5, score);
        }
        
        // Score platform quality
        function scorePlatform(platform, data, width, height) {
            let score = 0;
            
            // Width score (wider = better, cap at 800px)
            const widthScore = Math.min(1.0, platform.w / 800);
            score += widthScore * 0.5;
            
            // Position score (lower on screen = better, floors are at bottom)
            const positionScore = platform.y / height;
            score += positionScore * 0.3;
            
            // Brightness consistency (floors should be consistently LIGHT)
            let brightnessSum = 0;
            let sampleCount = 0;
            for (let x = platform.x; x < platform.x + platform.w; x += 10) {
                const idx = (Math.floor(platform.y) * width + Math.floor(x)) * 4;
                const brightness = (data[idx] + data[idx+1] + data[idx+2]) / 3;
                brightnessSum += brightness;
                sampleCount++;
            }
            const avgBrightness = brightnessSum / sampleCount;
            const brightnessScore = avgBrightness > 100 ? Math.min(1.0, avgBrightness / 200) : 0;
            score += brightnessScore * 0.2;
            
            return score;
        }
        
        // Generate battle layout using detected platforms
        function generateBattleLayout() {
            const canvas = battleState.canvas;
            battleState.platforms = [];
            
            // Detect platforms
            const detected = detectPlatforms();
            console.log(`Detected ${detected.length} platforms total`);
            
            if (detected.length < 7) {
                console.log('Not enough platforms detected, using fallback');
                return generateFallbackLayout();
            }
            
            // Safe zone filtering - only check X bounds, platforms already scanned at bottom
            const marginX = 160; // 300px sprite / 2 + 10px buffer
            
            const safe = detected.filter(p => {
                const centerX = p.x + p.w / 2;
                return centerX > marginX && centerX < canvas.width - marginX;
            });
            
            console.log(`${safe.length} platforms in safe zone`);
            
            if (safe.length < 7) {
                console.log('Not enough safe platforms, using fallback');
                return generateFallbackLayout();
            }
            
            // Shuffle safe platforms for variety each battle
            const shuffled = [...safe].sort(() => Math.random() - 0.5);
            
            // Pick platforms ensuring spatial separation (300px sprites need 200px+ spacing)
            const minDistance = 200;
            const selected = [];
            
            for (let i = 0; i < shuffled.length && selected.length < 7; i++) {
                const candidate = shuffled[i];
                const candidateX = candidate.x + candidate.w / 2;
                const candidateY = candidate.y;
                
                // Check if candidate overlaps with already selected platforms
                let overlaps = false;
                for (const existing of selected) {
                    const existingX = existing.x + existing.w / 2;
                    const existingY = existing.y;
                    
                    const dx = candidateX - existingX;
                    const dy = candidateY - existingY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < minDistance) {
                        overlaps = true;
                        break;
                    }
                }
                
                if (!overlaps) {
                    selected.push(candidate);
                }
            }
            
            console.log(`Selected ${selected.length} non-overlapping platforms`);
            
            // Need at least 7 non-overlapping platforms (4 heroes + 3 enemies)
            if (selected.length < 7) {
                console.log('Could not find 7 non-overlapping platforms, using fallback');
                return generateFallbackLayout();
            }
            
            // Position heroes
            for (let i = 0; i < 4; i++) {
                const p = selected[i];
                battleState.platforms.push(p);
                
                // Center of detection box
                const centerX = p.x + p.w / 2;
                const centerY = p.y + p.h / 2;
                
                // We need to solve: floor contact point (heroY + scaledBoxSize/2) = centerY
                // scaledBoxSize = 300 * (0.6 + heroY / canvas.height * 0.4)
                // This is circular, so we iterate to solve
                let heroY = centerY - 150; // Initial guess
                for (let iter = 0; iter < 5; iter++) {
                    const depthScale = 0.6 + (heroY / canvas.height) * 0.4;
                    const scaledBoxSize = 300 * depthScale;
                    heroY = centerY - scaledBoxSize / 2;
                }
                
                battleState.heroes[i].platform = p;
                battleState.heroes[i].x = centerX;
                battleState.heroes[i].y = heroY;
                battleState.heroes[i].facing = 'center';
            }
            
            // Position enemies
            for (let i = 0; i < battleState.enemies.length; i++) {
                const ep = selected[4 + i];
                battleState.platforms.push(ep);
                
                // Center of detection box
                const centerX = ep.x + ep.w / 2;
                const centerY = ep.y + ep.h / 2;
                
                const enemy = battleState.enemies[i];
                
                if (enemy.isMob) {
                    // For mobs: enemy.y is at FEET (bottom of sprite)
                    // Sprite bottom should be at centerY
                    enemy.x = centerX;
                    enemy.y = centerY;
                } else {
                    // For bosses: solve for Y position where floor contact point = centerY
                    let enemyY = centerY - 150; // Initial guess
                    for (let iter = 0; iter < 5; iter++) {
                        const depthScale = 0.6 + (enemyY / canvas.height) * 0.4;
                        const scaledBoxSize = 300 * depthScale;
                        enemyY = centerY - scaledBoxSize / 2;
                    }
                    enemy.x = centerX;
                    enemy.y = enemyY;
                }
                
                enemy.platform = ep;
                enemy.facing = 'center';
            }
            
            battleState.detectedPlatforms = detected;
            console.log('Platform layout generated successfully');
        }
        
        // Fallback positioning
        function generateFallbackLayout() {
            const canvas = battleState.canvas;
            const safePositions = {
                heroes: [
                    { x: 0.20, y: 0.40 },
                    { x: 0.25, y: 0.55 },
                    { x: 0.15, y: 0.65 },
                    { x: 0.30, y: 0.75 }
                ],
                enemies: [
                    { x: 0.75, y: 0.60 },
                    { x: 0.70, y: 0.45 },
                    { x: 0.80, y: 0.70 }
                ]
            };
            
            for (let i = 0; i < 4; i++) {
                const pos = safePositions.heroes[i];
                const heroX = canvas.width * pos.x;
                const heroY = canvas.height * pos.y;
                
                const platform = {
                    x: heroX - 50, y: heroY + 140, w: 100, h: 10,
                    type: 'fallback', color: '#6B4FA0'
                };
                
                battleState.platforms.push(platform);
                battleState.heroes[i].platform = platform;
                battleState.heroes[i].x = heroX;
                battleState.heroes[i].y = heroY;
                battleState.heroes[i].facing = 'center';
            }
            
            for (let i = 0; i < battleState.enemies.length; i++) {
                const pos = safePositions.enemies[i];
                const enemyX = canvas.width * pos.x;
                const enemyY = canvas.height * pos.y;
                
                const enemyPlatform = {
                    x: enemyX - 75, y: enemyY + 140, w: 150, h: 10,
                    type: 'fallback', color: '#4A2A6B'
                };
                
                battleState.platforms.push(enemyPlatform);
                battleState.enemies[i].platform = enemyPlatform;
                battleState.enemies[i].x = enemyX;
                battleState.enemies[i].y = enemyY;
                battleState.enemies[i].facing = 'center';
            }
        }
        

        // Handle canvas clicks for targeting
        function handleBattleClick(event) {
            const rect = battleState.canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // Handle swap targeting (hero selection)
            if (battleState.swapTargetingMode && battleState.swapInitiator) {
                for (const hero of battleState.heroes) {
                    if (hero === battleState.swapInitiator || hero.hp <= 0) continue;
                    
                    const canvas = battleState.canvas;
                    const depthScale = 0.6 + (hero.y / canvas.height) * 0.4;
                    const hitWidth = 64 * depthScale;
                    const hitHeight = 64 * depthScale;
                    const hitX = hero.x - hitWidth / 2;
                    const hitY = hero.y - hitHeight / 2;
                    
                    if (x >= hitX && x <= hitX + hitWidth && y >= hitY && y <= hitY + hitHeight) {
                        const initiator = battleState.swapInitiator;
                        
                        // Multiplayer: Client sends to host
                        if (multiplayerState.enabled && multiplayerState.role === 'client') {
                            sendWebSocketMessage({
                                type: 'player_action',
                                action: 'swap',
                                target: battleState.heroes.indexOf(hero),
                                hero: initiator.name
                            });
                            
                            // Exit swap mode
                            battleState.swapTargetingMode = false;
                            battleState.swapInitiator = null;
                            battleState.canvas.style.cursor = 'default';
                            return;
                        }
                        
                        // Swap positions
                        const tempX = initiator.x;
                        const tempY = initiator.y;
                        const tempPlatform = initiator.platform;
                        
                        initiator.x = hero.x;
                        initiator.y = hero.y;
                        initiator.platform = hero.platform;
                        
                        hero.x = tempX;
                        hero.y = tempY;
                        hero.platform = tempPlatform;
                        
                        showDiceRoll(`${initiator.name} swapped positions with ${hero.name}!`);
                        
                        // Exit swap mode
                        battleState.swapTargetingMode = false;
                        battleState.swapInitiator = null;
                        battleState.canvas.style.cursor = 'default';
                        
                        // Swap uses all action points
                        advanceTurn();
                        
                        // Host broadcasts state
                        if (multiplayerState.enabled && multiplayerState.role === 'host') {
                            broadcastGameState();
                        }
                        return;
                    }
                }
                return;
            }
            
            // Handle enemy targeting
            if (!battleState.targetingMode || !battleState.pendingAction) return;
            
            // Check if click hit an enemy
            for (const enemy of battleState.enemies) {
                if (enemy.hp <= 0 || !enemy.hostile) continue;
                
                const canvas = battleState.canvas;
                const depthScale = 0.6 + (enemy.y / canvas.height) * 0.4;
                let hitWidth, hitHeight, hitX, hitY;
                
                if (enemy.isMob) {
                    const mobAspectRatio = 1344 / 768;
                    const baseHeight = 75;
                    const spriteHeight = baseHeight * depthScale;
                    const spriteWidth = spriteHeight * mobAspectRatio;
                    hitWidth = spriteWidth;
                    hitHeight = spriteHeight;
                    hitX = enemy.x - hitWidth / 2;
                    hitY = enemy.y - spriteHeight;
                } else {
                    hitWidth = 200 * depthScale;
                    hitHeight = 200 * depthScale;
                    hitX = enemy.x - hitWidth / 2;
                    hitY = enemy.y - hitHeight / 2;
                }
                
                if (x >= hitX && x <= hitX + hitWidth && y >= hitY && y <= hitY + hitHeight) {
                    // Target found!
                    const attacker = battleState.turnOrder[battleState.currentTurn];
                    const enemyIndex = battleState.enemies.indexOf(enemy);
                    
                    // Multiplayer: Client sends to host
                    if (multiplayerState.enabled && multiplayerState.role === 'client') {
                        sendWebSocketMessage({
                            type: 'player_action',
                            action: battleState.pendingAction,
                            target: enemyIndex,
                            hero: attacker.name
                        });
                        
                        // Exit targeting mode
                        battleState.targetingMode = false;
                        battleState.pendingAction = null;
                        battleState.canvas.style.cursor = 'default';
                        return;
                    }
                    
                    executeAttack(attacker, enemy, battleState.pendingAction);
                    
                    // Exit targeting mode
                    battleState.targetingMode = false;
                    battleState.pendingAction = null;
                    battleState.canvas.style.cursor = 'default';
                    return;
                }
            }
        }
        
        // Render battle scene
        function renderBattle() {
            const ctx = battleState.ctx;
            const canvas = battleState.canvas;
            
            // Setup click handler
            if (!canvas.hasClickHandler) {
                canvas.addEventListener('click', handleBattleClick);
                canvas.hasClickHandler = true;
            }
            
            // Draw background image if loaded, otherwise fallback to gradient
            if (battleState.backgroundImage && battleState.backgroundImage.complete && battleState.backgroundImage.naturalHeight !== 0) {
                ctx.drawImage(battleState.backgroundImage, 0, 0, canvas.width, canvas.height);
            } else {
                // Fallback: Clear canvas with gradient
                ctx.fillStyle = '#1a0f2e';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw starry background
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                for (let i = 0; i < 100; i++) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    const r = Math.random() * 2;
                    ctx.beginPath();
                    ctx.arc(x, y, r, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Draw detected platform spawn areas if hitboxes enabled
            if (settings.showHitboxes && battleState.detectedPlatforms) {
                battleState.detectedPlatforms.forEach(platform => {
                    // Different colors for different detection methods
                    let fillColor, strokeColor;
                    
                    if (platform.type === 'detected') {
                        // Edge detection = GREEN
                        fillColor = 'rgba(0, 255, 0, 0.2)';
                        strokeColor = 'rgba(0, 255, 0, 0.8)';
                    } else if (platform.type === 'sampled') {
                        // Grid sampling = MAGENTA
                        fillColor = 'rgba(255, 0, 255, 0.2)';
                        strokeColor = 'rgba(255, 0, 255, 0.8)';
                    } else if (platform.type === 'gradient') {
                        // Gradient/flat area = CYAN
                        fillColor = 'rgba(0, 255, 255, 0.2)';
                        strokeColor = 'rgba(0, 255, 255, 0.8)';
                    } else {
                        // Unknown = WHITE
                        fillColor = 'rgba(255, 255, 255, 0.2)';
                        strokeColor = 'rgba(255, 255, 255, 0.8)';
                    }
                    
                    ctx.fillStyle = fillColor;
                    ctx.fillRect(platform.x, platform.y, platform.w, platform.h);
                    
                    ctx.strokeStyle = strokeColor;
                    ctx.lineWidth = 1;
                    ctx.strokeRect(platform.x, platform.y, platform.w, platform.h);
                });
            }
            
            // Draw platforms
            battleState.platforms.forEach(platform => {
                // Don't draw platforms, keep them invisible for collision only
                // ctx.fillStyle = platform.color;
                // ctx.fillRect(platform.x, platform.y, platform.w, platform.h);
                
                // Platform edge highlight
                // ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                // ctx.lineWidth = 2;
                // ctx.strokeRect(platform.x, platform.y, platform.w, platform.h);
            });
            
            // Draw heroes
            battleState.heroes.forEach(hero => {
                // Calculate depth-based scale (higher Y = farther back = smaller)
                // Y range: 0 (top) to canvas.height (bottom)
                // Scale range: 0.6 (top/far) to 1.0 (bottom/near)
                const depthScale = 0.6 + (hero.y / canvas.height) * 0.4;
                
                // Green highlight for swap targeting (other heroes)
                if (battleState.swapTargetingMode && hero !== battleState.swapInitiator && hero.hp > 0) {
                    ctx.save();
                    ctx.strokeStyle = '#00FF00';
                    ctx.lineWidth = 4 * depthScale;
                    ctx.shadowColor = '#00FF00';
                    ctx.shadowBlur = 20 * depthScale;
                    const pulseSize = Math.sin(Date.now() / 200) * 3 * depthScale;
                    const boxWidth = 300 * depthScale;
                    const boxHeight = 300 * depthScale;
                    ctx.strokeRect(
                        hero.x - boxWidth / 2 - pulseSize,
                        hero.y - boxHeight / 2 - pulseSize,
                        boxWidth + pulseSize * 2,
                        boxHeight + pulseSize * 2
                    );
                    ctx.restore();
                }
                
                // Draw hero sprite
                if (hero.sprite && hero.sprite.complete && hero.sprite.naturalHeight !== 0) {
                    const spriteWidth = 300 * depthScale;
                    const spriteHeight = 300 * depthScale;
                    const spriteX = hero.x - spriteWidth / 2;
                    // Per-hero offset adjustments (scaled with depth)
                    let offsetY = 10 * depthScale; // Default (Zooko, Nate)
                    if (hero.name === 'Zancas') {
                        offsetY = 20 * depthScale; // Zancas down 10px more
                    } else if (hero.name === 'CyberAxe') {
                        offsetY = 13 * depthScale; // CyberAxe down 3px more
                    }
                    const spriteY = hero.y - spriteHeight / 2 + offsetY;
                    
                    ctx.save();
                    if (hero.facing === 'left') {
                        ctx.translate(hero.x, hero.y);
                        ctx.scale(-1, 1);
                        ctx.translate(-hero.x, -hero.y);
                    }
                    ctx.drawImage(hero.sprite, spriteX, spriteY, spriteWidth, spriteHeight);
                    ctx.restore();
                } else {
                    // Fallback to colored circle if sprite not loaded
                    ctx.fillStyle = hero.color;
                    ctx.beginPath();
                    ctx.arc(hero.x, hero.y, 90 * depthScale, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                
                // Hero name
                ctx.fillStyle = '#FFFFFF';
                ctx.font = `bold ${Math.floor(12 * depthScale)}px Inter`;
                ctx.textAlign = 'center';
                ctx.fillText(hero.name.toUpperCase(), hero.x, hero.y - 195 * depthScale);
                
                // HP bar (positioned above sprite, below name)
                const barWidth = 80 * depthScale;
                const barHeight = 10 * depthScale;
                const barX = hero.x - barWidth / 2;
                const barY = hero.y - 180 * depthScale;
                
                // HP text (centered on top of bar)
                ctx.fillStyle = '#FFFFFF';
                ctx.font = `bold ${Math.floor(10 * depthScale)}px JetBrains Mono`;
                ctx.textAlign = 'center';
                ctx.fillText(`${hero.hp}/${hero.maxHp}`, hero.x, barY - 3);
                
                // Background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(barX, barY, barWidth, barHeight);
                
                // HP fill (GREEN -> YELLOW for heroes)
                const hpPercent = hero.hp / hero.maxHp;
                ctx.fillStyle = hpPercent > 0.5 ? '#27AE60' : hpPercent > 0.25 ? '#F39C12' : '#F1C40F';
                ctx.fillRect(barX, barY, barWidth * hpPercent, barHeight);
            });
            
            // Draw enemies
            battleState.enemies.forEach(enemy => {
                // Calculate depth-based scale (higher Y = farther back = smaller)
                const depthScale = 0.6 + (enemy.y / canvas.height) * 0.4;
                
                // Draw enemy sprite
                if (enemy.sprite && enemy.sprite.complete && enemy.sprite.naturalHeight !== 0) {
                    let spriteWidth, spriteHeight, spriteX, spriteY;
                    
                    if (enemy.isMob) {
                        // Mobs are 1344x768, render 4x smaller with correct aspect ratio
                        const mobAspectRatio = 1344 / 768; // 1.75
                        const baseHeight = 75; // 768 / 4 / 2.56 ‚âà 75px base height
                        spriteHeight = baseHeight * depthScale;
                        spriteWidth = spriteHeight * mobAspectRatio;
                        spriteX = enemy.x - spriteWidth / 2;
                        // Position so BOTTOM of sprite is at enemy.y (feet on ground)
                        spriteY = enemy.y - spriteHeight;
                    } else {
                        // Bosses are 300x300, centered
                        spriteWidth = 300 * depthScale;
                        spriteHeight = 300 * depthScale;
                        spriteX = enemy.x - spriteWidth / 2;
                        spriteY = enemy.y - spriteHeight / 2 + (10 * depthScale); // Offset down, scaled
                    }
                    
                    ctx.save();
                    if (enemy.facing === 'left') {
                        ctx.translate(enemy.x, enemy.y);
                        ctx.scale(-1, 1);
                        ctx.translate(-enemy.x, -enemy.y);
                    }
                    ctx.drawImage(enemy.sprite, spriteX, spriteY, spriteWidth, spriteHeight);
                    ctx.restore();
                } else {
                    // Fallback to colored circle if sprite not loaded
                    ctx.fillStyle = enemy.color;
                    ctx.beginPath();
                    ctx.arc(enemy.x, enemy.y, 50 * depthScale, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
                
                // Enemy name (RED for enemies)
                ctx.fillStyle = '#FF4444';
                ctx.font = `bold ${Math.floor(14 * depthScale)}px Inter`;
                ctx.textAlign = 'center';
                
                let nameOffsetY, barOffsetY;
                if (enemy.isMob) {
                    // For mobs, position above the sprite (which starts at enemy.y - spriteHeight)
                    const mobAspectRatio = 1344 / 768;
                    const baseHeight = 75;
                    const spriteHeight = baseHeight * depthScale;
                    nameOffsetY = enemy.y - spriteHeight - (10 * depthScale);
                    barOffsetY = enemy.y - spriteHeight - (30 * depthScale);
                } else {
                    // For bosses, position above centered sprite
                    nameOffsetY = enemy.y - 195 * depthScale;
                    barOffsetY = enemy.y - 180 * depthScale;
                }
                
                ctx.fillText(enemy.name.toUpperCase(), enemy.x, nameOffsetY);
                
                // HP bar
                const barWidth = 100 * depthScale;
                const barHeight = 10 * depthScale;
                const barX = enemy.x - barWidth / 2;
                const barY = barOffsetY;
                
                // HP text (centered on top of bar)
                ctx.fillStyle = '#FFFFFF';
                ctx.font = `bold ${Math.floor(10 * depthScale)}px JetBrains Mono`;
                ctx.textAlign = 'center';
                ctx.fillText(`${enemy.hp}/${enemy.maxHp}`, enemy.x, barY - 3);
                
                // Background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(barX, barY, barWidth, barHeight);
                
                // HP fill (RED for enemies)
                const hpPercent = enemy.hp / enemy.maxHp;
                ctx.fillStyle = hpPercent > 0.5 ? '#E74C3C' : hpPercent > 0.25 ? '#C0392B' : '#A93226';
                ctx.fillRect(barX, barY, barWidth * hpPercent, barHeight);
                
                // Highlight clickable enemies in targeting mode
                if (battleState.targetingMode && enemy.hostile) {
                    const depthScale = 0.6 + (enemy.y / canvas.height) * 0.4;
                    let highlightWidth, highlightHeight, highlightX, highlightY;
                    
                    if (enemy.isMob) {
                        const mobAspectRatio = 1344 / 768;
                        const baseHeight = 75;
                        const spriteHeight = baseHeight * depthScale;
                        const spriteWidth = spriteHeight * mobAspectRatio;
                        highlightWidth = spriteWidth + 20;
                        highlightHeight = spriteHeight + 20;
                        highlightX = enemy.x - highlightWidth / 2;
                        highlightY = enemy.y - spriteHeight - 10;
                    } else {
                        highlightWidth = 220 * depthScale;
                        highlightHeight = 220 * depthScale;
                        highlightX = enemy.x - highlightWidth / 2;
                        highlightY = enemy.y - highlightHeight / 2;
                    }
                    
                    // Pulsing glow effect
                    const pulseAlpha = 0.3 + Math.sin(Date.now() / 200) * 0.2;
                    ctx.strokeStyle = `rgba(255, 255, 0, ${pulseAlpha})`;
                    ctx.lineWidth = 4;
                    ctx.strokeRect(highlightX, highlightY, highlightWidth, highlightHeight);
                    
                    // Glow shadow
                    ctx.shadowColor = 'rgba(255, 255, 0, 0.8)';
                    ctx.shadowBlur = 20;
                    ctx.strokeRect(highlightX, highlightY, highlightWidth, highlightHeight);
                    ctx.shadowBlur = 0;
                }
            });
            
            // Draw hitboxes if enabled
            if (settings.showHitboxes) {
                // Draw hero spawn area boxes (scaled with depth)
                battleState.heroes.forEach(hero => {
                    const depthScale = 0.6 + (hero.y / canvas.height) * 0.4;
                    const boxSize = 300 * depthScale;
                    ctx.strokeStyle = '#00FF00';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(hero.x - boxSize / 2, hero.y - boxSize / 2, boxSize, boxSize);
                    
                    // Draw center point (hero.x, hero.y)
                    ctx.fillStyle = '#00FF00';
                    ctx.beginPath();
                    ctx.arc(hero.x, hero.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw FLOOR CONTACT POINT - bottom center of hitbox where feet should touch
                    const floorY = hero.y + boxSize / 2;
                    ctx.fillStyle = '#FF00FF';
                    ctx.beginPath();
                    ctx.arc(hero.x, floorY, 8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Draw x/y coordinates at top of hitbox
                    const topY = hero.y - boxSize / 2 - 5;
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = 'bold 12px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(`x:${Math.round(hero.x)} y:${Math.round(hero.y)}`, hero.x, topY);
                });
                
                // Draw enemy spawn area boxes (scaled with depth)
                battleState.enemies.forEach(enemy => {
                    const depthScale = 0.6 + (enemy.y / canvas.height) * 0.4;
                    
                    let boxSize, boxY, topY;
                    if (enemy.isMob) {
                        // Mobs: hitbox matches sprite size (aspect ratio 1.75:1)
                        const mobAspectRatio = 1344 / 768;
                        const baseHeight = 75;
                        const spriteHeight = baseHeight * depthScale;
                        const spriteWidth = spriteHeight * mobAspectRatio;
                        // Hitbox from feet (enemy.y) upward
                        ctx.strokeStyle = '#FF0000';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(enemy.x - spriteWidth / 2, enemy.y - spriteHeight, spriteWidth, spriteHeight);
                        
                        // Draw floor contact point at enemy.y (feet)
                        ctx.fillStyle = '#FF00FF';
                        ctx.beginPath();
                        ctx.arc(enemy.x, enemy.y, 8, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#FFFFFF';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        
                        // Top of hitbox for coordinates
                        topY = enemy.y - spriteHeight - 5;
                    } else {
                        // Bosses: 300x300 scaled box centered
                        const boxSize = 300 * depthScale;
                        ctx.strokeStyle = '#FF0000';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(enemy.x - boxSize / 2, enemy.y - boxSize / 2, boxSize, boxSize);
                        
                        // Draw center point
                        ctx.fillStyle = '#FF0000';
                        ctx.beginPath();
                        ctx.arc(enemy.x, enemy.y, 5, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Draw floor contact point
                        const floorY = enemy.y + boxSize / 2;
                        ctx.fillStyle = '#FF00FF';
                        ctx.beginPath();
                        ctx.arc(enemy.x, floorY, 8, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#FFFFFF';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        
                        // Top of hitbox for coordinates
                        topY = enemy.y - boxSize / 2 - 5;
                    }
                    
                    // Draw x/y coordinates at top of hitbox
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = 'bold 12px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(`x:${Math.round(enemy.x)} y:${Math.round(enemy.y)}`, enemy.x, topY);
                });
                
                // Draw platform hitboxes
                battleState.platforms.forEach(platform => {
                    ctx.strokeStyle = '#FFFF00';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(platform.x, platform.y, platform.w, platform.h);
                });
            }
        }
        
        // Update turn info display
        function updateBattleTurnInfo() {
            const currentHero = battleState.turnOrder[battleState.currentTurn];
            const turnInfo = document.getElementById('battleTurnInfo');
            if (turnInfo && currentHero) {
                let turnText = `${currentHero.name.toUpperCase()}'S TURN`;
                
                // Multiplayer: Show if it's you or waiting
                if (multiplayerState.enabled) {
                    if (multiplayerState.role === 'client') {
                        if (multiplayerState.myHeroes.includes(currentHero.name.toLowerCase())) {
                            turnText += ' (YOU)';
                        } else {
                            turnText = `Waiting for ${currentHero.name.toUpperCase()}...`;
                        }
                    }
                }
                
                turnInfo.textContent = turnText;
            }
            
            // Update active hero card highlighting
            document.querySelectorAll('.battleHeroCard').forEach(card => card.classList.remove('active'));
            const activeCard = document.getElementById(`battleCard${currentHero.name}`);
            if (activeCard) activeCard.classList.add('active');
            
            // Disable/enable buttons based on turn in multiplayer
            if (multiplayerState.enabled) {
                const isMyTurn = multiplayerState.myHeroes.includes(currentHero.name.toLowerCase());
                console.log('[TURN CHECK] Current hero:', currentHero.name, '| My heroes:', multiplayerState.myHeroes, '| Is my turn:', isMyTurn, '| Role:', multiplayerState.role);
                document.querySelectorAll('.battleButton').forEach(btn => {
                    if (btn.textContent.includes('RETREAT')) return; // Always allow retreat
                    btn.disabled = !isMyTurn;
                    btn.style.opacity = isMyTurn ? '1' : '0.3';
                });
            }
        }
        
        // Update battle hero card stats
        function updateBattleHeroCards() {
            // Include all heroes from original selection (alive or dead)
            const allHeroNames = ['nate', 'zooko', 'cyberaxe', 'zancas'];
            
            allHeroNames.forEach(heroName => {
                const hero = battleState.heroes.find(h => h.name.toLowerCase() === heroName);
                const card = document.getElementById(`battleCard${heroName.charAt(0).toUpperCase() + heroName.slice(1)}`);
                
                if (card) {
                    // Grey out if hero is dead/retreated
                    if (!hero || hero.hp <= 0) {
                        card.style.opacity = '0.3';
                        card.style.filter = 'grayscale(100%)';
                    } else {
                        card.style.opacity = '1';
                        card.style.filter = 'none';
                    }
                }
                
                if (!hero) return; // Skip if hero not in battle
                
                const hpEl = document.getElementById(`b${heroName}-hp`);
                const maxHpEl = document.getElementById(`b${heroName}-maxhp`);
                const acEl = document.getElementById(`b${heroName}-ac`);
                const xpEl = document.getElementById(`b${heroName}-xp`);
                const healsEl = document.getElementById(`b${heroName}-heals`);
                
                if (hpEl) hpEl.textContent = hero.hp;
                if (maxHpEl) maxHpEl.textContent = hero.maxHp;
                if (acEl) acEl.textContent = hero.stats.ac || 10;
                if (xpEl) xpEl.textContent = hero.xp || 0;
                
                // Update heal hearts display
                if (healsEl) {
                    const healsRemaining = hero.healsRemaining || 0;
                    let heartsHTML = '';
                    for (let i = 0; i < 2; i++) {
                        if (i < healsRemaining) {
                            heartsHTML += '‚ù§Ô∏è ';
                        } else {
                            heartsHTML += '‚ùå ';
                        }
                    }
                    healsEl.innerHTML = heartsHTML.trim();
                }
            });
        }
        
        // Update battle enemy cards
        function updateBattleEnemyCards() {
            const container = document.getElementById('battleEnemyCards');
            if (!container) return;
            
            // Sort enemies: bosses first, then mobs
            const sortedEnemies = [...battleState.enemies].sort((a, b) => {
                if (a.isMob === b.isMob) return 0;
                return a.isMob ? 1 : -1; // Bosses (isMob=false) first
            });
            
            // Set 2-column layout if more than 6 enemies
            if (sortedEnemies.length > 6) {
                container.classList.add('twoColumns');
            } else {
                container.classList.remove('twoColumns');
            }
            
            // Clear and rebuild cards
            container.innerHTML = '';
            
            sortedEnemies.forEach((enemy, index) => {
                const card = document.createElement('div');
                card.className = 'battleEnemyCard';
                card.id = `enemyCard${index}`;
                card.dataset.enemyIndex = battleState.enemies.indexOf(enemy);
                
                if (!enemy.isMob) {
                    card.classList.add('boss');
                }
                
                if (enemy.hp <= 0) {
                    card.classList.add('dead');
                }
                
                // Add targetable class if in targeting mode and hostile
                if (battleState.targetingMode && enemy.hostile && enemy.hp > 0) {
                    card.classList.add('targetable');
                }
                
                // Portrait
                const portrait = document.createElement('div');
                portrait.className = 'battleEnemyPortrait';
                portrait.style.backgroundImage = `url('${enemy.spritePath}')`;
                card.appendChild(portrait);
                
                // Name
                const name = document.createElement('div');
                name.className = 'battleEnemyName';
                name.textContent = enemy.name.toUpperCase();
                card.appendChild(name);
                
                // HP stat
                const hpStat = document.createElement('div');
                hpStat.className = 'battleEnemyStat';
                hpStat.style.color = '#ff6b6b';
                hpStat.innerHTML = `HP: <span>${enemy.hp}</span>/<span>${enemy.maxHp}</span>`;
                card.appendChild(hpStat);
                
                // AC stat
                const acStat = document.createElement('div');
                acStat.className = 'battleEnemyStat';
                acStat.innerHTML = `AC: <span>${enemy.ac || 10}</span>`;
                card.appendChild(acStat);
                
                // Click handler for targeting
                card.addEventListener('click', () => {
                    if (battleState.targetingMode && enemy.hostile && enemy.hp > 0) {
                        const attacker = battleState.turnOrder[battleState.currentTurn];
                        executeAttack(attacker, enemy, battleState.pendingAction);
                        
                        // Exit targeting mode
                        battleState.targetingMode = false;
                        battleState.pendingAction = null;
                        document.getElementById('battleCanvas').style.cursor = 'default';
                        updateBattleEnemyCards(); // Refresh to remove targetable class
                    }
                });
                
                container.appendChild(card);
            });
        }
        
        // D&D modifier calculation
        function calculateModifier(stat) {
            return Math.floor((stat - 10) / 2);
        }
        
        // Find closest hero to an enemy
        function findClosestHero(enemy, heroes) {
            let target = heroes[0];
            let minDistance = Math.sqrt(Math.pow(enemy.x - target.x, 2) + Math.pow(enemy.y - target.y, 2));
            
            for (let i = 1; i < heroes.length; i++) {
                const hero = heroes[i];
                const distance = Math.sqrt(Math.pow(enemy.x - hero.x, 2) + Math.pow(enemy.y - hero.y, 2));
                if (distance < minDistance) {
                    minDistance = distance;
                    target = hero;
                }
            }
            return target;
        }
        
        // Dice rolling functions
        function rollD20() {
            return Math.floor(Math.random() * 20) + 1;
        }
        
        function rollD6(count = 1) {
            let total = 0;
            for (let i = 0; i < count; i++) {
                total += Math.floor(Math.random() * 6) + 1;
            }
            return total;
        }
        
        // Display dice roll result
        function showDiceRoll(text) {
            const display = document.getElementById('diceRollDisplay');
            if (display) {
                display.textContent = text;
                display.style.display = 'block';
                setTimeout(() => {
                    display.style.display = 'none';
                }, 3000);
            }
        }
        
        // Show battle notification banner
        function showBattleNotification(text) {
            const notification = document.getElementById('battleNotification');
            if (notification) {
                notification.textContent = text;
                notification.style.display = 'block';
                setTimeout(() => {
                    notification.style.display = 'none';
                }, 3000);
            }
        }
        
        // Confirmation modal system
        let confirmationCallback = null;
        
        function showConfirmation(title, message, callback) {
            document.getElementById('confirmationTitle').textContent = title;
            document.getElementById('confirmationMessage').textContent = message;
            confirmationCallback = callback;
            document.getElementById('confirmationModal').style.display = 'block';
        }
        
        function confirmModalAction(confirmed) {
            document.getElementById('confirmationModal').style.display = 'none';
            if (confirmationCallback) {
                confirmationCallback(confirmed);
                confirmationCallback = null;
            }
        }
        
        // Handle battle actions
        function battleAction(action) {
            if (action === 'retreat') {
                // In multiplayer, retreat kills all your controlled heroes
                if (multiplayerState.enabled) {
                    multiplayerState.myHeroes.forEach(heroName => {
                        const hero = battleState.heroes.find(h => h.name.toLowerCase() === heroName);
                        if (hero) {
                            hero.hp = 0;
                        }
                    });
                    
                    if (multiplayerState.role === 'host') {
                        // Remove dead heroes from arrays
                        battleState.heroes = battleState.heroes.filter(h => h.hp > 0);
                        battleState.turnOrder = battleState.turnOrder.filter(combatant => {
                            if (battleState.heroes.includes(combatant)) return true;
                            if (battleState.enemies.includes(combatant)) return combatant.hp > 0;
                            return false;
                        });
                        
                        // Update UI and broadcast
                        updateBattleHeroCards();
                        renderBattle();
                        broadcastGameState();
                        
                        // Check if any heroes still alive
                        if (battleState.heroes.length === 0) {
                            showBattleNotification('DEFEAT! ALL HEROES RETREATED!');
                            
                            // Notify clients to end battle
                            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                                sendWebSocketMessage({
                                    type: 'battle_end',
                                    reason: 'retreat'
                                });
                            }
                            
                            setTimeout(() => {
                                // Hide notification
                                const notification = document.getElementById('battleNotification');
                                if (notification) notification.style.display = 'none';
                                
                                endBattle();
                            }, 2000);
                        } else {
                            // Reset turn if current combatant was removed
                            const currentCombatant = battleState.turnOrder[battleState.currentTurn];
                            if (!currentCombatant) {
                                battleState.currentTurn = 0;
                                updateBattleTurnInfo();
                            }
                        }
                    } else {
                        // Client sends retreat to host
                        sendWebSocketMessage({
                            type: 'player_action',
                            action: 'retreat',
                            heroes: multiplayerState.myHeroes
                        });
                        
                        // Update local UI immediately
                        updateBattleHeroCards();
                        renderBattle();
                    }
                } else {
                    // Single player - just end battle
                    endBattle();
                }
                return;
            }
            
            const currentCombatant = battleState.turnOrder[battleState.currentTurn];
            
            // Check if it's a hero's turn
            const isHeroTurn = battleState.heroes.includes(currentCombatant);
            
            if (!isHeroTurn) {
                console.log('Not hero turn');
                return;
            }
            
            // Multiplayer: Check if this is my hero
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                if (!multiplayerState.myHeroes.includes(currentCombatant.name.toLowerCase())) {
                    showDiceRoll('Not your turn!');
                    return;
                }
            }
            
            // Check if hero is disabled (0 HP)
            if (currentCombatant.hp <= 0) {
                showDiceRoll(`${currentCombatant.name} is disabled!`);
                advanceTurn();
                return;
            }
            
            // Enter targeting mode for attacks
            if (action === 'light' || action === 'heavy' || action === 'special') {
                // Multiplayer: Client enters targeting mode but won't execute until host confirms
                battleState.targetingMode = true;
                battleState.pendingAction = action;
                // Show targeting UI feedback
                document.getElementById('battleCanvas').style.cursor = 'crosshair';
                // Highlight enemies on canvas and cards
                updateBattleEnemyCards();
                renderBattle();
                return;
            }
            
            // Defend action - reduce damage by 50% until next turn
            if (action === 'defend') {
                // Multiplayer: Client sends to host
                if (multiplayerState.enabled && multiplayerState.role === 'client') {
                    sendWebSocketMessage({
                        type: 'player_action',
                        action: 'defend',
                        hero: currentCombatant.name
                    });
                    return;
                }
                
                currentCombatant.defending = true;
                showDiceRoll(`${currentCombatant.name} defends!`);
                advanceTurn();
                return;
            }
            
            // Heal action - restore 50% of max HP (costs 1 action point)
            if (action === 'heal') {
                if (currentCombatant.healsRemaining <= 0) {
                    showDiceRoll(`${currentCombatant.name} has no heals left!`);
                    return;
                }
                
                // Multiplayer: Client sends to host
                if (multiplayerState.enabled && multiplayerState.role === 'client') {
                    sendWebSocketMessage({
                        type: 'player_action',
                        action: 'heal',
                        hero: currentCombatant.name
                    });
                    return;
                }
                
                const healAmount = Math.floor(currentCombatant.maxHp * 0.5);
                currentCombatant.hp = Math.min(currentCombatant.maxHp, currentCombatant.hp + healAmount);
                currentCombatant.healsRemaining--;
                currentCombatant.usedHeal = true; // Mark that heal was used this turn
                
                showDiceRoll(`${currentCombatant.name} heals for ${healAmount} HP! (1 action used)`);
                updateBattleHeroCards();
                
                // Disable heavy and special buttons after heal
                document.getElementById('battleHeavyBtn').disabled = true;
                document.getElementById('battleHeavyBtn').style.opacity = '0.5';
                document.getElementById('battleSpecialBtn').disabled = true;
                document.getElementById('battleSpecialBtn').style.opacity = '0.5';
                
                // Host broadcasts state
                if (multiplayerState.enabled && multiplayerState.role === 'host') {
                    broadcastGameState();
                }
                
                return; // Don't advance turn
            }
            
            // Swap action - swap positions with another hero
            if (action === 'swap') {
                // Multiplayer: Client enters swap targeting mode
                battleState.swapTargetingMode = true;
                battleState.swapInitiator = currentCombatant;
                document.getElementById('battleCanvas').style.cursor = 'pointer';
                showDiceRoll(`${currentCombatant.name}: Select a hero to swap with`);
                renderBattle();
                return;
            }
            
            // Taunt action - draw enemy aggro with CHA check
            if (action === 'taunt') {
                // Multiplayer: Client sends to host
                if (multiplayerState.enabled && multiplayerState.role === 'client') {
                    sendWebSocketMessage({
                        type: 'player_action',
                        action: 'taunt',
                        hero: currentCombatant.name
                    });
                    return;
                }
                
                const chaModifier = calculateModifier(currentCombatant.stats?.cha || 10);
                const tauntRoll = rollD20() + chaModifier;
                const tauntDC = 12; // Base difficulty
                
                if (tauntRoll >= tauntDC) {
                    currentCombatant.taunting = true;
                    currentCombatant.tauntTurns = 3; // Lasts 3 turns
                    showDiceRoll(`${currentCombatant.name} taunts! d20(${tauntRoll}) SUCCESS!`);
                } else {
                    showDiceRoll(`${currentCombatant.name} taunt fails! d20(${tauntRoll}) vs DC ${tauntDC}`);
                }
                advanceTurn();
                
                // Host broadcasts state
                if (multiplayerState.enabled && multiplayerState.role === 'host') {
                    broadcastGameState();
                }
                return;
            }
            
            // Skip action - end turn without doing anything
            if (action === 'skip') {
                // Multiplayer: Client sends to host
                if (multiplayerState.enabled && multiplayerState.role === 'client') {
                    sendWebSocketMessage({
                        type: 'player_action',
                        action: 'skip',
                        hero: currentCombatant.name
                    });
                    return;
                }
                
                showDiceRoll(`${currentCombatant.name} skips turn.`);
                advanceTurn();
                
                // Host broadcasts state
                if (multiplayerState.enabled && multiplayerState.role === 'host') {
                    broadcastGameState();
                }
                return;
            }
        }
        
        // Execute attack on target
        function executeAttack(attacker, target, actionType) {
            const attackerStats = attacker.stats || {};
            const str = attackerStats.str || 10;
            const dex = attackerStats.dex || 10;
            const wis = attackerStats.wis || 10;
            
            let attackRoll = rollD20();
            let modifier = 0;
            let damageRoll = 0;
            let attackName = '';
            
            // Calculate attack and damage based on action type
            if (actionType === 'light') {
                modifier = calculateModifier(dex);
                attackRoll += calculateModifier(str);
                damageRoll = rollD6(1) + modifier;
                attackName = 'Light Attack';
            } else if (actionType === 'heavy') {
                modifier = calculateModifier(str);
                attackRoll += modifier;
                damageRoll = rollD6(2) + modifier;
                attackName = 'Heavy Attack';
            } else if (actionType === 'special') {
                modifier = calculateModifier(wis);
                attackRoll += modifier;
                damageRoll = rollD6(3) + modifier;
                attackName = 'Special Attack';
            }
            
            // Check if attack hits
            const targetAC = target.ac || 10;
            
            // Award 1 XP for attempting attack
            attacker.xp = (attacker.xp || 0) + 1;
            
            if (attackRoll >= targetAC) {
                // Apply defending reduction
                if (target.defending) {
                    damageRoll = Math.floor(damageRoll / 2);
                    target.defending = false;
                }
                
                target.hp = Math.max(0, target.hp - damageRoll);
                
                // Award 2 XP for hitting (total 3 including attempt)
                attacker.xp += 2;
                
                showDiceRoll(`${attackName}: d20(${attackRoll}) HIT! Damage: ${damageRoll}`);
            } else {
                showDiceRoll(`${attackName}: d20(${attackRoll}) MISS vs AC ${targetAC}`);
            }
            
            renderBattle();
            updateBattleEnemyCards();
            updateBattleHeroCards();
            
            // Check if target is dead
            if (target.hp <= 0) {
                // Award 10 XP for killing blow
                attacker.xp += 10;
                updateBattleHeroCards();
                // Remove from battle
                battleState.enemies = battleState.enemies.filter(e => e !== target);
                battleState.turnOrder = battleState.turnOrder.filter(c => c !== target);
                
                // Check win condition
                if (battleState.enemies.length === 0) {
                    battleState.won = true;
                    showBattleNotification('ROOM CLEARED!');
                    // Change retreat button to leave
                    const retreatBtn = document.querySelector('.battleButton.retreat');
                    if (retreatBtn) {
                        retreatBtn.textContent = 'üö™ LEAVE';
                    }
                    // Broadcast final state
                    if (multiplayerState.enabled && multiplayerState.role === 'host') {
                        broadcastGameState();
                    }
                    return;
                }
            }
            
            advanceTurn();
            
            // Broadcast state after action
            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                broadcastGameState();
            }
        }
        
        // Process AI turn
        function processAITurn(combatant) {
            if (!combatant.hostile) {
                // Friendly/neutral NPCs skip turn
                showDiceRoll(`${combatant.name} waits...`);
                advanceTurn();
                return;
            }
            
            // Hostile AI: pick closest hero and attack
            const aliveHeroes = battleState.heroes.filter(h => h.hp > 0);
            if (aliveHeroes.length === 0) {
                // Game over
                showBattleNotification('DEFEAT! ALL HEROES FALLEN!');
                
                // Notify clients if multiplayer
                if (multiplayerState.enabled && multiplayerState.role === 'host') {
                    sendWebSocketMessage({
                        type: 'battle_end',
                        reason: 'defeat'
                    });
                }
                
                setTimeout(() => {
                    // Hide notification
                    const notification = document.getElementById('battleNotification');
                    if (notification) notification.style.display = 'none';
                    
                    endBattle();
                }, 2000);
                return;
            }
            
            // Check for taunting heroes first
            const tauntingHeroes = aliveHeroes.filter(h => h.taunting && h.tauntTurns > 0);
            let target;
            
            if (tauntingHeroes.length > 0) {
                // Roll to resist taunt
                const resistRoll = rollD20();
                const resistDC = 15; // Base resist DC
                
                if (resistRoll < resistDC) {
                    // Failed to resist, attack taunter
                    target = tauntingHeroes[0];
                    showDiceRoll(`${combatant.name} is taunted by ${target.name}!`);
                } else {
                    // Resisted taunt, clear taunt status
                    tauntingHeroes.forEach(h => {
                        h.taunting = false;
                        h.tauntTurns = 0;
                    });
                    showDiceRoll(`${combatant.name} resists taunt! d20(${resistRoll})`);
                    // Fall through to normal targeting
                    target = findClosestHero(combatant, aliveHeroes);
                }
            } else {
                // No taunters, find closest hero
                target = findClosestHero(combatant, aliveHeroes);
            }
            
            // AI attack roll
            const attackRoll = rollD20();
            const damage = combatant.attackDamage || rollD6(1);
            
            // Don't damage heroes already at 0 HP
            if (target.hp <= 0) {
                showDiceRoll(`${combatant.name} ignores disabled ${target.name}`);
                advanceTurn();
                return;
            }
            
            if (attackRoll >= (target.stats?.ac || 10)) {
                let finalDamage = damage;
                if (target.defending) {
                    finalDamage = Math.floor(damage / 2);
                    target.defending = false;
                }
                
                target.hp = Math.max(0, target.hp - finalDamage);
                showDiceRoll(`${combatant.name} attacks ${target.name}: HIT for ${finalDamage} damage!`);
            } else {
                showDiceRoll(`${combatant.name} attacks ${target.name}: MISS!`);
            }
            
            renderBattle();
            updateBattleHeroCards();
            updateBattleEnemyCards();
            
            // Broadcast AI action to clients
            broadcastGameState();
            
            // Check if hero died
            if (target.hp <= 0) {
                const allHeroesDead = battleState.heroes.every(h => h.hp <= 0);
                if (allHeroesDead) {
                    showBattleNotification('DEFEAT! ALL HEROES FALLEN!');
                    
                    // Notify clients if multiplayer
                    if (multiplayerState.enabled && multiplayerState.role === 'host') {
                        sendWebSocketMessage({
                            type: 'battle_end',
                            reason: 'defeat'
                        });
                    }
                    
                    setTimeout(() => {
                        // Hide notification
                        const notification = document.getElementById('battleNotification');
                        if (notification) notification.style.display = 'none';
                        
                        endBattle();
                    }, 2000);
                    return;
                }
            }
            
            advanceTurn();
        }
        
        // Advance to next turn
        function advanceTurn() {
            battleState.currentTurn = (battleState.currentTurn + 1) % battleState.turnOrder.length;
            const nextCombatant = battleState.turnOrder[battleState.currentTurn];
            
            // Reset action state for new turn
            battleState.heroes.forEach(hero => {
                hero.usedHeal = false;
            });
            
            // Re-enable all buttons at start of turn
            const heavyBtn = document.getElementById('battleHeavyBtn');
            const specialBtn = document.getElementById('battleSpecialBtn');
            if (heavyBtn) {
                heavyBtn.disabled = false;
                heavyBtn.style.opacity = '1';
            }
            if (specialBtn) {
                specialBtn.disabled = false;
                specialBtn.style.opacity = '1';
            }
            
            // Decrement taunt turns for all heroes
            battleState.heroes.forEach(hero => {
                if (hero.tauntTurns > 0) {
                    hero.tauntTurns--;
                    if (hero.tauntTurns <= 0) {
                        hero.taunting = false;
                    }
                }
            });
            
            updateBattleTurnInfo();
            
            // Broadcast turn advancement to clients
            broadcastGameState();
            
            // If next turn is AI, process automatically
            if (!battleState.heroes.includes(nextCombatant)) {
                setTimeout(() => processAITurn(nextCombatant), 1000);
            }
        }
        
        // End battle and return to dungeon menu
        function endBattle() {
            // Save hero stats to shared save
            const sharedSave = loadSharedSave();
            if (sharedSave && sharedSave.heroes) {
                battleState.heroes.forEach(hero => {
                    const heroKey = hero.name.toLowerCase();
                    if (sharedSave.heroes[heroKey]) {
                        // Save all stats back to save file
                        sharedSave.heroes[heroKey].hp = hero.hp ?? 0;
                        sharedSave.heroes[heroKey].maxHp = hero.maxHp ?? 0;
                        sharedSave.heroes[heroKey].str = hero.stats?.str ?? sharedSave.heroes[heroKey].str;
                        sharedSave.heroes[heroKey].dex = hero.stats?.dex ?? sharedSave.heroes[heroKey].dex;
                        sharedSave.heroes[heroKey].con = hero.stats?.con ?? sharedSave.heroes[heroKey].con;
                        sharedSave.heroes[heroKey].int = hero.stats?.int ?? sharedSave.heroes[heroKey].int;
                        sharedSave.heroes[heroKey].wis = hero.stats?.wis ?? sharedSave.heroes[heroKey].wis;
                        sharedSave.heroes[heroKey].cha = hero.stats?.cha ?? sharedSave.heroes[heroKey].cha;
                        sharedSave.heroes[heroKey].xp = hero.xp ?? 0;
                        sharedSave.heroes[heroKey].level = hero.level ?? 1;
                    }
                });
                
                // Save current dungeon level
                const dungeonLevelEl = document.getElementById('dungeonMenuLevel');
                if (dungeonLevelEl && sharedSave.dungeonState) {
                    sharedSave.dungeonState.currentLevel = parseInt(dungeonLevelEl.textContent) || 1;
                }
                
                saveSharedSave(sharedSave);
            }
            
            battleState.active = false;
            currentScreen = 'dungeonMenu';
            document.getElementById('battleScreen').style.display = 'none';
            document.getElementById('dungeonMenuScreen').style.display = 'block';
            
            // Move music controls and ticker back to center bottom
            document.getElementById('musicControls').classList.remove('battleActive');
            document.getElementById('musicTicker').classList.remove('battleActive');
        }
        
        // ===== END BATTLE SYSTEM =====
        
        // Exit portal and return to arcade game
        function exitPortal() {
            try {
                // Load shared save
                const sharedSave = loadSharedSave();
                if (!sharedSave) {
                    alert('No shared save found! Cannot return to arcade.');
                    return;
                }
                
                // Get current dungeon level
                const dungeonLevelEl = document.getElementById('dungeonMenuLevel') || document.getElementById('dungeonLevel');
                const currentLevel = dungeonLevelEl ? (parseInt(dungeonLevelEl.textContent) || 1) : 1;
                
                // Update dungeon state
                sharedSave.dungeonState = {
                    currentLevel: currentLevel,
                    inventory: sharedSave.dungeonState?.inventory || [],
                    gold: sharedSave.dungeonState?.gold || 0,
                    questProgress: sharedSave.dungeonState?.questProgress || {
                        hasScepter: false,
                        hasReturned: false,
                        bossesDefeated: []
                    }
                };
                sharedSave.lastPlayed = Date.now();
                
                // Save updated shared state
                saveSharedSave(sharedSave);
                
                // Navigate back to arcade
                window.location.href = 'zlock_consensus.html';
            } catch (e) {
                console.error('Failed to exit portal:', e);
                alert('Portal exit failed! ' + e.message);
            }
        }
        
        // Update hero stat display (both title and dungeon screens)
        function updateHeroDisplay(heroName, stats) {
            const prefix = heroName.toLowerCase();
            
            // Title screen hero stats
            const levelEl = document.getElementById(`${prefix}-level`);
            const hpEl = document.getElementById(`${prefix}-hp`);
            const maxhpEl = document.getElementById(`${prefix}-maxhp`);
            const strEl = document.getElementById(`${prefix}-str`);
            const dexEl = document.getElementById(`${prefix}-dex`);
            const conEl = document.getElementById(`${prefix}-con`);
            const intEl = document.getElementById(`${prefix}-int`);
            const wisEl = document.getElementById(`${prefix}-wis`);
            const chaEl = document.getElementById(`${prefix}-cha`);
            const xpEl = document.getElementById(`${prefix}-xp`);
            
            // Dungeon screen hero stats (prefixed with 'd')
            const dhpEl = document.getElementById(`d${prefix}-hp`);
            const dmaxhpEl = document.getElementById(`d${prefix}-maxhp`);
            const dxpEl = document.getElementById(`d${prefix}-xp`);
            const dstrEl = document.getElementById(`d${prefix}-str`);
            const ddexEl = document.getElementById(`d${prefix}-dex`);
            const dconEl = document.getElementById(`d${prefix}-con`);
            const dintEl = document.getElementById(`d${prefix}-int`);
            const dwisEl = document.getElementById(`d${prefix}-wis`);
            const dchaEl = document.getElementById(`d${prefix}-cha`);
            
            // Update title screen
            if (levelEl) levelEl.textContent = stats.level || 1;
            if (hpEl) hpEl.textContent = stats.hp || 0;
            if (maxhpEl) maxhpEl.textContent = stats.maxHp || 0;
            if (strEl) strEl.textContent = stats.str || 0;
            if (dexEl) dexEl.textContent = stats.dex || 0;
            if (conEl) conEl.textContent = stats.con || 0;
            if (intEl) intEl.textContent = stats.int || 0;
            if (wisEl) wisEl.textContent = stats.wis || 0;
            if (chaEl) chaEl.textContent = stats.cha || 0;
            if (xpEl) xpEl.textContent = stats.xp || 0;
            
            // Update dungeon screen
            if (dhpEl) dhpEl.textContent = stats.hp || 0;
            if (dmaxhpEl) dmaxhpEl.textContent = stats.maxHp || 0;
            if (dxpEl) dxpEl.textContent = stats.xp || 0;
            if (dstrEl) dstrEl.textContent = stats.str || 0;
            if (ddexEl) ddexEl.textContent = stats.dex || 0;
            if (dconEl) dconEl.textContent = stats.con || 0;
            if (dintEl) dintEl.textContent = stats.int || 0;
            if (dwisEl) dwisEl.textContent = stats.wis || 0;
            if (dchaEl) dchaEl.textContent = stats.cha || 0;
        }
        
        // Update dungeon menu hero stats from save
        function updateDungeonMenuHeroes() {
            const sharedSave = loadSharedSave();
            if (!sharedSave || !sharedSave.heroes) return;
            
            updateHeroDisplay('zooko', sharedSave.heroes.zooko);
            updateHeroDisplay('nate', sharedSave.heroes.nate);
            updateHeroDisplay('zancas', sharedSave.heroes.zancas);
            updateHeroDisplay('cyberaxe', sharedSave.heroes.cyberaxe);
        }
        
        // Start adventure - switch from title to dungeon menu
        function startAdventure() {
            const titleScreen = document.getElementById('titleScreen');
            const dungeonMenuScreen = document.getElementById('dungeonMenuScreen');
            
            if (titleScreen) titleScreen.style.display = 'none';
            if (dungeonMenuScreen) dungeonMenuScreen.style.display = 'block';
            
            currentScreen = 'dungeonMenu';
            
            // Create save if it doesn't exist
            let sharedSave = loadSharedSave();
            if (!sharedSave) {
                sharedSave = createDefaultSharedSave();
                saveSharedSave(sharedSave);
            }
            
            // Sync dungeon level display
            if (sharedSave && sharedSave.arcadeState && sharedSave.arcadeState.level) {
                const dungeonMenuLevel = document.getElementById('dungeonMenuLevel');
                if (dungeonMenuLevel) {
                    dungeonMenuLevel.textContent = sharedSave.arcadeState.level;
                }
            }
            
            // Load hero stats from save to dungeon menu
            updateDungeonMenuHeroes();
            
            // If multiplayer host, notify clients to start and send save data
            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                sendWebSocketMessage({ 
                    type: 'game_start', 
                    screen: 'dungeonMenu',
                    saveData: sharedSave
                });
            }
        }
        
        // Pause game
        function pauseGame() {
            if (currentScreen === 'title') return; // Can't pause on title screen
            
            isPaused = true;
            const pauseScreen = document.getElementById('pauseScreen');
            if (pauseScreen) pauseScreen.style.display = 'flex';
        }
        
        // Resume game
        function resumeGame() {
            isPaused = false;
            const pauseScreen = document.getElementById('pauseScreen');
            if (pauseScreen) pauseScreen.style.display = 'none';
        }
        
        // Save game from pause menu
        function saveGameFromPause() {
            try {
                let sharedSave = loadSharedSave();
                if (!sharedSave) {
                    // Create new save if none exists
                    sharedSave = createDefaultSharedSave();
                }
                
                // Update last played timestamp
                sharedSave.lastPlayed = Date.now();
                
                // Save to localStorage
                if (saveSharedSave(sharedSave)) {
                    alert('Game saved successfully!');
                    // Update button states to reflect save exists
                    updateTitleScreenButtons();
                } else {
                    alert('Failed to save game!');
                }
            } catch (e) {
                console.error('Save error:', e);
                alert('Error saving game: ' + e.message);
            }
        }
        
        // Download save file
        function downloadSaveFile() {
            try {
                const sharedSave = loadSharedSave();
                if (!sharedSave) {
                    alert('No save data to download!');
                    return;
                }
                
                // Update timestamp
                sharedSave.lastPlayed = Date.now();
                saveSharedSave(sharedSave);
                
                // Create filename with date/time
                const now = new Date();
                const dateStr = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
                const hours = now.getHours();
                const minutes = String(now.getMinutes()).padStart(2, '0');
                const ampm = hours >= 12 ? 'pm' : 'am';
                const hour12 = hours % 12 || 12;
                const timeStr = `${hour12}_${minutes}_${ampm}`;
                
                const level = sharedSave.arcadeState ? sharedSave.arcadeState.level : 1;
                const filename = `tunnels-save-level${level}-${dateStr}-${timeStr}.json`;
                
                // Download JSON
                const jsonString = JSON.stringify(sharedSave, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                alert(`Save file downloaded: ${filename}`);
            } catch (e) {
                console.error('Download error:', e);
                alert('Error downloading save file: ' + e.message);
            }
        }
        
        // Show settings from pause
        function showSettingsFromPause() {
            showSettings();
        }
        
        // Quit to menu
        function quitToMenu() {
            isPaused = false;
            currentScreen = 'title';
            
            const pauseScreen = document.getElementById('pauseScreen');
            const dungeonMenuScreen = document.getElementById('dungeonMenuScreen');
            const titleScreen = document.getElementById('titleScreen');
            const battleScreen = document.getElementById('battleScreen');
            
            if (pauseScreen) pauseScreen.style.display = 'none';
            if (dungeonMenuScreen) dungeonMenuScreen.style.display = 'none';
            if (battleScreen) battleScreen.style.display = 'none';
            if (titleScreen) titleScreen.style.display = 'block';
            
            // Reload hero stats from save
            const sharedSave = loadSharedSave();
            const heroStatsEl = document.getElementById('heroStats');
            
            if (sharedSave && sharedSave.heroes) {
                // Show hero party
                if (heroStatsEl) heroStatsEl.style.display = 'block';
                
                // Update each hero's display
                updateHeroDisplay('zooko', sharedSave.heroes.zooko);
                updateHeroDisplay('nate', sharedSave.heroes.nate);
                updateHeroDisplay('zancas', sharedSave.heroes.zancas);
                updateHeroDisplay('cyberaxe', sharedSave.heroes.cyberaxe);
            } else {
                // Hide hero party when no save exists
                if (heroStatsEl) heroStatsEl.style.display = 'none';
            }
        }
        
        // ESC key listener
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                e.preventDefault();
                
                // Close all panels first
                const overlay = document.getElementById('overlay');
                const settingsPanel = document.getElementById('settingsPanel');
                const loadSavePanel = document.getElementById('loadSavePanel');
                
                if (overlay && overlay.style.display === 'block') {
                    closeAllPanels();
                    return;
                }
                
                // Toggle pause
                if (isPaused) {
                    resumeGame();
                } else {
                    pauseGame();
                }
            }
        });
        
        // ===== GAMEPAD FUNCTIONS =====
        function onGamepadConnected(e) {
            gamepadConnected = true;
            gamepadIndex = e.gamepad.index;
            console.log(`üéÆ Controller Connected: ${e.gamepad.id}`);
        }
        
        function onGamepadDisconnected(e) {
            if (e.gamepad.index === gamepadIndex) {
                gamepadConnected = false;
                gamepadIndex = null;
                gamepadButtonStates = {};
                console.log('üéÆ Controller Disconnected');
            }
        }
        
        function updateGamepad() {
            if (!gamepadConnected || gamepadIndex === null) return;
            
            // Don't process gamepad input while loading modal is visible
            const loadingModal = document.getElementById('loadingModal');
            if (loadingModal && loadingModal.style.display !== 'none') return;
            
            const now = Date.now();
            if (now - lastGamepadUpdate < gamepadUpdateInterval) return;
            lastGamepadUpdate = now;
            
            const gamepads = navigator.getGamepads();
            const gamepad = gamepads[gamepadIndex];
            
            if (!gamepad) return;
            
            // Process buttons
            gamepad.buttons.forEach((button, index) => {
                const wasPressed = gamepadButtonStates[index] || false;
                const isPressed = button.pressed;
                
                // Button just pressed (rising edge)
                if (isPressed && !wasPressed) {
                    handleGamepadButtonPress(index);
                }
                
                gamepadButtonStates[index] = isPressed;
            });
        }
        
        function handleGamepadButtonPress(buttonIndex) {
            // ===== SETTINGS PANEL NAVIGATION =====
            const settingsPanel = document.getElementById('settingsPanel');
            if (settingsPanel && settingsPanel.style.display === 'block') {
                // B button - Close
                if (buttonIndex === GamepadButtons.B) {
                    closeAllPanels();
                    return;
                }
                return; // Block all other inputs when settings is open
            }
            // ===== END SETTINGS PANEL NAVIGATION =====
            
            // ===== LOAD SAVE PANEL NAVIGATION =====
            const loadSavePanel = document.getElementById('loadSavePanel');
            if (loadSavePanel && loadSavePanel.style.display === 'block') {
                // B button - Close
                if (buttonIndex === GamepadButtons.B) {
                    closeAllPanels();
                    return;
                }
                return; // Block all other inputs when load save panel is open
            }
            // ===== END LOAD SAVE PANEL NAVIGATION =====
            
            // ===== TITLE SCREEN NAVIGATION =====
            if (currentScreen === 'title') {
                // A button - Start Adventure
                if (buttonIndex === GamepadButtons.A) {
                    startAdventure();
                    return;
                }
                // Y button - Settings
                else if (buttonIndex === GamepadButtons.Y) {
                    showSettings();
                    return;
                }
                // B button - Load Save File
                else if (buttonIndex === GamepadButtons.B) {
                    showLoadSave();
                    return;
                }
                // BACK button (SELECT) - Exit Portal
                else if (buttonIndex === GamepadButtons.SELECT) {
                    exitPortal();
                    return;
                }
            }
            // ===== END TITLE SCREEN NAVIGATION =====
            
            // ===== PAUSE MENU NAVIGATION =====
            if (isPaused) {
                // A button - Resume
                if (buttonIndex === GamepadButtons.A) {
                    resumeGame();
                    return;
                }
                // B button - Resume (also works)
                else if (buttonIndex === GamepadButtons.B) {
                    resumeGame();
                    return;
                }
                // Y button - Settings
                else if (buttonIndex === GamepadButtons.Y) {
                    showSettingsFromPause();
                    return;
                }
                // SELECT button - Quit to Menu
                else if (buttonIndex === GamepadButtons.SELECT) {
                    quitToMenu();
                    return;
                }
            }
            // ===== END PAUSE MENU NAVIGATION =====
            
            // START button - Pause/Resume
            if (buttonIndex === GamepadButtons.START) {
                if (currentScreen === 'title') return; // Can't pause on title screen
                
                if (isPaused) {
                    resumeGame();
                } else {
                    pauseGame();
                }
                return;
            }
        }
        
        // Poll gamepad in animation loop
        function gamepadLoop() {
            updateGamepad();
            requestAnimationFrame(gamepadLoop);
        }
        
        // Gamepad polling for Click to Enter
        function pollGamepadForClickToPlay() {
            const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
            for (let i = 0; i < gamepads.length; i++) {
                const gp = gamepads[i];
                if (gp && gp.buttons[0] && gp.buttons[0].pressed) { // A button
                    const clickToPlayPrompt = document.getElementById('clickToPlayPrompt');
                    if (clickToPlayPrompt && clickToPlayPrompt.style.display !== 'none') {
                        clickToPlayPrompt.click();
                        return;
                    }
                }
            }
            
            // Continue polling if loading modal is visible
            const loadingModal = document.getElementById('loadingModal');
            if (loadingModal && loadingModal.style.display !== 'none') {
                requestAnimationFrame(pollGamepadForClickToPlay);
            }
        }
        // ===== END GAMEPAD FUNCTIONS =====
        
        // Initialize on page load
        // Preload images and audio into browser cache
        function preloadAssets() {
            const imageList = [
                // Story intro background
                'story/intro/intro_a.png',
                // Character head icons
                'people/zooko_a_head_compressed.png',
                'people/Nate_a_head_compressed.png',
                'people/Zancas_a_head_compressed.png',
                'people/cyberaxe_a_head_compressed.png'
            ];
            
            artTotal = imageList.length;
            assetsToLoad += imageList.length;
            
            // Preload images
            imageList.forEach(imagePath => {
                const img = new Image();
                img.src = imagePath;
                img.addEventListener('load', () => {
                    console.log(`Preloaded: ${imagePath}`);
                    artLoaded++;
                    assetsLoaded++;
                    updateLoadingProgress();
                }, { once: true });
                img.addEventListener('error', (e) => {
                    console.error(`Failed to preload: ${imagePath}`, e);
                    artLoaded++;
                    assetsLoaded++;
                    updateLoadingProgress();
                }, { once: true });
            });
            
            // Preload music if enabled
            if (musicEnabled && musicVolume > 0) {
                audioTotal = 1;
                assetsToLoad += 1;
                
                const musicPlayer = document.getElementById('musicPlayer');
                if (musicPlayer) {
                    musicPlayer.volume = Math.min(1.0, musicVolume / 100);
                    musicPlayer.preload = 'metadata'; // Changed from 'auto' to avoid hanging
                    
                    // Set a timeout in case music doesn't load
                    const musicTimeout = setTimeout(() => {
                        console.log('Music preload timeout - continuing anyway');
                        audioLoaded++;
                        assetsLoaded++;
                        updateLoadingProgress();
                    }, 3000); // 3 second timeout
                    
                    musicPlayer.addEventListener('loadedmetadata', () => {
                        console.log('Music metadata loaded');
                        clearTimeout(musicTimeout);
                        audioLoaded++;
                        assetsLoaded++;
                        updateLoadingProgress();
                    }, { once: true });
                    
                    musicPlayer.addEventListener('error', (e) => {
                        console.error('Failed to preload music', e);
                        clearTimeout(musicTimeout);
                        audioLoaded++;
                        assetsLoaded++;
                        updateLoadingProgress();
                    }, { once: true });
                    
                    musicPlayer.load();
                } else {
                    // Music player doesn't exist, skip it
                    audioLoaded++;
                    assetsLoaded++;
                    updateLoadingProgress();
                }
            }
            
            updateLoadingProgress();
        }
        
        // Update loading progress indicator
        function updateLoadingProgress() {
            const loadingIndicator = document.getElementById('loadingIndicator');
            const loadingBar = document.getElementById('loadingBar');
            const loadingArt = document.getElementById('loadingArt');
            const loadingSound = document.getElementById('loadingSound');
            
            if (loadingIndicator && assetsToLoad > 0) {
                const percent = Math.floor((assetsLoaded / assetsToLoad) * 100);
                loadingIndicator.textContent = `${percent}%`;
                
                if (loadingBar) {
                    loadingBar.style.width = `${percent}%`;
                    loadingBar.textContent = `${percent}%`;
                }
                
                // Update category counts
                if (loadingArt) {
                    loadingArt.innerHTML = `üé® Art: <span style="color: #8B45FF; font-weight: bold;">${artLoaded}/${artTotal}</span>`;
                }
                if (loadingSound) {
                    loadingSound.innerHTML = `üîä Sound: <span style="color: #8B45FF; font-weight: bold;">${audioLoaded}/${audioTotal}</span>`;
                }
            }
            
            checkAllAssetsReady();
        }
        
        function checkAllAssetsReady() {
            if (assetsToLoad > 0 && assetsLoaded >= assetsToLoad && !allAssetsReady) {
                allAssetsReady = true;
                
                const loadingIndicator = document.getElementById('loadingIndicator');
                const loadingBar = document.getElementById('loadingBar');
                const loadingModal = document.getElementById('loadingModal');
                const loadingNote = document.getElementById('loadingNote');
                const clickToPlayPrompt = document.getElementById('clickToPlayPrompt');
                
                if (loadingIndicator) {
                    loadingIndicator.textContent = '‚úì All Assets Ready!';
                    loadingIndicator.style.color = '#2ECC71';
                }
                
                if (loadingBar) {
                    loadingBar.style.width = '100%';
                    loadingBar.textContent = '100%';
                    loadingBar.style.background = 'linear-gradient(90deg, #2ECC71, #27AE60)';
                }
                
                if (loadingNote) {
                    loadingNote.style.display = 'none';
                }
                
                if (clickToPlayPrompt) {
                    clickToPlayPrompt.style.display = 'block';
                    
                    // Start gamepad polling for A button
                    pollGamepadForClickToPlay();
                    
                    const handleClick = () => {
                        // Start music when user clicks
                        if (musicEnabled && musicVolume > 0 && !musicStarted) {
                            const randomTrack = themeTracks[Math.floor(Math.random() * themeTracks.length)];
                            loadMusic(randomTrack);
                        }
                        
                        // Fade out and remove loading modal
                        if (loadingModal) {
                            loadingModal.style.opacity = '0';
                            loadingModal.style.transition = 'opacity 0.5s ease';
                            setTimeout(() => {
                                loadingModal.style.display = 'none';
                            }, 500);
                        }
                        
                        // Remove click handler
                        clickToPlayPrompt.removeEventListener('click', handleClick);
                        document.removeEventListener('keydown', handleKeyDown);
                    };
                    
                    const handleKeyDown = (e) => {
                        if (e.key === 'a' || e.key === 'A' || e.key === 'Enter') {
                            handleClick();
                        }
                    };
                    
                    clickToPlayPrompt.addEventListener('click', handleClick);
                    document.addEventListener('keydown', handleKeyDown);
                }
            }
        }
        
        // ===== MULTIPLAYER WEBSOCKET FUNCTIONS =====
        
        function connectWebSocket() {
            if (multiplayerState.ws && multiplayerState.ws.readyState === WebSocket.OPEN) {
                return; // Already connected
            }
            
            const wsUrl = `ws://${window.location.hostname}:8765`;
            console.log('[MP] Connecting to WebSocket:', wsUrl);
            
            multiplayerState.ws = new WebSocket(wsUrl);
            
            multiplayerState.ws.onopen = () => {
                console.log('[MP] WebSocket connected');
                multiplayerState.enabled = true;
            };
            
            multiplayerState.ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                handleWebSocketMessage(data);
            };
            
            multiplayerState.ws.onerror = (error) => {
                console.error('[MP] WebSocket error:', error);
                showNotification('Multiplayer connection error', 'error');
            };
            
            multiplayerState.ws.onclose = () => {
                console.log('[MP] WebSocket closed');
                if (multiplayerState.enabled && !multiplayerState.isReconnecting) {
                    showNotification('Disconnected from multiplayer', 'warning');
                    resetMultiplayerState();
                }
            };
        }
        
        function handleWebSocketMessage(data) {
            console.log('[MP] Received:', data);
            
            switch(data.type) {
                case 'room_created':
                    multiplayerState.roomCode = data.code;
                    multiplayerState.role = 'host';
                    multiplayerState.myPlayerId = data.player_id;
                    // Host is always Player 1
                    multiplayerState.playerName = 'Player 1';
                    // Store initial player list
                    if (data.players) {
                        multiplayerState.connectedPlayers = data.players;
                    }
                    showNotification(`Room created: ${data.code}`, 'success');
                    // Host enters hero selection immediately
                    showHeroSelection();
                    break;
                
                case 'joined':
                    multiplayerState.roomCode = data.code;
                    multiplayerState.role = 'client';
                    multiplayerState.myPlayerId = data.player_id;
                    // Store player list
                    if (data.players) {
                        multiplayerState.connectedPlayers = data.players;
                        // Find my name from the list
                        const me = data.players.find(p => p.id === data.player_id);
                        if (me) {
                            multiplayerState.playerName = me.name;
                        }
                    }
                    showNotification(`Joined room: ${data.code}`, 'success');
                    // Show hero selection
                    showHeroSelection();
                    break;
                
                case 'error':
                    showNotification(data.message, 'error');
                    break;
                
                case 'players_update':
                    // Update connected players list
                    if (data.players) {
                        multiplayerState.connectedPlayers = data.players;
                    }
                    // Update hero selections if provided
                    if (data.heroes) {
                        updateHeroSelection({ heroes: data.heroes });
                    } else {
                        // Just update the player list display
                        updateConnectedPlayersListOnly();
                    }
                    break;
                
                case 'player_joined':
                    showNotification(`Player joined (${data.player_count} total)`, 'info');
                    break;
                
                case 'hero_selected':
                    // Update player list if provided
                    if (data.players) {
                        multiplayerState.connectedPlayers = data.players;
                    }
                    // Update hero selections
                    updateHeroSelection(data);
                    break;
                
                case 'player_action':
                    // Host receives client action
                    if (multiplayerState.role === 'host') {
                        processClientAction(data);
                    }
                    break;
                
                case 'state_update':
                    // Client receives state from host
                    if (multiplayerState.role === 'client') {
                        updateGameStateFromHost(data.state);
                    }
                    break;
                
                case 'battle_init':
                    // Client receives battle initialization from host
                    if (multiplayerState.role === 'client') {
                        initializeBattleFromHost(data.battleData);
                    }
                    break;
                
                case 'battle_end':
                    // Host notifies battle has ended
                    if (multiplayerState.role === 'client') {
                        const reason = data.reason;
                        if (reason === 'retreat') {
                            showBattleNotification('DEFEAT! ALL HEROES RETREATED!');
                        } else if (reason === 'defeat') {
                            showBattleNotification('DEFEAT! ALL HEROES FALLEN!');
                        }
                        
                        setTimeout(() => {
                            // Hide notification
                            const notification = document.getElementById('battleNotification');
                            if (notification) notification.style.display = 'none';
                            
                            // End battle and return to dungeon menu
                            endBattle();
                            
                            // Update dungeon menu with latest data
                            updateDungeonMenuHeroes();
                        }, 2000);
                    }
                    break;
                
                case 'kicked':
                    showNotification(data.message, 'error');
                    resetMultiplayerState();
                    break;
                
                case 'host_disconnected':
                    showNotification(data.message, 'error');
                    resetMultiplayerState();
                    currentScreen = 'title';
                    document.getElementById('battleScreen').style.display = 'none';
                    document.getElementById('dungeonMenuScreen').style.display = 'none';
                    document.getElementById('titleScreen').style.display = 'block';
                    break;
                
                case 'player_disconnected':
                    if (multiplayerState.role === 'host') {
                        handlePlayerDisconnect(data.player_id);
                    }
                    break;
                
                case 'code_changed':
                    multiplayerState.roomCode = data.code;
                    showNotification(`Room code changed to: ${data.code}`, 'info');
                    // Update hero selection display if visible
                    const heroCodeDisplay = document.getElementById('heroSelectionCode');
                    if (heroCodeDisplay && heroCodeDisplay.textContent !== '******') {
                        heroCodeDisplay.textContent = data.code;
                    }
                    break;
                
                case 'skip_turn':
                    // Advance turn (force skip)
                    advanceTurn();
                    break;
                
                case 'game_start':
                    // Host started the game - clients follow
                    if (multiplayerState.role === 'client') {
                        // Save host's save data to local storage
                        if (data.saveData) {
                            saveSharedSave(data.saveData);
                        }
                        
                        document.getElementById('titleScreen').style.display = 'none';
                        document.getElementById('heroSelectionModal').style.display = 'none';
                        // Reset music controls position
                        document.getElementById('musicControls').classList.remove('heroSelectionActive');
                        
                        if (data.screen === 'dungeonMenu') {
                            document.getElementById('musicTicker').classList.remove('battleActive');
                            document.getElementById('dungeonMenuScreen').style.display = 'block';
                            currentScreen = 'dungeonMenu';
                            
                            // Load hero stats from save
                            updateDungeonMenuHeroes();
                        } else if (data.screen === 'battle') {
                            // Client waits for battle_init message from host
                            // Just show the screen, don't initialize yet
                            document.getElementById('battleScreen').style.display = 'block';
                            document.getElementById('musicTicker').classList.add('battleActive');
                            currentScreen = 'battle';
                            
                            // Initialize canvas
                            battleState.canvas = document.getElementById('battleCanvas');
                            battleState.ctx = battleState.canvas.getContext('2d');
                            battleState.canvas.width = window.innerWidth;
                            battleState.canvas.height = window.innerHeight - 180;
                            battleState.active = true;
                            
                            // Move music controls to battle position
                            document.getElementById('musicControls').classList.add('battleActive');
                            
                            showNotification('Waiting for host to initialize battle...', 'info');
                            return; // Wait for battle_init
                        }
                        showNotification('Host started the game!', 'success');
                    }
                    break;
            }
            
            // Log message to debug panel
            logDebugMessage(data.type, data, 'in');
            updateDebugStatus();
        }
        
        function sendWebSocketMessage(data) {
            if (multiplayerState.ws && multiplayerState.ws.readyState === WebSocket.OPEN) {
                multiplayerState.ws.send(JSON.stringify(data));
                logDebugMessage(data.type, data, 'out');
                updateDebugStatus();
            } else {
                console.error('[MP] WebSocket not connected');
            }
        }
        
        function createMultiplayerRoom() {
            // Close settings panel
            closeAllPanels();
            
            connectWebSocket();
            setTimeout(() => {
                sendWebSocketMessage({ type: 'create_room' });
            }, 100);
        }
        
        function joinMultiplayerRoom() {
            const code = document.getElementById('joinRoomCodeInput').value.trim().toUpperCase();
            if (code.length !== 6) {
                showNotification('Please enter a 6-character room code', 'error');
                return;
            }
            
            connectWebSocket();
            setTimeout(() => {
                sendWebSocketMessage({ type: 'join_room', code });
            }, 100);
        }
        
        function quickJoinRoom() {
            const code = document.getElementById('titleJoinCode').value.trim().toUpperCase();
            if (code.length !== 6) {
                showNotification('Please enter a 6-character room code', 'error');
                return;
            }
            
            connectWebSocket();
            setTimeout(() => {
                sendWebSocketMessage({ type: 'join_room', code });
            }, 100);
        }
        
        function leaveRoom() {
            if (multiplayerState.ws) {
                multiplayerState.ws.close();
            }
            resetMultiplayerState();
            document.getElementById('connectionStatus').style.display = 'none';
            document.getElementById('joinRoomBtn').style.display = 'block';
            document.getElementById('leaveRoomBtn').style.display = 'none';
            showNotification('Left room', 'info');
        }
        
        function stopHosting() {
            if (multiplayerState.ws) {
                multiplayerState.ws.close();
            }
            resetMultiplayerState();
            document.getElementById('roomCodeDisplay').style.display = 'none';
            document.getElementById('createRoomBtn').style.display = 'block';
            document.getElementById('changeCodeBtn').style.display = 'none';
            document.getElementById('stopHostingBtn').style.display = 'none';
            document.getElementById('hostControlsBtn').style.display = 'none';
            showNotification('Stopped hosting', 'info');
        }
        
        function changeRoomCode() {
            if (confirm('Changing the room code will disconnect all players. Continue?')) {
                sendWebSocketMessage({ type: 'change_code' });
            }
        }
        
        function changeRoomCodeFromPanel() {
            closeHostControls();
            changeRoomCode();
        }
        
        function resetMultiplayerState() {
            multiplayerState.enabled = false;
            multiplayerState.role = null;
            multiplayerState.roomCode = null;
            multiplayerState.myHeroes = [];
            multiplayerState.myPlayerId = null;
            multiplayerState.playerHeroes = {};
            multiplayerState.connectedPlayers = [];
            if (multiplayerState.ws) {
                multiplayerState.ws.close();
                multiplayerState.ws = null;
            }
        }
        
        function toggleRoomCodeVisibility() {
            const codeSpan = document.getElementById('heroSelectionCode');
            const btn = event.target;
            
            if (codeSpan.textContent === '******') {
                codeSpan.textContent = multiplayerState.roomCode;
                btn.textContent = 'üëÅ HIDE';
            } else {
                codeSpan.textContent = '******';
                btn.textContent = 'üëÅ SHOW';
            }
        }
        
        function cancelHeroSelection() {
            if (confirm('Leave multiplayer session?')) {
                document.getElementById('heroSelectionModal').style.display = 'none';
                // Move music controls back to center
                document.getElementById('musicControls').classList.remove('heroSelectionActive');
                document.getElementById('musicTicker').classList.remove('battleActive');
                if (multiplayerState.role === 'host') {
                    stopHosting();
                } else {
                    leaveRoom();
                }
            }
        }
        
        function showHeroSelection() {
            document.getElementById('heroSelectionModal').style.display = 'block';
            // Move music controls to left
            document.getElementById('musicControls').classList.add('heroSelectionActive');
            document.getElementById('musicTicker').classList.add('battleActive');
            // Update room code display
            const codeDisplay = document.getElementById('heroSelectionCode');
            if (codeDisplay && multiplayerState.roomCode) {
                codeDisplay.textContent = multiplayerState.roomCode;
            }
            // Set player name input to current player name
            const nameInput = document.getElementById('playerNameInput');
            if (nameInput) {
                nameInput.value = multiplayerState.playerName;
            }
        }
        
        function updatePlayerName() {
            const nameInput = document.getElementById('playerNameInput');
            const newName = nameInput.value.trim() || 'Player';
            multiplayerState.playerName = newName;
            
            // Always notify server of name change
            sendWebSocketMessage({ 
                type: 'update_name', 
                playerName: newName 
            });
        }
        
        function selectHero(heroName) {
            const card = document.querySelector(`[data-hero="${heroName}"]`);
            
            // If clicking own hero, deselect it
            if (multiplayerState.myHeroes.includes(heroName)) {
                multiplayerState.myHeroes = multiplayerState.myHeroes.filter(h => h !== heroName);
                card.classList.remove('selected');
                card.style.borderWidth = '3px';
                sendWebSocketMessage({ type: 'deselect_hero', hero: heroName });
                showNotification('Hero deselected', 'info');
                return;
            }
            
            // Check if already taken by someone else
            if (card.classList.contains('taken')) {
                showNotification('Hero already taken', 'error');
                return;
            }
            
            // Select new hero (no limit on how many per player)
            multiplayerState.myHeroes.push(heroName);
            card.classList.add('selected');
            card.style.borderWidth = '5px';
            
            // Get player name from input, or use current playerName from state
            const nameInput = document.getElementById('playerNameInput');
            const playerName = nameInput.value.trim() || multiplayerState.playerName;
            multiplayerState.playerName = playerName;
            
            sendWebSocketMessage({ 
                type: 'select_hero', 
                hero: heroName, 
                playerName: playerName 
            });
        }
        
        function updateHeroSelection(data) {
            // Reset all cards first
            document.querySelectorAll('.heroSelectCard').forEach(card => {
                card.classList.remove('taken');
                card.style.opacity = '1';
                card.style.cursor = 'pointer';
                card.querySelector('.heroTakenLabel').style.display = 'none';
                card.querySelector('.heroPlayerLabel').style.display = 'none';
            });
            
            // Update hero selection UI with player names
            Object.keys(data.heroes).forEach(hero => {
                const heroData = data.heroes[hero];
                const card = document.querySelector(`[data-hero="${hero}"]`);
                if (card && heroData) {
                    card.classList.add('taken');
                    card.style.opacity = '0.7';
                    
                    const playerLabel = card.querySelector('.heroPlayerLabel');
                    if (playerLabel) {
                        playerLabel.textContent = heroData.playerName || 'Player';
                        playerLabel.style.display = 'block';
                    }
                    
                    // Don't disable if it's my hero
                    if (!multiplayerState.myHeroes.includes(hero)) {
                        card.style.cursor = 'not-allowed';
                        card.querySelector('.heroTakenLabel').style.display = 'block';
                    }
                }
            });
            
            // Update connected players list
            updateConnectedPlayersList(data.heroes);
            
            // Update player count
            const playerCount = multiplayerState.connectedPlayers.length;
            const countDisplay = document.getElementById('playerCountDisplay');
            if (countDisplay) {
                countDisplay.textContent = `${playerCount}/4`;
            }
            
            // Update waiting message and show game start options when all 4 heroes selected
            const heroCount = Object.keys(data.heroes).length;
            const waitingMsg = document.getElementById('heroWaitingMessage');
            const gameStartOptions = document.getElementById('gameStartOptions');
            
            if (heroCount === 4) {
                if (waitingMsg) waitingMsg.style.display = 'none';
                if (gameStartOptions && multiplayerState.role === 'host') {
                    gameStartOptions.style.display = 'block';
                }
            } else {
                if (waitingMsg) {
                    waitingMsg.style.display = 'block';
                    waitingMsg.textContent = `Select heroes (${heroCount}/4 selected). Players can select multiple heroes.`;
                }
                if (gameStartOptions) gameStartOptions.style.display = 'none';
            }
            
            // Update multiplayer status indicator
            updateMultiplayerStatus();
        }
        
        function updateConnectedPlayersList(heroes) {
            const listContent = document.getElementById('playersListContent');
            if (!listContent) return;
            
            listContent.innerHTML = '';
            
            // Show all connected players
            if (multiplayerState.connectedPlayers.length === 0) {
                listContent.innerHTML = '<div style="color: #89A0B4; font-size: 12px;">No players connected</div>';
                return;
            }
            
            multiplayerState.connectedPlayers.forEach(player => {
                const playerBadge = document.createElement('div');
                playerBadge.style.cssText = 'padding: 6px 12px; background: rgba(42, 157, 143, 0.3); border: 1px solid #2A9D8F; border-radius: 5px; font-size: 12px; margin-bottom: 5px;';
                
                const heroText = player.heroes && player.heroes.length > 0 
                    ? ` ‚Üí ${player.heroes.map(h => h.toUpperCase()).join(', ')}` 
                    : ' ‚Üí (no heroes)';
                playerBadge.innerHTML = `<span style="color: #F2C94C;">${player.name}</span> <span style="color: #89A0B4;">${heroText}</span>`;
                listContent.appendChild(playerBadge);
            });
        }
        
        function updateConnectedPlayersListOnly() {
            // Update just the player list without touching hero cards
            const listContent = document.getElementById('playersListContent');
            if (!listContent) return;
            
            listContent.innerHTML = '';
            
            if (multiplayerState.connectedPlayers.length === 0) {
                listContent.innerHTML = '<div style="color: #89A0B4; font-size: 12px;">No players connected</div>';
                return;
            }
            
            multiplayerState.connectedPlayers.forEach(player => {
                const playerBadge = document.createElement('div');
                playerBadge.style.cssText = 'padding: 6px 12px; background: rgba(42, 157, 143, 0.3); border: 1px solid #2A9D8F; border-radius: 5px; font-size: 12px; margin-bottom: 5px;';
                
                const heroText = player.heroes && player.heroes.length > 0 
                    ? ` ‚Üí ${player.heroes.map(h => h.toUpperCase()).join(', ')}` 
                    : ' ‚Üí (no heroes)';
                playerBadge.innerHTML = `<span style="color: #F2C94C;">${player.name}</span> <span style="color: #89A0B4;">${heroText}</span>`;
                listContent.appendChild(playerBadge);
            });
        }
        
        function updateMultiplayerStatus() {
            const statusDiv = document.getElementById('multiplayerStatus');
            const statusText = document.getElementById('mpStatusText');
            
            if (multiplayerState.enabled && multiplayerState.roomCode) {
                statusDiv.style.display = 'block';
                const playerCount = multiplayerState.connectedPlayers.length;
                const role = multiplayerState.role === 'host' ? 'üëë HOST' : 'üéÆ CLIENT';
                statusText.textContent = `${role} | Room: ${multiplayerState.roomCode} | Players: ${playerCount}/4`;
            } else {
                statusDiv.style.display = 'none';
            }
        }
        
        function startMultiplayerBattle() {
            // This function is now handled by showing game start options
            // See continueGame(), loadSaveGame(), startNewAdventure()
        }
        
        function continueGame() {
            if (multiplayerState.role !== 'host') {
                showNotification('Only host can start the game', 'error');
                return;
            }
            
            // Ensure save exists
            let sharedSave = loadSharedSave();
            if (!sharedSave) {
                sharedSave = createDefaultSharedSave();
                saveSharedSave(sharedSave);
            }
            
            // Hide hero selection
            document.getElementById('heroSelectionModal').style.display = 'none';
            document.getElementById('musicControls').classList.remove('heroSelectionActive');
            document.getElementById('musicTicker').classList.remove('battleActive');
            
            // Update dungeon menu with save data
            updateDungeonMenuHeroes();
            
            // Show dungeon menu
            currentScreen = 'dungeonMenu';
            document.getElementById('titleScreen').style.display = 'none';
            document.getElementById('dungeonMenuScreen').style.display = 'block';
            
            // Notify all clients to start WITH save data
            sendWebSocketMessage({ 
                type: 'game_start', 
                screen: 'dungeonMenu', 
                mode: 'continue',
                saveData: sharedSave
            });
            
            showNotification('Continuing from last save...', 'success');
        }
        
        function loadSaveGame() {
            if (multiplayerState.role !== 'host') {
                showNotification('Only host can start the game', 'error');
                return;
            }
            
            // Ensure save exists
            let sharedSave = loadSharedSave();
            if (!sharedSave) {
                sharedSave = createDefaultSharedSave();
                saveSharedSave(sharedSave);
            }
            
            // Hide hero selection
            document.getElementById('heroSelectionModal').style.display = 'none';
            document.getElementById('musicControls').classList.remove('heroSelectionActive');
            document.getElementById('musicTicker').classList.remove('battleActive');
            
            // For now, just show dungeon menu - load game UI can be added later
            currentScreen = 'dungeonMenu';
            document.getElementById('titleScreen').style.display = 'none';
            document.getElementById('dungeonMenuScreen').style.display = 'block';
            
            // Update dungeon menu with save data
            updateDungeonMenuHeroes();
            
            // Notify all clients to start WITH save data
            sendWebSocketMessage({ 
                type: 'game_start', 
                screen: 'dungeonMenu', 
                mode: 'load',
                saveData: sharedSave
            });
            
            showNotification('Load game functionality - showing dungeon menu', 'info');
        }
        
        function startNewAdventure() {
            if (multiplayerState.role !== 'host') {
                showNotification('Only host can start the game', 'error');
                return;
            }
            
            showConfirmation(
                'START NEW ADVENTURE?',
                'This will replace your local save game. All progress will be lost.',
                (confirmed) => {
                    if (!confirmed) return;
                    
                    // Hide hero selection
                    document.getElementById('heroSelectionModal').style.display = 'none';
                    document.getElementById('musicControls').classList.remove('heroSelectionActive');
                    document.getElementById('musicTicker').classList.remove('battleActive');
                    
                    // Create fresh save FIRST
                    const newSave = createDefaultSharedSave();
                    saveSharedSave(newSave);
                    
                    // Update dungeon menu with new save data
                    updateDungeonMenuHeroes();
                    
                    currentScreen = 'dungeonMenu';
                    document.getElementById('titleScreen').style.display = 'none';
                    document.getElementById('dungeonMenuScreen').style.display = 'block';
                    
                    // Notify all clients to start WITH save data
                    sendWebSocketMessage({ 
                        type: 'game_start', 
                        screen: 'dungeonMenu', 
                        mode: 'new',
                        saveData: newSave
                    });
                    
                    showNotification('Starting new adventure...', 'success');
                }
            );
        }
        
        function showHostControls() {
            document.getElementById('hostControlsPanel').style.display = 'block';
            updatePlayerList();
        }
        
        function closeHostControls() {
            document.getElementById('hostControlsPanel').style.display = 'none';
        }
        
        function updatePlayerList() {
            const list = document.getElementById('playerList');
            list.innerHTML = '';
            
            multiplayerState.connectedPlayers.forEach(player => {
                const div = document.createElement('div');
                div.style.cssText = 'padding: 10px; margin-bottom: 10px; background: rgba(0,0,0,0.5); border-radius: 5px; display: flex; justify-content: space-between; align-items: center;';
                div.innerHTML = `
                    <div>
                        <div style="color: #F2C94C; font-size: 14px;">${player.hero || 'No hero selected'}</div>
                        <div style="color: #89A0B4; font-size: 11px;">Player ${player.id}</div>
                    </div>
                    <div>
                        <button onclick="skipPlayerTurn(${player.id})" style="padding: 5px 10px; margin-right: 5px; background: #F39C12; border: none; border-radius: 3px; color: white; cursor: pointer;">SKIP TURN</button>
                        <button onclick="kickPlayer(${player.id})" style="padding: 5px 10px; background: #EB5757; border: none; border-radius: 3px; color: white; cursor: pointer;">KICK</button>
                    </div>
                `;
                list.appendChild(div);
            });
            
            // Update multiplayer status indicator
            updateMultiplayerStatus();
        }
        
        function kickPlayer(playerId) {
            if (confirm('Kick this player?')) {
                sendWebSocketMessage({ type: 'kick_player', player_id: playerId });
            }
        }
        
        function skipPlayerTurn(playerId) {
            sendWebSocketMessage({ type: 'skip_turn', player_id: playerId });
        }
        
        function handlePlayerDisconnect(playerId) {
            // Find hero controlled by this player
            for (let heroName in multiplayerState.playerHeroes) {
                if (multiplayerState.playerHeroes[heroName] === playerId) {
                    showNotification(`${heroName} disconnected - AI taking over`, 'warning');
                    // Mark hero as AI-controlled
                    const hero = battleState.heroes.find(h => h.name.toLowerCase() === heroName.toLowerCase());
                    if (hero) {
                        hero.aiControlled = true;
                    }
                    delete multiplayerState.playerHeroes[heroName];
                    break;
                }
            }
            // Remove from connected players
            multiplayerState.connectedPlayers = multiplayerState.connectedPlayers.filter(p => p.id !== playerId);
        }
        
        function processClientAction(data) {
            // Host processes action from client
            const action = data.action;
            const target = data.target;
            const heroName = data.hero;
            const heroesArray = data.heroes;
            
            // Handle retreat - kills all player's heroes
            if (action === 'retreat' && heroesArray) {
                heroesArray.forEach(hName => {
                    const hero = battleState.heroes.find(h => h.name.toLowerCase() === hName.toLowerCase());
                    if (hero) {
                        hero.hp = 0;
                    }
                });
                
                // Remove dead heroes from arrays
                battleState.heroes = battleState.heroes.filter(h => h.hp > 0);
                battleState.turnOrder = battleState.turnOrder.filter(combatant => {
                    if (battleState.heroes.includes(combatant)) return true;
                    if (battleState.enemies.includes(combatant)) return combatant.hp > 0;
                    return false;
                });
                
                updateBattleHeroCards();
                renderBattle();
                broadcastGameState();
                
                // Check if any heroes still alive
                if (battleState.heroes.length === 0) {
                    showBattleNotification('DEFEAT! ALL HEROES RETREATED!');
                    
                    // Notify all clients to end battle
                    sendWebSocketMessage({
                        type: 'battle_end',
                        reason: 'retreat'
                    });
                    
                    setTimeout(() => {
                        // Hide notification
                        const notification = document.getElementById('battleNotification');
                        if (notification) notification.style.display = 'none';
                        
                        endBattle();
                    }, 2000);
                } else {
                    // Reset turn if current combatant was removed
                    const currentCombatant = battleState.turnOrder[battleState.currentTurn];
                    if (!currentCombatant) {
                        battleState.currentTurn = 0;
                        updateBattleTurnInfo();
                    }
                }
                return;
            }
            
            // Find hero
            const hero = battleState.heroes.find(h => h.name.toLowerCase() === heroName.toLowerCase());
            if (!hero) return;
            
            // Execute action (existing battle logic)
            if (action === 'light' || action === 'heavy' || action === 'special') {
                const enemy = battleState.enemies[target];
                if (enemy) {
                    executeAttack(hero, enemy, action);
                }
            } else if (action === 'swap') {
                // Handle swap with target hero
                const targetHero = battleState.heroes[target];
                if (targetHero && targetHero !== hero) {
                    const tempX = hero.x;
                    const tempY = hero.y;
                    const tempPlatform = hero.platform;
                    
                    hero.x = targetHero.x;
                    hero.y = targetHero.y;
                    hero.platform = targetHero.platform;
                    
                    targetHero.x = tempX;
                    targetHero.y = tempY;
                    targetHero.platform = tempPlatform;
                    
                    showDiceRoll(`${hero.name} swapped positions with ${targetHero.name}!`);
                    advanceTurn();
                }
            } else if (action === 'defend') {
                hero.defending = true;
                showDiceRoll(`${hero.name} defends!`);
                advanceTurn();
            } else if (action === 'heal') {
                if (hero.healsRemaining > 0) {
                    const healAmount = Math.floor(hero.maxHp * 0.5);
                    hero.hp = Math.min(hero.maxHp, hero.hp + healAmount);
                    hero.healsRemaining--;
                    hero.usedHeal = true;
                    showDiceRoll(`${hero.name} heals for ${healAmount} HP! (1 action used)`);
                    updateBattleHeroCards();
                }
            } else if (action === 'taunt') {
                const chaModifier = calculateModifier(hero.stats?.cha || 10);
                const tauntRoll = rollD20() + chaModifier;
                const tauntDC = 12;
                
                if (tauntRoll >= tauntDC) {
                    hero.taunting = true;
                    hero.tauntTurns = 3;
                    showDiceRoll(`${hero.name} taunts! d20(${tauntRoll}) SUCCESS!`);
                } else {
                    showDiceRoll(`${hero.name} taunt fails! d20(${tauntRoll}) vs DC ${tauntDC}`);
                }
                advanceTurn();
            } else if (action === 'skip') {
                showDiceRoll(`${hero.name} skips turn.`);
                advanceTurn();
            }
            
            // Broadcast state to all clients
            broadcastGameState();
        }
        
        function broadcastGameState() {
            if (multiplayerState.role !== 'host') return;
            
            const canvas = battleState.canvas;
            
            const state = {
                turnOrder: battleState.turnOrder.map(c => ({ name: c.name, hp: c.hp })),
                heroes: battleState.heroes.map(h => ({
                    name: h.name,
                    hp: h.hp,
                    maxHp: h.maxHp,
                    xp: h.xp,
                    healsRemaining: h.healsRemaining,
                    stats: h.stats,
                    x: h.x / canvas.width,
                    y: h.y / canvas.height,
                    defending: h.defending,
                    taunting: h.taunting,
                    tauntTurns: h.tauntTurns || 0,
                    usedHeal: h.usedHeal || false,
                    facing: h.facing
                })),
                enemies: battleState.enemies.map(e => ({
                    name: e.name,
                    hp: e.hp,
                    maxHp: e.maxHp,
                    hostile: e.hostile,
                    x: e.x / canvas.width,
                    y: e.y / canvas.height
                })),
                currentTurn: battleState.currentTurn
            };
            
            sendWebSocketMessage({ type: 'state_update', state });
        }
        
        function updateGameStateFromHost(state) {
            // Client updates local state from host
            battleState.currentTurn = state.currentTurn;
            
            const canvas = battleState.canvas;
            
            // Rebuild heroes array to handle removals (retreats)
            battleState.heroes = state.heroes.map(heroData => {
                const existingHero = battleState.heroes.find(h => h.name === heroData.name);
                if (existingHero) {
                    // Update existing hero
                    existingHero.hp = heroData.hp;
                    existingHero.maxHp = heroData.maxHp;
                    existingHero.xp = heroData.xp;
                    existingHero.healsRemaining = heroData.healsRemaining;
                    existingHero.stats = heroData.stats;
                    existingHero.x = heroData.x * canvas.width;
                    existingHero.y = (heroData.y * canvas.height) - 25;
                    existingHero.defending = heroData.defending;
                    existingHero.taunting = heroData.taunting;
                    existingHero.tauntTurns = heroData.tauntTurns || 0;
                    existingHero.usedHeal = heroData.usedHeal || false;
                    existingHero.facing = heroData.facing;
                    return existingHero;
                } else {
                    console.warn('[MP] Received unknown hero:', heroData.name);
                    return null;
                }
            }).filter(h => h !== null);
            
            // Update enemies - rebuild array to handle removals
            battleState.enemies = state.enemies.map(enemyData => {
                const existingEnemy = battleState.enemies.find(e => e.name === enemyData.name);
                if (existingEnemy) {
                    // Update existing enemy
                    existingEnemy.hp = enemyData.hp;
                    existingEnemy.maxHp = enemyData.maxHp;
                    existingEnemy.hostile = enemyData.hostile;
                    existingEnemy.x = enemyData.x * canvas.width;
                    existingEnemy.y = (enemyData.y * canvas.height) - 25;
                    return existingEnemy;
                } else {
                    // This shouldn't happen in normal gameplay, but handle it
                    console.warn('[MP] Received unknown enemy:', enemyData.name);
                    return null;
                }
            }).filter(e => e !== null);
            
            // Rebuild turn order to match host
            battleState.turnOrder = state.turnOrder.map(combatantData => {
                return battleState.heroes.find(h => h.name === combatantData.name) || 
                       battleState.enemies.find(e => e.name === combatantData.name);
            }).filter(c => c);
            
            // Re-render
            renderBattle();
            updateBattleHeroCards();
            updateBattleEnemyCards();
            updateBattleTurnInfo();
        }
        
        function initializeBattleFromHost(battleData) {
            // Client receives full battle initialization from host
            // Ensure canvas is initialized
            if (!battleState.canvas) {
                battleState.canvas = document.getElementById('battleCanvas');
                battleState.ctx = battleState.canvas.getContext('2d');
                battleState.canvas.width = window.innerWidth;
                battleState.canvas.height = window.innerHeight - 180;
            }
            
            const canvas = battleState.canvas;
            
            // Set background
            battleState.backgroundPath = battleData.backgroundPath;
            battleState.backgroundImage = new Image();
            battleState.backgroundImage.onload = () => {
                renderBattle();
            };
            battleState.backgroundImage.onerror = () => {
                console.error('[MP ERROR] Background failed to load:', battleState.backgroundPath);
            };
            battleState.backgroundImage.src = battleState.backgroundPath;
            
            // Setup heroes with host's data
            battleState.heroes = battleData.heroes.map(hData => {
                const hero = {
                    name: hData.name,
                    hp: hData.hp,
                    maxHp: hData.maxHp,
                    xp: hData.xp,
                    healsRemaining: hData.healsRemaining,
                    stats: hData.stats,
                    color: hData.name === 'Zooko' ? '#F2C94C' : hData.name === 'Nate' ? '#E74C3C' : hData.name === 'Zancas' ? '#27AE60' : '#2E86DE',
                    x: hData.x * canvas.width,
                    y: (hData.y * canvas.height) - 25,
                    platform: hData.platform,
                    initiative: hData.initiative,
                    facing: 'center',
                    sprite: new Image(),
                    spritePath: hData.spritePath
                };
                hero.sprite.onload = () => {
                    renderBattle();
                };
                hero.sprite.onerror = () => {
                    console.error('[MP ERROR] Hero sprite failed:', hero.name, hero.spritePath);
                };
                hero.sprite.src = hero.spritePath + '?v=' + Date.now();
                return hero;
            });
            
            // Setup enemies with host's data
            battleState.enemies = battleData.enemies.map(eData => {
                const enemy = {
                    name: eData.name,
                    hp: eData.hp,
                    maxHp: eData.maxHp,
                    ac: eData.ac,
                    attackDamage: eData.attackDamage,
                    speed: eData.speed,
                    dex: eData.dex,
                    hostile: eData.hostile,
                    color: eData.isMob ? '#5C3317' : '#8B45FF',
                    x: eData.x * canvas.width,
                    y: (eData.y * canvas.height) - 25,
                    platform: eData.platform,
                    initiative: eData.initiative,
                    facing: 'center',
                    sprite: new Image(),
                    spritePath: eData.spritePath,
                    isMob: eData.isMob
                };
                enemy.sprite.onload = () => {
                    renderBattle();
                };
                enemy.sprite.onerror = () => {
                    console.error('[MP ERROR] Enemy sprite failed:', enemy.name, enemy.spritePath);
                };
                enemy.sprite.src = enemy.spritePath + '?v=' + Date.now();
                return enemy;
            });
            
            // Setup turn order from host
            const allCombatants = [...battleState.heroes, ...battleState.enemies];
            battleState.turnOrder = battleData.turnOrder.map(name => 
                allCombatants.find(c => c.name === name)
            ).filter(c => c); // Filter out any not found
            
            if (battleState.turnOrder.length === 0) {
                console.error('[MP ERROR] Turn order is empty after initialization!');
            }
            
            battleState.currentTurn = battleData.currentTurn;
            battleState.active = true;
            battleState.targetingMode = false;
            battleState.pendingAction = null;
            
            // Update UI
            updateBattleTurnInfo();
            updateBattleHeroCards();
            updateBattleEnemyCards();
            renderBattle();
            
            // Start battle animation loop for continuous updates
            function battleAnimationLoop() {
                if (battleState.active) {
                    renderBattle();
                    requestAnimationFrame(battleAnimationLoop);
                }
            }
            battleAnimationLoop();
            
            showNotification('Battle initialized!', 'success');
        }
        
        function showNotification(message, type = 'info') {
            // Simple notification system
            const color = type === 'error' ? '#EB5757' : type === 'success' ? '#27AE60' : type === 'warning' ? '#F39C12' : '#3498DB';
            showDiceRoll(message);
        }
        
        // ===== NETWORK DEBUG FUNCTIONS =====
        let debugMessageLog = [];
        const MAX_DEBUG_MESSAGES = 20;
        
        function toggleNetworkDebug() {
            const panel = document.getElementById('networkDebugPanel');
            const checkbox = document.getElementById('networkDebug');
            
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
                if (checkbox) checkbox.checked = true;
            } else {
                panel.style.display = 'none';
                if (checkbox) checkbox.checked = false;
            }
        }
        
        function logDebugMessage(type, data, direction = 'out') {
            const timestamp = new Date().toLocaleTimeString();
            const arrow = direction === 'out' ? '‚¨ÜÔ∏è' : '‚¨áÔ∏è';
            const color = direction === 'out' ? '#F39C12' : '#3498DB';
            
            debugMessageLog.push({
                timestamp,
                type,
                data,
                direction,
                arrow,
                color
            });
            
            // Keep only last 20 messages
            if (debugMessageLog.length > MAX_DEBUG_MESSAGES) {
                debugMessageLog.shift();
            }
            
            updateDebugLogDisplay();
        }
        
        function updateDebugLogDisplay() {
            const logDiv = document.getElementById('debugMessageLog');
            if (!logDiv) return;
            
            logDiv.innerHTML = debugMessageLog.map(msg => `
                <div style="margin-bottom: 8px; padding: 5px; border-left: 3px solid ${msg.color}; background: rgba(0,0,0,0.3);">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 3px;">
                        <span style="color: #89A0B4; font-size: 10px;">${msg.timestamp}</span>
                        <span style="font-size: 10px;">${msg.arrow} ${msg.type}</span>
                    </div>
                    <div style="color: #E9F0F7; font-size: 10px; word-break: break-word;">${JSON.stringify(msg.data, null, 2).slice(0, 200)}</div>
                </div>
            `).join('');
            
            // Auto-scroll to bottom
            logDiv.scrollTop = logDiv.scrollHeight;
        }
        
        function clearDebugLog() {
            debugMessageLog = [];
            updateDebugLogDisplay();
        }
        
        function updateDebugStatus() {
            const connStatus = document.getElementById('debugConnStatus');
            const roomState = document.getElementById('debugRoomState');
            
            if (connStatus) {
                if (multiplayerState.ws && multiplayerState.ws.readyState === WebSocket.OPEN) {
                    connStatus.textContent = '‚úÖ Connected';
                    connStatus.style.color = '#27AE60';
                } else {
                    connStatus.textContent = '‚ùå Disconnected';
                    connStatus.style.color = '#EB5757';
                }
            }
            
            if (roomState) {
                if (multiplayerState.enabled && multiplayerState.roomCode) {
                    const role = multiplayerState.role === 'host' ? 'üëë HOST' : 'üéÆ CLIENT';
                    const players = multiplayerState.connectedPlayers.length;
                    roomState.innerHTML = `
                        <div>${role}</div>
                        <div style="margin-top: 3px;">Code: <span style="color: #F2C94C; font-weight: bold;">${multiplayerState.roomCode}</span></div>
                        <div style="margin-top: 3px;">Players: ${players}/4</div>
                        <div style="margin-top: 3px;">My Heroes: <span style="color: #F2C94C;">${multiplayerState.myHeroes.join(', ') || 'None'}</span></div>
                    `;
                    roomState.style.color = '#2A9D8F';
                } else {
                    roomState.textContent = 'No room';
                    roomState.style.color = '#89A0B4';
                }
            }
        }
        
        // ===== END MULTIPLAYER FUNCTIONS =====
        
        function init() {
            console.log('Tunnels of Privacy - Initializing...');
            
            // Load settings
            loadSettings();
            console.log('Settings loaded:', settings);
            
            // ===== GAMEPAD SUPPORT =====
            // Handle gamepad connections
            window.addEventListener('gamepadconnected', onGamepadConnected);
            window.addEventListener('gamepaddisconnected', onGamepadDisconnected);
            // Start gamepad polling loop
            gamepadLoop();
            // ===== END GAMEPAD SUPPORT =====
            
            // Preload assets
            preloadAssets();
            
            // Start background animation
            startStoryIntroAnimation();
            
            // Load shared save and display hero stats
            const sharedSave = loadSharedSave();
            const heroStatsEl = document.getElementById('heroStats');
            
            if (sharedSave && sharedSave.heroes) {
                console.log('Loaded shared save with heroes:', sharedSave.heroes);
                
                // Show hero party
                if (heroStatsEl) heroStatsEl.style.display = 'block';
                
                // Update each hero's display
                updateHeroDisplay('zooko', sharedSave.heroes.zooko);
                updateHeroDisplay('nate', sharedSave.heroes.nate);
                updateHeroDisplay('zancas', sharedSave.heroes.zancas);
                updateHeroDisplay('cyberaxe', sharedSave.heroes.cyberaxe);
                
                // Update dungeon level from arcade level
                if (sharedSave.arcadeState && sharedSave.arcadeState.level) {
                    const arcadeLevel = sharedSave.arcadeState.level;
                    document.getElementById('dungeonLevel').textContent = arcadeLevel;
                    console.log('Dungeon depth set to arcade level:', arcadeLevel);
                } else {
                    console.log('No arcade level found - defaulting to level 1');
                }
            } else {
                console.log('No shared save found - hiding hero party');
                // Hide hero party when no save exists
                if (heroStatsEl) heroStatsEl.style.display = 'none';
            }
            
            // Update title screen button states
            updateTitleScreenButtons();
            
            console.log('Initialization complete. Portal system ready.');
        }
        
        // Run init when page loads
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
