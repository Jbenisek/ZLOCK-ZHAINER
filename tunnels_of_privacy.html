<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <title>TUNNELS OF PRIVACY - Dungeon Crawler v0.2.89</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet" media="print" onload="this.media='all'; this.onload=null;">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #0A0E12 0%, #1A1E2A 100%);
            color: #E9F0F7;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            cursor: default;
        }
        
        #gameContainer {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #titleScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 14, 18, 0.95);
            z-index: 100;
            pointer-events: none;
        }
        
        #dungeonMenuScreen {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0A0E12 0%, #1A1E2A 100%);
            z-index: 100;
        }
        
        #battleScreen {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a0f2e 0%, #0f0a1e 100%);
            z-index: 100;
        }
        
        #battleCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: calc(100% - 180px);
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        #battleNotification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(46, 204, 113, 0.95), rgba(39, 174, 96, 0.95));
            border: 4px solid #27AE60;
            border-radius: 12px;
            padding: 40px 60px;
            font-family: 'Inter', sans-serif;
            font-size: 48px;
            font-weight: 900;
            color: #FFFFFF;
            text-shadow: 0 4px 8px rgba(0, 0, 0, 0.6);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
            z-index: 1000;
            display: none;
            width: 700px;
            text-align: center;
            word-wrap: break-word;
            overflow-wrap: break-word;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 4px;
            animation: notificationPulse 0.5s ease-out;
        }
        
        @keyframes notificationPulse {
            0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        
        #battleEnemyCards {
            position: absolute;
            top: 20px;
            left: 20px;
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
            max-width: 160px;
            z-index: 10;
        }
        
        #battleEnemyCards.twoColumns {
            grid-template-columns: 1fr 1fr;
            max-width: 330px;
        }
        
        .battleEnemyCard {
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            border: 2px solid #E74C3C;
            border-radius: 8px;
            padding: 8px;
            width: 140px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .battleEnemyCard.boss {
            border-color: #8B45FF;
            box-shadow: 0 0 15px rgba(139, 69, 255, 0.4);
        }
        
        .battleEnemyCard.targetable {
            border-color: #FFD700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
            animation: cardPulse 1s infinite;
        }
        
        .battleEnemyCard:hover.targetable {
            transform: scale(1.05);
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.8);
        }
        
        @keyframes cardPulse {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.6); }
            50% { box-shadow: 0 0 30px rgba(255, 215, 0, 0.9); }
        }
        
        .battleEnemyCard.dead {
            opacity: 0.4;
            cursor: not-allowed;
            filter: grayscale(100%);
        }
        
        .battleEnemyPortrait {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-size: cover;
            background-position: center;
            border: 2px solid #E74C3C;
            margin: 0 auto 6px auto;
            box-shadow: 0 0 10px rgba(231, 76, 60, 0.4);
        }
        
        .battleEnemyCard.boss .battleEnemyPortrait {
            border-color: #8B45FF;
            box-shadow: 0 0 10px rgba(139, 69, 255, 0.4);
        }
        
        .battleEnemyName {
            font-family: 'Inter', sans-serif;
            font-size: 10px;
            font-weight: 700;
            text-align: center;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #E74C3C;
        }
        
        .battleEnemyCard.boss .battleEnemyName {
            color: #8B45FF;
        }
        
        .battleEnemyCard.captive {
            border-color: #F2C94C;
            box-shadow: 0 0 15px rgba(242, 201, 76, 0.4);
        }
        
        .battleEnemyCard.captive .battleEnemyPortrait {
            border-color: #F2C94C;
            box-shadow: 0 0 10px rgba(242, 201, 76, 0.4);
        }
        
        .battleEnemyCard.captive .battleEnemyName {
            color: #F2C94C;
            margin-top: -8px;
            position: relative;
            z-index: 10;
        }
        
        /* Chat Window Styles */
        #battleChatWindow {
            position: absolute;
            bottom: 10px;
            right: 20px;
            width: 350px;
            height: 300px;
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.95));
            border: 2px solid #5865F2;
            border-radius: 12px;
            display: none;
            flex-direction: column;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            z-index: 100;
        }
        
        #chatHeader {
            padding: 10px 15px;
            background: linear-gradient(135deg, #5865F2, #4752C4);
            border-radius: 10px 10px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        #chatHeader span {
            color: white;
            font-weight: 700;
            font-size: 14px;
        }
        
        #chatCloseBtn {
            background: none;
            border: none;
            color: white;
            font-size: 18px;
            cursor: pointer;
            padding: 0 5px;
        }
        
        #ttsToggleLabel {
            display: flex;
            align-items: center;
            gap: 4px;
            cursor: pointer;
            color: white;
            margin-left: auto;
            margin-right: 8px;
            padding: 2px 6px;
            border-radius: 4px;
            background: rgba(255,255,255,0.1);
        }
        
        #ttsToggleLabel:hover {
            background: rgba(255,255,255,0.2);
        }
        
        #ttsToggle {
            width: 14px;
            height: 14px;
            cursor: pointer;
        }
        
        #chatMessages {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .chatMessage {
            display: flex;
            gap: 8px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }
        
        .chatAvatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background-size: cover;
            background-position: center;
            flex-shrink: 0;
            border: 2px solid #444;
        }
        
        .chatContent {
            flex: 1;
            min-width: 0;
        }
        
        .chatName {
            font-size: 12px;
            font-weight: 700;
            margin-bottom: 2px;
        }
        
        .chatName.hostile { color: #E74C3C; }
        .chatName.questable { color: #F2C94C; }
        .chatName.friendly { color: #27AE60; }
        .chatName.player { color: #FFFFFF; }
        
        .chatText {
            font-size: 13px;
            color: #BFD1E0;
            word-wrap: break-word;
            overflow-wrap: break-word;
            white-space: pre-wrap;
        }
        
        .typingCursor {
            color: #5865F2;
            animation: cursorBlink 0.5s infinite;
        }
        
        @keyframes cursorBlink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        #chatInputArea {
            padding: 10px;
            border-top: 1px solid #333;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        #chatTargetSelector {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            max-height: 80px;
            overflow-y: auto;
            padding: 4px 0;
        }
        
        .chatTargetBtn {
            padding: 3px 8px;
            font-size: 10px;
            border: 1px solid #444;
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.5);
            color: #aaa;
            cursor: pointer;
            white-space: nowrap;
            max-width: 100px;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .chatTargetBtn:hover {
            background: rgba(88, 101, 242, 0.3);
            border-color: #5865F2;
        }
        
        .chatTargetBtn.active {
            background: #5865F2;
            color: white;
            border-color: #5865F2;
        }
        
        .chatTargetBtn.hostile {
            border-color: #E74C3C;
        }
        
        .chatTargetBtn.hostile.active {
            background: #E74C3C;
        }
        
        .chatTargetBtn.friendly {
            border-color: #F2C94C;
        }
        
        .chatTargetBtn.friendly.active {
            background: #F2C94C;
            color: #000;
        }
        
        .chatTargetBtn.boss {
            border-color: #8B45FF;
        }
        
        .chatTargetBtn.boss.active {
            background: #8B45FF;
        }
        
        .chatTargetBtn.broadcast {
            border-color: #27AE60;
        }
        
        .chatTargetBtn.broadcast.active {
            background: #27AE60;
        }
        
        #chatInputRow {
            display: flex;
            gap: 8px;
        }
        
        #chatInput {
            flex: 1;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #444;
            border-radius: 6px;
            padding: 8px 12px;
            color: white;
            font-size: 13px;
            outline: none;
        }
        
        #chatInput:focus {
            border-color: #5865F2;
        }
        
        #chatSendBtn {
            background: #5865F2;
            border: none;
            border-radius: 6px;
            padding: 8px 15px;
            color: white;
            font-weight: 600;
            cursor: pointer;
        }
        
        #chatModelSelector {
            display: flex;
            gap: 3px;
            padding: 5px 10px;
            border-bottom: 1px solid #333;
            flex-wrap: wrap;
            align-items: center;
            position: relative;
            z-index: 10;
        }
        
        #chatModelSelector span {
            pointer-events: none;
            user-select: none;
        }
        
        .modelBtn {
            width: 24px;
            height: 24px;
            border: 1px solid #444;
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.5);
            color: #aaa;
            font-size: 11px;
            cursor: pointer;
            padding: 0;
            position: relative;
            z-index: 11;
        }
        
        .modelBtn:hover {
            background: rgba(88, 101, 242, 0.3);
            border-color: #5865F2;
        }
        
        .modelBtn.active {
            background: #5865F2;
            color: white;
            border-color: #5865F2;
        }
        
        .modelBtn.exhausted {
            opacity: 0.5;
            cursor: not-allowed;
            position: relative;
        }
        
        .modelBtn.exhausted::after {
            content: '‚úï';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #E74C3C;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 0 0 2px black;
        }
        
        #chatSendBtn:hover {
            background: #4752C4;
        }
        
        #chatSendBtn:disabled {
            background: #333;
            cursor: not-allowed;
        }
        
        .battleEnemyStat {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: #BFD1E0;
            text-align: center;
            margin: 2px 0;
        }
        
        #battleUI {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 180px;
            background: linear-gradient(180deg, rgba(10, 14, 18, 0) 0%, rgba(10, 14, 18, 0.95) 20%, rgba(10, 14, 18, 0.98) 100%);
            display: flex;
            flex-direction: row;
            align-items: flex-end;
            justify-content: center;
            padding: 15px;
            gap: 15px;
        }
        
        #battleUILeft {
            display: flex;
            flex-direction: row;
            gap: 10px;
            flex-shrink: 0;
        }
        
        #battleUICenter {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            gap: 10px;
        }
        
        #battleUIRight {
            display: flex;
            flex-direction: row;
            gap: 10px;
            flex-shrink: 0;
        }
        
        .battleHeroCard {
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            border: 2px solid #2A9D8F;
            border-radius: 8px;
            padding: 8px;
            width: 140px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
        }
        
        .battleHeroCard.active {
            border-color: #F2C94C;
            box-shadow: 0 0 20px rgba(242, 201, 76, 0.6);
        }
        
        /* Character-specific card borders */
        #battleCardZooko {
            border-color: #F2C94C;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4), 0 0 10px rgba(242, 201, 76, 0.3);
        }
        #battleCardNate {
            border-color: #E74C3C;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4), 0 0 10px rgba(231, 76, 60, 0.3);
        }
        #battleCardZancas {
            border-color: #27AE60;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4), 0 0 10px rgba(39, 174, 96, 0.3);
        }
        #battleCardCyberAxe {
            border-color: #2E86DE;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4), 0 0 10px rgba(46, 134, 222, 0.3);
        }
        
        .battleHeroPortrait {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-size: cover;
            background-position: center;
            border: 2px solid #2A9D8F;
            margin: 0 auto 6px auto;
            box-shadow: 0 0 10px rgba(42, 157, 143, 0.4);
        }
        
        .battleHeroName {
            font-family: 'Inter', sans-serif;
            font-size: 11px;
            font-weight: 700;
            text-align: center;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .battleHeroStat {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: #BFD1E0;
            text-align: center;
            margin: 2px 0;
        }
        
        #battleTurnInfo {
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            color: #F2C94C;
            text-shadow: 0 0 10px rgba(242, 201, 76, 0.5);
            margin-bottom: 5px;
        }
        
        #battleActions {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 5px;
            width: 100%;
            max-width: 700px;
        }
        
        .battleButton {
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            border: 2px solid #2A9D8F;
            color: #E9F0F7;
            font-family: 'Inter', sans-serif;
            font-size: 10px;
            font-weight: 600;
            padding: 4px 4px;
            border-radius: 6px;
            cursor: pointer;
            pointer-events: all;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .battleButton:hover:not(:disabled) {
            background: linear-gradient(135deg, rgba(42, 157, 143, 0.3), rgba(42, 157, 143, 0.2));
            border-color: #3DBAA3;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(42, 157, 143, 0.4);
        }
        
        .battleButton:active:not(:disabled) {
            transform: translateY(0px) scale(0.95);
            box-shadow: 0 2px 8px rgba(42, 157, 143, 0.6);
        }
        
        .battleButton:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        .battleButton.attack-weak { border-color: #3498DB; }
        .battleButton.attack-weak:hover:not(:disabled) { 
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.3), rgba(52, 152, 219, 0.2));
            border-color: #5DADE2;
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
        }
        
        .battleButton.attack-strong { border-color: #E74C3C; }
        .battleButton.attack-strong:hover:not(:disabled) { 
            background: linear-gradient(135deg, rgba(231, 76, 60, 0.3), rgba(231, 76, 60, 0.2));
            border-color: #EC7063;
            box-shadow: 0 6px 20px rgba(231, 76, 60, 0.4);
        }
        
        .battleButton.special { border-color: #F39C12; }
        .battleButton.special:hover:not(:disabled) { 
            background: linear-gradient(135deg, rgba(243, 156, 18, 0.3), rgba(243, 156, 18, 0.2));
            border-color: #F8C471;
            box-shadow: 0 6px 20px rgba(243, 156, 18, 0.4);
        }
        
        .battleButton.defend { border-color: #27AE60; }
        .battleButton.defend:hover:not(:disabled) { 
            background: linear-gradient(135deg, rgba(39, 174, 96, 0.3), rgba(39, 174, 96, 0.2));
            border-color: #52BE80;
            box-shadow: 0 6px 20px rgba(39, 174, 96, 0.4);
        }
        
        .battleButton.heal { border-color: #9B59B6; }
        .battleButton.heal:hover:not(:disabled) { 
            background: linear-gradient(135deg, rgba(155, 89, 182, 0.3), rgba(155, 89, 182, 0.2));
            border-color: #AF7AC5;
            box-shadow: 0 6px 20px rgba(155, 89, 182, 0.4);
        }
        
        .battleButton.swap { border-color: #3498DB; }
        .battleButton.swap:hover:not(:disabled) { 
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.3), rgba(52, 152, 219, 0.2));
            border-color: #5DADE2;
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
        }
        
        .battleButton.taunt { border-color: #E67E22; }
        .battleButton.taunt:hover:not(:disabled) { 
            background: linear-gradient(135deg, rgba(230, 126, 34, 0.3), rgba(230, 126, 34, 0.2));
            border-color: #F39C12;
            box-shadow: 0 6px 20px rgba(230, 126, 34, 0.4);
        }
        
        .battleButton.retreat { border-color: #95A5A6; }
        .battleButton.retreat:hover:not(:disabled) { 
            background: linear-gradient(135deg, rgba(149, 165, 166, 0.3), rgba(149, 165, 166, 0.2));
            border-color: #BDC3C7;
            box-shadow: 0 6px 20px rgba(149, 165, 166, 0.4);
        }
        
        #pauseScreen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 14, 18, 0.98);
            z-index: 1000;
            pointer-events: all;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        #pauseTitle {
            font-size: 72px;
            font-weight: 900;
            color: #8B45FF;
            text-shadow: 0 0 40px rgba(139, 69, 255, 0.6);
            margin-bottom: 40px;
            letter-spacing: 8px;
        }
        
        #storyIntroBackground {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.3;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            transition: opacity 2s ease-in-out;
        }
        
        #title {
            display: none;
        }
        
        #subtitle {
            display: none;
        }
        
        /* Center Column - Main Menu Buttons */
        #menuButtonsCenter {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            pointer-events: none;
        }
        
        .menuButton {
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            border: 2px solid #2A9D8F;
            color: #E9F0F7;
            font-family: 'Inter', sans-serif;
            font-size: 18px;
            font-weight: 700;
            padding: 14px 40px;
            margin: 8px;
            cursor: pointer;
            transition: all 0.2s;
            border-radius: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
            width: 380px;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: all;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
        }
        
        .menuButton:hover {
            background: linear-gradient(135deg, rgba(20, 27, 34, 0.95), rgba(42, 157, 143, 0.2));
            box-shadow: 0 6px 25px rgba(42, 157, 143, 0.4);
            transform: translateY(-2px);
            border-color: #4ECDC4;
        }
        
        .menuButton:active {
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.98), rgba(15, 19, 24, 0.95));
            transform: translateY(0px);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }
        
        .menuButton:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        /* Explore Level Button with loading bar */
        #exploreLevelBtn {
            position: relative;
            overflow: hidden;
            z-index: 1;
        }
        
        #exploreLevelBtn .loadingBar {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, rgba(42, 157, 143, 0.4), rgba(78, 205, 196, 0.5));
            transition: width 0.3s ease-out;
            z-index: -1;
            border-radius: 6px;
        }
        
        #exploreLevelBtn.ready {
            border-color: #27AE60;
            box-shadow: 0 0 15px rgba(39, 174, 96, 0.5);
        }
        
        #exploreLevelBtn.ready .loadingBar {
            background: linear-gradient(90deg, rgba(39, 174, 96, 0.4), rgba(46, 204, 113, 0.5));
        }
        
        #exploreLevelBtn .btnText {
            position: relative;
            z-index: 2;
        }
        
        .portalButton {
            background: linear-gradient(135deg, rgba(139, 69, 255, 0.4), rgba(139, 69, 255, 0.3));
            border-color: #8B45FF;
        }
        
        .portalButton:hover {
            background: linear-gradient(135deg, rgba(139, 69, 255, 0.6), rgba(139, 69, 255, 0.5));
            border-color: #A45FFF;
            box-shadow: 0 5px 20px rgba(139, 69, 255, 0.5);
        }
        
        /* Left Column - Hero Stats (Title Screen) */
        #heroStats {
            position: absolute;
            left: 60px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(20, 27, 34, 0.8);
            border: 2px solid #26313B;
            border-radius: 12px;
            padding: 25px;
            width: 320px;
            pointer-events: all;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
        }
        
        /* Hero Cards in Corners (Dungeon Menu) */
        .dungeonHeroCard {
            position: absolute;
            background: linear-gradient(135deg, rgba(39, 174, 96, 0.1), rgba(39, 174, 96, 0.05));
            border: 1px solid #27AE60;
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            width: 160px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
        }
        
        #dungeonZooko { top: 20px; left: 20px; border-color: #EB5757; box-shadow: 0 0 15px rgba(235, 87, 87, 0.3); }
        #dungeonNate { bottom: 80px; left: 20px; border-color: #F2C94C; box-shadow: 0 0 15px rgba(242, 201, 76, 0.3); }
        #dungeonZancas { top: 20px; right: 20px; border-color: #27AE60; box-shadow: 0 0 15px rgba(39, 174, 96, 0.3); }
        #dungeonCyberAxe { bottom: 80px; right: 20px; border-color: #2E86DE; box-shadow: 0 0 15px rgba(46, 134, 222, 0.3); }
        
        .heroRow {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 12px;
        }
        
        .heroCard {
            background: linear-gradient(135deg, rgba(39, 174, 96, 0.1), rgba(39, 174, 96, 0.05));
            border: 1px solid #27AE60;
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            position: relative;
        }
        
        .heroPortrait {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            margin: 0 auto 8px auto;
            background-size: cover;
            background-position: center;
            border: 2px solid #27AE60;
            box-shadow: 0 0 10px rgba(39, 174, 96, 0.4);
        }
        
        .heroName {
            font-weight: 700;
            font-size: 14px;
            color: #F2C94C;
            margin-bottom: 8px;
        }
        
        .heroStat {
            font-size: 11px;
            color: #ffffff;
            margin: 2px 0;
            font-family: 'JetBrains Mono', monospace;
            font-weight: 700;
        }
        
        #versionDisplay {
            position: absolute;
            bottom: 20px;
            right: 20px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: #5A7A8F;
        }
        
        .comingSoon {
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            border-color: #EB5757;
            color: #EB5757;
        }
        
        .comingSoon:hover {
            background: linear-gradient(135deg, rgba(235, 87, 87, 0.2), rgba(235, 87, 87, 0.1));
            box-shadow: 0 6px 25px rgba(235, 87, 87, 0.4);
            transform: translateY(-2px);
            border-color: #FF6B6B;
        }
        
        /* Center Column - Level Display (at top of center buttons) */
        #dungeonLevelDisplay {
            text-align: center;
            padding: 15px;
            background: linear-gradient(135deg, rgba(139, 69, 255, 0.2), rgba(75, 0, 130, 0.2));
            border: 2px solid #8B45FF;
            border-radius: 10px;
            width: 380px;
            pointer-events: none;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            margin-bottom: 20px;
        }
        
        /* Music Ticker */
        #musicTicker {
            position: fixed;
            bottom: 10px;
            left: 10px;
            transform: translateX(0);
            background: rgba(42, 157, 143, 0.3);
            border: 2px solid #2A9D8F;
            border-radius: 8px;
            overflow: hidden;
            width: 400px;
            max-width: 25%;
            z-index: 500;
            pointer-events: auto;
            transition: left 0.3s ease, transform 0.3s ease;
        }
        
        /* Center ticker on dungeon menu */
        #musicTicker.dungeonMenuActive {
            left: 50%;
            transform: translateX(-50%);
        }
        
        /* Move ticker to bottom left during battle */
        #musicTicker.battleActive {
            left: 10px;
            transform: translateX(0);
        }
        
        #musicTickerWrapper {
            display: flex;
            width: fit-content;
            animation: scrollTicker 30s linear infinite;
        }
        
        #musicTicker:hover #musicTickerWrapper {
            animation-duration: 60s;
        }
        
        .tickerText {
            color: #F2C94C;
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            font-weight: 700;
            white-space: nowrap;
            padding-right: 100px;
        }
        
        @keyframes scrollTicker {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }
        
        /* Music Control Panel - Bottom of Screen Above Ticker */
        #musicControls {
            position: fixed;
            bottom: 65px;
            left: 10px;
            transform: translateX(0);
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            border: 2px solid #2A9D8F;
            border-radius: 8px;
            padding: 12px;
            min-width: 240px;
            max-width: 25%;
            pointer-events: auto;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8);
            z-index: 500;
            transition: left 0.3s ease, transform 0.3s ease;
        }
        
        /* Center controls on dungeon menu */
        #musicControls.dungeonMenuActive {
            left: 50%;
            transform: translateX(-50%);
        }
        
        /* Move controls to bottom left during battle or hero selection */
        #musicControls.battleActive,
        #musicControls.heroSelectionActive {
            left: 10px;
            transform: translateX(0);
        }
        
        .musicControlTitle {
            margin: 0 0 10px 0;
            color: #2A9D8F;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            text-align: center;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .musicButton {
            padding: 8px 16px;
            background: linear-gradient(135deg, rgba(42, 157, 143, 0.4), rgba(42, 157, 143, 0.3));
            border: 2px solid #2A9D8F;
            color: #F2C94C;
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            font-weight: bold;
            margin: 3px 0;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 6px;
            width: 100%;
            text-align: center;
        }
        
        .musicButton:hover {
            background: linear-gradient(135deg, rgba(42, 157, 143, 0.6), rgba(42, 157, 143, 0.5));
            border-color: #2ECC71;
        }
        
        .musicButton:active {
            transform: translateY(1px);
        }
        
        .volumeControl {
            margin: 10px 0 0 0;
        }
        
        .volumeLabel {
            color: #BFD1E0;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            display: block;
            margin-bottom: 4px;
        }
        
        .volumeSlider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(139, 69, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }
        
        .volumeSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #8B45FF;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(139, 69, 255, 0.5);
        }
        
        .volumeSlider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #8B45FF;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 5px rgba(139, 69, 255, 0.5);
        }
        
        #overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 14, 18, 0.9);
            z-index: 150;
            pointer-events: all;
        }
        
        #settingsPanel {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            border: 2px solid #2A9D8F;
            border-radius: 12px;
            padding: 25px;
            max-width: 450px;
            width: auto;
            z-index: 1100;
            pointer-events: all;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
        }
        
        .panelTitle {
            font-size: 28px;
            font-weight: 900;
            color: #2A9D8F;
            margin-bottom: 20px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .settingRow {
            margin: 20px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .settingLabel {
            font-size: 18px;
            color: #E9F0F7;
        }
        
        input[type="range"] {
            width: 200px;
        }
        
        /* Loading Screen Styles */
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }
        
        @keyframes slowBlink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
    </style>
</head>
<body>
    <!-- Loading Modal -->
    <div id="loadingModal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.95); display: flex; align-items: center; justify-content: center; z-index: 10000;">
        <div style="background: linear-gradient(135deg, #1a2332 0%, #0d1218 100%); padding: 40px 60px; border-radius: 15px; border: 2px solid #8B45FF; box-shadow: 0 10px 50px rgba(139, 69, 255, 0.5); text-align: center; min-width: 500px;">
            <div style="font-size: 48px; margin-bottom: 20px; animation: pulse 1.5s ease-in-out infinite;">üè∞</div>
            <div style="font-size: 24px; font-weight: bold; color: #8B45FF; margin-bottom: 10px;">TUNNELS OF PRIVACY</div>
            <div style="font-size: 14px; color: #F2C94C; margin-bottom: 15px; font-style: italic;">A Dungeon Crawler Adventure</div>
            <div id="loadingNote" style="font-size: 12px; color: #BFD1E0; margin-bottom: 20px; line-height: 1.5;">Loading assets... This may take a moment on first visit</div>
            
            <!-- Category breakdown -->
            <div style="margin-bottom: 15px; text-align: left; font-size: 13px; color: #BFD1E0;">
                <div id="loadingArt" style="margin-bottom: 5px;">üé® Art: <span style="color: #8B45FF; font-weight: bold;">0/0</span></div>
                <div id="loadingSound" style="margin-bottom: 5px;">üîä Sound: <span style="color: #8B45FF; font-weight: bold;">0/0</span></div>
            </div>
            
            <!-- Overall progress -->
            <div id="loadingIndicator" style="font-size: 18px; color: #2ECC71; margin-bottom: 20px; font-weight: bold;">0%</div>
            
            <div style="width: 100%; height: 30px; background: rgba(139, 69, 255, 0.2); border-radius: 15px; overflow: hidden; border: 1px solid #8B45FF;">
                <div id="loadingBar" style="height: 100%; width: 0%; background: linear-gradient(90deg, #8B45FF, #2ECC71); transition: width 0.3s ease; border-radius: 15px; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 14px;"></div>
            </div>
            
            <!-- Click to Play prompt (hidden until ready) -->
            <div id="clickToPlayPrompt" style="display: none; margin-top: 30px; font-size: 24px; color: #2ECC71; font-weight: bold; animation: slowBlink 2s ease-in-out infinite; cursor: pointer;">
                <div style="margin-bottom: 10px;">üéÆ CLICK TO ENTER üéÆ</div>
                <div style="font-size: 14px; color: #89A0B4;">
                    <span style="display: inline-block; padding: 5px 10px; background: rgba(52, 152, 219, 0.3); border-radius: 5px; margin-right: 5px;">MOUSE</span>
                    or
                    <span style="display: inline-block; padding: 5px 10px; background: rgba(46, 204, 113, 0.3); border-radius: 5px; margin-left: 5px;">üéÆ A</span>
                </div>
            </div>
        </div>
    </div>
    
    <div id="gameContainer">
        <!-- Dungeon Menu Screen -->
        <div id="dungeonMenuScreen">
            <!-- Hero Cards in Corners -->
            <div class="dungeonHeroCard" id="dungeonZooko">
                <div class="heroPortrait" style="background-image: url('people/zooko_a_head_compressed.png'); border-color: #EB5757; box-shadow: 0 0 10px rgba(235, 87, 87, 0.4);"></div>
                <div class="heroName" style="color: #EB5757;">ZOOKO</div>
                <div class="heroStat" style="color: #ff6b6b; font-size: 12px; margin: 4px 0;">HP: <span id="dzooko-hp">0</span>/<span id="dzooko-maxhp">0</span></div>
                <div class="heroStat" style="color: #F2C94C; font-size: 11px; margin: 2px 0;">XP: <span id="dzooko-xp">0</span></div>
                <div class="heroStat">STR: <span id="dzooko-str">0</span>  INT: <span id="dzooko-int">0</span></div>
                <div class="heroStat">DEX: <span id="dzooko-dex">0</span>  WIS: <span id="dzooko-wis">0</span></div>
                <div class="heroStat">CON: <span id="dzooko-con">0</span>  CHA: <span id="dzooko-cha">0</span></div>
            </div>
            
            <div class="dungeonHeroCard" id="dungeonNate">
                <div class="heroPortrait" style="background-image: url('people/Nate_a_head_compressed.png'); border-color: #F2C94C; box-shadow: 0 0 10px rgba(242, 201, 76, 0.4);"></div>
                <div class="heroName" style="color: #F2C94C;">NATE</div>
                <div class="heroStat" style="color: #ff6b6b; font-size: 12px; margin: 4px 0;">HP: <span id="dnate-hp">0</span>/<span id="dnate-maxhp">0</span></div>
                <div class="heroStat" style="color: #F2C94C; font-size: 11px; margin: 2px 0;">XP: <span id="dnate-xp">0</span></div>
                <div class="heroStat">STR: <span id="dnate-str">0</span>  INT: <span id="dnate-int">0</span></div>
                <div class="heroStat">DEX: <span id="dnate-dex">0</span>  WIS: <span id="dnate-wis">0</span></div>
                <div class="heroStat">CON: <span id="dnate-con">0</span>  CHA: <span id="dnate-cha">0</span></div>
            </div>
            
            <div class="dungeonHeroCard" id="dungeonZancas">
                <div class="heroPortrait" style="background-image: url('people/Zancas_a_head_compressed.png'); border-color: #27AE60; box-shadow: 0 0 10px rgba(39, 174, 96, 0.4);"></div>
                <div class="heroName" style="color: #27AE60;">ZANCAS</div>
                <div class="heroStat" style="color: #ff6b6b; font-size: 12px; margin: 4px 0;">HP: <span id="dzancas-hp">0</span>/<span id="dzancas-maxhp">0</span></div>
                <div class="heroStat" style="color: #F2C94C; font-size: 11px; margin: 2px 0;">XP: <span id="dzancas-xp">0</span></div>
                <div class="heroStat">STR: <span id="dzancas-str">0</span>  INT: <span id="dzancas-int">0</span></div>
                <div class="heroStat">DEX: <span id="dzancas-dex">0</span>  WIS: <span id="dzancas-wis">0</span></div>
                <div class="heroStat">CON: <span id="dzancas-con">0</span>  CHA: <span id="dzancas-cha">0</span></div>
            </div>
            
            <div class="dungeonHeroCard" id="dungeonCyberAxe">
                <div class="heroPortrait" style="background-image: url('people/cyberaxe_a_head_compressed.png'); border-color: #2E86DE; box-shadow: 0 0 10px rgba(46, 134, 222, 0.4);"></div>
                <div class="heroName" style="color: #2E86DE;">CYBERAXE</div>
                <div class="heroStat" style="color: #ff6b6b; font-size: 12px; margin: 4px 0;">HP: <span id="dcyberaxe-hp">0</span>/<span id="dcyberaxe-maxhp">0</span></div>
                <div class="heroStat" style="color: #F2C94C; font-size: 11px; margin: 2px 0;">XP: <span id="dcyberaxe-xp">0</span></div>
                <div class="heroStat">STR: <span id="dcyberaxe-str">0</span>  INT: <span id="dcyberaxe-int">0</span></div>
                <div class="heroStat">DEX: <span id="dcyberaxe-dex">0</span>  WIS: <span id="dcyberaxe-wis">0</span></div>
                <div class="heroStat">CON: <span id="dcyberaxe-con">0</span>  CHA: <span id="dcyberaxe-cha">0</span></div>
            </div>
            
            <!-- Center Menu -->
            <div style="position: absolute; top: 42%; left: 50%; transform: translate(-50%, -50%); display: flex; flex-direction: column; align-items: center; gap: 12px;">
                <div style="text-align: center; padding: 15px; background: linear-gradient(135deg, rgba(139, 69, 255, 0.2), rgba(75, 0, 130, 0.2)); border: 2px solid #8B45FF; border-radius: 10px; width: 380px; backdrop-filter: blur(10px); box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4); margin-bottom: 10px;">
                    <div style="color: #BFD1E0; font-size: 14px; margin-bottom: 5px;">Dungeon Menu</div>
                    <div style="color: #F2C94C; font-size: 28px; font-weight: 900; text-shadow: 0 0 20px rgba(242, 201, 76, 0.5);">LEVEL <span id="dungeonMenuLevel">1</span></div>
                    <div style="color: #FFD700; font-size: 16px; font-weight: 700; margin-top: 5px;">üí∞ <span id="dungeonMenuGold">0</span> Gold</div>
                </div>
                
                <button class="menuButton" id="exploreLevelBtn" onclick="startBattle()">
                    <div class="loadingBar" id="exploreLoadingBar"></div>
                    <span class="btnText">EXPLORE LEVEL</span>
                </button>
                <button class="menuButton comingSoon" disabled>ENTER LEVEL STORE<br><span style="font-size: 12px; font-weight: 400;">(If Found)</span></button>
                <button class="menuButton">INVENTORY</button>
                <button class="menuButton">REST / SLEEP</button>
                <button class="menuButton" onclick="refreshGameData()" style="background: linear-gradient(135deg, #2A9D8F, #1B7368); border-color: #2A9D8F;">üîÑ REFRESH DATA</button>
            </div>
        </div>
        
        <!-- Battle Screen -->
        <div id="battleScreen">
            <canvas id="battleCanvas"></canvas>
            
            <!-- Battle Notification Banner -->
            <div id="battleNotification">ROOM CLEARED!</div>
            
            <!-- Gold Display (Top Center) -->
            <div id="battleGoldDisplay" style="position: absolute; top: 10px; left: 50%; transform: translateX(-50%); background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(30, 30, 30, 0.8)); border: 2px solid #FFD700; border-radius: 8px; padding: 8px 20px; z-index: 100; display: flex; align-items: center; gap: 8px;">
                <span style="font-size: 20px;">üí∞</span>
                <span id="battleGold" style="color: #FFD700; font-size: 18px; font-weight: 700; font-family: 'JetBrains Mono', monospace;">0</span>
            </div>
            
            <!-- Enemy Cards (Left Side) -->
            <div id="battleEnemyCards">
                <!-- Populated dynamically by updateBattleEnemyCards() -->
            </div>
            
            <div id="battleUI">
                <!-- Left Hero Cards: Zooko & Nate -->
                <div id="battleUILeft">
                    <div class="battleHeroCard" id="battleCardZooko">
                        <div class="battleHeroPortrait" style="background-image: url('people/zooko_a_head_compressed.png'); border-color: #F2C94C;"></div>
                        <div class="battleHeroName" style="color: #F2C94C;">ZOOKO</div>
                        <div class="battleHeroStat" style="color: #ff6b6b;">HP: <span id="bzooko-hp">30</span>/<span id="bzooko-maxhp">30</span></div>
                        <div class="battleHeroStat">AC: <span id="bzooko-ac">12</span></div>
                        <div class="battleHeroStat" style="color: #FFD700;">XP: <span id="bzooko-xp">0</span></div>
                        <div class="battleHeroStat" style="color: #ff1744; font-size: 14px;" id="bzooko-heals">‚ù§Ô∏è ‚ù§Ô∏è</div>
                    </div>
                    <div class="battleHeroCard" id="battleCardNate">
                        <div class="battleHeroPortrait" style="background-image: url('people/Nate_a_head_compressed.png'); border-color: #E74C3C;"></div>
                        <div class="battleHeroName" style="color: #E74C3C;">NATE</div>
                        <div class="battleHeroStat" style="color: #ff6b6b;">HP: <span id="bnate-hp">28</span>/<span id="bnate-maxhp">30</span></div>
                        <div class="battleHeroStat">AC: <span id="bnate-ac">14</span></div>
                        <div class="battleHeroStat" style="color: #FFD700;">XP: <span id="bnate-xp">0</span></div>
                        <div class="battleHeroStat" style="color: #ff1744; font-size: 14px;" id="bnate-heals">‚ù§Ô∏è ‚ù§Ô∏è</div>
                    </div>
                </div>
                
                <!-- Center Action Bar -->
                <div id="battleUICenter">
                    <div id="battleTurnInfo">ZOOKO'S TURN</div>
                    <div id="multiplayerStatus" style="display: none; background: rgba(42, 157, 143, 0.3); border: 2px solid #2A9D8F; border-radius: 5px; padding: 5px 10px; font-size: 11px; color: #2A9D8F; margin-bottom: 8px; text-align: center;">
                        üéÆ <span id="mpStatusText">Multiplayer</span>
                    </div>
                    <div id="diceRollDisplay" style="display: block; background: linear-gradient(135deg, rgba(0,0,0,0.95), rgba(20,20,40,0.95)); color: #E0E0E0; padding: 12px 20px; border-radius: 12px; font-size: 14px; font-weight: bold; text-align: center; margin-bottom: 10px; border: 2px solid #7A8B9C; width: 500px; box-shadow: 0 0 20px rgba(122, 139, 156, 0.2), inset 0 0 20px rgba(122, 139, 156, 0.05); text-shadow: 0 0 10px rgba(224, 224, 224, 0.5), 0 0 20px rgba(224, 224, 224, 0.2); letter-spacing: 1px;">‚è≥ Waiting to Roll...</div>
                    <div id="battleActions">
                        <button class="battleButton attack-weak" onclick="battleAction('light')">‚öî LIGHT</button>
                        <button class="battleButton attack-strong" id="battleHeavyBtn" onclick="battleAction('heavy')">‚ö° HEAVY</button>
                        <button class="battleButton special" id="battleSpecialBtn" onclick="battleAction('special')">‚ú® SPECIAL</button>
                        <button class="battleButton defend" onclick="battleAction('defend')">üõ° DEFEND</button>
                        <button class="battleButton swap" onclick="battleAction('swap')">üîÑ SWAP</button>
                        <button class="battleButton taunt" onclick="battleAction('taunt')">üó£ TAUNT</button>
                        <button class="battleButton heal" onclick="battleAction('heal')">üíö HEAL</button>
                        <button class="battleButton" id="battleSkipBtn" onclick="battleAction('skip')">‚è≠ SKIP</button>
                        <button class="battleButton" onclick="battleAction('talk')">üí¨ TALK</button>
                        <button class="battleButton retreat" onclick="battleAction('retreat')">üèÉ RETREAT</button>
                    </div>
                </div>
                
                <!-- Right Hero Cards: Zancas & CyberAxe -->
                <div id="battleUIRight">
                    <div class="battleHeroCard" id="battleCardZancas">
                        <div class="battleHeroPortrait" style="background-image: url('people/Zancas_a_head_compressed.png'); border-color: #27AE60;"></div>
                        <div class="battleHeroName" style="color: #27AE60;">ZANCAS</div>
                        <div class="battleHeroStat" style="color: #ff6b6b;">HP: <span id="bzancas-hp">24</span>/<span id="bzancas-maxhp">26</span></div>
                        <div class="battleHeroStat">AC: <span id="bzancas-ac">15</span></div>
                        <div class="battleHeroStat" style="color: #FFD700;">XP: <span id="bzancas-xp">0</span></div>
                        <div class="battleHeroStat" style="color: #ff1744; font-size: 14px;" id="bzancas-heals">‚ù§Ô∏è ‚ù§Ô∏è</div>
                    </div>
                    <div class="battleHeroCard" id="battleCardCyberAxe">
                        <div class="battleHeroPortrait" style="background-image: url('people/cyberaxe_a_head_compressed.png'); border-color: #2E86DE;"></div>
                        <div class="battleHeroName" style="color: #2E86DE;">CYBERAXE</div>
                        <div class="battleHeroStat" style="color: #ff6b6b;">HP: <span id="bcyberaxe-hp">32</span>/<span id="bcyberaxe-maxhp">35</span></div>
                        <div class="battleHeroStat">AC: <span id="bcyberaxe-ac">15</span></div>
                        <div class="battleHeroStat" style="color: #FFD700;">XP: <span id="bcyberaxe-xp">0</span></div>
                        <div class="battleHeroStat" style="color: #ff1744; font-size: 14px;" id="bcyberaxe-heals">‚ù§Ô∏è ‚ù§Ô∏è</div>
                    </div>
                    </div>
                </div>
            </div>
            
            <!-- Chat Window -->
            <div id="battleChatWindow">
                <div id="chatHeader">
                    <span>üí¨ Battle Chat</span>
                    <span id="chatStatus" style="font-size: 11px; color: #aaa;"></span>
                    <label id="ttsToggleLabel" title="Enable text-to-speech for NPC responses">
                        <input type="checkbox" id="ttsToggle" checked onchange="toggleTTS()">
                        <span style="font-size: 11px;">üîä</span>
                    </label>
                    <button id="chatCloseBtn" onclick="toggleChatWindow()">‚úï</button>
                </div>
                <div id="chatModelSelector">
                    <span style="font-size: 10px; color: #888; margin-right: 4px;">Free:</span>
                    <button class="modelBtn active" onclick="selectChatModel(2)" title="Groq Llama 3.1 8B (FREE)">2</button>
                    <button class="modelBtn" onclick="selectChatModel(4)" title="Groq Gemma 2 9B (FREE)">4</button>
                    <button class="modelBtn" onclick="selectChatModel(5)" title="Groq Mixtral 8x7B (FREE)">5</button>
                    <span style="font-size: 10px; color: #F39C12; margin-left: 6px; margin-right: 4px;">Paid:</span>
                    <button class="modelBtn" onclick="selectChatModel(1)" title="OpenRouter Mistral Nemo ($)" style="border-color: #F39C12;">1</button>
                    <button class="modelBtn" onclick="selectChatModel(3)" title="Groq Llama 3.3 70B ($)" style="border-color: #F39C12;">3</button>
                    <button class="modelBtn" onclick="selectChatModel(6)" title="OpenRouter Llama 3.1 8B ($)" style="border-color: #F39C12;">6</button>
                    <button class="modelBtn" onclick="selectChatModel(7)" title="OpenRouter Gemma 2 9B ($)" style="border-color: #F39C12;">7</button>
                    <button class="modelBtn" onclick="selectChatModel(8)" title="OpenRouter Qwen 2.5 7B ($)" style="border-color: #F39C12;">8</button>
                    <button class="modelBtn" onclick="selectChatModel(9)" title="OpenRouter Ministral 3B ($)" style="border-color: #F39C12;">9</button>
                    <button class="modelBtn" onclick="selectChatModel(10)" title="OpenRouter L3 Lunaris 8B ($)" style="border-color: #F39C12;">10</button>
                    <span id="chatCostDisplay" style="margin-left: 8px; font-size: 11px; color: #4CAF50;">$0.000000 | 0 tok</span>
                </div>
                <div id="chatMessages"></div>
                <div id="chatInputArea">
                    <div id="chatTargetSelector">
                        <button class="chatTargetBtn broadcast active" onclick="selectChatTarget(null)" title="Speak to everyone">üì¢ ALL</button>
                        <!-- Entity buttons populated dynamically -->
                    </div>
                    <div id="chatInputRow">
                        <input type="text" id="chatInput" placeholder="Say something..." onkeypress="if(event.key==='Enter')sendChatMessage()">
                        <button id="chatSendBtn" onclick="sendChatMessage()">Send</button>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="titleScreen">
            <!-- Story Intro Background Animation -->
            <div id="storyIntroBackground"></div>
            
            <div id="title">TUNNELS OF PRIVACY</div>
            <div id="subtitle">A Dungeon Crawler Adventure</div>
            
            <!-- Center Column - Level Display, Menu Buttons, Music Controls -->
            <div id="menuButtonsCenter">
                <div id="dungeonLevelDisplay">
                    <div style="color: #BFD1E0; font-size: 14px; margin-bottom: 5px;">Current Dungeon Depth</div>
                    <div style="color: #F2C94C; font-size: 36px; font-weight: 900; text-shadow: 0 0 20px rgba(242, 201, 76, 0.5);">LEVEL <span id="dungeonLevel">1</span></div>
                </div>
                
                <button id="startAdventureBtn" class="menuButton" onclick="startAdventure()">START ADVENTURE<span style="display: inline-block; width: 26px; height: 26px; background: #27AE60; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">A</span></button>
                <button id="continueBtn" class="menuButton comingSoon" disabled onclick="continueGame()">CONTINUE<span style="display: inline-block; width: 26px; height: 26px; background: #EB5757; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">A</span></button>
                <button class="menuButton" onclick="showLoadSave()">LOAD SAVE FILE<span style="display: inline-block; width: 26px; height: 26px; background: #3498DB; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">B</span></button>
                <button class="menuButton" onclick="showSettings()">SETTINGS<span style="display: inline-block; width: 26px; height: 26px; background: #2A9D8F; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">Y</span></button>
                <button class="menuButton portalButton" onclick="exitPortal()">
                    <div style="display: flex; align-items: center; justify-content: space-between; width: 100%;">
                        <div style="text-align: left;">
                            <div style="font-size: 18px; font-weight: 700;">EXIT PORTAL</div>
                            <div style="font-size: 10px; font-weight: 400; margin-top: 2px;">(RETURN TO ARCADE)</div>
                        </div>
                        <span style="display: inline-block; padding: 4px 10px; background: #8B45FF; border-radius: 5px; font-weight: bold; color: white; font-size: 12px;">BACK</span>
                    </div>
                </button>
            </div>
            
            <div id="versionDisplay">Tunnels of Privacy v0.2.79 ‚Ä¢ Portal System Active</div>
            
            <!-- About/Donate Button (Bottom Right) -->
            <div style="
                position: absolute;
                bottom: 20px;
                right: 20px;
                width: 200px;
                background: rgba(10, 14, 18, 0.8);
                border: 2px solid #2D9CDB;
                border-radius: 10px;
                padding: 12px;
                backdrop-filter: blur(10px);
                cursor: pointer;
                transition: all 0.3s ease;
                text-align: center;
                pointer-events: all;
                z-index: 100;
            " onclick="showAbout()" onmouseenter="this.style.borderColor='#F2C94C'; this.style.boxShadow='0 0 15px rgba(242, 201, 76, 0.4)';" onmouseleave="this.style.borderColor='#2D9CDB'; this.style.boxShadow='none';">
                <div style="font-size: 14px; font-weight: 700; color: #F2C94C; margin-bottom: 3px;">ABOUT / DONATE</div>
                <div style="font-size: 11px; color: #89A0B4;">Support Development</div>
            </div>
            
            <!-- Multiplayer Controls (Top Left) -->
            <div style="position: absolute; top: 20px; left: 20px; display: flex; flex-direction: column; gap: 10px; align-items: flex-start; pointer-events: all; z-index: 100;">
                <!-- Create Room Button -->
                <button class="menuButton" onclick="createMultiplayerRoom()" style="padding: 10px 20px; font-size: 14px; margin: 0; pointer-events: all; background: linear-gradient(135deg, rgba(42, 157, 143, 0.4), rgba(42, 157, 143, 0.3)); border-color: #2A9D8F; white-space: nowrap; width: 250px;">üéÆ CREATE ROOM</button>
                
                <!-- Room Code Input and Join Button -->
                <div style="display: flex; gap: 10px; align-items: stretch;">
                    <input type="text" id="titleJoinCode" placeholder="CODE" maxlength="6" onkeypress="if(event.key==='Enter') quickJoinRoom()" style="width: 90px; padding: 10px; background: rgba(0,0,0,0.7); border: 2px solid #2A9D8F; border-radius: 5px; color: #F2C94C; font-size: 14px; text-align: center; letter-spacing: 2px; font-family: 'JetBrains Mono', monospace; text-transform: uppercase; pointer-events: all;">
                    <button class="menuButton" onclick="quickJoinRoom()" style="padding: 10px 15px; font-size: 14px; margin: 0; pointer-events: all; white-space: nowrap; width: 150px;">JOIN</button>
                </div>
                
                <!-- Player Name Input -->
                <div style="display: flex; flex-direction: column; gap: 5px; align-items: flex-start;">
                    <input type="text" id="multiplayerPlayerName" placeholder="Enter your Player Name" maxlength="20" style="width: 250px; padding: 10px; background: rgba(0,0,0,0.7); border: 2px solid #2A9D8F; border-radius: 5px; color: #E9F0F7; font-size: 14px; font-family: 'Inter', sans-serif; pointer-events: all;">
                    <div style="color: #F2C94C; font-size: 10px; font-style: italic; margin-top: -2px;">Changing will Reset Join in Progress</div>
                </div>
            </div>
        </div>
        
        <!-- Network Debug Panel -->
        <div id="networkDebugPanel" style="display: none; position: fixed; top: 10px; right: 10px; width: 400px; max-height: 500px; overflow-y: auto; background: rgba(10, 14, 18, 0.95); border: 2px solid #2A9D8F; border-radius: 8px; padding: 15px; z-index: 150; font-family: 'JetBrains Mono', monospace; font-size: 11px;">
            <div style="font-size: 14px; font-weight: bold; color: #2A9D8F; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center;">
                <span>üåê NETWORK DEBUG</span>
                <button onclick="toggleNetworkDebug()" style="background: #EB5757; border: none; border-radius: 3px; color: white; padding: 3px 8px; cursor: pointer; font-size: 10px;">‚úï</button>
            </div>
            
            <div style="margin-bottom: 10px; padding: 8px; background: rgba(0,0,0,0.5); border-radius: 5px;">
                <div style="color: #89A0B4; margin-bottom: 5px;">Connection Status:</div>
                <div id="debugConnStatus" style="color: #F2C94C; font-weight: bold;">Disconnected</div>
            </div>
            
            <div style="margin-bottom: 10px; padding: 8px; background: rgba(0,0,0,0.5); border-radius: 5px;">
                <div style="color: #89A0B4; margin-bottom: 5px;">Room State:</div>
                <div id="debugRoomState" style="color: #2A9D8F;">No room</div>
            </div>
            
            <div style="margin-bottom: 10px;">
                <div style="color: #89A0B4; margin-bottom: 5px; display: flex; justify-content: space-between;">
                    <span>Message Log (Last 20):</span>
                    <button onclick="clearDebugLog()" style="background: #E74C3C; border: none; border-radius: 3px; color: white; padding: 2px 6px; cursor: pointer; font-size: 9px;">CLEAR</button>
                </div>
                <div id="debugMessageLog" style="max-height: 300px; overflow-y: auto; background: rgba(0,0,0,0.7); border: 1px solid #2A9D8F; border-radius: 5px; padding: 8px;"></div>
            </div>
        </div>
        
        <!-- Music Control Panel - Bottom Above Ticker (OUTSIDE titleScreen so always visible) -->
        <div id="musicControls">
            <h3 class="musicControlTitle">üéµ Music Controls</h3>
            
            <!-- Playback Controls -->
            <div style="display: flex; gap: 6px; justify-content: center; margin-bottom: 12px;">
                <button onclick="musicPrevious()" class="musicButton" style="padding: 8px 12px; width: auto;">‚èÆ</button>
                <button id="musicPlayPauseBtn" onclick="musicPlayPause()" class="musicButton" style="padding: 8px 16px; border-color: #F2C94C; width: auto;">‚ñ∂</button>
                <button onclick="musicNext()" class="musicButton" style="padding: 8px 12px; width: auto;">‚è≠</button>
            </div>
            
            <!-- Volume Control -->
            <div style="margin-bottom: 12px;">
                <label style="color: #BFD1E0; font-family: 'JetBrains Mono', monospace; font-size: 10px; display: block; margin-bottom: 4px; text-align: center;">Volume:</label>
                <div style="display: flex; align-items: center; gap: 8px; justify-content: center;">
                    <input type="range" class="volumeSlider" id="volumeSlider" min="1" max="150" value="75" oninput="updateVolume()" style="flex: 1; max-width: 200px;">
                    <span id="volumeSliderValue" style="color: #2D9CDB; font-family: 'JetBrains Mono', monospace; font-size: 10px; font-weight: bold; min-width: 30px; text-align: right;">75</span>
                </div>
            </div>
        </div>
        
        <!-- Music Ticker (OUTSIDE titleScreen so always visible) -->
        <div id="musicTicker">
            <div id="musicTickerWrapper">
                <span class="tickerText" id="musicTickerText1">‚ô´ Theme Song ‚ô´</span>
                <span class="tickerText" id="musicTickerText2">‚ô´ Theme Song ‚ô´</span>
            </div>
        </div>
    </div>
    
    <!-- Pause Screen -->
    <div id="pauseScreen">
        <div id="pauseTitle">PAUSED</div>
        <button class="menuButton" onclick="resumeGame()">RESUME<span style="display: inline-block; width: 26px; height: 26px; background: #E74C3C; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">B</span></button>
        <button class="menuButton" onclick="saveGameFromPause()" style="background: linear-gradient(135deg, rgba(46, 134, 222, 0.4), rgba(46, 134, 222, 0.3)); border-color: #3498DB;">SAVE GAME<span style="display: inline-block; width: 26px; height: 26px; background: #3498DB; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">üíæ</span></button>
        <button class="menuButton" onclick="downloadSaveFile()" style="background: linear-gradient(135deg, rgba(39, 174, 96, 0.4), rgba(39, 174, 96, 0.3)); border-color: #27AE60;">SAVE GAME FILE<span style="display: inline-block; width: 26px; height: 26px; background: #27AE60; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">‚¨á</span></button>
        <button class="menuButton" onclick="showSettingsFromPause()">SETTINGS<span style="display: inline-block; width: 26px; height: 26px; background: #F39C12; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">Y</span></button>
        <button class="menuButton" id="resyncBtn" onclick="requestResync()" style="display: none; background: linear-gradient(135deg, rgba(155, 89, 182, 0.4), rgba(155, 89, 182, 0.3)); border-color: #9B59B6;">üîÑ RESYNC FROM HOST<span style="display: inline-block; width: 26px; height: 26px; background: #9B59B6; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">‚Üª</span></button>
        <button class="menuButton" id="hostControlsBtn" onclick="showHostControls()" style="display: none; background: linear-gradient(135deg, rgba(42, 157, 143, 0.4), rgba(42, 157, 143, 0.3)); border-color: #2A9D8F;">HOST CONTROLS<span style="display: inline-block; width: 26px; height: 26px; background: #2A9D8F; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">üéÆ</span></button>
        <button class="menuButton" onclick="quitToMenu()">QUIT TO MENU<span style="display: inline-block; padding: 4px 10px; background: #555; border-radius: 5px; margin-left: 10px; font-weight: bold; color: white; font-size: 12px;">‚óÄ</span></button>
    </div>
    
    <!-- Hero Selection Modal (Multiplayer) -->
    <div id="heroSelectionModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.95); z-index: 300; pointer-events: all;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; max-width: 1000px; width: 95%;">
            <div style="color: #2A9D8F; font-size: 32px; font-weight: 900; margin-bottom: 15px; text-shadow: 0 0 20px rgba(42, 157, 143, 0.5);">SELECT YOUR HERO</div>
            
            <!-- Player Name Input -->
            <div style="margin-bottom: 15px;">
                <input type="text" id="playerNameInput" placeholder="Enter your name..." maxlength="20" style="width: 300px; padding: 10px 15px; background: rgba(0,0,0,0.7); border: 2px solid #2A9D8F; border-radius: 5px; color: #F2C94C; font-size: 16px; text-align: center; font-family: 'JetBrains Mono', monospace;" oninput="updatePlayerName()">
            </div>
            
            <!-- Room Info Bar -->
            <div style="margin-bottom: 20px; display: flex; justify-content: center; align-items: center; gap: 20px; flex-wrap: wrap;">
                <div style="background: rgba(42, 157, 143, 0.2); padding: 8px 16px; border-radius: 8px; border: 2px solid #2A9D8F;">
                    <span style="color: #89A0B4; font-size: 11px; margin-right: 8px;">ROOM:</span>
                    <span id="heroSelectionCode" style="color: #F2C94C; font-size: 18px; font-weight: bold; letter-spacing: 3px; font-family: 'JetBrains Mono', monospace;">------</span>
                    <button onclick="toggleRoomCodeVisibility()" style="background: none; border: none; color: #2A9D8F; cursor: pointer; font-size: 14px; margin-left: 8px; padding: 0;">üëÅ</button>
                </div>
                <div style="background: rgba(42, 157, 143, 0.2); padding: 8px 16px; border-radius: 8px; border: 2px solid #2A9D8F;">
                    <span style="color: #89A0B4; font-size: 11px; margin-right: 8px;">PLAYERS:</span>
                    <span id="playerCountDisplay" style="color: #F2C94C; font-size: 18px; font-weight: bold;">1/4</span>
                </div>
            </div>
            
            <!-- Connected Players List -->
            <div id="connectedPlayersList" style="margin-bottom: 20px; padding: 15px; background: rgba(0,0,0,0.5); border-radius: 8px; border: 2px solid #2A9D8F; max-height: 120px; overflow-y: auto;">
                <div style="color: #89A0B4; font-size: 12px; margin-bottom: 10px; text-transform: uppercase;">Connected Players:</div>
                <div id="playersListContent" style="display: flex; flex-wrap: wrap; gap: 10px; justify-content: center;">
                    <!-- Dynamically populated -->
                </div>
            </div>
            
            <div id="heroSelectionGrid" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; margin-bottom: 20px;">
                <!-- Zooko -->
                <div class="heroSelectCard" data-hero="zooko" onclick="selectHero('zooko')" style="cursor: pointer; padding: 20px; background: linear-gradient(135deg, rgba(242, 201, 76, 0.2), rgba(242, 201, 76, 0.1)); border: 3px solid #F2C94C; border-radius: 12px; transition: all 0.3s;">
                    <div style="width: 120px; height: 120px; margin: 0 auto 15px; background-image: url('people/zooko_a_head_compressed.png'); background-size: cover; background-position: center; border-radius: 50%; border: 3px solid #F2C94C;"></div>
                    <div style="color: #F2C94C; font-size: 18px; font-weight: bold;">ZOOKO</div>
                    <div class="heroPlayerLabel" style="display: none; color: #2A9D8F; font-size: 11px; margin-top: 5px; font-style: italic;"></div>
                    <div class="heroTakenLabel" style="display: none; color: #EB5757; font-size: 12px; margin-top: 5px;">TAKEN</div>
                </div>
                <!-- Nate -->
                <div class="heroSelectCard" data-hero="nate" onclick="selectHero('nate')" style="cursor: pointer; padding: 20px; background: linear-gradient(135deg, rgba(231, 76, 60, 0.2), rgba(231, 76, 60, 0.1)); border: 3px solid #E74C3C; border-radius: 12px; transition: all 0.3s;">
                    <div style="width: 120px; height: 120px; margin: 0 auto 15px; background-image: url('people/Nate_a_head_compressed.png'); background-size: cover; background-position: center; border-radius: 50%; border: 3px solid #E74C3C;"></div>
                    <div style="color: #E74C3C; font-size: 18px; font-weight: bold;">NATE</div>
                    <div class="heroPlayerLabel" style="display: none; color: #2A9D8F; font-size: 11px; margin-top: 5px; font-style: italic;"></div>
                    <div class="heroTakenLabel" style="display: none; color: #EB5757; font-size: 12px; margin-top: 5px;">TAKEN</div>
                </div>
                <!-- Zancas -->
                <div class="heroSelectCard" data-hero="zancas" onclick="selectHero('zancas')" style="cursor: pointer; padding: 20px; background: linear-gradient(135deg, rgba(39, 174, 96, 0.2), rgba(39, 174, 96, 0.1)); border: 3px solid #27AE60; border-radius: 12px; transition: all 0.3s;">
                    <div style="width: 120px; height: 120px; margin: 0 auto 15px; background-image: url('people/Zancas_a_head_compressed.png'); background-size: cover; background-position: center; border-radius: 50%; border: 3px solid #27AE60;"></div>
                    <div style="color: #27AE60; font-size: 18px; font-weight: bold;">ZANCAS</div>
                    <div class="heroPlayerLabel" style="display: none; color: #2A9D8F; font-size: 11px; margin-top: 5px; font-style: italic;"></div>
                    <div class="heroTakenLabel" style="display: none; color: #EB5757; font-size: 12px; margin-top: 5px;">TAKEN</div>
                </div>
                <!-- CyberAxe -->
                <div class="heroSelectCard" data-hero="cyberaxe" onclick="selectHero('cyberaxe')" style="cursor: pointer; padding: 20px; background: linear-gradient(135deg, rgba(46, 134, 222, 0.2), rgba(46, 134, 222, 0.1)); border: 3px solid #2E86DE; border-radius: 12px; transition: all 0.3s;">
                    <div style="width: 120px; height: 120px; margin: 0 auto 15px; background-image: url('people/cyberaxe_a_head_compressed.png'); background-size: cover; background-position: center; border-radius: 50%; border: 3px solid #2E86DE;"></div>
                    <div style="color: #2E86DE; font-size: 18px; font-weight: bold;">CYBERAXE</div>
                    <div class="heroPlayerLabel" style="display: none; color: #2A9D8F; font-size: 11px; margin-top: 5px; font-style: italic;"></div>
                    <div class="heroTakenLabel" style="display: none; color: #EB5757; font-size: 12px; margin-top: 5px;">TAKEN</div>
                </div>
            </div>
            <div id="heroWaitingMessage" style="color: #89A0B4; font-size: 14px; margin-bottom: 15px;">Click heroes to select. Players can select multiple heroes.</div>
            <div id="reconnectOptions" style="display: none; margin-bottom: 15px;">
                <div style="color: #2A9D8F; font-size: 16px; margin-bottom: 15px; font-weight: bold;">üîÑ Reconnecting to Game in Progress</div>
                <div style="display: flex; flex-direction: column; gap: 10px; max-width: 400px; margin: 0 auto;">
                    <button class="menuButton" onclick="rejoinGame()" style="padding: 15px; font-size: 14px; background: linear-gradient(135deg, rgba(42, 157, 143, 0.4), rgba(42, 157, 143, 0.3)); border-color: #2A9D8F;">REJOIN GAME</button>
                    <div style="color: #89A0B4; font-size: 12px; font-style: italic; margin-top: 5px;">Select your heroes above, then click to rejoin</div>
                </div>
            </div>
            <div id="gameStartOptions" style="display: none; margin-bottom: 15px;">
                <div style="color: #F2C94C; font-size: 16px; margin-bottom: 15px; font-weight: bold;">All heroes selected! Choose how to start:</div>
                <div style="display: flex; flex-direction: column; gap: 10px; max-width: 400px; margin: 0 auto;">
                    <button class="menuButton" onclick="continueGame()" style="padding: 15px; font-size: 14px; background: linear-gradient(135deg, rgba(42, 157, 143, 0.4), rgba(42, 157, 143, 0.3)); border-color: #2A9D8F;">CONTINUE</button>
                    <button class="menuButton" onclick="loadSaveGame()" style="padding: 15px; font-size: 14px; background: linear-gradient(135deg, rgba(46, 134, 222, 0.4), rgba(46, 134, 222, 0.3)); border-color: #2E86DE;">LOAD SAVE GAME</button>
                    <button class="menuButton" onclick="startNewAdventure()" style="padding: 15px; font-size: 14px; background: linear-gradient(135deg, rgba(242, 201, 76, 0.4), rgba(242, 201, 76, 0.3)); border-color: #F2C94C;">START NEW ADVENTURE</button>
                    <div style="color: #EB5757; font-size: 12px; font-style: italic; margin-top: 5px;">‚ö† Starting new adventure replaces local save</div>
                </div>
            </div>
            <div style="display: flex; gap: 15px; justify-content: center;">
                <button class="menuButton" onclick="cancelHeroSelection()" style="padding: 12px 30px; font-size: 14px; background: linear-gradient(135deg, rgba(235, 87, 87, 0.4), rgba(235, 87, 87, 0.3)); border-color: #EB5757;">BACK</button>
            </div>
        </div>
    </div>
    
    <!-- Host Controls Panel -->
    <div id="hostControlsPanel" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9)); border: 2px solid #2A9D8F; border-radius: 12px; padding: 25px; max-width: 500px; width: 85vw; z-index: 300; pointer-events: all; box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8); backdrop-filter: blur(10px);">
        <div class="panelTitle" style="color: #2A9D8F;">üéÆ HOST CONTROLS</div>
        <div id="playerList" style="margin: 20px 0; max-height: 300px; overflow-y: auto;">
            <!-- Dynamically populated -->
        </div>
        <div style="display: flex; gap: 10px; margin-top: 20px;">
            <button class="menuButton" onclick="changeRoomCodeFromPanel()" style="flex: 1; padding: 10px; font-size: 13px;">CHANGE CODE</button>
            <button class="menuButton" onclick="closeHostControls()" style="flex: 1; padding: 10px; font-size: 13px; background: linear-gradient(135deg, rgba(235, 87, 87, 0.4), rgba(235, 87, 87, 0.3)); border-color: #EB5757;">CLOSE</button>
        </div>
    </div>
    
    <!-- Confirmation Modal -->
    <div id="confirmationModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); z-index: 400; pointer-events: all;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; background: linear-gradient(135deg, rgba(26, 26, 46, 0.95), rgba(13, 13, 26, 0.95)); border: 3px solid #F2C94C; border-radius: 15px; padding: 40px 60px; box-shadow: 0 10px 50px rgba(0, 0, 0, 0.9);">
            <div id="confirmationTitle" style="color: #F2C94C; font-size: 28px; font-weight: 900; margin-bottom: 20px; text-shadow: 0 0 15px rgba(242, 201, 76, 0.5); text-transform: uppercase; letter-spacing: 2px;">CONFIRM ACTION</div>
            <div id="confirmationMessage" style="color: #89A0B4; font-size: 16px; margin-bottom: 30px; line-height: 1.5;">Are you sure?</div>
            <div style="display: flex; gap: 20px; justify-content: center;">
                <button onclick="confirmModalAction(false)" style="padding: 12px 30px; font-size: 16px; font-weight: bold; background: linear-gradient(135deg, rgba(231, 76, 60, 0.4), rgba(192, 57, 43, 0.4)); border: 2px solid #E74C3C; border-radius: 8px; color: #FFFFFF; cursor: pointer; text-transform: uppercase; letter-spacing: 1px; transition: all 0.2s;">CANCEL</button>
                <button onclick="confirmModalAction(true)" style="padding: 12px 30px; font-size: 16px; font-weight: bold; background: linear-gradient(135deg, rgba(46, 204, 113, 0.4), rgba(39, 174, 96, 0.4)); border: 2px solid #27AE60; border-radius: 8px; color: #FFFFFF; cursor: pointer; text-transform: uppercase; letter-spacing: 1px; transition: all 0.2s;">YES</button>
            </div>
        </div>
    </div>
    
    <!-- Overlay for modal panels -->
    <div id="overlay" onclick="closeAllPanels()"></div>
    
    <!-- Settings Panel -->
    <div id="settingsPanel">
        <div class="panelTitle">SETTINGS</div>
        
        <!-- Music Controls -->
        <div class="settingRow" style="margin-bottom: 10px;">
            <span class="settingLabel" style="font-size: 16px;">Music Enabled</span>
            <input type="checkbox" id="musicEnabled" checked onchange="updateSettings()">
        </div>
        
        <div class="settingRow" style="margin-bottom: 15px;">
            <span class="settingLabel" style="font-size: 16px;">Music Volume</span>
            <input type="range" id="musicVolume" min="1" max="150" value="75" oninput="updateSettings()" style="width: 150px;">
            <span id="musicVolumeValue" style="margin-left: 8px; font-weight: bold; color: #2D9CDB; font-size: 14px;">75</span>
        </div>
        
        <!-- Hitbox Toggle -->
        <div class="settingRow" style="margin-bottom: 15px;">
            <span class="settingLabel" style="font-size: 16px;">Show Hitboxes</span>
            <input type="checkbox" id="showHitboxes" onchange="updateSettings()">
        </div>
        
        <!-- Network Debug Toggle -->
        <div class="settingRow" style="margin-bottom: 15px;">
            <span class="settingLabel" style="font-size: 16px;">Network Debug</span>
            <input type="checkbox" id="networkDebug" onchange="toggleNetworkDebug()">
        </div>
        
        <!-- LLM Settings Section -->
        <div style="margin: 15px 0 10px 0; padding-top: 15px; border-top: 1px solid rgba(255, 255, 255, 0.1);">
            <span style="font-size: 14px; font-weight: bold; color: #2D9CDB;">ü§ñ AI Settings</span>
        </div>
        
        <!-- LLM Free Will Toggle -->
        <div class="settingRow" style="margin-bottom: 15px;">
            <span class="settingLabel" style="font-size: 16px;">NPC Free Will Chat</span>
            <input type="checkbox" id="llmFreeWill" onchange="updateSettings()">
            <span style="font-size: 10px; color: #89A0B4; margin-left: 8px;">NPCs chat on their own</span>
        </div>
        
        <!-- LLM Free vs Paid Toggle -->
        <div class="settingRow" style="margin-bottom: 15px;">
            <span class="settingLabel" style="font-size: 16px;">Use Paid LLM Models</span>
            <input type="checkbox" id="llmUsePaid" onchange="updateSettings()">
            <span style="font-size: 10px; color: #89A0B4; margin-left: 8px;">Better quality, costs $</span>
        </div>
        
        <!-- RP Mode Toggle -->
        <div class="settingRow" style="margin-bottom: 15px;">
            <span class="settingLabel" style="font-size: 16px;">Roleplay Mode</span>
            <input type="checkbox" id="rpMode" onchange="updateSettings()" checked>
            <span style="font-size: 10px; color: #89A0B4; margin-left: 8px;">*dramatic emotes* vs normal speech</span>
        </div>
        
        <!-- Diagnostic Mode Toggle -->
        <div class="settingRow" style="margin-bottom: 15px;">
            <span class="settingLabel" style="font-size: 16px;">Diag Mode (5 HP)</span>
            <input type="checkbox" id="diagMode" onchange="updateSettings()">
            <span style="font-size: 10px; color: #EB5757; margin-left: 8px;">Enemies have 5 HP for testing</span>
        </div>
        
        <div style="margin: 10px 0; padding: 10px; background: rgba(42, 157, 143, 0.1); border-radius: 5px; font-size: 11px; color: #89A0B4;">
            üí° Settings are saved independently for Tunnels of Privacy
        </div>
        
        <button class="menuButton" onclick="clearCache()" style="margin-top: 15px; width: 100%; padding: 12px; font-size: 14px; background: linear-gradient(135deg, rgba(235, 87, 87, 0.4), rgba(235, 87, 87, 0.3)); border-color: #EB5757;">CLEAR CACHE<span style="display: inline-block; width: 26px; height: 26px; background: #EB5757; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">X</span></button>
        <button class="menuButton" onclick="closeAllPanels()" style="margin-top: 15px; width: 100%; padding: 12px; font-size: 14px;">CLOSE<span style="display: inline-block; width: 26px; height: 26px; background: #E74C3C; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">B</span></button>
        
        <div style="display: block; width: 100%; margin-top: 15px; padding: 10px 0; text-align: center; font-family: 'JetBrains Mono', monospace; font-size: 11px; color: #5A7A8F; border-top: 1px solid rgba(255, 255, 255, 0.1);">
            Tunnels of Privacy v0.2.61
        </div>
    </div>
    
    <!-- About/Donate Panel -->
    <div id="aboutPanel" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9)); border: 2px solid #2D9CDB; border-radius: 12px; padding: 25px; max-width: 500px; width: 85vw; z-index: 200; pointer-events: all; box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8); backdrop-filter: blur(10px);">
        <div class="panelTitle">ABOUT / DONATE</div>
        <div style="font-family: 'Inter', sans-serif; color: #D4E3F0; line-height: 1.8; text-align: center;">
            <div style="margin-bottom: 25px;">
                <div style="font-size: 18px; font-weight: 700; color: #F2C94C; margin-bottom: 10px;">Created by CyberAxe</div>
                <div style="font-size: 16px; margin-bottom: 5px;">
                    <a href="https://www.OutlandishlyCrafted.com" target="_blank" style="color: #2D9CDB; text-decoration: none; font-weight: 600;">www.OutlandishlyCrafted.com</a>
                </div>
            </div>
            
            <div style="margin-bottom: 25px; padding-top: 20px; border-top: 2px solid #26313B;">
                <div style="font-size: 16px; font-weight: 700; color: #27AE60; margin-bottom: 10px;">Report Bugs & Get Support</div>
                <div style="font-size: 14px;">
                    <a href="https://github.com/Jbenisek/ZLOCK-ZHAINER" target="_blank" style="color: #2D9CDB; text-decoration: none; font-weight: 600;">github.com/Jbenisek/ZLOCK-ZHAINER</a>
                </div>
            </div>
            
            <div style="margin-bottom: 20px; padding-top: 20px; border-top: 2px solid #26313B;">
                <div style="font-size: 18px; font-weight: 700; color: #EB5757; margin-bottom: 15px;">Donate and Support</div>
                <div style="font-size: 11px; font-family: 'JetBrains Mono', monospace; background: rgba(0, 0, 0, 0.3); padding: 12px; border-radius: 8px; word-break: break-all; color: #F2C94C; margin-bottom: 15px;">
                    u1gvnthgukm0ecnan3tgj3h6pdhrmmv8zyqx8ayup9yg9er4t5l7nesas6leavc4x3rsj98n65nn2w3ekzur9yejadlmv7k4vjgu8kp58q
                </div>
                <div>
                    <img src="items/CyberAxeZcashWalletQR.PNG" alt="Zcash Donation QR Code" style="max-width: 200px; border: 2px solid #26313B; border-radius: 8px; background: white; padding: 10px;">
                </div>
            </div>
        </div>
        <button class="menuButton" onclick="closeAllPanels()" style="width: 100%; margin-top: 20px;">CLOSE<span style="display: inline-block; width: 26px; height: 26px; background: #E74C3C; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">B</span></button>
    </div>
    
    <!-- Load Save Panel -->
    <div id="loadSavePanel" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9)); border: 2px solid #3498DB; border-radius: 12px; padding: 25px; max-width: 600px; width: 85vw; z-index: 200; pointer-events: all; box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8); backdrop-filter: blur(10px);">
        <div class="panelTitle" style="color: #3498DB;">LOAD SAVE FILE</div>
        
        <div style="margin: 15px 0; padding: 15px; background: rgba(52, 152, 219, 0.1); border-radius: 8px; border: 1px solid rgba(52, 152, 219, 0.3);">
            <div style="color: #BFD1E0; font-family: 'JetBrains Mono', monospace; font-size: 12px; margin-bottom: 10px;">
                üì• Import save file from arcade game or previous dungeon run
            </div>
            <input type="file" id="saveFileInput" accept=".json" style="display: block; width: 100%; padding: 10px; background: rgba(10, 14, 18, 0.8); border: 2px solid #3498DB; border-radius: 6px; color: #E9F0F7; font-family: 'JetBrains Mono', monospace; font-size: 12px; cursor: pointer; margin-bottom: 10px;">
            <button class="menuButton" onclick="loadSaveFile()" style="width: 100%; margin: 0;">LOAD FILE<span style="display: inline-block; width: 26px; height: 26px; background: #27AE60; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">A</span></button>
        </div>
        
        <div style="margin: 15px 0; padding: 10px; background: rgba(241, 196, 15, 0.1); border-radius: 5px; font-size: 11px; color: #89A0B4;">
            üí° You can export save files from the arcade game's settings menu. This allows you to continue your adventure with the same hero stats and progress.
        </div>
        
        <button class="menuButton" onclick="closeAllPanels()" style="margin-top: 15px; width: 100%; padding: 12px; font-size: 14px;">CLOSE<span style="display: inline-block; width: 26px; height: 26px; background: #E74C3C; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">B</span></button>
    </div>

    <script>
        // Portal System - localStorage keys with "top_" prefix
        const STORAGE_KEYS = {
            SETTINGS: 'top_tunnels_settings',
            SHARED_SAVE: 'top_shared_save'
        };
        
        const GAME_VERSION = 'v0.2.89';
        
        // ===== MULTIPLAYER STATE =====
        let multiplayerState = {
            enabled: false,
            role: null, // 'host' or 'client'
            roomCode: null,
            ws: null,
            myHeroes: [], // Array of hero names this player controls
            myPlayerId: null,
            playerName: 'Player',
            playerHeroes: {}, // { hero_name: { playerId, playerName } }
            connectedPlayers: [], // [ { id, hero, name } ]
            isReconnecting: false,
            // Client-only: Cache of hero stats from host broadcasts
            heroStatsCache: {
                zooko: null,
                nate: null,
                zancas: null,
                cyberaxe: null
            },
            // Client-only: Cache of gold from host
            goldCache: 0
        };
        
        // ===== GAMEPAD SUPPORT =====
        let gamepadConnected = false;
        let gamepadIndex = null;
        let gamepadButtonStates = {};
        let gamepadAxisDeadzone = 0.25;
        let lastGamepadUpdate = 0;
        const gamepadUpdateInterval = 16; // ~60Hz polling
        
        // Button mapping (standard gamepad layout)
        const GamepadButtons = {
            A: 0,           // Bottom face button (A on Xbox, X on PlayStation)
            B: 1,           // Right face button (B on Xbox, Circle on PlayStation)
            X: 2,           // Left face button (X on Xbox, Square on PlayStation)
            Y: 3,           // Top face button (Y on Xbox, Triangle on PlayStation)
            LB: 4,          // Left bumper
            RB: 5,          // Right bumper
            LT: 6,          // Left trigger
            RT: 7,          // Right trigger
            SELECT: 8,      // Select/Back/Share
            START: 9,       // Start/Menu/Options
            L3: 10,         // Left stick button
            R3: 11,         // Right stick button
            DPAD_UP: 12,
            DPAD_DOWN: 13,
            DPAD_LEFT: 14,
            DPAD_RIGHT: 15
        };
        
        // Axis mapping
        const GamepadAxes = {
            LEFT_X: 0,
            LEFT_Y: 1,
            RIGHT_X: 2,
            RIGHT_Y: 3
        };
        // ===== END GAMEPAD SUPPORT =====
        
        // Music System
        let currentMusic = null;
        let musicEnabled = true;
        let musicVolume = 75; // Music volume (1-150)
        let musicStarted = false;
        let currentTrackIndex = 0;
        let mainThemePlayed = false; // Track if main theme has played
        
        // Asset loading tracking
        let assetsToLoad = 0;
        let assetsLoaded = 0;
        let artTotal = 0;
        let artLoaded = 0;
        let audioTotal = 0;
        let audioLoaded = 0;
        let allAssetsReady = false;
        
        // Ticker facts system
        let tickerFacts = [];
        let currentTickerFact = '';
        
        // Game state
        let isPaused = false;
        let currentScreen = 'title'; // 'title', 'dungeonMenu', 'exploration'
        
        // Load ticker facts from JSON file
        fetch('ticker_facts.json')
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                tickerFacts = data.facts;
                
                // Pick initial random fact
                if (tickerFacts.length > 0) {
                    currentTickerFact = tickerFacts[Math.floor(Math.random() * tickerFacts.length)];
                }
            })
            .catch(err => {});
        
        // ===== STORY INTRO BACKGROUND ANIMATION =====
        // intro_a.png is 8x16 atlas (128 frames) at 16fps
        let storyIntroCurrentFrame = 0;
        let storyIntroDirection = 1; // 1 = forward, -1 = backward (ping-pong)
        let storyIntroIntervalId = null;
        const INTRO_COLS = 8;
        const INTRO_ROWS = 16;
        const INTRO_TOTAL_FRAMES = 128;
        const INTRO_FPS = 16;
        
        function startStoryIntroAnimation() {
            const bgElement = document.getElementById('storyIntroBackground');
            if (!bgElement) return;
            
            // Use dungeon intro animation
            const imageFile = 'story/intro/intro_a.png';
            
            // Set intro_a atlas as background
            bgElement.style.backgroundImage = `url('${imageFile}')`;
            bgElement.style.backgroundSize = `${INTRO_COLS * 100}% ${INTRO_ROWS * 100}%`;
            bgElement.style.opacity = '1';
            
            // Start frame animation at 16fps
            const frameInterval = 1000 / INTRO_FPS; // ~62.5ms per frame
            storyIntroIntervalId = window.setInterval(() => {
                // Calculate current frame position in atlas
                const col = storyIntroCurrentFrame % INTRO_COLS;
                const row = Math.floor(storyIntroCurrentFrame / INTRO_COLS);
                
                // Set background position to show current frame
                const xPercent = (col / (INTRO_COLS - 1)) * 100;
                const yPercent = (row / (INTRO_ROWS - 1)) * 100;
                bgElement.style.backgroundPosition = `${xPercent}% ${yPercent}%`;
                
                // Advance frame with ping-pong
                storyIntroCurrentFrame += storyIntroDirection;
                
                // Reverse at boundaries (ping-pong mode)
                if (storyIntroCurrentFrame >= INTRO_TOTAL_FRAMES - 1) {
                    storyIntroCurrentFrame = INTRO_TOTAL_FRAMES - 1;
                    storyIntroDirection = -1;
                } else if (storyIntroCurrentFrame <= 0) {
                    storyIntroCurrentFrame = 0;
                    storyIntroDirection = 1;
                }
            }, frameInterval);
        }
        
        function stopStoryIntroAnimation() {
            if (storyIntroIntervalId) {
                window.clearInterval(storyIntroIntervalId);
                storyIntroIntervalId = null;
            }
        }
        // ===== END STORY INTRO BACKGROUND ANIMATION =====
        
        // ===== SPRITE SHEET ANIMATION SYSTEM =====
        // Supports 9x9 atlas (81 frames), 16fps, ping-pong/loop/once modes
        // Used for heroes, mobs, bosses in battle
        
        const ANIM_GRID_SIZE = 9; // 9x9 grid
        const ANIM_TOTAL_FRAMES = 81;
        const ANIM_DEFAULT_FPS = 16;
        
        // Animation state paths for heroes
        // States can be a single path (string) or array of variants for random selection
        const HERO_ANIM_PATHS = {
            zooko: { 
                idle: [
                    'tunnelsofprivacy/heros/zooko_idle.png',
                    'tunnelsofprivacy/heros/zooko_idle_a.png',
                    'tunnelsofprivacy/heros/zooko_idle_b.png'
                ],
                light_attack: 'tunnelsofprivacy/heros/zooko_light_attack.png',
                heavy_attack: 'tunnelsofprivacy/heros/zooko_heavy_attack.png',
                special_attack: 'tunnelsofprivacy/heros/zooko_special_attack.png',
                knockout: 'tunnelsofprivacy/heros/zooko_knockout.png',
                hit: 'tunnelsofprivacy/heros/zooko_hit.png',
                defend: 'tunnelsofprivacy/heros/zooko_def.png'
            },
            nate: { 
                idle: [
                    'tunnelsofprivacy/heros/nate_idle.png',
                    'tunnelsofprivacy/heros/nate_idle_a.png',
                    'tunnelsofprivacy/heros/nate_idle_b.png',
                    'tunnelsofprivacy/heros/nate_idle_c.png'
                ],
                light_attack: 'tunnelsofprivacy/heros/nate_light_attack.png',
                heavy_attack: 'tunnelsofprivacy/heros/nate_heavy_attack.png',
                special_attack: [
                    'tunnelsofprivacy/heros/nate_special_attack.png',
                    'tunnelsofprivacy/heros/nate_special_attack_a.png'
                ],
                knockout: 'tunnelsofprivacy/heros/nate_knockout.png',
                hit: 'tunnelsofprivacy/heros/nate_hit.png',
                defend: 'tunnelsofprivacy/heros/nate_def.png',
                heal: 'tunnelsofprivacy/heros/nate_heal.png',
                taunt: 'tunnelsofprivacy/heros/nate_taunt.png',
                myturn: 'tunnelsofprivacy/heros/nate_myturn.png'
            },
            zancas: { 
                idle: [
                    'tunnelsofprivacy/heros/zancas_idle.png',
                    'tunnelsofprivacy/heros/zancas_idle_a.png',
                    'tunnelsofprivacy/heros/zancas_idle_b.png'
                ],
                light_attack: 'tunnelsofprivacy/heros/zancas_light_attack.png',
                heavy_attack: 'tunnelsofprivacy/heros/zancas_heavy_attack.png',
                special_attack: 'tunnelsofprivacy/heros/zancas_special_attack.png',
                knockout: 'tunnelsofprivacy/heros/zancas_knockout.png',
                hit: 'tunnelsofprivacy/heros/zancas_hit.png',
                defend: 'tunnelsofprivacy/heros/zancas_def.png',
                heal: 'tunnelsofprivacy/heros/zancas_heal.png'
            },
            cyberaxe: { 
                idle: [
                    'tunnelsofprivacy/heros/cyberaxe_idle.png',
                    'tunnelsofprivacy/heros/cyberaxe_idle_a.png',
                    'tunnelsofprivacy/heros/cyberaxe_idle_b.png'
                ],
                light_attack: 'tunnelsofprivacy/heros/cyberaxe_light_attack.png',
                heavy_attack: 'tunnelsofprivacy/heros/cyberaxe_heavy_attack.png',
                special_attack: 'tunnelsofprivacy/heros/cyberaxe_special_attack.png',
                knockout: 'tunnelsofprivacy/heros/cyberaxe_knockout.png',
                hit: 'tunnelsofprivacy/heros/cyberaxe_hit.png',
                defend: 'tunnelsofprivacy/heros/cyberaxe_def.png'
            }
        };
        
        // Cache for loaded sprite sheets
        const spriteSheetCache = {};
        
        // Load a sprite sheet (lazy load with caching)
        function loadSpriteSheet(path) {
            if (spriteSheetCache[path]) {
                return Promise.resolve(spriteSheetCache[path]);
            }
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    spriteSheetCache[path] = img;
                    resolve(img);
                };
                img.onerror = reject;
                img.src = path + '?v=' + Date.now();
            });
        }
        
        // Initialize animation controller for a combatant
        function initAnimation(combatant, sheetPath, playMode = 'pingpong') {
            combatant.anim = {
                sheet: null,
                sheetPath: sheetPath,
                frameSize: 0,       // Auto-calculated from sheet.width / 9
                frame: 0,           // Current frame 0-80
                fps: ANIM_DEFAULT_FPS,
                lastTime: 0,        // Last frame update timestamp
                direction: 1,       // 1 = forward, -1 = reverse
                playMode: playMode, // 'pingpong', 'loop', 'once'
                state: 'idle',
                playing: true,
                onComplete: null    // Callback when animation completes (for 'once' mode)
            };
            
            // Load the sprite sheet
            loadSpriteSheet(sheetPath).then(sheet => {
                combatant.anim.sheet = sheet;
                combatant.anim.frameSize = sheet.width / ANIM_GRID_SIZE;
            }).catch(err => {
                console.error('Failed to load sprite sheet:', sheetPath, err);
            });
        }
        
        // Update animation frame based on elapsed time
        function updateAnimation(combatant, currentTime) {
            const anim = combatant.anim;
            if (!anim || !anim.sheet || !anim.playing) return;
            
            // Initialize lastTime on first call
            if (anim.lastTime === 0) {
                anim.lastTime = currentTime;
                return;
            }
            
            const frameInterval = 1000 / anim.fps;
            const elapsed = currentTime - anim.lastTime;
            
            if (elapsed >= frameInterval) {
                anim.lastTime = currentTime - (elapsed % frameInterval);
                
                // Advance frame
                anim.frame += anim.direction;
                
                // Handle boundaries based on play mode
                if (anim.playMode === 'pingpong') {
                    if (anim.frame >= ANIM_TOTAL_FRAMES - 1) {
                        anim.frame = ANIM_TOTAL_FRAMES - 1;
                        anim.direction = -1;
                    } else if (anim.frame <= 0) {
                        anim.frame = 0;
                        const wasReversing = anim.direction === -1;
                        anim.direction = 1;
                        // Cycle complete (just finished reversing) - pick new random variant
                        if (wasReversing && anim.state === 'idle') {
                            pickNextIdleVariant(combatant);
                        }
                    }
                } else if (anim.playMode === 'loop') {
                    if (anim.frame >= ANIM_TOTAL_FRAMES) {
                        anim.frame = 0;
                    }
                } else if (anim.playMode === 'once') {
                    if (anim.frame >= ANIM_TOTAL_FRAMES - 1) {
                        anim.frame = ANIM_TOTAL_FRAMES - 1;
                        anim.playing = false;
                        if (anim.onComplete) anim.onComplete();
                    }
                }
            }
        }
        
        // Pick next idle variant for combatants with multiple idles
        function pickNextIdleVariant(combatant) {
            const anim = combatant.anim;
            if (!anim) return;
            
            const heroKey = combatant.name.toLowerCase();
            const paths = HERO_ANIM_PATHS[heroKey];
            if (!paths || !Array.isArray(paths.idle) || paths.idle.length <= 1) return;
            
            // Pick a different variant than current
            const otherPaths = paths.idle.filter(p => p !== anim.sheetPath);
            if (otherPaths.length === 0) return;
            
            const newPath = otherPaths[Math.floor(Math.random() * otherPaths.length)];
            anim.sheetPath = newPath;
            
            // Check if already cached (instant swap)
            if (spriteSheetCache[newPath]) {
                anim.sheet = spriteSheetCache[newPath];
                anim.frameSize = anim.sheet.width / ANIM_GRID_SIZE;
                anim.frame = 0; // Reset to start of new animation
            } else {
                // Load and swap when ready
                loadSpriteSheet(newPath).then(sheet => {
                    anim.sheet = sheet;
                    anim.frameSize = sheet.width / ANIM_GRID_SIZE;
                    anim.frame = 0; // Reset to start of new animation
                });
            }
        }
        
        // Preload all idle variants for a hero (call on battle start)
        function preloadIdleVariants(heroKey) {
            const paths = HERO_ANIM_PATHS[heroKey];
            if (paths && Array.isArray(paths.idle)) {
                paths.idle.forEach(path => loadSpriteSheet(path));
            }
        }
        
        // Draw animated sprite from atlas
        function drawAnimatedSprite(ctx, combatant, destX, destY, destWidth, destHeight, flipX = false) {
            const anim = combatant.anim;
            if (!anim || !anim.sheet || !anim.sheet.complete) {
                // Fallback: draw static sprite if available
                if (combatant.sprite && combatant.sprite.complete && combatant.sprite.naturalHeight !== 0) {
                    ctx.save();
                    if (flipX) {
                        ctx.translate(destX + destWidth / 2, destY + destHeight / 2);
                        ctx.scale(-1, 1);
                        ctx.translate(-(destX + destWidth / 2), -(destY + destHeight / 2));
                    }
                    ctx.drawImage(combatant.sprite, destX, destY, destWidth, destHeight);
                    ctx.restore();
                }
                return;
            }
            
            // Calculate source rectangle from 9x9 grid
            const col = anim.frame % ANIM_GRID_SIZE;
            const row = Math.floor(anim.frame / ANIM_GRID_SIZE);
            const srcX = col * anim.frameSize;
            const srcY = row * anim.frameSize;
            const srcSize = anim.frameSize;
            
            ctx.save();
            if (flipX) {
                ctx.translate(destX + destWidth / 2, destY + destHeight / 2);
                ctx.scale(-1, 1);
                ctx.translate(-(destX + destWidth / 2), -(destY + destHeight / 2));
            }
            ctx.drawImage(
                anim.sheet,
                srcX, srcY, srcSize, srcSize,  // Source rectangle
                destX, destY, destWidth, destHeight  // Destination rectangle
            );
            ctx.restore();
        }
        
        // Change animation state (e.g., idle -> attack -> idle)
        function setAnimationState(combatant, newState, playMode = 'pingpong', onComplete = null, broadcastToClients = true) {
            const anim = combatant.anim;
            if (!anim) return;
            
            // Get the path for this combatant's new state
            const heroKey = combatant.name.toLowerCase();
            const paths = HERO_ANIM_PATHS[heroKey];
            if (!paths || !paths[newState]) {
                console.warn('No animation path for:', heroKey, newState);
                return;
            }
            
            // Broadcast animation to clients (only if host and broadcastToClients is true)
            if (broadcastToClients && multiplayerState.enabled && multiplayerState.role === 'host') {
                sendWebSocketMessage({
                    type: 'animation_sync',
                    combatantName: combatant.name,
                    animState: newState,
                    playMode: playMode
                });
            }
            
            // Handle array of variants (random selection)
            let newPath = paths[newState];
            if (Array.isArray(newPath)) {
                newPath = newPath[Math.floor(Math.random() * newPath.length)];
            }
            
            // If same path and already playing, don't restart (but allow different variant)
            if (anim.sheetPath === newPath && anim.playing) {
                return;
            }
            
            anim.state = newState;
            anim.sheetPath = newPath;
            anim.frame = 0;
            anim.direction = 1;
            anim.playMode = playMode;
            anim.playing = true;
            anim.onComplete = onComplete;
            anim.lastTime = 0;
            
            // Load new sprite sheet
            loadSpriteSheet(newPath).then(sheet => {
                anim.sheet = sheet;
                anim.frameSize = sheet.width / ANIM_GRID_SIZE;
            });
        }
        // ===== END SPRITE SHEET ANIMATION SYSTEM =====
        
        const themeTracks = [
            { file: 'music/main_theme.webm', name: 'Tunnels of Privacy Theme' },
            { file: 'music/theme_a.webm', name: 'Electric Coin Company' },
            { file: 'music/theme_b.webm', name: 'Zcash Foundation' },
            { file: 'music/theme_c_boss.webm', name: 'Proof of Work Battle' },
            { file: 'music/theme_d.webm', name: 'ZecWallet Lite' },
            { file: 'music/theme_e.webm', name: 'Private by Default' },
            { file: 'music/theme_f.webm', name: 'Halo Arc Dreams' },
            { file: 'music/theme_g.webm', name: 'Mining the Future' },
            { file: 'music/theme_h.webm', name: 'zkSNARK Symphony' },
            { file: 'music/theme_i.webm', name: 'Trusted Setup Ceremony' },
            { file: 'music/theme_j.webm', name: 'Shielded Sunset' }
        ];
        
        function loadMusic(trackData) {
            if (!musicEnabled) return;
            
            // Check if we're already playing this track
            if (currentMusic && currentMusic.src.endsWith(trackData.file)) {
                return; // Don't restart the same track
            }
            
            // Update music ticker with track name
            const tickerText1 = document.getElementById('musicTickerText1');
            const tickerText2 = document.getElementById('musicTickerText2');
            if (tickerText1 && tickerText2 && trackData.name) {
                // Pick a new random fact each time track changes
                if (tickerFacts.length > 0) {
                    currentTickerFact = tickerFacts[Math.floor(Math.random() * tickerFacts.length)];
                }
                
                const musicInfo = `‚ô´ Theme Song: ${trackData.name} ‚ô´`;
                
                // Combine music info with fun fact
                const finalText = currentTickerFact ? `${musicInfo}  ‚Ä¢  ${currentTickerFact}` : musicInfo;
                tickerText1.textContent = finalText;
                tickerText2.textContent = finalText;
            }
            
            // Use musicVolume divided by 100 (1-150 scale), clamped to max 1.0
            const volumeScale = Math.min(1.0, musicVolume / 100);
            
            // Create new audio element
            const newMusic = new Audio(trackData.file);
            newMusic.loop = false;
            newMusic.volume = 0; // Start silent
            
            // Fade in new track
            newMusic.play().then(() => {
                fadeMusic(newMusic, 0, volumeScale, 1000);
                musicStarted = true;
                updateMusicButton();
                
                // When song ends, play next random track
                // Add listener AFTER play() succeeds to ensure it's attached
                newMusic.addEventListener('ended', () => {
                    if (!musicEnabled) return;
                    mainThemePlayed = true; // Mark main theme as played
                    // Pick random track excluding main theme (index 0)
                    const randomIndex = Math.floor(Math.random() * (themeTracks.length - 1)) + 1;
                    const randomTrack = themeTracks[randomIndex];
                    loadMusic(randomTrack);
                });
            }).catch(err => {
                console.log('Music autoplay blocked:', err);
            });
            
            // Fade out old track
            if (currentMusic) {
                const oldMusic = currentMusic;
                fadeMusic(oldMusic, oldMusic.volume, 0, 1000, () => {
                    oldMusic.pause();
                    oldMusic.src = '';
                });
            }
            
            currentMusic = newMusic;
        }
        
        function fadeMusic(audioElement, startVol, endVol, duration, callback) {
            const steps = 20;
            const stepTime = duration / steps;
            const volStep = (endVol - startVol) / steps;
            let currentStep = 0;
            
            const fadeInterval = setInterval(() => {
                currentStep++;
                const newVol = startVol + (volStep * currentStep);
                audioElement.volume = Math.max(0, Math.min(1, newVol));
                
                if (currentStep >= steps) {
                    clearInterval(fadeInterval);
                    audioElement.volume = Math.max(0, Math.min(1.5, endVol));
                    if (callback) callback();
                }
            }, stepTime);
        }
        
        // Music Control Functions
        function musicPlayPause() {
            const btn = document.getElementById('musicPlayPauseBtn');
            
            if (!currentMusic) {
                // No music loaded yet, start with main theme
                musicEnabled = true;
                loadMusic(themeTracks[0]); // Always start with main theme
                if (btn) btn.textContent = '‚è∏';
                return;
            }
            
            if (currentMusic.paused) {
                currentMusic.play().catch(err => console.log('Play error:', err));
                musicEnabled = true;
                if (btn) btn.textContent = '‚è∏';
            } else {
                currentMusic.pause();
                musicEnabled = false;
                if (btn) btn.textContent = '‚ñ∂';
            }
        }
        
        function musicPrevious() {
            if (currentMusic) {
                currentMusic.pause();
            }
            
            musicEnabled = true; // Enable music if it was paused
            mainThemePlayed = true;
            // Pick random track excluding main theme (index 0)
            const randomIndex = Math.floor(Math.random() * (themeTracks.length - 1)) + 1;
            const randomTrack = themeTracks[randomIndex];
            loadMusic(randomTrack);
        }
        
        function musicNext() {
            if (currentMusic) {
                currentMusic.pause();
            }
            
            musicEnabled = true; // Enable music if it was paused
            mainThemePlayed = true;
            // Pick random track excluding main theme (index 0)
            const randomIndex = Math.floor(Math.random() * (themeTracks.length - 1)) + 1;
            const randomTrack = themeTracks[randomIndex];
            loadMusic(randomTrack);
        }
        
        function updateMusicButton() {
            const btn = document.getElementById('musicPlayPauseBtn');
            if (btn) {
                if (currentMusic && !currentMusic.paused) {
                    btn.textContent = '‚è∏';
                } else {
                    btn.textContent = '‚ñ∂';
                }
            }
        }
        
        function updateVolume() {
            const slider = document.getElementById('volumeSlider');
            if (!slider) return;
            
            musicVolume = parseInt(slider.value);
            
            // Update settings object
            settings.musicVolume = musicVolume;
            
            // Update volume display
            const volumeDisplay = document.getElementById('volumeSliderValue');
            if (volumeDisplay) {
                volumeDisplay.textContent = musicVolume;
            }
            
            // Update settings panel slider if open
            const settingsSlider = document.getElementById('musicVolume');
            if (settingsSlider) {
                settingsSlider.value = musicVolume;
            }
            const settingsVolumeDisplay = document.getElementById('musicVolumeValue');
            if (settingsVolumeDisplay) {
                settingsVolumeDisplay.textContent = musicVolume;
            }
            
            if (currentMusic) {
                currentMusic.volume = Math.min(1.0, musicVolume / 100);
            }
            
            // Save to localStorage
            saveSettings();
        }
        
        // Settings System
        let settings = {
            musicEnabled: true,
            musicVolume: 75,
            showHitboxes: false,
            playerName: '',
            llmFreeWill: false,      // NPCs chat autonomously
            llmUsePaid: false,       // Use paid LLM models
            rpMode: true,            // RP emotes/dramatic speech vs normal 2025 talk
            diagMode: false          // Diagnostic mode - enemies have 5 HP
        };
        
        function showSettings() {
            document.getElementById('overlay').style.display = 'block';
            document.getElementById('settingsPanel').style.display = 'block';
            
            // Load current settings into UI
            document.getElementById('musicEnabled').checked = settings.musicEnabled;
            document.getElementById('musicVolume').value = settings.musicVolume;
            document.getElementById('musicVolumeValue').textContent = settings.musicVolume;
            document.getElementById('showHitboxes').checked = settings.showHitboxes;
            document.getElementById('llmFreeWill').checked = settings.llmFreeWill;
            document.getElementById('llmUsePaid').checked = settings.llmUsePaid;
            document.getElementById('rpMode').checked = settings.rpMode !== false; // Default true
            document.getElementById('diagMode').checked = settings.diagMode === true;
        }
        
        function showAbout() {
            document.getElementById('overlay').style.display = 'block';
            document.getElementById('aboutPanel').style.display = 'block';
        }
        
        function updateSettings() {
            // Read values from UI
            settings.musicEnabled = document.getElementById('musicEnabled').checked;
            settings.musicVolume = parseInt(document.getElementById('musicVolume').value);
            settings.showHitboxes = document.getElementById('showHitboxes').checked;
            settings.llmFreeWill = document.getElementById('llmFreeWill').checked;
            settings.llmUsePaid = document.getElementById('llmUsePaid').checked;
            settings.rpMode = document.getElementById('rpMode').checked;
            settings.diagMode = document.getElementById('diagMode').checked;
            
            // Update display
            document.getElementById('musicVolumeValue').textContent = settings.musicVolume;
            
            // Apply to game state
            musicEnabled = settings.musicEnabled;
            musicVolume = settings.musicVolume;
            
            // Re-render battle if active to show/hide hitboxes
            if (battleState.active) {
                renderBattle();
            }
            
            // Handle music enable/disable
            if (currentMusic) {
                if (musicEnabled) {
                    // Enable: Resume if paused
                    if (currentMusic.paused) {
                        currentMusic.play().catch(err => console.log('Play error:', err));
                    }
                    currentMusic.volume = Math.min(1.0, musicVolume / 100);
                } else {
                    // Disable: Pause music
                    currentMusic.pause();
                }
            }
            
            // Update volume slider in main controls
            const mainSlider = document.getElementById('volumeSlider');
            if (mainSlider) {
                mainSlider.value = musicVolume;
            }
            
            // Update play/pause button
            updateMusicButton();
            
            // Save to localStorage
            saveSettings();
        }
        
        function closeAllPanels() {
            document.getElementById('overlay').style.display = 'none';
            document.getElementById('settingsPanel').style.display = 'none';
            document.getElementById('aboutPanel').style.display = 'none';
            const loadSavePanel = document.getElementById('loadSavePanel');
            if (loadSavePanel) {
                loadSavePanel.style.display = 'none';
            }
        }
        
        function showLoadSave() {
            document.getElementById('overlay').style.display = 'block';
            const loadSavePanel = document.getElementById('loadSavePanel');
            if (loadSavePanel) {
                loadSavePanel.style.display = 'block';
            }
        }
        
        function loadSaveFile() {
            const fileInput = document.getElementById('saveFileInput');
            const file = fileInput.files[0];
            
            if (!file) {
                alert('Please select a save file first!');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const saveData = JSON.parse(e.target.result);
                    
                    // Validate save data structure
                    if (!saveData || !saveData.heroes) {
                        alert('Invalid save file format! Missing hero data.');
                        return;
                    }
                    
                    // Save to localStorage
                    if (saveSharedSave(saveData)) {
                        alert('Save file loaded successfully!');
                        
                        // Refresh hero displays
                        if (saveData.heroes.zooko) updateHeroDisplay('zooko', saveData.heroes.zooko);
                        if (saveData.heroes.nate) updateHeroDisplay('nate', saveData.heroes.nate);
                        if (saveData.heroes.zancas) updateHeroDisplay('zancas', saveData.heroes.zancas);
                        if (saveData.heroes.cyberaxe) updateHeroDisplay('cyberaxe', saveData.heroes.cyberaxe);
                        
                        // Update gold display
                        updateGoldDisplay();
                        
                        // Update dungeon level if arcade state exists
                        if (saveData.arcadeState && saveData.arcadeState.level) {
                            document.getElementById('dungeonLevel').textContent = saveData.arcadeState.level;
                        }
                        
                        // Update title screen buttons
                        updateTitleScreenButtons();
                        
                        // Close panel
                        closeAllPanels();
                        
                        // Clear file input
                        fileInput.value = '';
                    } else {
                        alert('Failed to save the loaded data to localStorage.');
                    }
                } catch (error) {
                    alert('Error reading save file: ' + error.message);
                    console.error('Save file load error:', error);
                }
            };
            
            reader.onerror = function() {
                alert('Error reading file!');
            };
            
            reader.readAsText(file);
        }
        
        function saveSettings() {
            try {
                localStorage.setItem(STORAGE_KEYS.SETTINGS, JSON.stringify(settings));
            } catch (e) {
                console.error('Failed to save settings:', e);
            }
        }
        
        function loadSettings() {
            try {
                const saved = localStorage.getItem(STORAGE_KEYS.SETTINGS);
                if (saved) {
                    const loaded = JSON.parse(saved);
                    settings = { ...settings, ...loaded };
                    
                    // Apply to game state
                    musicEnabled = settings.musicEnabled;
                    musicVolume = settings.musicVolume;
                    
                    // Update main volume slider and display
                    const mainSlider = document.getElementById('volumeSlider');
                    if (mainSlider) {
                        mainSlider.value = musicVolume;
                    }
                    const volumeDisplay = document.getElementById('volumeSliderValue');
                    if (volumeDisplay) {
                        volumeDisplay.textContent = musicVolume;
                    }
                    
                    // Populate player name input field
                    const playerNameInput = document.getElementById('multiplayerPlayerName');
                    if (playerNameInput && settings.playerName) {
                        playerNameInput.value = settings.playerName;
                    }
                }
            } catch (e) {
                console.error('Failed to load settings:', e);
            }
        }
        
        // Load shared save and populate hero stats
        function loadSharedSave() {
            try {
                const saved = localStorage.getItem(STORAGE_KEYS.SHARED_SAVE);
                if (!saved) return null;
                
                const sharedSave = JSON.parse(saved);
                return migrateSharedSave(sharedSave);
            } catch (e) {
                console.error('Failed to load shared save:', e);
                return null;
            }
        }
        
        // Save shared save to localStorage
        function saveSharedSave(sharedSave) {
            try {
                const jsonString = JSON.stringify(sharedSave);
                localStorage.setItem(STORAGE_KEYS.SHARED_SAVE, jsonString);
                console.log('Shared save written. Size:', jsonString.length, 'bytes');
                return true;
            } catch (e) {
                console.error('Failed to save shared save:', e);
                return false;
            }
        }
        
        // Migrate shared save between versions
        function migrateSharedSave(sharedSave) {
            // Currently at version 1, no migrations needed yet
            return sharedSave;
        }
        
        // Creates default shared save with initial hero stats
        function createDefaultSharedSave() {
            return {
                saveVersion: 1,
                lastPlayed: Date.now(),
                arcadeState: null,
                dungeonState: {
                    currentLevel: 1,
                    inventory: [],
                    gold: 0,
                    questProgress: {
                        hasScepter: false,
                        hasReturned: false,
                        bossesDefeated: []
                    }
                },
                heroes: {
                    zooko: {
                        name: 'Zooko',
                        str: 8, dex: 11, con: 10, int: 15, wis: 13, cha: 9,
                        hp: 22, maxHp: 25, ac: 12, xp: 0, level: 1
                    },
                    nate: {
                        name: 'Nate',
                        str: 14, dex: 12, con: 13, int: 10, wis: 9, cha: 11,
                        hp: 28, maxHp: 30, ac: 14, xp: 0, level: 1
                    },
                    zancas: {
                        name: 'Zancas',
                        str: 10, dex: 15, con: 11, int: 12, wis: 14, cha: 8,
                        hp: 24, maxHp: 26, ac: 13, xp: 0, level: 1
                    },
                    cyberaxe: {
                        name: 'CyberAxe',
                        str: 16, dex: 10, con: 14, int: 8, wis: 11, cha: 10,
                        hp: 32, maxHp: 35, ac: 15, xp: 0, level: 1
                    }
                }
            };
        }
        
        // Clear cache - deletes all localStorage data and forces hard reload
        function clearCache() {
            if (confirm('This will delete ALL saved data including your progress. Are you sure?')) {
                try {
                    localStorage.removeItem(STORAGE_KEYS.SETTINGS);
                    localStorage.removeItem(STORAGE_KEYS.SHARED_SAVE);
                    
                    // Clear browser cache for images and assets
                    if ('caches' in window) {
                        caches.keys().then(function(names) {
                            for (let name of names) caches.delete(name);
                        });
                    }
                    
                    alert('Cache cleared! The page will reload with fresh assets.');
                    // Force hard reload (bypass cache)
                    location.reload(true);
                } catch (e) {
                    console.error('Clear cache error:', e);
                    alert('Error clearing cache: ' + e.message);
                }
            }
        }
        
        // Update title screen button states based on save existence
        function updateTitleScreenButtons() {
            const sharedSave = loadSharedSave();
            const continueBtn = document.getElementById('continueBtn');
            
            if (sharedSave && (sharedSave.arcadeState || sharedSave.dungeonState)) {
                // Has save - enable CONTINUE
                continueBtn.disabled = false;
                continueBtn.classList.remove('comingSoon');
            } else {
                // No save - disable CONTINUE
                continueBtn.disabled = true;
                continueBtn.classList.add('comingSoon');
            }
        }
        
        // Continue game - load from save
        // Single-player: Continue game from save
        function continueGameSinglePlayer() {
            const sharedSave = loadSharedSave();
            if (!sharedSave) {
                alert('No save game found! Start a new adventure first.');
                return;
            }
            
            // Center music controls for dungeon menu
            document.getElementById('musicControls').classList.add('dungeonMenuActive');
            document.getElementById('musicTicker').classList.add('dungeonMenuActive');
            
            // Show dungeon menu with existing save (no warning needed)
            document.getElementById('titleScreen').style.display = 'none';
            document.getElementById('dungeonMenuScreen').style.display = 'block';
            currentScreen = 'dungeonMenu';
            
            // Update dungeon menu with save data
            updateDungeonMenuHeroes();
            updateGoldDisplay();
            
            // Apply client UI restrictions
            applyClientUIRestrictions();
            
            // Pre-generate next encounter while player is in dungeon menu
            preGenerateNextEncounter();
        }
        
        // Router: Determine which continue function to call
        function continueGame() {
            if (multiplayerState.enabled) {
                continueGameMultiplayer();
            } else {
                continueGameSinglePlayer();
            }
        }
        
        // ===== BATTLE SYSTEM =====
        
        // Battle state
        let battleState = {
            active: false,
            won: false,
            currentTurn: 0,
            turnOrder: [],
            heroes: [],
            allHeroes: [], // All heroes including dead/retreated ones (for saving stats)
            enemies: [],
            platforms: [],
            canvas: null,
            ctx: null,
            backgroundImage: null,
            backgroundPath: '',
            detectedPlatforms: [],
            targetingMode: false,
            pendingAction: null,
            swapTargetingMode: false,
            swapInitiator: null
        };
        
        // Pre-generated encounter data (prepared while in dungeon menu)
        let preGeneratedEncounter = {
            ready: false,
            generating: false,
            boss: null,
            mobs: [],
            captive: null,
            background: null,
            roomLevel: 2
        };
        
        // Pre-generate the next encounter while player is in dungeon menu
        async function preGenerateNextEncounter() {
            // Don't regenerate if already ready or currently generating
            if (preGeneratedEncounter.ready || preGeneratedEncounter.generating) {
                return;
            }
            
            // Only host generates encounters
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                return;
            }
            
            preGeneratedEncounter.generating = true;
            console.log('[PreGen] Starting encounter pre-generation...');
            
            // Reset loading bar
            updateExploreLoadingBar(0);
            
            try {
                // Load enemy data
                let bossesData = [];
                let mobsData = [];
                try {
                    const bossResponse = await fetch('tunnelsofprivacy/bosses/bosses_data.json');
                    bossesData = await bossResponse.json();
                    const mobResponse = await fetch('tunnelsofprivacy/mobs/mobs_data.json');
                    const mobObj = await mobResponse.json();
                    mobsData = mobObj.mobs || [];
                    updateExploreLoadingBar(10);  // Data loaded
                } catch(e) {
                    console.error('[PreGen] Failed to load enemy data:', e);
                    preGeneratedEncounter.generating = false;
                    updateExploreLoadingBar(0);
                    return;
                }
                
                const roomLevel = preGeneratedEncounter.roomLevel;
                
                // Generate boss (progress: 10% -> 40%)
                const boss = bossesData.find(b => b.mainLevel === roomLevel);
                if (boss) {
                    const generatedBoss = await generateEncounter('boss', boss, roomLevel);
                    preGeneratedEncounter.boss = {
                        baseData: boss,
                        generated: generatedBoss
                    };
                    console.log('[PreGen] Boss generated:', generatedBoss?.name || boss.name);
                    updateExploreLoadingBar(40);
                    await new Promise(r => setTimeout(r, 500));  // Brief delay to avoid rate limits
                }
                
                // Generate 2 mobs (progress: 40% -> 70%)
                preGeneratedEncounter.mobs = [];
                const hostileMobs = mobsData.filter(m => m.behavior?.hostile);
                for (let i = 0; i < 2 && i < hostileMobs.length; i++) {
                    const mob = hostileMobs[Math.floor(Math.random() * hostileMobs.length)];
                    const generatedMob = await generateEncounter('mob', mob, roomLevel);
                    preGeneratedEncounter.mobs.push({
                        baseData: mob,
                        generated: generatedMob
                    });
                    console.log('[PreGen] Mob generated:', generatedMob?.name || mob.name);
                    updateExploreLoadingBar(40 + (i + 1) * 15);  // 55%, 70%
                    await new Promise(r => setTimeout(r, 500));  // Brief delay to avoid rate limits
                }
                
                // Generate captive (50% chance) (progress: 70% -> 90%)
                preGeneratedEncounter.captive = null;
                if (Math.random() > 0.5) {
                    const captiveData = await generateEncounter('captive', {}, roomLevel);
                    const captiveSpriteNum = Math.floor(Math.random() * 12) + 1;
                    preGeneratedEncounter.captive = {
                        generated: captiveData,
                        spriteNum: captiveSpriteNum
                    };
                    console.log('[PreGen] Captive generated:', captiveData?.name);
                }
                updateExploreLoadingBar(90);
                
                // Pre-select background
                const backgroundOptions = [
                    'backgrounds_lvl1 (8).png',
                    'backgrounds_lvl1 (10).png',
                    'backgrounds_lvl1 (12).png',
                    'backgrounds_lvl1 (14).png',
                    'backgrounds_lvl1 (15).png',
                    'backgrounds_lvl1 (16).png'
                ];
                preGeneratedEncounter.background = backgroundOptions[Math.floor(Math.random() * backgroundOptions.length)];
                
                preGeneratedEncounter.ready = true;
                preGeneratedEncounter.generating = false;
                updateExploreLoadingBar(100);  // Complete!
                console.log('[PreGen] ‚úì Encounter ready! Click Explore Dungeon to start instantly.');
                
            } catch (error) {
                console.error('[PreGen] Error during pre-generation:', error);
                preGeneratedEncounter.generating = false;
                updateExploreLoadingBar(0);
            }
        }
        
        // Update the Explore Level button loading bar
        function updateExploreLoadingBar(percent) {
            const loadingBar = document.getElementById('exploreLoadingBar');
            const exploreBtn = document.getElementById('exploreLevelBtn');
            const btnText = exploreBtn?.querySelector('.btnText');
            
            if (loadingBar) {
                loadingBar.style.width = percent + '%';
            }
            
            if (exploreBtn) {
                if (percent >= 100) {
                    exploreBtn.classList.add('ready');
                    if (btnText) btnText.textContent = '‚öîÔ∏è EXPLORE LEVEL';
                } else if (percent > 0) {
                    exploreBtn.classList.remove('ready');
                    if (btnText) btnText.textContent = `PREPARING... ${percent}%`;
                } else {
                    exploreBtn.classList.remove('ready');
                    if (btnText) btnText.textContent = 'EXPLORE LEVEL';
                }
            }
        }
        
        // Reset pre-generated encounter (call after battle ends)
        function resetPreGeneratedEncounter() {
            preGeneratedEncounter = {
                ready: false,
                generating: false,
                boss: null,
                mobs: [],
                captive: null,
                background: null,
                roomLevel: 2
            };
            // Reset loading bar UI
            updateExploreLoadingBar(0);
        }
        
        // Chat state for battle
        let chatState = {
            visible: false,
            messages: [],  // { id, senderName, senderType, senderAvatar, text, timestamp }
            targetNpc: null,  // Currently selected NPC to chat with (deprecated - use targetEntity)
            targetEntity: null,  // Current chat target: null = broadcast, or { type, index, name }
            selectedModel: 2,  // Model ID 1-10 (default to free model 2)
            exhaustedModels: [],  // Track rate-limited models
            totalCost: 0,      // Running cost tally in dollars
            totalTokens: 0,    // Running token count
            ttsEnabled: true,  // TTS on by default
            ttsAvailable: false // Set by server check
        };
        
        // TTS audio queue and current audio
        let ttsAudioQueue = [];
        let ttsCurrentAudio = null;
        
        // Toggle TTS on/off
        function toggleTTS() {
            const checkbox = document.getElementById('ttsToggle');
            chatState.ttsEnabled = checkbox?.checked ?? false;
            console.log('[TTS] Enabled:', chatState.ttsEnabled);
        }
        
        // Check TTS availability on page load
        async function checkTTSAvailability() {
            try {
                const response = await fetch('/api/tts-status', { method: 'POST' });
                const data = await response.json();
                chatState.ttsAvailable = data.enabled;
                console.log('[TTS] Server availability:', data.enabled);
                
                // Update UI if TTS not available
                if (!data.enabled) {
                    const toggle = document.getElementById('ttsToggle');
                    const label = document.getElementById('ttsToggleLabel');
                    if (toggle) toggle.disabled = true;
                    if (label) label.title = 'TTS not available - piper-tts not installed on server';
                }
            } catch (e) {
                console.log('[TTS] Server check failed:', e);
                chatState.ttsAvailable = false;
            }
        }
        
        // Get voice type based on entity
        function getTTSVoiceType(senderType, senderName, entityVoiceType) {
            // If entity has LLM-assigned voice type, use that first
            if (entityVoiceType) {
                return entityVoiceType;
            }
            
            // Check if it's a hero name
            const heroNames = ['zooko', 'nate', 'zancas', 'cyberaxe'];
            const lowerName = (senderName || '').toLowerCase();
            if (heroNames.includes(lowerName)) {
                return lowerName;
            }
            
            // Map sender types to voice types (fallback)
            switch (senderType) {
                case 'boss': return 'boss';
                case 'mob': case 'enemy': return 'mob';
                case 'captive': return 'captive';
                case 'npc': return 'npc';
                case 'narrator': case 'system': return 'narrator';
                default: return 'default';
            }
        }
        
        // Play TTS for a message
        async function playTTS(text, senderType, senderName, entityVoiceType, entityPersonality) {
            if (!chatState.ttsEnabled || !chatState.ttsAvailable) return;
            
            // Skip empty or very short text
            if (!text || text.length < 2) return;
            
            // Skip action-only messages like *silence* or *growls*
            if (text.trim().startsWith('*') && text.trim().endsWith('*') && text.length < 30) {
                return;
            }
            
            try {
                const voiceType = getTTSVoiceType(senderType, senderName, entityVoiceType);
                console.log(`[TTS] Generating audio for "${text.substring(0, 30)}..." with voice: ${voiceType}, personality: ${entityPersonality || 'none'}`);
                
                const response = await fetch('/api/tts', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text, voiceType, personality: entityPersonality || '' })
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    console.error('[TTS] Error:', error);
                    return;
                }
                
                // Get audio blob and play it
                const audioBlob = await response.blob();
                const audioUrl = URL.createObjectURL(audioBlob);
                
                // Queue audio playback
                ttsAudioQueue.push({ url: audioUrl, text: text.substring(0, 30) });
                playNextTTSAudio();
                
            } catch (e) {
                console.error('[TTS] Playback error:', e);
            }
        }
        
        // Play next audio in queue
        function playNextTTSAudio() {
            if (ttsCurrentAudio || ttsAudioQueue.length === 0) return;
            
            const { url, text } = ttsAudioQueue.shift();
            console.log(`[TTS] Playing: "${text}..."`);
            
            ttsCurrentAudio = new Audio(url);
            ttsCurrentAudio.volume = 0.8;
            
            ttsCurrentAudio.onended = () => {
                URL.revokeObjectURL(url);
                ttsCurrentAudio = null;
                playNextTTSAudio(); // Play next in queue
            };
            
            ttsCurrentAudio.onerror = (e) => {
                console.error('[TTS] Audio playback error:', e);
                URL.revokeObjectURL(url);
                ttsCurrentAudio = null;
                playNextTTSAudio();
            };
            
            ttsCurrentAudio.play().catch(e => {
                console.log('[TTS] Autoplay blocked, user interaction needed');
                ttsCurrentAudio = null;
            });
        }
        
        // Select chat target entity
        function selectChatTarget(entity) {
            chatState.targetEntity = entity;
            
            // Update button visuals
            document.querySelectorAll('.chatTargetBtn').forEach(btn => {
                const isActive = entity === null ? 
                    btn.classList.contains('broadcast') : 
                    btn.dataset.entityType === entity?.type && btn.dataset.entityIndex === String(entity?.index);
                btn.classList.toggle('active', isActive);
            });
            
            // Update input placeholder
            const input = document.getElementById('chatInput');
            if (input) {
                if (entity === null) {
                    input.placeholder = 'Say something to everyone...';
                } else {
                    input.placeholder = `Say something to ${entity.name}...`;
                }
            }
            
            console.log('[Chat] Target:', entity ? entity.name : 'BROADCAST');
        }
        
        // Update chat target buttons based on current entities
        function updateChatTargets() {
            const container = document.getElementById('chatTargetSelector');
            if (!container) return;
            
            // Clear existing buttons (except broadcast)
            container.innerHTML = '<button class="chatTargetBtn broadcast' + (chatState.targetEntity === null ? ' active' : '') + '" onclick="selectChatTarget(null)" title="Speak to everyone">üì¢ ALL</button>';
            
            // Add boss/enemy buttons
            battleState.enemies.forEach((enemy, index) => {
                if (enemy.hp > 0) {
                    const btnClass = enemy.isMob ? 'hostile' : 'boss';
                    const isActive = chatState.targetEntity?.type === 'enemy' && chatState.targetEntity?.index === index;
                    const shortName = enemy.name.length > 10 ? enemy.name.substring(0, 9) + '‚Ä¶' : enemy.name;
                    const btn = document.createElement('button');
                    btn.className = `chatTargetBtn ${btnClass}${isActive ? ' active' : ''}`;
                    btn.dataset.entityType = 'enemy';
                    btn.dataset.entityIndex = index;
                    btn.onclick = () => selectChatTarget({ type: 'enemy', index, name: enemy.name, entity: enemy });
                    btn.title = enemy.name;
                    btn.textContent = `‚öîÔ∏è ${shortName}`;
                    container.appendChild(btn);
                }
            });
            
            // Add captive button if present
            if (battleState.captiveNpc && !battleState.captiveNpc.rescued) {
                const captive = battleState.captiveNpc;
                const isActive = chatState.targetEntity?.type === 'captive';
                const shortName = captive.name.length > 10 ? captive.name.substring(0, 9) + '‚Ä¶' : captive.name;
                const btn = document.createElement('button');
                btn.className = `chatTargetBtn friendly${isActive ? ' active' : ''}`;
                btn.dataset.entityType = 'captive';
                btn.dataset.entityIndex = '0';
                btn.onclick = () => selectChatTarget({ type: 'captive', index: 0, name: captive.name, entity: captive });
                btn.title = captive.name + ' (Captive)';
                btn.textContent = `‚õìÔ∏è ${shortName}`;
                container.appendChild(btn);
            }
        }
        
        // Select chat model (1-10)
        function selectChatModel(modelId) {
            // Don't allow selecting exhausted models
            if (chatState.exhaustedModels.includes(modelId)) {
                console.log(`[Chat] Model ${modelId} is exhausted (rate limited)`);
                return;
            }
            
            chatState.selectedModel = modelId;
            // Update button visuals - use onclick attribute to match model ID
            document.querySelectorAll('.modelBtn').forEach(btn => {
                // Extract model ID from onclick attribute: onclick="selectChatModel(X)"
                const onclickAttr = btn.getAttribute('onclick') || '';
                const match = onclickAttr.match(/selectChatModel\((\d+)\)/);
                const btnModelId = match ? parseInt(match[1]) : 0;
                btn.classList.toggle('active', btnModelId === modelId);
            });
            console.log(`[Chat] Selected model ${modelId}`);
        }
        
        // Mark a model as exhausted (rate limited)
        function markModelExhausted(modelId) {
            if (!chatState.exhaustedModels.includes(modelId)) {
                chatState.exhaustedModels.push(modelId);
                // Update button visual
                document.querySelectorAll('.modelBtn').forEach(btn => {
                    const onclickAttr = btn.getAttribute('onclick') || '';
                    const match = onclickAttr.match(/selectChatModel\((\d+)\)/);
                    const btnModelId = match ? parseInt(match[1]) : 0;
                    if (btnModelId === modelId) {
                        btn.classList.add('exhausted');
                        btn.title = btn.title + ' (RATE LIMITED)';
                    }
                });
                console.log(`[Chat] Model ${modelId} marked as exhausted`);
                
                // If current model is exhausted, switch to another free model
                if (chatState.selectedModel === modelId) {
                    const freeModels = [2, 4, 5];
                    const availableFree = freeModels.filter(m => !chatState.exhaustedModels.includes(m));
                    if (availableFree.length > 0) {
                        selectChatModel(availableFree[0]);
                    }
                }
            }
        }
        
        // Toggle chat window visibility
        function toggleChatWindow() {
            chatState.visible = !chatState.visible;
            const chatWindow = document.getElementById('battleChatWindow');
            if (chatWindow) {
                chatWindow.style.display = chatState.visible ? 'flex' : 'none';
                if (chatState.visible) {
                    document.getElementById('chatInput').focus();
                    updateChatTargets();  // Refresh entity buttons when opening
                }
            }
        }
        
        // Typewriter effect for NPC messages
        function typewriterEffect(messageId, fullText, charIndex = 0) {
            const container = document.getElementById('chatMessages');
            if (!container) return;
            
            // Find the message element by data-id
            const msgElement = container.querySelector(`[data-msg-id="${messageId}"] .chatText`);
            if (!msgElement) return;
            
            // Also update the stored message text for consistency
            const msg = chatState.messages.find(m => m.id === messageId);
            if (msg) {
                msg.displayText = fullText.substring(0, charIndex);
            }
            
            // Update displayed text with cursor
            const displayText = fullText.substring(0, charIndex);
            msgElement.innerHTML = formatChatText(displayText) + (charIndex < fullText.length ? '<span class="typingCursor">‚ñå</span>' : '');
            
            // Continue typing if not done
            if (charIndex < fullText.length) {
                // Variable speed: faster for spaces, slower for punctuation
                const char = fullText[charIndex];
                let delay = 25; // Base speed (ms per char)
                if (char === ' ') delay = 15;
                else if ('.!?'.includes(char)) delay = 150;
                else if (',;:'.includes(char)) delay = 80;
                
                setTimeout(() => typewriterEffect(messageId, fullText, charIndex + 1), delay);
            } else {
                // Done typing - remove cursor
                msgElement.innerHTML = formatChatText(fullText);
                if (msg) msg.displayText = fullText;
            }
        }
        
        // Add message to chat
        function addChatMessage(senderName, senderType, senderAvatar, text, isNpc = false, voiceType = null, personality = null) {
            const message = {
                id: Date.now(),
                senderName,
                senderType,  // 'hostile', 'questable', 'friendly', 'player', 'boss', 'mob', 'captive'
                senderAvatar,
                text,
                displayText: isNpc ? '' : text,  // For typewriter effect
                isNpc,
                voiceType,  // LLM-assigned voice type
                personality,  // For TTS emotional adjustment
                timestamp: new Date().toLocaleTimeString()
            };
            
            // Add to front (newest first)
            chatState.messages.unshift(message);
            
            // Keep last 50 messages
            if (chatState.messages.length > 50) {
                chatState.messages.pop();
            }
            
            renderChatMessages();
            
            // Start typewriter effect for NPC messages
            if (isNpc && text.length > 0) {
                setTimeout(() => typewriterEffect(message.id, text, 0), 100);
                
                // Play TTS for NPC responses (pass entity's voiceType and personality)
                playTTS(text, senderType, senderName, voiceType, personality);
            }
            
            // Broadcast to other players if host (send full text, clients show instantly)
            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                sendWebSocketMessage({
                    type: 'chat_message',
                    message: { ...message, displayText: text }  // Send full text to clients
                });
            }
        }
        
        // Format chat text - convert *text* to italics, escape HTML
        function formatChatText(text) {
            // First escape HTML to prevent XSS
            const escaped = text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;');
            // Convert *text* to italics (common roleplay notation)
            return escaped.replace(/\*([^*]+)\*/g, '<em>$1</em>');
        }
        
        // Render chat messages
        function renderChatMessages() {
            const container = document.getElementById('chatMessages');
            if (!container) return;
            
            container.innerHTML = chatState.messages.map(msg => `
                <div class="chatMessage" data-msg-id="${msg.id}">
                    <div class="chatAvatar" style="background-image: url('${msg.senderAvatar}');"></div>
                    <div class="chatContent">
                        <div class="chatName ${msg.senderType}">${msg.senderName}</div>
                        <div class="chatText">${formatChatText(msg.displayText !== undefined ? msg.displayText : msg.text)}</div>
                    </div>
                </div>
            `).join('');
        }
        
        // Send chat message from player
        async function sendChatMessage() {
            const input = document.getElementById('chatInput');
            const sendBtn = document.getElementById('chatSendBtn');
            const statusEl = document.getElementById('chatStatus');
            const message = input.value.trim();
            
            if (!message) return;
            
            // Get player name
            const playerName = multiplayerState.enabled ? 
                (multiplayerState.playerName || 'Player') : 'Player';
            
            // Get current hero avatar (use first alive hero)
            const currentHero = battleState.heroes.find(h => h.hp > 0);
            const heroAvatar = currentHero ? 
                `people/${currentHero.name.toLowerCase()}_a_head_compressed.png` : 
                'people/zooko_a_head_compressed.png';
            
            // Add player message to chat
            addChatMessage(playerName, 'player', heroAvatar, message, false);
            
            // Clear input
            input.value = '';
            
            // In multiplayer, only host calls LLM
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                // Send to host for LLM processing
                if (statusEl) statusEl.textContent = 'Sending to host...';
                sendWebSocketMessage({
                    type: 'chat_request',
                    playerName: playerName,
                    message: message
                });
                setTimeout(() => { if (statusEl) statusEl.textContent = ''; }, 2000);
                return;
            }
            
            // Get NPC to respond based on selected target
            let respondingNpc = null;
            
            // If a specific target is selected, use that
            if (chatState.targetEntity) {
                if (chatState.targetEntity.type === 'captive') {
                    respondingNpc = battleState.captiveNpc;
                } else if (chatState.targetEntity.type === 'enemy') {
                    respondingNpc = battleState.enemies[chatState.targetEntity.index];
                }
                
                // Validate the target is still valid
                if (respondingNpc && (respondingNpc.hp <= 0 || respondingNpc.rescued)) {
                    respondingNpc = null;
                    selectChatTarget(null);  // Reset to broadcast
                }
            }
            
            // If broadcast mode or no valid target, pick first available NPC
            if (!respondingNpc) {
                // Check captive first (friendly NPC who can chat)
                if (battleState.captiveNpc && !battleState.captiveNpc.rescued && battleState.captiveNpc.canChat) {
                    respondingNpc = battleState.captiveNpc;
                }
                
                // If no captive, try enemies
                if (!respondingNpc) {
                    respondingNpc = battleState.enemies.find(e => e.hp > 0 && e.backstory);
                }
            }
            
            if (!respondingNpc) {
                // No NPC can respond
                if (statusEl) statusEl.textContent = 'No one can talk';
                addChatMessage('System', 'friendly', 'people/zooko_a_head_compressed.png', 
                    '*No one responds...*', true);
                setTimeout(() => { if (statusEl) statusEl.textContent = ''; }, 2000);
                return;
            }
            
            // Determine NPC type for the API
            const npcType = respondingNpc.isCaptive ? 'captive' : (respondingNpc.isBoss ? 'boss' : 'mob');
            
            // Disable send while waiting
            sendBtn.disabled = true;
            sendBtn.textContent = '...';
            
            // Start response timer
            const startTime = performance.now();
            let timerInterval = setInterval(() => {
                const elapsed = ((performance.now() - startTime) / 1000).toFixed(1);
                if (statusEl) statusEl.textContent = `Model ${chatState.selectedModel} - ${elapsed}s...`;
            }, 100);
            
            try {
                // Call server LLM API
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        npcName: respondingNpc.name,
                        backstory: respondingNpc.backstory || 'A mysterious creature.',
                        npcType: npcType,
                        conversation: chatState.messages.slice(0, 10).reverse(),
                        message: message,
                        playerName: playerName,
                        modelId: chatState.selectedModel,
                        rpMode: settings.rpMode !== false  // Default true for RP style
                    })
                });
                
                // Stop timer
                clearInterval(timerInterval);
                const totalTime = ((performance.now() - startTime) / 1000).toFixed(2);
                
                const result = await response.json();
                
                if (result.success) {
                    if (statusEl) statusEl.textContent = `Model ${chatState.selectedModel}: ${totalTime}s`;
                    // Clear status after 5 seconds
                    setTimeout(() => { if (statusEl && statusEl.textContent.includes(totalTime)) statusEl.textContent = ''; }, 5000);
                    
                    // Update cost tracking
                    if (result.usage) {
                        chatState.totalCost += result.usage.cost || 0;
                        chatState.totalTokens += (result.usage.promptTokens || 0) + (result.usage.completionTokens || 0);
                        const costDisplay = document.getElementById('chatCostDisplay');
                        if (costDisplay) {
                            costDisplay.textContent = `$${chatState.totalCost.toFixed(6)} | ${chatState.totalTokens} tok`;
                        }
                    }
                    
                    // Determine NPC type for color (captive = friendly, hostile enemy = hostile, etc)
                    const chatNpcType = respondingNpc.isCaptive ? 'friendly' :
                        (respondingNpc.hostile ? 'hostile' : 
                        (respondingNpc.questable ? 'questable' : 'friendly'));
                    
                    // Add NPC response (include LLM-assigned voiceType and personality)
                    addChatMessage(
                        respondingNpc.name,
                        chatNpcType,
                        respondingNpc.spritePath || 'people/zooko_a_head_compressed.png',
                        result.response,
                        true,
                        respondingNpc.voiceType,  // Pass entity's voice type
                        respondingNpc.personality  // Pass entity's personality for TTS
                    );
                    
                    // Process negotiation outcomes (betrayal, retreat, rage)
                    processNegotiation(respondingNpc, message, result.response);
                } else {
                    // Check for rate limit error
                    const errorMsg = result.error || 'Unknown';
                    const isRateLimit = errorMsg.toLowerCase().includes('rate') || 
                                       errorMsg.toLowerCase().includes('limit') ||
                                       errorMsg.toLowerCase().includes('quota') ||
                                       errorMsg.toLowerCase().includes('429') ||
                                       errorMsg.toLowerCase().includes('exceeded');
                    
                    if (isRateLimit) {
                        // Mark current model as exhausted
                        markModelExhausted(chatState.selectedModel);
                        if (statusEl) statusEl.textContent = `Model ${chatState.selectedModel} rate limited!`;
                        addChatMessage('System', 'friendly', 'people/zooko_a_head_compressed.png', 
                            `*Model ${chatState.selectedModel} is rate limited. Try another model.*`, true);
                    } else {
                        if (statusEl) statusEl.textContent = `Error (${totalTime}s): ` + errorMsg;
                    }
                    console.error('Chat API error:', result.error);
                }
            } catch (error) {
                clearInterval(timerInterval);
                if (statusEl) statusEl.textContent = 'Connection error';
                console.error('Chat fetch error:', error);
            }
            
            sendBtn.disabled = false;
            sendBtn.textContent = 'Send';
        }
        
        // Clear chat when battle ends
        function clearBattleChat() {
            chatState.messages = [];
            chatState.visible = false;
            chatState.targetNpc = null;
            const chatWindow = document.getElementById('battleChatWindow');
            if (chatWindow) chatWindow.style.display = 'none';
            renderChatMessages();
        }
        
        // ============================================
        // NEGOTIATION SYSTEM - Mob Betrayal & Boss Retreat
        // ============================================
        
        // Initialize negotiation state for an enemy
        function initNegotiationState(enemy) {
            if (!enemy.negotiationState) {
                enemy.negotiationState = {
                    // Mob betrayal tracking
                    goldOffered: 0,           // Total gold offered so far
                    betrayalThreshold: enemy.isBoss ? 999999 : (50 + Math.floor(Math.random() * 150)),  // 50-200 gold for mobs
                    lowOfferCount: 0,         // Number of insultingly low offers
                    rageStacks: 0,            // Rage buildup (each stack = +10% HP)
                    
                    // Boss morale tracking
                    morale: 100,              // Boss morale (0-100)
                    insultCount: 0,           // Times insulted/threatened
                    failedAttacks: 0,         // Consecutive missed attacks
                    
                    // State flags
                    betrayed: false,          // Mob switched sides
                    retreated: false,         // Boss fled
                    enraged: false            // Currently enraged (double attack)
                };
            }
            return enemy.negotiationState;
        }
        
        // Process negotiation after each chat exchange
        function processNegotiation(npc, playerMessage, npcResponse) {
            if (!npc || npc.hp <= 0) return;
            
            const state = initNegotiationState(npc);
            const msgLower = playerMessage.toLowerCase();
            const responseLower = npcResponse.toLowerCase();
            
            // === MOB BETRAYAL LOGIC ===
            if (!npc.isBoss && npc.hostile) {
                // Check for gold offers in player message
                const goldMatch = msgLower.match(/(\d+)\s*(gold|coins?|gp|money)/i);
                if (goldMatch) {
                    const offeredGold = parseInt(goldMatch[1]);
                    
                    // Check if player actually HAS this gold
                    const sharedSave = loadSharedSave();
                    const currentGold = sharedSave?.dungeonState?.gold || 0;
                    
                    if (offeredGold > currentGold) {
                        // Player tried to offer gold they don't have - instant rage!
                        addChatMessage('System', 'system', null, `‚ùå You only have ${currentGold} gold! ${npc.name} sees through your empty promise!`, false);
                        triggerRage(npc, 'Your LIES have enraged');
                        return;
                    }
                    
                    state.goldOffered += offeredGold;
                    state.lastOfferAmount = offeredGold;  // Track last offer for deduction on success
                    
                    // Check if offer is insulting (less than 10% of threshold)
                    if (offeredGold < state.betrayalThreshold * 0.1) {
                        state.lowOfferCount++;
                        
                        // After 3 low offers, mob gets enraged
                        if (state.lowOfferCount >= 3 && !state.enraged) {
                            triggerRage(npc, 'Your pathetic offers have enraged');
                        }
                    }
                    
                    // Check for betrayal - roll with modifier based on offer
                    const offerRatio = state.goldOffered / state.betrayalThreshold;
                    if (offerRatio >= 0.5) {  // At least 50% of threshold to have a chance
                        const betrayalRoll = rollD20();
                        const dc = Math.max(5, 20 - Math.floor(offerRatio * 15));  // DC 5-20 based on offer
                        
                        console.log(`[Negotiation] ${npc.name} betrayal check: d20(${betrayalRoll}) vs DC ${dc}, offer ratio: ${(offerRatio * 100).toFixed(0)}%`);
                        
                        if (betrayalRoll >= dc || state.goldOffered >= state.betrayalThreshold) {
                            triggerBetrayal(npc, state.goldOffered);
                            return;
                        } else if (betrayalRoll <= 3) {
                            // Critical fail - mob gets angry
                            triggerRage(npc, 'Your bribe attempt has angered');
                        }
                    }
                    
                    // Show offer progress
                    const progress = Math.min(100, (state.goldOffered / state.betrayalThreshold) * 100);
                    showDiceRoll(`üí∞ ${npc.name} considers your offer... (${progress.toFixed(0)}% convinced)`);
                }
                
                // Check for threats/insults making mob angry
                if (msgLower.match(/threat|kill|destroy|die|weak|pathetic|coward/i)) {
                    state.lowOfferCount++;
                    if (state.lowOfferCount >= 2 && !state.enraged) {
                        triggerRage(npc, 'Your threats have enraged');
                    }
                }
            }
            
            // === BOSS RETREAT/RAGE LOGIC ===
            if (npc.isBoss) {
                // Check for insults/threats
                if (msgLower.match(/weak|pathetic|coward|afraid|scared|flee|run away|give up/i)) {
                    state.insultCount++;
                    state.morale -= 10;
                    console.log(`[Negotiation] ${npc.name} morale: ${state.morale} (insulted)`);
                }
                
                // Check for intimidation in NPC response (they're worried)
                if (responseLower.match(/perhaps|maybe.*wrong|reconsider|mercy|spare|retreat|flee/i)) {
                    state.morale -= 5;
                }
                
                // Check morale + HP for retreat/rage
                const hpPercent = (npc.hp / npc.maxHp) * 100;
                if (hpPercent < 30 && state.morale < 50) {
                    // Boss is low HP and demoralized - roll for retreat or rage
                    const retreatRoll = rollD20();
                    console.log(`[Negotiation] ${npc.name} retreat check: d20(${retreatRoll}), HP: ${hpPercent.toFixed(0)}%, Morale: ${state.morale}`);
                    
                    if (retreatRoll <= 8) {
                        // Boss retreats!
                        triggerBossRetreat(npc);
                    } else if (retreatRoll >= 17 && !state.enraged) {
                        // Boss gets enraged instead!
                        triggerRage(npc, 'Cornered and desperate,');
                        state.enraged = true;
                    }
                }
            }
        }
        
        // Trigger mob betrayal - switch sides!
        function triggerBetrayal(mob, goldPaid) {
            const state = mob.negotiationState;
            state.betrayed = true;
            mob.hostile = false;
            
            // Deduct gold from player
            if (goldPaid > 0) {
                const sharedSave = JSON.parse(localStorage.getItem('top_shared_save') || '{}');
                if (!sharedSave.dungeonState) sharedSave.dungeonState = {};
                sharedSave.dungeonState.gold = Math.max(0, (sharedSave.dungeonState.gold || 0) - goldPaid);
                localStorage.setItem('top_shared_save', JSON.stringify(sharedSave));
                
                addChatMessage('System', 'system', null, `üí∏ Paid ${goldPaid} gold to ${mob.name}!`, false);
                updateGoldDisplay();
            }
            
            // Visual/audio feedback
            showDiceRoll(`‚öîÔ∏è‚û°Ô∏èü§ù ${mob.name} BETRAYS THE BOSS!`);
            showBattleNotification(`${mob.name} switches sides!`);
            
            // Add chat message
            addChatMessage(mob.name, 'friendly', mob.spritePath, 
                `*${mob.name} turns against their former master!* "You've convinced me. Let's take down that tyrant together!"`, 
                true, mob.voiceType);
            
            // Change color to friendly
            mob.color = '#00FF00';
            
            renderBattle();
            updateBattleEnemyCards();
            
            console.log(`[Negotiation] ${mob.name} has betrayed the boss!`);
        }
        
        // Trigger boss retreat - they flee!
        function triggerBossRetreat(boss) {
            const state = boss.negotiationState;
            state.retreated = true;
            
            // Visual/audio feedback
            showDiceRoll(`üèÉ ${boss.name} RETREATS!`);
            showBattleNotification(`${boss.name} flees in terror!`);
            
            // Add chat message
            addChatMessage(boss.name, 'hostile', boss.spritePath,
                `*${boss.name} staggers back, fear in their eyes* "This isn't over! I'll return stronger!" *vanishes into the shadows*`,
                true, boss.voiceType);
            
            // Remove boss from battle (set HP to 0 but mark as retreated)
            boss.hp = 0;
            boss.retreated = true;
            
            // Award partial XP for retreat
            const partialXP = Math.floor((boss.stats?.experience || 100) * 0.5);
            battleState.heroes.forEach(h => {
                if (h.hp > 0) h.xp = (h.xp || 0) + Math.floor(partialXP / battleState.heroes.filter(x => x.hp > 0).length);
            });
            showDiceRoll(`üìú Gained ${partialXP} XP from boss retreat!`);
            
            renderBattle();
            updateBattleEnemyCards();
            checkBattleEnd();
            
            console.log(`[Negotiation] ${boss.name} has retreated!`);
        }
        
        // Trigger rage - enemy gets stronger!
        function triggerRage(enemy, reason) {
            const state = enemy.negotiationState;
            state.rageStacks++;
            state.enraged = true;
            
            // Boost HP by 10% per rage stack
            const hpBoost = Math.floor(enemy.maxHp * 0.1);
            enemy.hp = Math.min(enemy.maxHp, enemy.hp + hpBoost);
            enemy.maxHp += hpBoost;
            
            // Boost damage slightly
            enemy.attackDamage = Math.floor(enemy.attackDamage * 1.1);
            
            // Visual/audio feedback
            const emoji = enemy.isBoss ? 'üëø' : 'üò§';
            showDiceRoll(`${emoji} ${reason} ${enemy.name}! (+${hpBoost} HP, +10% damage)`);
            showBattleNotification(`${enemy.name} enters a RAGE!`);
            
            // Add chat message
            addChatMessage(enemy.name, 'hostile', enemy.spritePath,
                `*${enemy.name}'s eyes glow with fury* "ENOUGH! You will PAY for this!"`,
                true, enemy.voiceType);
            
            // Change color to indicate rage
            enemy.color = '#FF0000';
            
            renderBattle();
            updateBattleEnemyCards();
            
            console.log(`[Negotiation] ${enemy.name} has entered a rage! (stack ${state.rageStacks})`);
        }
        
        // Update boss morale when they take damage or miss attacks
        function updateBossMorale(boss, event) {
            if (!boss || !boss.isBoss) return;
            
            const state = initNegotiationState(boss);
            
            switch (event) {
                case 'took_damage':
                    state.morale -= 5;
                    break;
                case 'missed_attack':
                    state.failedAttacks++;
                    state.morale -= 3 * state.failedAttacks;  // Gets worse with consecutive misses
                    break;
                case 'hit_attack':
                    state.failedAttacks = 0;  // Reset on successful hit
                    state.morale = Math.min(100, state.morale + 5);  // Slight morale boost
                    break;
                case 'ally_died':
                    state.morale -= 15;
                    break;
            }
            
            state.morale = Math.max(0, Math.min(100, state.morale));
            
            // Check for retreat/rage at critical morale
            const hpPercent = (boss.hp / boss.maxHp) * 100;
            if (state.morale < 30 && hpPercent < 40 && !state.retreated && !state.enraged) {
                const crisisRoll = rollD20();
                console.log(`[Negotiation] ${boss.name} crisis check: d20(${crisisRoll}), HP: ${hpPercent.toFixed(0)}%, Morale: ${state.morale}`);
                
                if (crisisRoll <= 10) {
                    triggerBossRetreat(boss);
                } else if (crisisRoll >= 16) {
                    triggerRage(boss, 'Pushed to the brink,');
                }
            }
        }
        
        // Check for enraged double attack
        function shouldDoDoubleAttack(enemy) {
            if (!enemy.negotiationState?.enraged) return false;
            
            // 30% chance for double attack when enraged
            const doubleRoll = rollD20();
            if (doubleRoll >= 15) {
                showDiceRoll(`‚ö° ${enemy.name}'s rage fuels a DOUBLE ATTACK!`);
                return true;
            }
            return false;
        }

        // Generate unique encounter data via Dungeon Master LLM
        async function generateEncounter(type, baseData, roomLevel, retryCount = 0) {
            const maxRetries = 2;
            try {
                const response = await fetch('/api/generate-encounter', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        type: type,
                        baseData: baseData,
                        roomLevel: roomLevel,
                        useFreeModel: !settings.llmUsePaid
                    })
                });
                
                const result = await response.json();
                if (result.success && result.data) {
                    console.log(`[DM] Generated ${type}:`, result.data);
                    return result.data;
                } else {
                    console.warn(`[DM] Failed to generate ${type}:`, result.error || result.raw);
                    // Retry on JSON parse failure
                    if (retryCount < maxRetries && result.error && result.error.includes('JSON')) {
                        console.log(`[DM] Retrying ${type} generation (attempt ${retryCount + 2}/${maxRetries + 1})...`);
                        return generateEncounter(type, baseData, roomLevel, retryCount + 1);
                    }
                    return null;
                }
            } catch (error) {
                console.error('[DM] Encounter generation error:', error);
                return null;
            }
        }
        
        // Apply generated data to boss/mob
        function applyGeneratedData(enemy, generated) {
            if (!generated) return;
            
            // Apply name
            if (generated.name) {
                enemy.name = generated.name;
            }
            
            // Apply backstory
            if (generated.backstory) {
                enemy.backstory = generated.backstory;
            }
            
            // Apply personality
            if (generated.personality) {
                enemy.personality = generated.personality;
            }
            
            // Apply voice type (LLM-chosen based on gender/nature)
            if (generated.voiceType) {
                enemy.voiceType = generated.voiceType;
            }
            
            // Apply gender
            if (generated.gender) {
                enemy.gender = generated.gender;
            }
            
            // Apply stat modifiers
            if (generated.statModifiers) {
                if (generated.statModifiers.hpMod) {
                    enemy.hp = Math.max(1, enemy.hp + generated.statModifiers.hpMod);
                    enemy.maxHp = Math.max(1, enemy.maxHp + generated.statModifiers.hpMod);
                }
                if (generated.statModifiers.damageMod) {
                    enemy.attackDamage = Math.max(1, enemy.attackDamage + generated.statModifiers.damageMod);
                }
                if (generated.statModifiers.acMod) {
                    enemy.ac = Math.max(1, enemy.ac + generated.statModifiers.acMod);
                }
            }
            
            // Apply negotiation options
            if (generated.negotiation) {
                enemy.negotiation = generated.negotiation;
            }
            
            // Apply gold drop amount (LLM-determined based on backstory)
            if (generated.goldDrop !== undefined) {
                enemy.goldDrop = generated.goldDrop;
            } else {
                // Default gold based on enemy type
                enemy.goldDrop = enemy.isBoss ? (50 + Math.floor(Math.random() * 100)) : (5 + Math.floor(Math.random() * 20));
            }
            
            // Apply opening line
            if (generated.openingLine) {
                enemy.openingLine = generated.openingLine;
            }
        }
        
        // Trigger NPC free will chat (autonomous chat)
        function triggerFreeWillChat(npc, trigger) {
            if (!settings.llmFreeWill) return;
            if (!npc || !npc.backstory) return;
            
            // Don't spam - check cooldown
            if (npc.lastFreeWillChat && Date.now() - npc.lastFreeWillChat < 10000) return;
            npc.lastFreeWillChat = Date.now();
            
            // Build a context-specific prompt
            let contextPrompt = '';
            switch (trigger) {
                case 'battle_start':
                    if (npc.openingLine) {
                        addChatMessage(npc.name, npc.hostile ? 'hostile' : 'friendly', 
                            npc.spritePath || 'people/zooko_a_head_compressed.png', npc.openingLine, true, npc.voiceType, npc.personality);
                        return;
                    }
                    contextPrompt = 'The battle just started. Say something to intimidate or greet the heroes.';
                    break;
                case 'took_damage':
                    contextPrompt = 'You just took damage! React with pain, anger, or determination.';
                    break;
                case 'dealt_damage':
                    contextPrompt = 'You just hit a hero! Gloat, taunt, or comment on your attack.';
                    break;
                case 'low_health':
                    contextPrompt = 'You are badly wounded. Express fear, defiance, or consider surrendering.';
                    break;
                case 'ally_died':
                    contextPrompt = 'One of your allies just died. React with grief, rage, or indifference.';
                    break;
                default:
                    return; // Unknown trigger, skip
            }
            
            // Make async LLM call for free will response
            (async () => {
                try {
                    const response = await fetch('/api/chat', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            npcName: npc.name,
                            backstory: npc.backstory,
                            npcType: npc.isBoss ? 'boss' : 'mob',
                            conversation: chatState.messages.slice(0, 5).reverse(),
                            message: contextPrompt,
                            playerName: 'System',
                            modelId: settings.llmUsePaid ? 3 : 2,  // Use Groq models for speed
                            rpMode: settings.rpMode !== false
                        })
                    });
                    
                    const result = await response.json();
                    if (result.success && result.response) {
                        const npcType = npc.hostile ? 'hostile' : (npc.questable ? 'questable' : 'friendly');
                        addChatMessage(npc.name, npcType, npc.spritePath || 'people/zooko_a_head_compressed.png', 
                            result.response, true, npc.voiceType, npc.personality);
                    }
                } catch (error) {
                    console.error('[Free Will] Chat error:', error);
                }
            })();
        }
        
        // Start a battle encounter
        async function startBattle() {
            // Multiplayer clients cannot start battles - only host
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                showNotification('Only host can start battles', 'error');
                return;
            }
            
            // Switch to battle screen
            currentScreen = 'battle';
            document.getElementById('dungeonMenuScreen').style.display = 'none';
            document.getElementById('battleScreen').style.display = 'block';
            
            // If multiplayer host, notify clients
            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                sendWebSocketMessage({ type: 'game_start', screen: 'battle' });
            }
            
            // Move music controls and ticker to bottom left during battle
            document.getElementById('musicControls').classList.add('battleActive');
            document.getElementById('musicTicker').classList.add('battleActive');
            
            // Update gold display for battle screen
            updateGoldDisplay();
            
            // Start dice roll ticker
            startDiceRollTicker();
            
            // Initialize canvas
            battleState.canvas = document.getElementById('battleCanvas');
            battleState.ctx = battleState.canvas.getContext('2d');
            
            // Set canvas size
            battleState.canvas.width = window.innerWidth;
            battleState.canvas.height = window.innerHeight - 180;
            
            // Multiplayer client: Wait for battle_init from host
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                showDiceRoll('Waiting for host to start battle...');
                return; // Don't generate battle - wait for host's battle_init message
            }
            
            // Check if we have pre-generated encounter ready
            const usePreGenerated = preGeneratedEncounter.ready;
            
            // Load enemy data (only if not pre-generated)
            let bossesData = [];
            let mobsData = [];
            if (!usePreGenerated) {
                try {
                    const bossResponse = await fetch('tunnelsofprivacy/bosses/bosses_data.json');
                    bossesData = await bossResponse.json();
                    const mobResponse = await fetch('tunnelsofprivacy/mobs/mobs_data.json');
                    const mobObj = await mobResponse.json();
                    mobsData = mobObj.mobs || [];
                } catch(e) {
                    console.error('Failed to load enemy data:', e);
                }
            }
            
            // Load shared save to get hero stats
            const sharedSave = loadSharedSave();
            
            // Setup heroes with sprites
            battleState.heroes = [
                { 
                    name: 'Zooko', 
                    hp: sharedSave?.heroes?.zooko?.hp ?? 30, 
                    maxHp: sharedSave?.heroes?.zooko?.maxHp ?? 30,
                    xp: sharedSave?.heroes?.zooko?.xp ?? 0,
                    healsRemaining: 2,
                    stats: sharedSave?.heroes?.zooko || {},
                    color: '#F2C94C',
                    x: 0, y: 0, platform: null, facing: 'center',
                    sprite: new Image(),
                    spritePath: 'tunnelsofprivacy/heros/zooko.png'
                },
                { 
                    name: 'Nate', 
                    hp: sharedSave?.heroes?.nate?.hp ?? 28, 
                    maxHp: sharedSave?.heroes?.nate?.maxHp ?? 30,
                    xp: sharedSave?.heroes?.nate?.xp ?? 0,
                    healsRemaining: 2,
                    stats: sharedSave?.heroes?.nate || {},
                    color: '#E74C3C',
                    x: 0, y: 0, platform: null, facing: 'center',
                    sprite: new Image(),
                    spritePath: 'tunnelsofprivacy/heros/nate.png'
                },
                { 
                    name: 'Zancas', 
                    hp: sharedSave?.heroes?.zancas?.hp ?? 24, 
                    maxHp: sharedSave?.heroes?.zancas?.maxHp ?? 26,
                    xp: sharedSave?.heroes?.zancas?.xp ?? 0,
                    healsRemaining: 2,
                    stats: sharedSave?.heroes?.zancas || {},
                    color: '#27AE60',
                    x: 0, y: 0, platform: null, facing: 'center',
                    sprite: new Image(),
                    spritePath: 'tunnelsofprivacy/heros/zancas.png'
                },
                { 
                    name: 'CyberAxe', 
                    hp: sharedSave?.heroes?.cyberaxe?.hp ?? 32, 
                    maxHp: sharedSave?.heroes?.cyberaxe?.maxHp ?? 35,
                    xp: sharedSave?.heroes?.cyberaxe?.xp ?? 0,
                    healsRemaining: 2,
                    stats: sharedSave?.heroes?.cyberaxe || {},
                    color: '#2E86DE',
                    x: 0, y: 0, platform: null, facing: 'center',
                    sprite: new Image(),
                    spritePath: 'tunnelsofprivacy/heros/cyberaxe.png'
                }
            ];
            
            // Initialize animation controllers for heroes
            battleState.heroes.forEach(hero => {
                const heroKey = hero.name.toLowerCase();
                let idlePath = HERO_ANIM_PATHS[heroKey]?.idle;
                // Handle array of idle variants - pick random one
                if (Array.isArray(idlePath)) {
                    idlePath = idlePath[Math.floor(Math.random() * idlePath.length)];
                }
                if (idlePath) {
                    initAnimation(hero, idlePath, 'pingpong');
                }
            });
            
            // Load hero sprites with cache busting (fallback for when animation not loaded)
            battleState.heroes.forEach(hero => {
                hero.sprite.onload = () => {
                    renderBattle(); // Re-render when each sprite loads
                };
                // Add timestamp to prevent caching
                hero.sprite.src = hero.spritePath + '?v=' + Date.now();
            });
            
            // Setup enemies from loaded data (level 2 for testing)
            battleState.enemies = [];
            battleState.captiveNpc = null;  // Captive NPC to rescue
            const roomLevel = usePreGenerated ? preGeneratedEncounter.roomLevel : 2;
            
            // Show loading indicator for LLM generation (only if not pre-generated)
            if (!usePreGenerated) {
                showDiceRoll('Dungeon Master is preparing the encounter...');
            }
            
            if (usePreGenerated && preGeneratedEncounter.boss) {
                // Use pre-generated boss
                const boss = preGeneratedEncounter.boss.baseData;
                const bossEnemy = {
                    name: boss.name,
                    species: boss.name,
                    hp: boss.stats.hp || 50,
                    maxHp: boss.stats.maxHp || 50,
                    ac: boss.stats.ac,
                    attackDamage: boss.stats.attackDamage,
                    speed: boss.stats.speed,
                    dex: boss.stats.initiative || 0,
                    hostile: boss.behavior?.hostile !== false,
                    backstory: boss.backstory || null,
                    isBoss: true,
                    color: '#8B45FF',
                    x: 0, y: 0, platform: null, facing: 'center',
                    sprite: new Image(),
                    spritePath: boss.spritePath,
                    isMob: false
                };
                applyGeneratedData(bossEnemy, preGeneratedEncounter.boss.generated);
                if (settings.diagMode) {
                    bossEnemy.hp = 5;
                    bossEnemy.maxHp = 5;
                }
                battleState.enemies.push(bossEnemy);
                console.log('[Battle] Using pre-generated boss:', bossEnemy.name);
            } else {
                // Generate boss on-the-fly (fallback)
                const boss = bossesData.find(b => b.mainLevel === roomLevel);
                if (boss) {
                    const bossEnemy = {
                        name: boss.name,
                        species: boss.name,
                        hp: boss.stats.hp || 50,
                        maxHp: boss.stats.maxHp || 50,
                        ac: boss.stats.ac,
                        attackDamage: boss.stats.attackDamage,
                        speed: boss.stats.speed,
                        dex: boss.stats.initiative || 0,
                        hostile: boss.behavior?.hostile !== false,
                        backstory: boss.backstory || null,
                        isBoss: true,
                        color: '#8B45FF',
                        x: 0, y: 0, platform: null, facing: 'center',
                        sprite: new Image(),
                        spritePath: boss.spritePath,
                        isMob: false
                    };
                    const generatedBoss = await generateEncounter('boss', boss, roomLevel);
                    applyGeneratedData(bossEnemy, generatedBoss);
                    if (settings.diagMode) {
                        bossEnemy.hp = 5;
                        bossEnemy.maxHp = 5;
                    }
                    battleState.enemies.push(bossEnemy);
                }
            }
            
            if (usePreGenerated && preGeneratedEncounter.mobs.length > 0) {
                // Use pre-generated mobs
                for (const mobData of preGeneratedEncounter.mobs) {
                    const mob = mobData.baseData;
                    const mobEnemy = {
                        name: mob.name,
                        species: mob.name,
                        hp: mob.stats.hp || 15,
                        maxHp: mob.stats.maxHp || 15,
                        ac: mob.stats.ac,
                        attackDamage: mob.stats.attackDamage,
                        speed: mob.stats.speed,
                        dex: 0,
                        hostile: mob.behavior?.hostile !== false,
                        backstory: mob.backstory || null,
                        isBoss: false,
                        color: '#5C3317',
                        x: 0, y: 0, platform: null, facing: 'center',
                        sprite: new Image(),
                        spritePath: mob.spritePath,
                        isMob: true
                    };
                    applyGeneratedData(mobEnemy, mobData.generated);
                    if (settings.diagMode) {
                        mobEnemy.hp = 5;
                        mobEnemy.maxHp = 5;
                    }
                    battleState.enemies.push(mobEnemy);
                    console.log('[Battle] Using pre-generated mob:', mobEnemy.name);
                }
            } else if (!usePreGenerated) {
                // Generate mobs on-the-fly (fallback)
                const hostileMobs = mobsData.filter(m => m.behavior?.hostile);
                for (let i = 0; i < 2 && i < hostileMobs.length; i++) {
                    const mob = hostileMobs[Math.floor(Math.random() * hostileMobs.length)];
                    const mobEnemy = {
                        name: mob.name,
                        species: mob.name,
                        hp: mob.stats.hp || 15,
                        maxHp: mob.stats.maxHp || 15,
                        ac: mob.stats.ac,
                        attackDamage: mob.stats.attackDamage,
                        speed: mob.stats.speed,
                        dex: 0,
                        hostile: mob.behavior?.hostile !== false,
                        backstory: mob.backstory || null,
                        isBoss: false,
                        color: '#5C3317',
                        x: 0, y: 0, platform: null, facing: 'center',
                        sprite: new Image(),
                        spritePath: mob.spritePath,
                        isMob: true
                    };
                    const generatedMob = await generateEncounter('mob', mob, roomLevel);
                    applyGeneratedData(mobEnemy, generatedMob);
                    if (settings.diagMode) {
                        mobEnemy.hp = 5;
                        mobEnemy.maxHp = 5;
                    }
                    battleState.enemies.push(mobEnemy);
                }
            }
            
            // Setup captive NPC
            if (usePreGenerated && preGeneratedEncounter.captive) {
                // Use pre-generated captive
                const captiveData = preGeneratedEncounter.captive.generated;
                const captiveSpritePath = `tunnelsofprivacy/npcs/captives/prisoners (${preGeneratedEncounter.captive.spriteNum}).png`;
                
                battleState.captiveNpc = {
                    name: captiveData?.name || 'Mysterious Prisoner',
                    species: captiveData?.species || 'human',
                    gender: captiveData?.gender || 'unknown',
                    voiceType: captiveData?.voiceType || null,
                    backstory: captiveData?.backstory || 'A prisoner needing rescue.',
                    personality: captiveData?.personality || 'grateful',
                    rescueReward: captiveData?.rescueReward || { gold: 20 },
                    goldReward: captiveData?.rescueReward?.gold || captiveData?.goldReward || 20,
                    dialogueOnRescue: captiveData?.dialogueOnRescue || 'Thank you for saving me!',
                    rescued: false,
                    x: 0,
                    y: 0,
                    sprite: new Image(),
                    spritePath: captiveSpritePath,
                    color: '#F2C94C',
                    isCaptive: true,
                    isMob: false,
                    canChat: true,
                    hostile: false,
                    hp: 1,
                    maxHp: 1
                };
                
                battleState.captiveNpc.sprite.onerror = () => {
                    console.log('[DM] Captive sprite not found, using fallback circle:', captiveSpritePath);
                };
                battleState.captiveNpc.sprite.onload = () => {
                    renderBattle();
                };
                battleState.captiveNpc.sprite.src = battleState.captiveNpc.spritePath + '?v=' + Date.now();
                console.log('[Battle] Using pre-generated captive:', battleState.captiveNpc.name);
            } else if (!usePreGenerated && Math.random() > 0.5) {
                // Generate captive on-the-fly (fallback)
                const captiveData = await generateEncounter('captive', {}, roomLevel);
                const captiveSpriteNum = Math.floor(Math.random() * 12) + 1;
                const captiveSpritePath = `tunnelsofprivacy/npcs/captives/prisoners (${captiveSpriteNum}).png`;
                
                battleState.captiveNpc = {
                    name: captiveData?.name || 'Mysterious Prisoner',
                    species: captiveData?.species || 'human',
                    gender: captiveData?.gender || 'unknown',
                    voiceType: captiveData?.voiceType || null,
                    backstory: captiveData?.backstory || 'A prisoner needing rescue.',
                    personality: captiveData?.personality || 'grateful',
                    rescueReward: captiveData?.rescueReward || { gold: 20 },
                    goldReward: captiveData?.rescueReward?.gold || captiveData?.goldReward || 20,
                    dialogueOnRescue: captiveData?.dialogueOnRescue || 'Thank you for saving me!',
                    rescued: false,
                    x: 0,
                    y: 0,
                    sprite: new Image(),
                    spritePath: captiveSpritePath,
                    color: '#F2C94C',
                    isCaptive: true,
                    isMob: false,
                    canChat: true,
                    hostile: false,
                    hp: 1,
                    maxHp: 1
                };
                
                battleState.captiveNpc.sprite.onerror = () => {
                    console.log('[DM] Captive sprite not found, using fallback circle:', captiveSpritePath);
                };
                battleState.captiveNpc.sprite.onload = () => {
                    renderBattle();
                };
                battleState.captiveNpc.sprite.src = battleState.captiveNpc.spritePath + '?v=' + Date.now();
                console.log('[DM] Captive NPC generated:', battleState.captiveNpc.name, 'sprite:', captiveSpritePath);
            }
            
            // Load enemy sprites
            battleState.enemies.forEach(enemy => {
                enemy.sprite.onload = () => {
                    renderBattle();
                };
                enemy.sprite.src = enemy.spritePath + '?v=' + Date.now();
            });
            
            // Load background (use pre-generated or pick random)
            let selectedBg;
            if (usePreGenerated && preGeneratedEncounter.background) {
                selectedBg = preGeneratedEncounter.background;
            } else {
                const backgroundOptions = [
                    'backgrounds_lvl1 (8).png',
                    'backgrounds_lvl1 (10).png',
                    'backgrounds_lvl1 (12).png',
                    'backgrounds_lvl1 (14).png',
                    'backgrounds_lvl1 (15).png',
                    'backgrounds_lvl1 (16).png'
                ];
                selectedBg = backgroundOptions[Math.floor(Math.random() * backgroundOptions.length)];
            }
            battleState.backgroundPath = `tunnelsofprivacy/backgrounds/lvl1-10/${selectedBg}`;
            battleState.backgroundImage = new Image();
            battleState.backgroundImage.onload = () => {
                // Only host runs floor scanning
                if (!multiplayerState.enabled || multiplayerState.role === 'host') {
                    // Run floor scanning to detect platforms
                    generateBattleLayout();
                    
                    // After layout is generated, send to clients
                    if (multiplayerState.enabled && multiplayerState.role === 'host') {
                        sendBattleInitToClients();
                    }
                }
                
                renderBattle();
            };
            battleState.backgroundImage.src = battleState.backgroundPath;
            
            // Reset pre-generated encounter after using it
            if (usePreGenerated) {
                resetPreGeneratedEncounter();
            }
            
            // Calculate initiative for all combatants
            const allCombatants = [...battleState.heroes, ...battleState.enemies];
            allCombatants.forEach(c => {
                const dexMod = calculateModifier(c.stats?.dex || c.dex || 10);
                c.initiative = rollD20() + dexMod;
            });
            
            // Setup turn order sorted by initiative (highest first)
            battleState.turnOrder = allCombatants.sort((a, b) => b.initiative - a.initiative);
            battleState.currentTurn = 0;
            battleState.active = true;
            battleState.won = false;
            battleState.targetingMode = false;
            battleState.pendingAction = null;
            
            // Update UI
            updateBattleTurnInfo();
            updateBattleHeroCards();
            updateBattleEnemyCards();
            
            // Open chat window by default when entering battle
            chatState.visible = true;
            const chatWindow = document.getElementById('battleChatWindow');
            if (chatWindow) chatWindow.style.display = 'flex';
            updateChatTargets();  // Refresh entity buttons with enemy names
            
            // Render initial state (will re-render when bg loads)
            renderBattle();
            
            // Trigger free will chat for boss at battle start
            const mainBoss = battleState.enemies.find(e => e.isBoss);
            if (mainBoss) {
                setTimeout(() => triggerFreeWillChat(mainBoss, 'battle_start'), 1000);
            }
            
            // Show captive NPC notification if present
            if (battleState.captiveNpc) {
                setTimeout(() => {
                    showBattleNotification(`A prisoner is here: ${battleState.captiveNpc.name}!`);
                }, 2000);
            }
            
            // Start battle animation loop for continuous updates (targeting highlights, etc.)
            function battleAnimationLoop() {
                if (battleState.active) {
                    renderBattle();
                    requestAnimationFrame(battleAnimationLoop);
                }
            }
            battleAnimationLoop();
            
            // If first turn is AI, process it automatically
            const firstCombatant = battleState.turnOrder[0];
            if (!battleState.heroes.includes(firstCombatant)) {
                setTimeout(() => processAITurn(firstCombatant), 1500);
            }
        }
        
        // Send battle initialization data to clients (called after floor scanning completes)
        function sendBattleInitToClients() {
            const canvas = battleState.canvas;
            const battleData = {
                backgroundPath: battleState.backgroundPath,
                canvasWidth: canvas.width,
                canvasHeight: canvas.height,
                heroes: battleState.heroes.map(h => ({
                    name: h.name,
                    hp: h.hp,
                    maxHp: h.maxHp,
                    xp: h.xp,
                    healsRemaining: h.healsRemaining,
                    stats: h.stats,
                    x: h.x / canvas.width,
                    y: h.y / canvas.height,
                    platform: h.platform,
                    initiative: h.initiative,
                    spritePath: h.spritePath
                })),
                enemies: battleState.enemies.map(e => ({
                    name: e.name,
                    species: e.species,
                    hp: e.hp,
                    maxHp: e.maxHp,
                    ac: e.ac,
                    attackDamage: e.attackDamage,
                    speed: e.speed,
                    dex: e.dex,
                    hostile: e.hostile,
                    x: e.x / canvas.width,
                    y: e.y / canvas.height,
                    platform: e.platform,
                    initiative: e.initiative,
                    spritePath: e.spritePath,
                    isMob: e.isMob,
                    isBoss: e.isBoss,
                    goldDrop: e.goldDrop || 0,
                    backstory: e.backstory
                })),
                // Include captive NPC data for clients (full mob-like data)
                captiveNpc: battleState.captiveNpc ? {
                    name: battleState.captiveNpc.name,
                    species: battleState.captiveNpc.species,
                    backstory: battleState.captiveNpc.backstory,
                    personality: battleState.captiveNpc.personality,
                    rescueReward: battleState.captiveNpc.rescueReward,
                    goldReward: battleState.captiveNpc.goldReward || battleState.captiveNpc.rescueReward?.gold || 0,
                    dialogueOnRescue: battleState.captiveNpc.dialogueOnRescue,
                    rescued: battleState.captiveNpc.rescued,
                    hp: battleState.captiveNpc.hp || 1,
                    maxHp: battleState.captiveNpc.maxHp || 1,
                    x: battleState.captiveNpc.x / canvas.width,
                    y: battleState.captiveNpc.y / canvas.height,
                    spritePath: battleState.captiveNpc.spritePath,
                    color: battleState.captiveNpc.color,
                    isCaptive: true,
                    isMob: false,
                    canChat: true,
                    hostile: false,
                    facing: battleState.captiveNpc.facing || 'center'
                } : null,
                turnOrder: battleState.turnOrder.map(c => c.name),
                currentTurn: battleState.currentTurn
            };
            sendWebSocketMessage({ type: 'battle_init', battleData: battleData });
        }

        
        // Detect platforms using multi-method approach
        function detectPlatforms() {
            if (!battleState.backgroundImage || !battleState.backgroundImage.complete) {
                return [];
            }
            
            const tempCanvas = document.createElement('canvas');
            const ctx = tempCanvas.getContext('2d');
            tempCanvas.width = battleState.backgroundImage.width;
            tempCanvas.height = battleState.backgroundImage.height;
            
            ctx.drawImage(battleState.backgroundImage, 0, 0);
            const imageData = ctx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            const data = imageData.data;
            
            const allPlatforms = [];
            
            // METHOD 1: Adaptive thresholding with local contrast
            const method1 = detectByAdaptiveThreshold(data, tempCanvas.width, tempCanvas.height);
            allPlatforms.push(...method1);
            
            // METHOD 2: Multi-angle edge detection
            const method2 = detectByMultiAngle(data, tempCanvas.width, tempCanvas.height);
            allPlatforms.push(...method2);
            
            // METHOD 3: Color clustering
            const method3 = detectByColorClustering(data, tempCanvas.width, tempCanvas.height);
            allPlatforms.push(...method3);
            
            // Score and rank all platforms
            const scored = allPlatforms.map(p => ({
                ...p,
                score: scorePlatform(p, data, tempCanvas.width, tempCanvas.height)
            }));
            
            // Filter minimum score and sort
            const valid = scored.filter(p => p.score > 0.3).sort((a, b) => b.score - a.score);
            
            // Scale to canvas size
            const scaleX = battleState.canvas.width / tempCanvas.width;
            const scaleY = battleState.canvas.height / tempCanvas.height;
            
            return valid.map(p => ({
                x: p.x * scaleX,
                y: p.y * scaleY,
                w: p.w * scaleX,
                h: p.h * scaleY,
                type: p.type,
                score: p.score,
                color: p.color
            }));
        }
        
        // Adaptive thresholding - find LIGHT horizontal floor areas using box scanning
        function detectByAdaptiveThreshold(data, width, height) {
            const platforms = [];
            const boxWidth = 150; // Scan boxes 150px wide
            const boxHeight = 50; // 50px tall boxes
            const boxStepX = 50; // Move box right by 50px
            const boxStepY = 25; // Move box down by 25px
            const minBrightness = 100;
            
            // Scan bottom 60% of image only
            for (let boxY = Math.floor(height * 0.6); boxY < height - boxHeight - 10; boxY += boxStepY) {
                for (let boxX = 0; boxX < width - boxWidth; boxX += boxStepX) {
                    // Sample the entire box
                    let boxBrightnessSum = 0;
                    let boxSamples = 0;
                    
                    for (let dy = 0; dy < boxHeight; dy += 5) {
                        for (let dx = 0; dx < boxWidth; dx += 5) {
                            const x = boxX + dx;
                            const y = boxY + dy;
                            const i = (y * width + x) * 4;
                            const brightness = (data[i] + data[i+1] + data[i+2]) / 3;
                            boxBrightnessSum += brightness;
                            boxSamples++;
                        }
                    }
                    
                    const avgBrightness = boxBrightnessSum / boxSamples;
                    
                    // Check if box is bright enough
                    if (avgBrightness > minBrightness) {
                        // Depth test: trace down to find distance to ground
                        const depthScore = calculateDepthScore(data, width, height, boxX, boxY, boxWidth, boxHeight, avgBrightness);
                        
                        // Only accept platforms with good depth scores (close to ground or at bottom)
                        if (depthScore > 0.5) {
                            platforms.push({
                                x: boxX, y: boxY, w: boxWidth, h: boxHeight,
                                type: 'adaptive', color: '#FF00FF',
                                depthScore: depthScore
                            });
                        }
                    }
                }
            }
            
            return platforms;
        }
        
        // Multi-angle edge detection - find LIGHT floor areas at various slopes using boxes
        function detectByMultiAngle(data, width, height) {
            const platforms = [];
            const angles = [0, 5, -5];
            const boxWidth = 150;
            const boxHeight = 50;
            const boxStepX = 50;
            const boxStepY = 30;
            const minBrightness = 100;
            
            angles.forEach(angle => {
                const rad = angle * Math.PI / 180;
                const tanAngle = Math.tan(rad);
                
                for (let baseY = Math.floor(height * 0.6); baseY < height - boxHeight - 10; baseY += boxStepY) {
                    for (let boxX = 0; boxX < width - boxWidth; boxX += boxStepX) {
                        const centerY = Math.floor(baseY + boxX * tanAngle);
                        if (centerY < 0 || centerY >= height - boxHeight - 10) continue;
                        
                        // Sample box at this position
                        let boxBrightnessSum = 0;
                        let boxSamples = 0;
                        
                        for (let dy = 0; dy < boxHeight; dy += 5) {
                            for (let dx = 0; dx < boxWidth; dx += 5) {
                                const x = boxX + dx;
                                const y = centerY + dy;
                                if (y >= height) continue;
                                const i = (y * width + x) * 4;
                                const brightness = (data[i] + data[i+1] + data[i+2]) / 3;
                                boxBrightnessSum += brightness;
                                boxSamples++;
                            }
                        }
                        
                        const avgBrightness = boxBrightnessSum / boxSamples;
                        
                        if (avgBrightness > minBrightness) {
                            // Depth test
                            const depthScore = calculateDepthScore(data, width, height, boxX, centerY, boxWidth, boxHeight, avgBrightness);
                            
                            if (depthScore > 0.5) {
                                platforms.push({
                                    x: boxX, y: centerY, w: boxWidth, h: boxHeight,
                                    type: 'angle', color: '#00FFFF',
                                    depthScore: depthScore
                                });
                            }
                        }
                    }
                }
            });
            
            return platforms;
        }
        
        // Color clustering - find LIGHT colored horizontal floor regions using boxes
        function detectByColorClustering(data, width, height) {
            const platforms = [];
            const boxWidth = 150;
            const boxHeight = 50;
            const boxStepX = 50;
            const boxStepY = 25;
            const colorTolerance = 60;
            const minBrightness = 100;
            
            for (let boxY = Math.floor(height * 0.6); boxY < height - boxHeight - 10; boxY += boxStepY) {
                for (let boxX = 0; boxX < width - boxWidth; boxX += boxStepX) {
                    // Sample box at this position
                    let avgR = 0, avgG = 0, avgB = 0;
                    let samples = 0;
                    
                    for (let dy = 0; dy < boxHeight; dy += 5) {
                        for (let dx = 0; dx < boxWidth; dx += 5) {
                            const x = boxX + dx;
                            const y = boxY + dy;
                            const i = (y * width + x) * 4;
                            avgR += data[i];
                            avgG += data[i+1];
                            avgB += data[i+2];
                            samples++;
                        }
                    }
                    
                    avgR /= samples;
                    avgG /= samples;
                    avgB /= samples;
                    const brightness = (avgR + avgG + avgB) / 3;
                    
                    // Only consider LIGHT boxes as potential floor
                    if (brightness > minBrightness) {
                        // Depth test
                        const depthScore = calculateDepthScore(data, width, height, boxX, boxY, boxWidth, boxHeight, brightness);
                        
                        if (depthScore > 0.5) {
                            platforms.push({
                                x: boxX, y: boxY, w: boxWidth, h: boxHeight,
                                type: 'cluster', color: '#00FF00',
                                depthScore: depthScore
                            });
                        }
                    }
                }
            }
            
            return platforms;
        }
        
        // Calculate depth score - traces downward to find distance to ground
        function calculateDepthScore(data, width, height, boxX, boxY, boxWidth, boxHeight, platformBrightness) {
            const centerX = boxX + Math.floor(boxWidth / 2);
            const startY = boxY + boxHeight;
            const maxDepth = 200; // Don't trace more than 200px down
            
            let distanceToGround = 0;
            let foundGround = false;
            
            // Trace straight down from center of platform
            for (let y = startY; y < Math.min(height, startY + maxDepth); y += 5) {
                const i = (y * width + centerX) * 4;
                const brightness = (data[i] + data[i+1] + data[i+2]) / 3;
                
                // Check for ground indicators:
                // 1. Hit bottom of image
                if (y >= height - 10) {
                    distanceToGround = y - startY;
                    foundGround = true;
                    break;
                }
                
                // 2. Hit much darker area (void/background)
                if (brightness < 50) {
                    distanceToGround = y - startY;
                    foundGround = true;
                    break;
                }
                
                // 3. Hit similar brightness (continuous support)
                if (Math.abs(brightness - platformBrightness) < 30) {
                    // Keep tracing, we're still on connected surface
                    continue;
                }
            }
            
            // If we traced all the way down without finding ground, it's floating
            if (!foundGround) {
                return 0;
            }
            
            // Score based on distance to ground
            // 0 distance (at bottom) = 1.0 score
            // 50px or more = 0.5 score (minimum acceptable)
            // >200px = rejected above
            const score = 1.0 - (distanceToGround / 400);
            return Math.max(0.5, score);
        }
        
        // Score platform quality
        function scorePlatform(platform, data, width, height) {
            let score = 0;
            
            // Width score (wider = better, cap at 800px)
            const widthScore = Math.min(1.0, platform.w / 800);
            score += widthScore * 0.5;
            
            // Position score (lower on screen = better, floors are at bottom)
            const positionScore = platform.y / height;
            score += positionScore * 0.3;
            
            // Brightness consistency (floors should be consistently LIGHT)
            let brightnessSum = 0;
            let sampleCount = 0;
            for (let x = platform.x; x < platform.x + platform.w; x += 10) {
                const idx = (Math.floor(platform.y) * width + Math.floor(x)) * 4;
                const brightness = (data[idx] + data[idx+1] + data[idx+2]) / 3;
                brightnessSum += brightness;
                sampleCount++;
            }
            const avgBrightness = brightnessSum / sampleCount;
            const brightnessScore = avgBrightness > 100 ? Math.min(1.0, avgBrightness / 200) : 0;
            score += brightnessScore * 0.2;
            
            return score;
        }
        
        // Generate battle layout using detected platforms
        function generateBattleLayout() {
            const canvas = battleState.canvas;
            battleState.platforms = [];
            
            // Detect platforms
            const detected = detectPlatforms();
            console.log(`Detected ${detected.length} platforms total`);
            
            if (detected.length < 7) {
                console.log('Not enough platforms detected, using fallback');
                return generateFallbackLayout();
            }
            
            // Safe zone filtering - only check X bounds, platforms already scanned at bottom
            const marginX = 160; // 300px sprite / 2 + 10px buffer
            
            const safe = detected.filter(p => {
                const centerX = p.x + p.w / 2;
                return centerX > marginX && centerX < canvas.width - marginX;
            });
            
            console.log(`${safe.length} platforms in safe zone`);
            
            if (safe.length < 7) {
                console.log('Not enough safe platforms, using fallback');
                return generateFallbackLayout();
            }
            
            // Shuffle safe platforms for variety each battle
            const shuffled = [...safe].sort(() => Math.random() - 0.5);
            
            // Pick platforms ensuring spatial separation (300px sprites need 200px+ spacing)
            const minDistance = 200;
            const selected = [];
            
            for (let i = 0; i < shuffled.length && selected.length < 7; i++) {
                const candidate = shuffled[i];
                const candidateX = candidate.x + candidate.w / 2;
                const candidateY = candidate.y;
                
                // Check if candidate overlaps with already selected platforms
                let overlaps = false;
                for (const existing of selected) {
                    const existingX = existing.x + existing.w / 2;
                    const existingY = existing.y;
                    
                    const dx = candidateX - existingX;
                    const dy = candidateY - existingY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < minDistance) {
                        overlaps = true;
                        break;
                    }
                }
                
                if (!overlaps) {
                    selected.push(candidate);
                }
            }
            
            console.log(`Selected ${selected.length} non-overlapping platforms`);
            
            // Need at least 7 non-overlapping platforms (4 heroes + 3 enemies)
            if (selected.length < 7) {
                console.log('Could not find 7 non-overlapping platforms, using fallback');
                return generateFallbackLayout();
            }
            
            // Position heroes
            for (let i = 0; i < 4; i++) {
                const p = selected[i];
                battleState.platforms.push(p);
                
                // Center of detection box
                const centerX = p.x + p.w / 2;
                const centerY = p.y + p.h / 2;
                
                // We need to solve: floor contact point (heroY + scaledBoxSize/2) = centerY
                // scaledBoxSize = 300 * (0.6 + heroY / canvas.height * 0.4)
                // This is circular, so we iterate to solve
                let heroY = centerY - 150; // Initial guess
                for (let iter = 0; iter < 5; iter++) {
                    const depthScale = 0.6 + (heroY / canvas.height) * 0.4;
                    const scaledBoxSize = 300 * depthScale;
                    heroY = centerY - scaledBoxSize / 2;
                }
                
                battleState.heroes[i].platform = p;
                battleState.heroes[i].x = centerX;
                battleState.heroes[i].y = heroY;
                battleState.heroes[i].facing = 'center';
            }
            
            // Position enemies
            for (let i = 0; i < battleState.enemies.length; i++) {
                const ep = selected[4 + i];
                battleState.platforms.push(ep);
                
                // Center of detection box
                const centerX = ep.x + ep.w / 2;
                const centerY = ep.y + ep.h / 2;
                
                const enemy = battleState.enemies[i];
                
                if (enemy.isMob) {
                    // For mobs: enemy.y is at FEET (bottom of sprite)
                    // Sprite bottom should be at centerY
                    enemy.x = centerX;
                    enemy.y = centerY;
                } else {
                    // For bosses: solve for Y position where floor contact point = centerY
                    let enemyY = centerY - 150; // Initial guess
                    for (let iter = 0; iter < 5; iter++) {
                        const depthScale = 0.6 + (enemyY / canvas.height) * 0.4;
                        const scaledBoxSize = 300 * depthScale;
                        enemyY = centerY - scaledBoxSize / 2;
                    }
                    enemy.x = centerX;
                    enemy.y = enemyY;
                }
                
                enemy.platform = ep;
                enemy.facing = 'center';
            }
            
            // Position captive NPC if present (far left, below heroes)
            if (battleState.captiveNpc && !battleState.captiveNpc.rescued) {
                battleState.captiveNpc.x = canvas.width * 0.10;
                battleState.captiveNpc.y = canvas.height * 0.80;
                battleState.captiveNpc.facing = 'center';
            }
            
            battleState.detectedPlatforms = detected;
            console.log('Platform layout generated successfully');
        }
        
        // Fallback positioning
        function generateFallbackLayout() {
            const canvas = battleState.canvas;
            const safePositions = {
                heroes: [
                    { x: 0.20, y: 0.40 },
                    { x: 0.25, y: 0.55 },
                    { x: 0.15, y: 0.65 },
                    { x: 0.30, y: 0.75 }
                ],
                enemies: [
                    { x: 0.75, y: 0.60 },
                    { x: 0.70, y: 0.45 },
                    { x: 0.80, y: 0.70 }
                ]
            };
            
            for (let i = 0; i < 4; i++) {
                const pos = safePositions.heroes[i];
                const heroX = canvas.width * pos.x;
                const heroY = canvas.height * pos.y;
                
                const platform = {
                    x: heroX - 50, y: heroY + 140, w: 100, h: 10,
                    type: 'fallback', color: '#6B4FA0'
                };
                
                battleState.platforms.push(platform);
                battleState.heroes[i].platform = platform;
                battleState.heroes[i].x = heroX;
                battleState.heroes[i].y = heroY;
                battleState.heroes[i].facing = 'center';
            }
            
            for (let i = 0; i < battleState.enemies.length; i++) {
                const pos = safePositions.enemies[i];
                const enemyX = canvas.width * pos.x;
                const enemyY = canvas.height * pos.y;
                
                const enemyPlatform = {
                    x: enemyX - 75, y: enemyY + 140, w: 150, h: 10,
                    type: 'fallback', color: '#4A2A6B'
                };
                
                battleState.platforms.push(enemyPlatform);
                battleState.enemies[i].platform = enemyPlatform;
                battleState.enemies[i].x = enemyX;
                battleState.enemies[i].y = enemyY;
                battleState.enemies[i].facing = 'center';
            }
            
            // Position captive NPC if present (far left, below heroes - like a friendly mob)
            if (battleState.captiveNpc && !battleState.captiveNpc.rescued) {
                const captiveX = canvas.width * 0.10;  // Far left
                const captiveY = canvas.height * 0.80;  // Lower area (front of room)
                battleState.captiveNpc.x = captiveX;
                battleState.captiveNpc.y = captiveY;
                battleState.captiveNpc.facing = 'center';
            }
        }
        

        // Handle canvas clicks for targeting
        function handleBattleClick(event) {
            const rect = battleState.canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // Handle swap targeting (hero selection)
            if (battleState.swapTargetingMode && battleState.swapInitiator) {
                for (const hero of battleState.heroes) {
                    if (hero === battleState.swapInitiator || hero.hp <= 0) continue;
                    
                    const canvas = battleState.canvas;
                    const depthScale = 0.6 + (hero.y / canvas.height) * 0.4;
                    const hitWidth = 64 * depthScale;
                    const hitHeight = 64 * depthScale;
                    const hitX = hero.x - hitWidth / 2;
                    const hitY = hero.y - hitHeight / 2;
                    
                    if (x >= hitX && x <= hitX + hitWidth && y >= hitY && y <= hitY + hitHeight) {
                        const initiator = battleState.swapInitiator;
                        
                        // Multiplayer: Client sends to host
                        if (multiplayerState.enabled && multiplayerState.role === 'client') {
                            sendWebSocketMessage({
                                type: 'player_action',
                                action: 'swap',
                                target: battleState.heroes.indexOf(hero),
                                hero: initiator.name
                            });
                            
                            // Exit swap mode
                            battleState.swapTargetingMode = false;
                            battleState.swapInitiator = null;
                            battleState.canvas.style.cursor = 'default';
                            return;
                        }
                        
                        // Swap positions
                        const tempX = initiator.x;
                        const tempY = initiator.y;
                        const tempPlatform = initiator.platform;
                        
                        initiator.x = hero.x;
                        initiator.y = hero.y;
                        initiator.platform = hero.platform;
                        
                        hero.x = tempX;
                        hero.y = tempY;
                        hero.platform = tempPlatform;
                        
                        showDiceRoll(`${initiator.name} swapped positions with ${hero.name}!`);
                        
                        // Exit swap mode
                        battleState.swapTargetingMode = false;
                        battleState.swapInitiator = null;
                        battleState.canvas.style.cursor = 'default';
                        
                        // Swap uses all action points
                        advanceTurn();
                        
                        // Host broadcasts state
                        if (multiplayerState.enabled && multiplayerState.role === 'host') {
                            broadcastGameState();
                        }
                        return;
                    }
                }
                return;
            }
            
            // Handle enemy targeting
            if (!battleState.targetingMode || !battleState.pendingAction) return;
            
            // Check if click hit an enemy
            for (const enemy of battleState.enemies) {
                if (enemy.hp <= 0 || !enemy.hostile) continue;
                
                const canvas = battleState.canvas;
                const depthScale = 0.6 + (enemy.y / canvas.height) * 0.4;
                let hitWidth, hitHeight, hitX, hitY;
                
                if (enemy.isMob) {
                    const mobAspectRatio = 1344 / 768;
                    const baseHeight = 75;
                    const spriteHeight = baseHeight * depthScale;
                    const spriteWidth = spriteHeight * mobAspectRatio;
                    hitWidth = spriteWidth;
                    hitHeight = spriteHeight;
                    hitX = enemy.x - hitWidth / 2;
                    hitY = enemy.y - spriteHeight;
                } else {
                    hitWidth = 200 * depthScale;
                    hitHeight = 200 * depthScale;
                    hitX = enemy.x - hitWidth / 2;
                    hitY = enemy.y - hitHeight / 2;
                }
                
                if (x >= hitX && x <= hitX + hitWidth && y >= hitY && y <= hitY + hitHeight) {
                    // Target found!
                    const attacker = battleState.turnOrder[battleState.currentTurn];
                    const enemyIndex = battleState.enemies.indexOf(enemy);
                    
                    // Multiplayer: Client sends to host
                    if (multiplayerState.enabled && multiplayerState.role === 'client') {
                        sendWebSocketMessage({
                            type: 'player_action',
                            action: battleState.pendingAction,
                            target: enemyIndex,
                            hero: attacker.name
                        });
                        
                        // Exit targeting mode
                        battleState.targetingMode = false;
                        battleState.pendingAction = null;
                        battleState.canvas.style.cursor = 'default';
                        return;
                    }
                    
                    executeAttack(attacker, enemy, battleState.pendingAction);
                    
                    // Exit targeting mode
                    battleState.targetingMode = false;
                    battleState.pendingAction = null;
                    battleState.canvas.style.cursor = 'default';
                    return;
                }
            }
        }
        
        // Render battle scene
        function renderBattle() {
            const ctx = battleState.ctx;
            const canvas = battleState.canvas;
            
            // Setup click handler
            if (!canvas.hasClickHandler) {
                canvas.addEventListener('click', handleBattleClick);
                canvas.hasClickHandler = true;
            }
            
            // Draw background image if loaded, otherwise fallback to gradient
            if (battleState.backgroundImage && battleState.backgroundImage.complete && battleState.backgroundImage.naturalHeight !== 0) {
                ctx.drawImage(battleState.backgroundImage, 0, 0, canvas.width, canvas.height);
            } else {
                // Fallback: Clear canvas with gradient
                ctx.fillStyle = '#1a0f2e';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw starry background
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                for (let i = 0; i < 100; i++) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    const r = Math.random() * 2;
                    ctx.beginPath();
                    ctx.arc(x, y, r, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Draw detected platform spawn areas if hitboxes enabled
            if (settings.showHitboxes && battleState.detectedPlatforms) {
                battleState.detectedPlatforms.forEach(platform => {
                    // Different colors for different detection methods
                    let fillColor, strokeColor;
                    
                    if (platform.type === 'detected') {
                        // Edge detection = GREEN
                        fillColor = 'rgba(0, 255, 0, 0.2)';
                        strokeColor = 'rgba(0, 255, 0, 0.8)';
                    } else if (platform.type === 'sampled') {
                        // Grid sampling = MAGENTA
                        fillColor = 'rgba(255, 0, 255, 0.2)';
                        strokeColor = 'rgba(255, 0, 255, 0.8)';
                    } else if (platform.type === 'gradient') {
                        // Gradient/flat area = CYAN
                        fillColor = 'rgba(0, 255, 255, 0.2)';
                        strokeColor = 'rgba(0, 255, 255, 0.8)';
                    } else {
                        // Unknown = WHITE
                        fillColor = 'rgba(255, 255, 255, 0.2)';
                        strokeColor = 'rgba(255, 255, 255, 0.8)';
                    }
                    
                    ctx.fillStyle = fillColor;
                    ctx.fillRect(platform.x, platform.y, platform.w, platform.h);
                    
                    ctx.strokeStyle = strokeColor;
                    ctx.lineWidth = 1;
                    ctx.strokeRect(platform.x, platform.y, platform.w, platform.h);
                });
            }
            
            // Draw platforms
            battleState.platforms.forEach(platform => {
                // Don't draw platforms, keep them invisible for collision only
                // ctx.fillStyle = platform.color;
                // ctx.fillRect(platform.x, platform.y, platform.w, platform.h);
                
                // Platform edge highlight
                // ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                // ctx.lineWidth = 2;
                // ctx.strokeRect(platform.x, platform.y, platform.w, platform.h);
            });
            
            // Draw heroes
            battleState.heroes.forEach(hero => {
                // Calculate depth-based scale (higher Y = farther back = smaller)
                // Y range: 0 (top) to canvas.height (bottom)
                // Scale range: 0.6 (top/far) to 1.0 (bottom/near)
                const depthScale = 0.6 + (hero.y / canvas.height) * 0.4;
                
                // Green highlight for swap targeting (other heroes)
                if (battleState.swapTargetingMode && hero !== battleState.swapInitiator && hero.hp > 0) {
                    ctx.save();
                    ctx.strokeStyle = '#00FF00';
                    ctx.lineWidth = 4 * depthScale;
                    ctx.shadowColor = '#00FF00';
                    ctx.shadowBlur = 20 * depthScale;
                    const pulseSize = Math.sin(Date.now() / 200) * 3 * depthScale;
                    const boxWidth = 300 * depthScale;
                    const boxHeight = 300 * depthScale;
                    ctx.strokeRect(
                        hero.x - boxWidth / 2 - pulseSize,
                        hero.y - boxHeight / 2 - pulseSize,
                        boxWidth + pulseSize * 2,
                        boxHeight + pulseSize * 2
                    );
                    ctx.restore();
                }
                
                // Update animation frame
                const currentTime = performance.now();
                updateAnimation(hero, currentTime);
                
                // Draw hero sprite (animated or fallback)
                const spriteWidth = 300 * depthScale;
                const spriteHeight = 300 * depthScale;
                const spriteX = hero.x - spriteWidth / 2;
                // Per-hero offset adjustments (scaled with depth)
                let offsetY = 10 * depthScale; // Default (Zooko, Nate)
                if (hero.name === 'Zancas') {
                    offsetY = 20 * depthScale; // Zancas down 10px more
                } else if (hero.name === 'CyberAxe') {
                    offsetY = 13 * depthScale; // CyberAxe down 3px more
                }
                const spriteY = hero.y - spriteHeight / 2 + offsetY;
                
                const flipX = hero.facing === 'left';
                drawAnimatedSprite(ctx, hero, spriteX, spriteY, spriteWidth, spriteHeight, flipX);
                
                // Fallback check - if no animation and no static sprite loaded
                if ((!hero.anim || !hero.anim.sheet) && (!hero.sprite || !hero.sprite.complete || hero.sprite.naturalHeight === 0)) {
                    // Fallback to colored circle if sprite not loaded
                    ctx.fillStyle = hero.color;
                    ctx.beginPath();
                    ctx.arc(hero.x, hero.y, 90 * depthScale, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                
                // Ground-plane nameplate (at hero's feet, tilted for 3D perspective)
                ctx.save();
                
                // Position at hero's feet (bottom of sprite area)
                const groundY = hero.y + 160 * depthScale;  // Below hero sprite (moved down)
                
                // Calculate tilt based on screen position (left=-5¬∞, middle=0¬∞, right=+5¬∞)
                const screenThird = canvas.width / 3;
                let tiltAngle = 0;
                if (hero.x < screenThird) {
                    // Left third: -5 degrees
                    tiltAngle = -5;
                } else if (hero.x > screenThird * 2) {
                    // Right third: +5 degrees
                    tiltAngle = 5;
                }
                // Middle third: 0 degrees (no tilt)
                
                // Convert degrees to radians for sin calculation
                const tiltRadians = tiltAngle * Math.PI / 180;
                const tiltSkew = Math.sin(tiltRadians);  // sin(5¬∞) ‚âà 0.087, sin(-5¬∞) ‚âà -0.087, sin(0¬∞) = 0
                
                // Apply perspective transform - squish vertically for ground plane effect
                // 50% taller than original 35% = 52.5% scale
                ctx.translate(hero.x, groundY);
                ctx.transform(1, tiltSkew, 0, 0.525, 0, 0);  // Dynamic tilt + 52.5% vertical scale
                ctx.translate(-hero.x, -groundY);
                
                const barWidth = 100 * depthScale;
                const barHeight = 20 * depthScale;  // Taller since it gets squished
                const barX = hero.x - barWidth / 2;
                const barY = groundY;
                
                // Shadow/glow under the nameplate
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.beginPath();
                ctx.ellipse(hero.x, barY + barHeight + 10 * depthScale, barWidth * 0.6, 8 * depthScale, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Hero name (above HP bar on ground)
                ctx.fillStyle = '#FFFFFF';
                ctx.font = `bold ${Math.floor(16 * depthScale)}px Inter`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText(hero.name.toUpperCase(), hero.x, barY - 2 * depthScale);
                
                // HP bar background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(barX, barY, barWidth, barHeight);
                
                // HP bar border
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 2;
                ctx.strokeRect(barX, barY, barWidth, barHeight);
                
                // HP fill (GREEN -> YELLOW for heroes)
                const hpPercent = hero.hp / hero.maxHp;
                ctx.fillStyle = hpPercent > 0.5 ? '#27AE60' : hpPercent > 0.25 ? '#F39C12' : '#F1C40F';
                ctx.fillRect(barX + 2, barY + 2, (barWidth - 4) * hpPercent, barHeight - 4);
                
                // HP text INSIDE bar (centered)
                ctx.fillStyle = '#FFFFFF';
                ctx.font = `bold ${Math.floor(14 * depthScale)}px JetBrains Mono`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(`${hero.hp}/${hero.maxHp}`, hero.x, barY + barHeight / 2);
                
                ctx.restore();  // Restore normal transform
            });
            
            // Draw enemies
            battleState.enemies.forEach(enemy => {
                // Calculate depth-based scale (higher Y = farther back = smaller)
                const depthScale = 0.6 + (enemy.y / canvas.height) * 0.4;
                
                // Draw enemy sprite
                if (enemy.sprite && enemy.sprite.complete && enemy.sprite.naturalHeight !== 0) {
                    let spriteWidth, spriteHeight, spriteX, spriteY;
                    
                    if (enemy.isMob) {
                        // Mobs are 1344x768, render 4x smaller with correct aspect ratio
                        const mobAspectRatio = 1344 / 768; // 1.75
                        const baseHeight = 75; // 768 / 4 / 2.56 ‚âà 75px base height
                        spriteHeight = baseHeight * depthScale;
                        spriteWidth = spriteHeight * mobAspectRatio;
                        spriteX = enemy.x - spriteWidth / 2;
                        // Position so BOTTOM of sprite is at enemy.y (feet on ground)
                        spriteY = enemy.y - spriteHeight;
                    } else {
                        // Bosses are 300x300, centered
                        spriteWidth = 300 * depthScale;
                        spriteHeight = 300 * depthScale;
                        spriteX = enemy.x - spriteWidth / 2;
                        spriteY = enemy.y - spriteHeight / 2 + (10 * depthScale); // Offset down, scaled
                    }
                    
                    ctx.save();
                    if (enemy.facing === 'left') {
                        ctx.translate(enemy.x, enemy.y);
                        ctx.scale(-1, 1);
                        ctx.translate(-enemy.x, -enemy.y);
                    }
                    ctx.drawImage(enemy.sprite, spriteX, spriteY, spriteWidth, spriteHeight);
                    ctx.restore();
                } else {
                    // Fallback to colored circle if sprite not loaded
                    ctx.fillStyle = enemy.color;
                    ctx.beginPath();
                    ctx.arc(enemy.x, enemy.y, 50 * depthScale, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
                
                // Calculate HP bar position first, then build labels above it
                let barOffsetY;
                if (enemy.isMob) {
                    const mobAspectRatio = 1344 / 768;
                    const baseHeight = 75;
                    const spriteHeight = baseHeight * depthScale;
                    barOffsetY = enemy.y - spriteHeight - (5 * depthScale);
                } else {
                    // For bosses, position above centered sprite
                    barOffsetY = enemy.y - 165 * depthScale;
                }
                
                // HP bar with text inside
                const barWidth = 100 * depthScale;
                const barHeight = 14 * depthScale;
                const barX = enemy.x - barWidth / 2;
                const barY = barOffsetY;
                
                // Calculate label positions (build upward from HP bar)
                const speciesOffsetY = barY - (5 * depthScale);  // Species just above bar
                const nameOffsetY = speciesOffsetY - (12 * depthScale);  // Name above species
                
                // Name (unique name - RED for enemies)
                ctx.fillStyle = '#FF4444';
                ctx.font = `bold ${Math.floor(14 * depthScale)}px Inter`;
                ctx.textAlign = 'center';
                ctx.fillText(enemy.name.toUpperCase(), enemy.x, nameOffsetY);
                
                // Species/Type (smaller, between name and bar) - ALWAYS show
                ctx.fillStyle = '#AAAAAA';
                if (enemy.isMob) {
                    // Mobs: species in gray, normal weight
                    ctx.font = `${Math.floor(10 * depthScale)}px Inter`;
                    ctx.fillText(enemy.species || 'Creature', enemy.x, speciesOffsetY);
                } else {
                    // Bosses: species in gray but BOLD
                    ctx.font = `bold ${Math.floor(10 * depthScale)}px Inter`;
                    ctx.fillText(enemy.species || 'Boss', enemy.x, speciesOffsetY);
                }
                
                // Background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(barX, barY, barWidth, barHeight);
                
                // HP fill (RED for enemies)
                const hpPercent = enemy.hp / enemy.maxHp;
                ctx.fillStyle = hpPercent > 0.5 ? '#E74C3C' : hpPercent > 0.25 ? '#C0392B' : '#A93226';
                ctx.fillRect(barX, barY, barWidth * hpPercent, barHeight);
                
                // HP text INSIDE bar (centered)
                ctx.fillStyle = '#FFFFFF';
                ctx.font = `bold ${Math.floor(10 * depthScale)}px JetBrains Mono`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(`${enemy.hp}/${enemy.maxHp}`, enemy.x, barY + barHeight / 2);
                ctx.textBaseline = 'alphabetic';  // Reset
                
                // Gold display BELOW HP bar (public ledger - they use Bitcoin/gold, not Zcash!)
                const goldAmount = enemy.goldDrop || 0;
                const goldY = barY + barHeight + (12 * depthScale);
                ctx.fillStyle = '#FFD700';  // Gold color
                ctx.font = `bold ${Math.floor(10 * depthScale)}px JetBrains Mono`;
                ctx.textAlign = 'center';
                ctx.fillText(`üí∞ ${goldAmount}`, enemy.x, goldY);
                
                // Highlight clickable enemies in targeting mode
                if (battleState.targetingMode && enemy.hostile) {
                    const depthScale = 0.6 + (enemy.y / canvas.height) * 0.4;
                    let highlightWidth, highlightHeight, highlightX, highlightY;
                    
                    if (enemy.isMob) {
                        const mobAspectRatio = 1344 / 768;
                        const baseHeight = 75;
                        const spriteHeight = baseHeight * depthScale;
                        const spriteWidth = spriteHeight * mobAspectRatio;
                        highlightWidth = spriteWidth + 20;
                        highlightHeight = spriteHeight + 20;
                        highlightX = enemy.x - highlightWidth / 2;
                        highlightY = enemy.y - spriteHeight - 10;
                    } else {
                        highlightWidth = 220 * depthScale;
                        highlightHeight = 220 * depthScale;
                        highlightX = enemy.x - highlightWidth / 2;
                        highlightY = enemy.y - highlightHeight / 2;
                    }
                    
                    // Pulsing glow effect
                    const pulseAlpha = 0.3 + Math.sin(Date.now() / 200) * 0.2;
                    ctx.strokeStyle = `rgba(255, 255, 0, ${pulseAlpha})`;
                    ctx.lineWidth = 4;
                    ctx.strokeRect(highlightX, highlightY, highlightWidth, highlightHeight);
                    
                    // Glow shadow
                    ctx.shadowColor = 'rgba(255, 255, 0, 0.8)';
                    ctx.shadowBlur = 20;
                    ctx.strokeRect(highlightX, highlightY, highlightWidth, highlightHeight);
                    ctx.shadowBlur = 0;
                }
            });
            
            // Draw captive NPC if present and not rescued (rendered like a mob)
            if (battleState.captiveNpc && !battleState.captiveNpc.rescued && battleState.captiveNpc.x > 0) {
                const captive = battleState.captiveNpc;
                const depthScale = 0.6 + (captive.y / canvas.height) * 0.4;
                
                // Draw captive sprite (static image) or fallback to colored circle
                if (captive.sprite && captive.sprite.complete && captive.sprite.naturalHeight !== 0) {
                    // Static captive image - use actual aspect ratio
                    const imgWidth = captive.sprite.naturalWidth;
                    const imgHeight = captive.sprite.naturalHeight;
                    const aspectRatio = imgWidth / imgHeight;
                    
                    // Scale to reasonable size (base height ~250px at full scale - 25% larger)
                    const baseHeight = 250;
                    const spriteHeight = baseHeight * depthScale;
                    const spriteWidth = spriteHeight * aspectRatio;
                    const spriteX = captive.x - spriteWidth / 2;
                    const spriteY = captive.y - spriteHeight;  // Bottom at captive.y
                    
                    ctx.save();
                    if (captive.facing === 'left') {
                        ctx.translate(captive.x, captive.y);
                        ctx.scale(-1, 1);
                        ctx.translate(-captive.x, -captive.y);
                    }
                    ctx.drawImage(captive.sprite, spriteX, spriteY, spriteWidth, spriteHeight);
                    ctx.restore();
                } else {
                    // Fallback to gold circle (like mobs fallback)
                    ctx.fillStyle = captive.color || '#F2C94C';
                    ctx.beginPath();
                    ctx.arc(captive.x, captive.y, 50 * depthScale, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    
                    // Add chain icon in center
                    ctx.fillStyle = '#8B4513';
                    ctx.font = `bold ${Math.floor(24 * depthScale)}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('‚õìÔ∏è', captive.x, captive.y);
                }
                
                // Captive name and HP bar - positioned above sprite (same as enemies)
                const captiveBaseHeight = 250;
                const spriteHeight = captiveBaseHeight * depthScale;
                const barOffsetY = captive.y - spriteHeight - (5 * depthScale);
                
                // HP bar with text inside (if captive has HP)
                const barWidth = 80 * depthScale;
                const barHeight = 14 * depthScale;
                const barX = captive.x - barWidth / 2;
                const barY = barOffsetY;
                
                // Calculate label positions (build upward from HP bar - same as enemies)
                const speciesOffsetY = barY - (5 * depthScale);  // Species just above bar
                const nameOffsetY = speciesOffsetY - (12 * depthScale);  // Name above species
                
                // Name (GOLD for friendly)
                ctx.fillStyle = '#F2C94C';
                ctx.font = `bold ${Math.floor(14 * depthScale)}px Inter`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'alphabetic';
                ctx.fillText(captive.name.toUpperCase(), captive.x, nameOffsetY);
                
                // Species label below name
                ctx.fillStyle = '#27AE60';
                ctx.font = `${Math.floor(10 * depthScale)}px Inter`;
                ctx.fillText(`‚õìÔ∏è ${captive.species || 'Captive'}`, captive.x, speciesOffsetY);
                
                // Draw HP bar
                if (captive.hp && captive.maxHp) {
                    // Background
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(barX, barY, barWidth, barHeight);
                    
                    // HP fill (GREEN for friendly)
                    const hpPercent = captive.hp / captive.maxHp;
                    ctx.fillStyle = '#27AE60';
                    ctx.fillRect(barX, barY, barWidth * hpPercent, barHeight);
                    
                    // HP text INSIDE bar
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = `bold ${Math.floor(10 * depthScale)}px JetBrains Mono`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(`${captive.hp}/${captive.maxHp}`, captive.x, barY + barHeight / 2);
                    ctx.textBaseline = 'alphabetic';
                    
                    // Gold display BELOW HP bar (public ledger - NPCs also on transparent chain)
                    const goldAmount = captive.goldDrop || 0;
                    const goldY = barY + barHeight + (12 * depthScale);
                    ctx.fillStyle = '#FFD700';
                    ctx.font = `bold ${Math.floor(10 * depthScale)}px JetBrains Mono`;
                    ctx.textAlign = 'center';
                    ctx.fillText(`üí∞ ${goldAmount}`, captive.x, goldY);
                }
            }
            
            // Draw hitboxes if enabled
            if (settings.showHitboxes) {
                // Draw hero spawn area boxes (scaled with depth)
                battleState.heroes.forEach(hero => {
                    const depthScale = 0.6 + (hero.y / canvas.height) * 0.4;
                    const boxSize = 300 * depthScale;
                    ctx.strokeStyle = '#00FF00';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(hero.x - boxSize / 2, hero.y - boxSize / 2, boxSize, boxSize);
                    
                    // Draw center point (hero.x, hero.y)
                    ctx.fillStyle = '#00FF00';
                    ctx.beginPath();
                    ctx.arc(hero.x, hero.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw FLOOR CONTACT POINT - bottom center of hitbox where feet should touch
                    const floorY = hero.y + boxSize / 2;
                    ctx.fillStyle = '#FF00FF';
                    ctx.beginPath();
                    ctx.arc(hero.x, floorY, 8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Draw x/y coordinates at top of hitbox
                    const topY = hero.y - boxSize / 2 - 5;
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = 'bold 12px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(`x:${Math.round(hero.x)} y:${Math.round(hero.y)}`, hero.x, topY);
                });
                
                // Draw enemy spawn area boxes (scaled with depth)
                battleState.enemies.forEach(enemy => {
                    const depthScale = 0.6 + (enemy.y / canvas.height) * 0.4;
                    
                    let boxSize, boxY, topY;
                    if (enemy.isMob) {
                        // Mobs: hitbox matches sprite size (aspect ratio 1.75:1)
                        const mobAspectRatio = 1344 / 768;
                        const baseHeight = 75;
                        const spriteHeight = baseHeight * depthScale;
                        const spriteWidth = spriteHeight * mobAspectRatio;
                        // Hitbox from feet (enemy.y) upward
                        ctx.strokeStyle = '#FF0000';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(enemy.x - spriteWidth / 2, enemy.y - spriteHeight, spriteWidth, spriteHeight);
                        
                        // Draw floor contact point at enemy.y (feet)
                        ctx.fillStyle = '#FF00FF';
                        ctx.beginPath();
                        ctx.arc(enemy.x, enemy.y, 8, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#FFFFFF';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        
                        // Top of hitbox for coordinates
                        topY = enemy.y - spriteHeight - 5;
                    } else {
                        // Bosses: 300x300 scaled box centered
                        const boxSize = 300 * depthScale;
                        ctx.strokeStyle = '#FF0000';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(enemy.x - boxSize / 2, enemy.y - boxSize / 2, boxSize, boxSize);
                        
                        // Draw center point
                        ctx.fillStyle = '#FF0000';
                        ctx.beginPath();
                        ctx.arc(enemy.x, enemy.y, 5, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Draw floor contact point
                        const floorY = enemy.y + boxSize / 2;
                        ctx.fillStyle = '#FF00FF';
                        ctx.beginPath();
                        ctx.arc(enemy.x, floorY, 8, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#FFFFFF';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        
                        // Top of hitbox for coordinates
                        topY = enemy.y - boxSize / 2 - 5;
                    }
                    
                    // Draw x/y coordinates at top of hitbox
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = 'bold 12px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(`x:${Math.round(enemy.x)} y:${Math.round(enemy.y)}`, enemy.x, topY);
                });
                
                // Draw platform hitboxes
                battleState.platforms.forEach(platform => {
                    ctx.strokeStyle = '#FFFF00';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(platform.x, platform.y, platform.w, platform.h);
                });
            }
        }
        
        // Update turn info display
        function updateBattleTurnInfo() {
            const currentHero = battleState.turnOrder[battleState.currentTurn];
            const turnInfo = document.getElementById('battleTurnInfo');
            
            // Safety check: currentHero can be undefined if turnOrder is empty or currentTurn is out of bounds
            if (!currentHero) {
                if (turnInfo) turnInfo.textContent = 'Waiting...';
                return;
            }
            
            if (turnInfo) {
                let turnText = `${currentHero.name.toUpperCase()}'S TURN`;
                
                // Multiplayer: Show if it's you or waiting
                if (multiplayerState.enabled) {
                    if (multiplayerState.role === 'client') {
                        if (multiplayerState.myHeroes.includes(currentHero.name.toLowerCase())) {
                            turnText += ' (YOU)';
                        } else {
                            turnText = `Waiting for ${currentHero.name.toUpperCase()}...`;
                        }
                    }
                }
                
                turnInfo.textContent = turnText;
            }
            
            // Update active hero card highlighting
            document.querySelectorAll('.battleHeroCard').forEach(card => card.classList.remove('active'));
            const activeCard = document.getElementById(`battleCard${currentHero.name}`);
            if (activeCard) activeCard.classList.add('active');
            
            // Trigger myturn animation if hero has one (plays once, returns to idle)
            if (battleState.heroes.includes(currentHero) && currentHero.hp > 0) {
                const heroKey = currentHero.name.toLowerCase();
                const paths = HERO_ANIM_PATHS[heroKey];
                if (paths && paths.myturn) {
                    setAnimationState(currentHero, 'myturn', 'once', () => {
                        setAnimationState(currentHero, 'idle', 'pingpong');
                    });
                }
            }
            
            // Disable/enable buttons based on turn in multiplayer
            if (multiplayerState.enabled) {
                const isMyTurn = multiplayerState.myHeroes.includes(currentHero.name.toLowerCase());
                document.querySelectorAll('.battleButton').forEach(btn => {
                    // Always allow retreat/leave and talk buttons
                    if (btn.textContent.includes('RETREAT') || btn.textContent.includes('LEAVE') || btn.textContent.includes('TALK')) return;
                    btn.disabled = !isMyTurn;
                    btn.style.opacity = isMyTurn ? '1' : '0.3';
                });
            }
        }
        
        // Update gold display in both dungeon menu and battle screen
        function updateGoldDisplay() {
            let gold = 0;
            
            // Clients use cached gold from host, host/single-player use localStorage
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                gold = multiplayerState.goldCache || 0;
            } else {
                const sharedSave = loadSharedSave();
                gold = sharedSave?.dungeonState?.gold || 0;
            }
            
            const dungeonMenuGold = document.getElementById('dungeonMenuGold');
            const battleGold = document.getElementById('battleGold');
            
            if (dungeonMenuGold) dungeonMenuGold.textContent = gold;
            if (battleGold) battleGold.textContent = gold;
        }
        
        // Update battle hero card stats
        function updateBattleHeroCards() {
            // Include all heroes from original selection (alive or dead)
            const allHeroNames = ['nate', 'zooko', 'cyberaxe', 'zancas'];
            
            allHeroNames.forEach(heroName => {
                const hero = battleState.heroes.find(h => h.name.toLowerCase() === heroName);
                const card = document.getElementById(`battleCard${heroName.charAt(0).toUpperCase() + heroName.slice(1)}`);
                
                if (card) {
                    // Grey out if hero is dead/retreated
                    if (!hero || hero.hp <= 0 || hero.retreated) {
                        card.style.opacity = '0.3';
                        card.style.filter = 'grayscale(100%)';
                    } else {
                        card.style.opacity = '1';
                        card.style.filter = 'none';
                    }
                }
                
                if (!hero) return; // Skip if hero not in battle
                
                const hpEl = document.getElementById(`b${heroName}-hp`);
                const maxHpEl = document.getElementById(`b${heroName}-maxhp`);
                const acEl = document.getElementById(`b${heroName}-ac`);
                const xpEl = document.getElementById(`b${heroName}-xp`);
                const healsEl = document.getElementById(`b${heroName}-heals`);
                
                if (hpEl) hpEl.textContent = hero.hp;
                if (maxHpEl) maxHpEl.textContent = hero.maxHp;
                if (acEl) acEl.textContent = hero.stats.ac || 10;
                if (xpEl) xpEl.textContent = hero.xp || 0;
                
                // Update heal hearts display
                if (healsEl) {
                    const healsRemaining = hero.healsRemaining || 0;
                    let heartsHTML = '';
                    for (let i = 0; i < 2; i++) {
                        if (i < healsRemaining) {
                            heartsHTML += '‚ù§Ô∏è ';
                        } else {
                            heartsHTML += '‚ùå ';
                        }
                    }
                    healsEl.innerHTML = heartsHTML.trim();
                }
            });
        }
        
        // Update battle enemy cards
        function updateBattleEnemyCards() {
            const container = document.getElementById('battleEnemyCards');
            if (!container) return;
            
            // Sort enemies: bosses first, then mobs
            const sortedEnemies = [...battleState.enemies].sort((a, b) => {
                if (a.isMob === b.isMob) return 0;
                return a.isMob ? 1 : -1; // Bosses (isMob=false) first
            });
            
            // Set 2-column layout if more than 6 enemies
            if (sortedEnemies.length > 6) {
                container.classList.add('twoColumns');
            } else {
                container.classList.remove('twoColumns');
            }
            
            // Clear and rebuild cards
            container.innerHTML = '';
            
            sortedEnemies.forEach((enemy, index) => {
                const card = document.createElement('div');
                card.className = 'battleEnemyCard';
                card.id = `enemyCard${index}`;
                card.dataset.enemyIndex = battleState.enemies.indexOf(enemy);
                
                // Check if this mob has betrayed and is now friendly
                const isBetrayed = enemy.negotiationState?.betrayed || !enemy.hostile;
                
                if (!enemy.isMob) {
                    card.classList.add('boss');
                }
                
                if (enemy.hp <= 0) {
                    card.classList.add('dead');
                }
                
                // Style betrayed mobs as friendly (green)
                if (isBetrayed && !enemy.isBoss) {
                    card.classList.add('friendly');
                    card.style.borderColor = '#00FF00';
                    card.style.boxShadow = '0 0 15px rgba(0, 255, 0, 0.4)';
                }
                
                // Add targetable class if in targeting mode and hostile
                if (battleState.targetingMode && enemy.hostile && enemy.hp > 0) {
                    card.classList.add('targetable');
                }
                
                // Portrait
                const portrait = document.createElement('div');
                portrait.className = 'battleEnemyPortrait';
                portrait.style.backgroundImage = `url('${enemy.spritePath}')`;
                // Green border for betrayed mobs
                if (isBetrayed && !enemy.isBoss) {
                    portrait.style.borderColor = '#00FF00';
                }
                card.appendChild(portrait);
                
                // Name - add ally indicator for betrayed mobs
                const name = document.createElement('div');
                name.className = 'battleEnemyName';
                if (isBetrayed && !enemy.isBoss) {
                    name.innerHTML = `ü§ù ${enemy.name.toUpperCase()}`;
                    name.style.color = '#00FF00';
                } else {
                    name.textContent = enemy.name.toUpperCase();
                }
                card.appendChild(name);
                
                // HP stat - green for betrayed mobs
                const hpStat = document.createElement('div');
                hpStat.className = 'battleEnemyStat';
                hpStat.style.color = isBetrayed && !enemy.isBoss ? '#00FF00' : '#ff6b6b';
                hpStat.innerHTML = `HP: <span>${enemy.hp}</span>/<span>${enemy.maxHp}</span>`;
                card.appendChild(hpStat);
                
                // AC stat
                const acStat = document.createElement('div');
                acStat.className = 'battleEnemyStat';
                acStat.innerHTML = `AC: <span>${enemy.ac || 10}</span>`;
                card.appendChild(acStat);
                
                // Gold stat (public ledger - enemies use Bitcoin/gold, not Zcash!)
                const goldStat = document.createElement('div');
                goldStat.className = 'battleEnemyStat';
                goldStat.style.color = '#FFD700';
                goldStat.innerHTML = `üí∞ <span>${enemy.goldDrop || 0}</span>`;
                card.appendChild(goldStat);
                
                // Click handler for targeting
                card.addEventListener('click', () => {
                    if (battleState.targetingMode && enemy.hostile && enemy.hp > 0) {
                        const attacker = battleState.turnOrder[battleState.currentTurn];
                        executeAttack(attacker, enemy, battleState.pendingAction);
                        
                        // Exit targeting mode
                        battleState.targetingMode = false;
                        battleState.pendingAction = null;
                        document.getElementById('battleCanvas').style.cursor = 'default';
                        updateBattleEnemyCards(); // Refresh to remove targetable class
                    }
                });
                
                container.appendChild(card);
            });
            
            // Add captive card if present and not rescued
            if (battleState.captiveNpc && !battleState.captiveNpc.rescued) {
                const captive = battleState.captiveNpc;
                const card = document.createElement('div');
                card.className = 'battleEnemyCard captive';
                card.id = 'captiveCard';
                
                // Portrait
                const portrait = document.createElement('div');
                portrait.className = 'battleEnemyPortrait';
                portrait.style.backgroundImage = `url('${captive.spritePath}')`;
                card.appendChild(portrait);
                
                // Name with chain emoji
                const name = document.createElement('div');
                name.className = 'battleEnemyName';
                name.textContent = `‚õìÔ∏è ${captive.name.toUpperCase()}`;
                card.appendChild(name);
                
                // HP stat
                const hpStat = document.createElement('div');
                hpStat.className = 'battleEnemyStat';
                hpStat.style.color = '#27AE60';
                hpStat.innerHTML = `HP: <span>${captive.hp || '?'}</span>/<span>${captive.maxHp || '?'}</span>`;
                card.appendChild(hpStat);
                
                // AC stat
                const acStat = document.createElement('div');
                acStat.className = 'battleEnemyStat';
                acStat.innerHTML = `AC: <span>${captive.ac || 10}</span>`;
                card.appendChild(acStat);
                
                // Gold stat (captive's reward - public on Bitcoin/gold network!)
                const goldStat = document.createElement('div');
                goldStat.className = 'battleEnemyStat';
                goldStat.style.color = '#FFD700';
                goldStat.innerHTML = `üí∞ <span>${captive.goldReward || 0}</span>`;
                card.appendChild(goldStat);
                
                // "CAPTIVE" label
                const label = document.createElement('div');
                label.className = 'battleEnemyStat';
                label.style.color = '#F2C94C';
                label.style.fontWeight = 'bold';
                label.textContent = 'CAPTIVE';
                card.appendChild(label);
                
                container.appendChild(card);
            }
        }
        
        // D&D modifier calculation
        function calculateModifier(stat) {
            return Math.floor((stat - 10) / 2);
        }
        
        // Find closest hero to an enemy
        function findClosestHero(enemy, heroes) {
            let target = heroes[0];
            let minDistance = Math.sqrt(Math.pow(enemy.x - target.x, 2) + Math.pow(enemy.y - target.y, 2));
            
            for (let i = 1; i < heroes.length; i++) {
                const hero = heroes[i];
                const distance = Math.sqrt(Math.pow(enemy.x - hero.x, 2) + Math.pow(enemy.y - hero.y, 2));
                if (distance < minDistance) {
                    minDistance = distance;
                    target = hero;
                }
            }
            return target;
        }
        
        // Dice rolling functions
        function rollD20() {
            return Math.floor(Math.random() * 20) + 1;
        }
        
        function rollD6(count = 1) {
            let total = 0;
            for (let i = 0; i < count; i++) {
                total += Math.floor(Math.random() * 6) + 1;
            }
            return total;
        }
        
        // Dice roll ticker system
        let diceRollTickerInterval = null;
        const diceRollTickerMessages = [
            '‚è≥ ...Waiting to Roll... ‚è≥',
            'üéÆ ...Tunnels of Privacy... üéÆ',
            '...Created by CyberAxe for Zcash...'
        ];
        let diceRollTickerIndex = 0;
        let diceRollTickerCharIndex = 0;
        let currentMessage = '';
        
        function startDiceRollTicker() {
            if (diceRollTickerInterval) return; // Already running
            const display = document.getElementById('diceRollDisplay');
            if (display) {
                display.style.overflow = 'visible';
                display.style.whiteSpace = 'normal';
            }
            
            // Waterfall effect: reveal text from center outward
            diceRollTickerInterval = setInterval(() => {
                const display = document.getElementById('diceRollDisplay');
                if (display) {
                    const message = diceRollTickerMessages[diceRollTickerIndex];
                    const totalLength = message.length;
                    
                    if (diceRollTickerCharIndex < totalLength) {
                        // Build text from center outward
                        const center = Math.floor(totalLength / 2);
                        const revealRadius = Math.floor(diceRollTickerCharIndex / 2);
                        
                        let visibleText = '';
                        for (let i = 0; i < totalLength; i++) {
                            const distanceFromCenter = Math.abs(i - center);
                            if (distanceFromCenter <= revealRadius) {
                                visibleText += message[i];
                            } else {
                                visibleText += ' ';
                            }
                        }
                        
                        display.innerHTML = visibleText;
                        diceRollTickerCharIndex++;
                    } else {
                        // Hold full message for 2 seconds
                        if (diceRollTickerCharIndex === totalLength) {
                            display.innerHTML = message;
                        }
                        diceRollTickerCharIndex++;
                        
                        // After holding, move to next message
                        if (diceRollTickerCharIndex > totalLength + 13) { // 13 frames * 150ms ‚âà 2 seconds
                            diceRollTickerIndex = (diceRollTickerIndex + 1) % diceRollTickerMessages.length;
                            diceRollTickerCharIndex = 0;
                        }
                    }
                }
            }, 150);
        }
        
        function stopDiceRollTicker() {
            if (diceRollTickerInterval) {
                clearInterval(diceRollTickerInterval);
                diceRollTickerInterval = null;
                diceRollTickerIndex = 0;
                diceRollTickerCharIndex = 0;
            }
        }
        
        // Display dice roll result
        function showDiceRoll(text) {
            const display = document.getElementById('diceRollDisplay');
            if (display) {
                stopDiceRollTicker();
                display.style.overflow = 'visible';
                display.style.whiteSpace = 'normal';
                display.innerHTML = text;
                display.style.display = 'block';
                setTimeout(() => {
                    display.style.overflow = 'hidden';
                    display.style.whiteSpace = 'nowrap';
                    diceRollTickerPosition = 0;
                    startDiceRollTicker();
                }, 3000);
            }
        }
        
        // Show battle notification banner
        function showBattleNotification(text) {
            const notification = document.getElementById('battleNotification');
            if (notification) {
                notification.textContent = text;
                notification.style.display = 'block';
                setTimeout(() => {
                    notification.style.display = 'none';
                }, 3000);
            }
        }
        
        // Confirmation modal system
        let confirmationCallback = null;
        
        function showConfirmation(title, message, callback) {
            document.getElementById('confirmationTitle').textContent = title;
            document.getElementById('confirmationMessage').textContent = message;
            confirmationCallback = callback;
            document.getElementById('confirmationModal').style.display = 'block';
        }
        
        function confirmModalAction(confirmed) {
            document.getElementById('confirmationModal').style.display = 'none';
            if (confirmationCallback) {
                confirmationCallback(confirmed);
                confirmationCallback = null;
            }
        }
        
        // Handle battle actions
        function battleAction(action) {
            if (action === 'retreat') {
                // Check if battle is won (leave instead of retreat)
                if (battleState.won && multiplayerState.enabled) {
                    // Only host can leave after victory - clients wait
                    if (multiplayerState.role === 'host') {
                        // Host clicked leave - end battle for everyone
                        sendWebSocketMessage({ type: 'battle_end', reason: 'victory' });
                        setTimeout(() => {
                            endBattle();
                        }, 1000);
                    } else {
                        // Client clicked leave - show persistent message to wait for host
                        const notification = document.getElementById('battleNotification');
                        if (notification) {
                            notification.textContent = 'Waiting for host to leave...';
                            notification.style.display = 'block';
                            // Don't auto-hide - will hide when battle_end is received
                        }
                    }
                    return;
                }
                
                // Regular retreat logic (battle not won)
                if (multiplayerState.enabled) {
                    multiplayerState.myHeroes.forEach(heroName => {
                        const hero = battleState.heroes.find(h => h.name.toLowerCase() === heroName);
                        if (hero) {
                            hero.retreated = true;
                        }
                    });
                    
                    if (multiplayerState.role === 'host') {
                        // Save all heroes for stat persistence (before filtering)
                        // Merge with existing allHeroes to preserve previously retreated heroes
                        if (battleState.allHeroes.length === 0) {
                            battleState.allHeroes = [...battleState.heroes];
                        } else {
                            // Add any heroes not already in allHeroes
                            battleState.heroes.forEach(hero => {
                                if (!battleState.allHeroes.find(h => h.name === hero.name)) {
                                    battleState.allHeroes.push(hero);
                                }
                            });
                        }
                        
                        // Remove retreated heroes from arrays
                        battleState.heroes = battleState.heroes.filter(h => !h.retreated);
                        battleState.turnOrder = battleState.turnOrder.filter(combatant => {
                            if (battleState.heroes.includes(combatant)) return true;
                            if (battleState.enemies.includes(combatant)) return combatant.hp > 0;
                            return false;
                        });
                        
                        // Update UI and broadcast
                        updateBattleHeroCards();
                        renderBattle();
                        broadcastGameState();
                        
                        // Check if any heroes still alive
                        if (battleState.heroes.length === 0) {
                            showBattleNotification('DEFEAT! ALL HEROES RETREATED!');
                            
                            // Notify clients to end battle
                            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                                sendWebSocketMessage({
                                    type: 'battle_end',
                                    reason: 'retreat'
                                });
                            }
                            
                            setTimeout(() => {
                                // Hide notification
                                const notification = document.getElementById('battleNotification');
                                if (notification) notification.style.display = 'none';
                                
                                endBattle();
                            }, 2000);
                        } else {
                            // Reset turn if current combatant was removed
                            const currentCombatant = battleState.turnOrder[battleState.currentTurn];
                            if (!currentCombatant) {
                                battleState.currentTurn = 0;
                                updateBattleTurnInfo();
                            }
                        }
                    } else {
                        // Client sends retreat to host
                        sendWebSocketMessage({
                            type: 'player_action',
                            action: 'retreat',
                            heroes: multiplayerState.myHeroes
                        });
                        
                        // Update local UI immediately
                        updateBattleHeroCards();
                        renderBattle();
                    }
                } else {
                    // Single player - just end battle
                    endBattle();
                }
                return;
            }
            
            // Talk action - toggle chat window (no turn cost, can use anytime)
            if (action === 'talk') {
                toggleChatWindow();
                return;
            }
            
            const currentCombatant = battleState.turnOrder[battleState.currentTurn];
            
            // Check if it's a hero's turn
            const isHeroTurn = battleState.heroes.includes(currentCombatant);
            
            if (!isHeroTurn) {
                console.log('Not hero turn');
                return;
            }
            
            // Multiplayer: Check if this is my hero
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                if (!multiplayerState.myHeroes.includes(currentCombatant.name.toLowerCase())) {
                    showDiceRoll('Not your turn!');
                    return;
                }
            }
            
            // Check if hero is disabled (0 HP)
            if (currentCombatant.hp <= 0) {
                showDiceRoll(`${currentCombatant.name} is disabled!`);
                advanceTurn();
                return;
            }
            
            // Reset defending state when hero takes a new action
            if (currentCombatant.defending) {
                currentCombatant.defending = false;
                // Reset from defend animation to idle
                const heroKey = currentCombatant.name.toLowerCase();
                const paths = HERO_ANIM_PATHS[heroKey];
                if (paths && paths.defend) {
                    setAnimationState(currentCombatant, 'idle', 'pingpong');
                }
            }
            
            // Enter targeting mode for attacks
            if (action === 'light' || action === 'heavy' || action === 'special') {
                // Multiplayer: Client enters targeting mode but won't execute until host confirms
                battleState.targetingMode = true;
                battleState.pendingAction = action;
                // Show targeting UI feedback
                document.getElementById('battleCanvas').style.cursor = 'crosshair';
                // Highlight enemies on canvas and cards
                updateBattleEnemyCards();
                renderBattle();
                return;
            }
            
            // Defend action - reduce damage by 50% until next turn
            if (action === 'defend') {
                // Multiplayer: Client sends to host
                if (multiplayerState.enabled && multiplayerState.role === 'client') {
                    sendWebSocketMessage({
                        type: 'player_action',
                        action: 'defend',
                        hero: currentCombatant.name
                    });
                    return;
                }
                
                currentCombatant.defending = true;
                
                // Trigger defend animation (ping-pong while defending)
                const heroKey = currentCombatant.name.toLowerCase();
                const paths = HERO_ANIM_PATHS[heroKey];
                if (paths && paths.defend) {
                    setAnimationState(currentCombatant, 'defend', 'pingpong');
                }
                
                showDiceRoll(`${currentCombatant.name} defends!`);
                advanceTurn();
                return;
            }
            
            // Heal action - restore 50% of max HP (costs 1 action point)
            if (action === 'heal') {
                if (currentCombatant.healsRemaining <= 0) {
                    showDiceRoll(`${currentCombatant.name} has no heals left!`);
                    return;
                }
                
                // Multiplayer: Client sends to host
                if (multiplayerState.enabled && multiplayerState.role === 'client') {
                    sendWebSocketMessage({
                        type: 'player_action',
                        action: 'heal',
                        hero: currentCombatant.name
                    });
                    return;
                }
                
                const healAmount = Math.floor(currentCombatant.maxHp * 0.5);
                currentCombatant.hp = Math.min(currentCombatant.maxHp, currentCombatant.hp + healAmount);
                currentCombatant.healsRemaining--;
                currentCombatant.usedHeal = true; // Mark that heal was used this turn
                
                // Trigger heal animation if hero has one (plays once, returns to idle)
                const heroKey = currentCombatant.name.toLowerCase();
                const paths = HERO_ANIM_PATHS[heroKey];
                if (paths && paths.heal) {
                    setAnimationState(currentCombatant, 'heal', 'once', () => {
                        setAnimationState(currentCombatant, 'idle', 'pingpong');
                    });
                }
                
                showDiceRoll(`${currentCombatant.name} heals for ${healAmount} HP! (1 action used)`);
                updateBattleHeroCards();
                
                // Disable heavy and special buttons after heal
                document.getElementById('battleHeavyBtn').disabled = true;
                document.getElementById('battleHeavyBtn').style.opacity = '0.5';
                document.getElementById('battleSpecialBtn').disabled = true;
                document.getElementById('battleSpecialBtn').style.opacity = '0.5';
                
                // Host broadcasts state
                if (multiplayerState.enabled && multiplayerState.role === 'host') {
                    broadcastGameState();
                }
                
                return; // Don't advance turn
            }
            
            // Swap action - swap positions with another hero
            if (action === 'swap') {
                // Multiplayer: Client enters swap targeting mode
                battleState.swapTargetingMode = true;
                battleState.swapInitiator = currentCombatant;
                document.getElementById('battleCanvas').style.cursor = 'pointer';
                showDiceRoll(`${currentCombatant.name}: Select a hero to swap with`);
                renderBattle();
                return;
            }
            
            // Taunt action - draw enemy aggro with CHA check
            if (action === 'taunt') {
                // Multiplayer: Client sends to host
                if (multiplayerState.enabled && multiplayerState.role === 'client') {
                    sendWebSocketMessage({
                        type: 'player_action',
                        action: 'taunt',
                        hero: currentCombatant.name
                    });
                    return;
                }
                
                const chaModifier = calculateModifier(currentCombatant.stats?.cha || 10);
                const tauntRoll = rollD20() + chaModifier;
                const tauntDC = 12; // Base difficulty
                
                // Trigger taunt animation if hero has one (plays once, returns to idle)
                const heroKey = currentCombatant.name.toLowerCase();
                const paths = HERO_ANIM_PATHS[heroKey];
                if (paths && paths.taunt) {
                    setAnimationState(currentCombatant, 'taunt', 'once', () => {
                        setAnimationState(currentCombatant, 'idle', 'pingpong');
                    });
                }
                
                if (tauntRoll >= tauntDC) {
                    currentCombatant.taunting = true;
                    currentCombatant.tauntTurns = 3; // Lasts 3 turns
                    showDiceRoll(`${currentCombatant.name} taunts! d20(${tauntRoll}) SUCCESS!`);
                } else {
                    showDiceRoll(`${currentCombatant.name} taunt fails! d20(${tauntRoll}) vs DC ${tauntDC}`);
                }
                advanceTurn();
                
                // Host broadcasts state
                if (multiplayerState.enabled && multiplayerState.role === 'host') {
                    broadcastGameState();
                }
                return;
            }
            
            // Skip action - end turn without doing anything
            if (action === 'skip') {
                // Multiplayer: Client sends to host
                if (multiplayerState.enabled && multiplayerState.role === 'client') {
                    sendWebSocketMessage({
                        type: 'player_action',
                        action: 'skip',
                        hero: currentCombatant.name
                    });
                    return;
                }
                
                showDiceRoll(`${currentCombatant.name} skips turn.`);
                advanceTurn();
                
                // Host broadcasts state
                if (multiplayerState.enabled && multiplayerState.role === 'host') {
                    broadcastGameState();
                }
                return;
            }
        }
        
        // Execute attack on target
        function executeAttack(attacker, target, actionType) {
            // Check if hero has attack animation
            const isHero = battleState.heroes.includes(attacker);
            const heroKey = isHero ? attacker.name.toLowerCase() : null;
            const animState = actionType + '_attack'; // 'light_attack', 'heavy_attack', 'special_attack'
            const paths = heroKey ? HERO_ANIM_PATHS[heroKey] : null;
            const hasAnimation = paths && paths[animState];
            
            // Trigger attack animation if hero has one
            if (hasAnimation) {
                setAnimationState(attacker, animState, 'once', () => {
                    setAnimationState(attacker, 'idle', 'pingpong');
                });
            }
            
            // Delay attack logic to sync with animation (2 seconds)
            const delay = hasAnimation ? 2000 : 0;
            
            setTimeout(() => {
                executeAttackLogic(attacker, target, actionType);
            }, delay);
        }
        
        // Actual attack logic (separated for animation delay)
        function executeAttackLogic(attacker, target, actionType) {
            const attackerStats = attacker.stats || {};
            const str = attackerStats.str || 10;
            const dex = attackerStats.dex || 10;
            const wis = attackerStats.wis || 10;
            
            let attackRoll = rollD20();
            let modifier = 0;
            let damageRoll = 0;
            let attackName = '';
            
            // Calculate attack and damage based on action type
            if (actionType === 'light') {
                modifier = calculateModifier(dex);
                attackRoll += calculateModifier(str);
                damageRoll = rollD6(1) + modifier;
                attackName = 'Light Attack';
            } else if (actionType === 'heavy') {
                modifier = calculateModifier(str);
                attackRoll += modifier;
                damageRoll = rollD6(2) + modifier;
                attackName = 'Heavy Attack';
            } else if (actionType === 'special') {
                modifier = calculateModifier(wis);
                attackRoll += modifier;
                damageRoll = rollD6(3) + modifier;
                attackName = 'Special Attack';
            }
            
            // Check if attack hits
            const targetAC = target.ac || 10;
            
            // Award 1 XP for attempting attack
            attacker.xp = (attacker.xp || 0) + 1;
            
            if (attackRoll >= targetAC) {
                // Apply defending reduction
                if (target.defending) {
                    damageRoll = Math.floor(damageRoll / 2);
                    target.defending = false;
                    
                    // Award 3 XP to defender for successfully defending
                    if (battleState.heroes.includes(target)) {
                        target.xp = (target.xp || 0) + 3;
                    }
                }
                
                target.hp = Math.max(0, target.hp - damageRoll);
                
                // Update boss morale when they take damage
                if (target.isBoss) {
                    updateBossMorale(target, 'took_damage');
                }
                
                // Trigger free will chat for damaged enemy
                if (battleState.enemies.includes(target) && target.hp > 0) {
                    if (target.hp < target.maxHp * 0.3) {
                        triggerFreeWillChat(target, 'low_health');
                    } else {
                        triggerFreeWillChat(target, 'took_damage');
                    }
                }
                
                // Trigger free will chat for attacker if enemy dealt damage
                if (battleState.enemies.includes(attacker)) {
                    triggerFreeWillChat(attacker, 'dealt_damage');
                }
                
                // Award 2 XP for hitting (total 3 including attempt)
                attacker.xp += 2;
                
                // Generate fake dice rolls for display
                const numDice = actionType === 'light' ? 1 : (actionType === 'heavy' ? 2 : 3);
                const diceRolls = [];
                for (let i = 0; i < numDice; i++) {
                    diceRolls.push(Math.floor(Math.random() * 6) + 1);
                }
                const diceTotal = diceRolls.reduce((a, b) => a + b, 0);
                showDiceRoll(`üé≤ Rolled: ${diceRolls.join(', ')} = <span style="color:#00ff00">${diceTotal}</span> vs <span style="color:#00ff00">${targetAC}</span> <span style="color:#00ff00">‚úì</span>`);
            } else {
                // Miss - award 1 XP to defender if they're a hero
                if (battleState.heroes.includes(target)) {
                    target.xp = (target.xp || 0) + 1;
                }
                // Generate fake dice rolls for display
                const numDice = actionType === 'light' ? 1 : (actionType === 'heavy' ? 2 : 3);
                const diceRolls = [];
                for (let i = 0; i < numDice; i++) {
                    diceRolls.push(Math.floor(Math.random() * 6) + 1);
                }
                const diceTotal = diceRolls.reduce((a, b) => a + b, 0);
                showDiceRoll(`üé≤ Rolled: ${diceRolls.join(', ')} = <span style="color:#ff0000">${diceTotal}</span> vs <span style="color:#ff0000">${targetAC}</span> <span style="color:#ff0000">‚úó</span>`);
            }
            
            renderBattle();
            updateBattleEnemyCards();
            updateBattleHeroCards();
            updateChatTargets();  // Update chat target buttons
            
            // Check if target is dead
            if (target.hp <= 0) {
                // Award 10 XP for killing blow
                attacker.xp += 10;
                
                // Award gold from enemy
                const goldDrop = target.goldDrop || (target.isBoss ? 100 : 10);
                const sharedSave = JSON.parse(localStorage.getItem('top_shared_save') || '{}');
                if (!sharedSave.dungeonState) sharedSave.dungeonState = {};
                sharedSave.dungeonState.gold = (sharedSave.dungeonState.gold || 0) + goldDrop;
                localStorage.setItem('top_shared_save', JSON.stringify(sharedSave));
                
                addChatMessage('System', 'system', null, `üí∞ ${attacker.name} looted ${goldDrop} gold from ${target.name}!`, false);
                updateGoldDisplay();
                updateBattleHeroCards();
                
                // Update boss morale when ally dies
                const boss = battleState.enemies.find(e => e.isBoss && e.hp > 0);
                if (boss && target !== boss) {
                    updateBossMorale(boss, 'ally_died');
                }
                
                // Remove from battle
                battleState.enemies = battleState.enemies.filter(e => e !== target);
                battleState.turnOrder = battleState.turnOrder.filter(c => c !== target);
                
                // Check win condition
                if (battleState.enemies.length === 0) {
                    battleState.won = true;
                    
                    // Award 100 XP to all heroes for clearing the room
                    battleState.heroes.forEach(hero => {
                        hero.xp = (hero.xp || 0) + 100;
                    });
                    updateBattleHeroCards();
                    
                    showBattleNotification('ROOM CLEARED!');
                    
                    // Rescue captive NPC if present
                    if (battleState.captiveNpc && !battleState.captiveNpc.rescued) {
                        battleState.captiveNpc.rescued = true;
                        setTimeout(() => {
                            // Show rescue dialogue
                            addChatMessage(
                                battleState.captiveNpc.name,
                                'friendly',
                                'people/zooko_a_head_compressed.png',
                                battleState.captiveNpc.dialogueOnRescue,
                                true,
                                battleState.captiveNpc.voiceType
                            );
                            
                            // Give reward
                            const reward = battleState.captiveNpc.rescueReward;
                            let rewardText = 'Rescued ' + battleState.captiveNpc.name + '!';
                            if (reward.gold) {
                                rewardText += ` +${reward.gold} gold`;
                            }
                            if (reward.item) {
                                rewardText += ` +${reward.item}`;
                            }
                            if (reward.info) {
                                setTimeout(() => {
                                    addChatMessage(
                                        battleState.captiveNpc.name,
                                        'friendly',
                                        'people/zooko_a_head_compressed.png',
                                        `*whispers* ${reward.info}`,
                                        true,
                                        battleState.captiveNpc.voiceType
                                    );
                                }, 2000);
                            }
                            showBattleNotification(rewardText);
                            
                            // Update UI to remove captive from chat targets and HUD
                            updateChatTargets();
                            updateBattleEnemyCards();
                        }, 1500);
                    }
                    
                    // Change retreat button to leave
                    const retreatBtn = document.querySelector('.battleButton.retreat');
                    if (retreatBtn) {
                        retreatBtn.textContent = 'üö™ LEAVE';
                    }
                    // Broadcast final state (includes captive.rescued = true)
                    if (multiplayerState.enabled && multiplayerState.role === 'host') {
                        broadcastGameState();
                    }
                    return;
                }
            }
            
            advanceTurn();
            
            // Broadcast state after action
            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                broadcastGameState();
            }
        }
        
        // Process AI turn
        function processAITurn(combatant) {
            if (!combatant.hostile) {
                // Check if this is a betrayed mob that should attack enemies
                if (combatant.negotiationState?.betrayed) {
                    // Betrayed mob attacks hostile enemies (prioritize boss)
                    const hostileEnemies = battleState.enemies.filter(e => e.hostile && e.hp > 0 && e !== combatant);
                    if (hostileEnemies.length > 0) {
                        // Prioritize boss
                        const boss = hostileEnemies.find(e => e.isBoss);
                        const target = boss || hostileEnemies[0];
                        
                        const attackRoll = rollD20();
                        const damage = combatant.attackDamage || rollD6(1);
                        
                        if (attackRoll >= (target.ac || 10)) {
                            target.hp = Math.max(0, target.hp - damage);
                            showDiceRoll(`ü§ù ${combatant.name} BETRAYS! Attacks ${target.name} for ${damage} damage!`);
                            
                            if (target.hp <= 0) {
                                showBattleNotification(`${target.name} defeated by betrayal!`);
                                battleState.enemies = battleState.enemies.filter(e => e !== target);
                                battleState.turnOrder = battleState.turnOrder.filter(c => c !== target);
                            }
                        } else {
                            showDiceRoll(`ü§ù ${combatant.name} attacks ${target.name}: MISS!`);
                        }
                        
                        renderBattle();
                        updateBattleEnemyCards();
                        advanceTurn();
                        return;
                    }
                }
                
                // Friendly/neutral NPCs skip turn
                showDiceRoll(`${combatant.name} waits...`);
                advanceTurn();
                return;
            }
            
            // Hostile AI: pick closest hero and attack
            const aliveHeroes = battleState.heroes.filter(h => h.hp > 0);
            if (aliveHeroes.length === 0) {
                // Game over
                showBattleNotification('DEFEAT! ALL HEROES FALLEN!');
                
                // Notify clients if multiplayer
                if (multiplayerState.enabled && multiplayerState.role === 'host') {
                    sendWebSocketMessage({
                        type: 'battle_end',
                        reason: 'defeat'
                    });
                }
                
                setTimeout(() => {
                    // Hide notification
                    const notification = document.getElementById('battleNotification');
                    if (notification) notification.style.display = 'none';
                    
                    endBattle();
                }, 2000);
                return;
            }
            
            // Check for taunting heroes first
            const tauntingHeroes = aliveHeroes.filter(h => h.taunting && h.tauntTurns > 0);
            let target;
            
            if (tauntingHeroes.length > 0) {
                // Roll to resist taunt
                const resistRoll = rollD20();
                const resistDC = 15; // Base resist DC
                
                if (resistRoll < resistDC) {
                    // Failed to resist, attack taunter
                    target = tauntingHeroes[0];
                    showDiceRoll(`${combatant.name} is taunted by ${target.name}!`);
                } else {
                    // Resisted taunt, clear taunt status
                    tauntingHeroes.forEach(h => {
                        h.taunting = false;
                        h.tauntTurns = 0;
                    });
                    showDiceRoll(`${combatant.name} resists taunt! d20(${resistRoll})`);
                    // Fall through to normal targeting
                    target = findClosestHero(combatant, aliveHeroes);
                }
            } else {
                // No taunters, find closest hero
                target = findClosestHero(combatant, aliveHeroes);
            }
            
            // AI attack roll
            const attackRoll = rollD20();
            const damage = combatant.attackDamage || rollD6(1);
            
            // Don't damage heroes already at 0 HP
            if (target.hp <= 0) {
                showDiceRoll(`${combatant.name} ignores disabled ${target.name}`);
                advanceTurn();
                return;
            }
            
            if (attackRoll >= (target.stats?.ac || 10)) {
                let finalDamage = damage;
                if (target.defending) {
                    finalDamage = Math.floor(damage / 2);
                    target.defending = false;
                    // Reset from defend animation (hit animation will play next)
                }
                
                target.hp = Math.max(0, target.hp - finalDamage);
                
                // Trigger hit animation if hero has one (and not knocked out)
                if (battleState.heroes.includes(target) && target.hp > 0) {
                    const heroKey = target.name.toLowerCase();
                    const paths = HERO_ANIM_PATHS[heroKey];
                    if (paths && paths.hit) {
                        setAnimationState(target, 'hit', 'once', () => {
                            setAnimationState(target, 'idle', 'pingpong');
                        });
                    }
                }
                
                showDiceRoll(`${combatant.name} attacks ${target.name}: HIT for ${finalDamage} damage!`);
                
                // Update boss morale on successful hit
                if (combatant.isBoss) {
                    updateBossMorale(combatant, 'hit_attack');
                }
            } else {
                showDiceRoll(`${combatant.name} attacks ${target.name}: MISS!`);
                
                // Update boss morale on missed attack
                if (combatant.isBoss) {
                    updateBossMorale(combatant, 'missed_attack');
                }
            }
            
            renderBattle();
            updateBattleHeroCards();
            updateBattleEnemyCards();
            updateChatTargets();  // Update chat target buttons
            
            // Broadcast AI action to clients
            broadcastGameState();
            
            // Check if hero died
            if (target.hp <= 0) {
                // Trigger knockout animation if available
                if (battleState.heroes.includes(target)) {
                    const heroKey = target.name.toLowerCase();
                    const paths = HERO_ANIM_PATHS[heroKey];
                    if (paths && paths.knockout) {
                        setAnimationState(target, 'knockout', 'once');
                    }
                }
                
                const allHeroesDead = battleState.heroes.every(h => h.hp <= 0);
                if (allHeroesDead) {
                    showBattleNotification('DEFEAT! ALL HEROES FALLEN!');
                    
                    // Notify clients if multiplayer
                    if (multiplayerState.enabled && multiplayerState.role === 'host') {
                        sendWebSocketMessage({
                            type: 'battle_end',
                            reason: 'defeat'
                        });
                    }
                    
                    setTimeout(() => {
                        // Hide notification
                        const notification = document.getElementById('battleNotification');
                        if (notification) notification.style.display = 'none';
                        
                        endBattle();
                    }, 2000);
                    return;
                }
            }
            
            // Check for enraged double attack
            if (shouldDoDoubleAttack(combatant)) {
                // Do a second attack after a short delay
                setTimeout(() => {
                    if (combatant.hp > 0 && battleState.active) {
                        const stillAliveHeroes = battleState.heroes.filter(h => h.hp > 0);
                        if (stillAliveHeroes.length > 0) {
                            const secondTarget = findClosestHero(combatant, stillAliveHeroes);
                            const secondRoll = rollD20();
                            const secondDamage = combatant.attackDamage || rollD6(1);
                            
                            if (secondRoll >= (secondTarget.stats?.ac || 10)) {
                                let finalDmg = secondDamage;
                                if (secondTarget.defending) {
                                    finalDmg = Math.floor(secondDamage / 2);
                                    secondTarget.defending = false;
                                }
                                secondTarget.hp = Math.max(0, secondTarget.hp - finalDmg);
                                showDiceRoll(`‚ö° ${combatant.name} RAGE ATTACK: ${finalDmg} damage to ${secondTarget.name}!`);
                            } else {
                                showDiceRoll(`‚ö° ${combatant.name} rage attack MISSES ${secondTarget.name}!`);
                            }
                            renderBattle();
                            updateBattleHeroCards();
                            
                            // Check for hero death
                            if (secondTarget.hp <= 0) {
                                const allDead = battleState.heroes.every(h => h.hp <= 0);
                                if (allDead) {
                                    showBattleNotification('DEFEAT!');
                                    setTimeout(() => endBattle(), 2000);
                                    return;
                                }
                            }
                        }
                    }
                    advanceTurn();
                }, 800);
                return;  // Don't advance turn yet - wait for double attack
            }
            
            advanceTurn();
        }
        
        // Advance to next turn
        function advanceTurn() {
            battleState.currentTurn = (battleState.currentTurn + 1) % battleState.turnOrder.length;
            const nextCombatant = battleState.turnOrder[battleState.currentTurn];
            
            // Reset action state for new turn
            battleState.heroes.forEach(hero => {
                hero.usedHeal = false;
            });
            
            // Re-enable all buttons at start of turn
            const heavyBtn = document.getElementById('battleHeavyBtn');
            const specialBtn = document.getElementById('battleSpecialBtn');
            if (heavyBtn) {
                heavyBtn.disabled = false;
                heavyBtn.style.opacity = '1';
            }
            if (specialBtn) {
                specialBtn.disabled = false;
                specialBtn.style.opacity = '1';
            }
            
            // Decrement taunt turns for all heroes
            battleState.heroes.forEach(hero => {
                if (hero.tauntTurns > 0) {
                    hero.tauntTurns--;
                    if (hero.tauntTurns <= 0) {
                        hero.taunting = false;
                    }
                }
            });
            
            updateBattleTurnInfo();
            
            // Broadcast turn advancement to clients
            broadcastGameState();
            
            // Auto-skip if current combatant has 0 HP or is retreated
            if (nextCombatant && (nextCombatant.hp <= 0 || nextCombatant.retreated)) {
                if (battleState.heroes.includes(nextCombatant)) {
                    showDiceRoll(`${nextCombatant.name} is disabled - skipping turn`);
                }
                setTimeout(() => advanceTurn(), 500);
                return;
            }
            
            // If next turn is AI, process automatically
            if (!battleState.heroes.includes(nextCombatant)) {
                setTimeout(() => processAITurn(nextCombatant), 1000);
            }
        }
        
        // End battle and return to dungeon menu
        function endBattle() {
            // Save hero stats to shared save
            const sharedSave = loadSharedSave();
            if (sharedSave && sharedSave.heroes) {
                // Use allHeroes to include dead/retreated heroes
                const heroesToSave = battleState.allHeroes.length > 0 ? battleState.allHeroes : battleState.heroes;
                
                heroesToSave.forEach(hero => {
                    const heroKey = hero.name.toLowerCase();
                    if (sharedSave.heroes[heroKey]) {
                        // Save all stats back to save file
                        sharedSave.heroes[heroKey].hp = hero.hp ?? 0;
                        sharedSave.heroes[heroKey].maxHp = hero.maxHp ?? 0;
                        sharedSave.heroes[heroKey].str = hero.stats?.str ?? sharedSave.heroes[heroKey].str;
                        sharedSave.heroes[heroKey].dex = hero.stats?.dex ?? sharedSave.heroes[heroKey].dex;
                        sharedSave.heroes[heroKey].con = hero.stats?.con ?? sharedSave.heroes[heroKey].con;
                        sharedSave.heroes[heroKey].int = hero.stats?.int ?? sharedSave.heroes[heroKey].int;
                        sharedSave.heroes[heroKey].wis = hero.stats?.wis ?? sharedSave.heroes[heroKey].wis;
                        sharedSave.heroes[heroKey].cha = hero.stats?.cha ?? sharedSave.heroes[heroKey].cha;
                        sharedSave.heroes[heroKey].xp = hero.xp ?? 0;
                        sharedSave.heroes[heroKey].level = hero.level ?? 1;
                    }
                });
                
                // Save current dungeon level
                const dungeonLevelEl = document.getElementById('dungeonMenuLevel');
                if (dungeonLevelEl && sharedSave.dungeonState) {
                    sharedSave.dungeonState.currentLevel = parseInt(dungeonLevelEl.textContent) || 1;
                }
                
                saveSharedSave(sharedSave);
                
                // Host saves to localStorage only - clients will update from next state_update
            }
            
            battleState.active = false;
            currentScreen = 'dungeonMenu';
            document.getElementById('battleScreen').style.display = 'none';
            document.getElementById('dungeonMenuScreen').style.display = 'block';
            
            // Move music controls back to center
            document.getElementById('musicControls').classList.remove('battleActive');
            document.getElementById('musicControls').classList.add('dungeonMenuActive');
            document.getElementById('musicTicker').classList.remove('battleActive');
            document.getElementById('musicTicker').classList.add('dungeonMenuActive');
            
            // Update dungeon menu hero displays with saved stats
            updateDungeonMenuHeroes();
            updateGoldDisplay();
            
            // Move music controls and ticker back to center bottom
            document.getElementById('musicControls').classList.remove('battleActive');
            document.getElementById('musicTicker').classList.remove('battleActive');
            
            // Clear battle chat
            clearBattleChat();
            
            // Pre-generate next encounter while player is in dungeon menu
            preGenerateNextEncounter();
        }
        
        // ===== END BATTLE SYSTEM =====
        
        // Exit portal and return to arcade game
        function exitPortal() {
            try {
                // Load shared save
                const sharedSave = loadSharedSave();
                if (!sharedSave) {
                    alert('No shared save found! Cannot return to arcade.');
                    return;
                }
                
                // Get current dungeon level
                const dungeonLevelEl = document.getElementById('dungeonMenuLevel') || document.getElementById('dungeonLevel');
                const currentLevel = dungeonLevelEl ? (parseInt(dungeonLevelEl.textContent) || 1) : 1;
                
                // Update dungeon state
                sharedSave.dungeonState = {
                    currentLevel: currentLevel,
                    inventory: sharedSave.dungeonState?.inventory || [],
                    gold: sharedSave.dungeonState?.gold || 0,
                    questProgress: sharedSave.dungeonState?.questProgress || {
                        hasScepter: false,
                        hasReturned: false,
                        bossesDefeated: []
                    }
                };
                sharedSave.lastPlayed = Date.now();
                
                // Save updated shared state
                saveSharedSave(sharedSave);
                
                // Navigate back to arcade
                window.location.href = 'zlock_consensus.html';
            } catch (e) {
                console.error('Failed to exit portal:', e);
                alert('Portal exit failed! ' + e.message);
            }
        }
        
        // Update hero stat display (both title and dungeon screens)
        function updateHeroDisplay(heroName, stats) {
            const prefix = heroName.toLowerCase();
            
            // Title screen hero stats
            const levelEl = document.getElementById(`${prefix}-level`);
            const hpEl = document.getElementById(`${prefix}-hp`);
            const maxhpEl = document.getElementById(`${prefix}-maxhp`);
            const strEl = document.getElementById(`${prefix}-str`);
            const dexEl = document.getElementById(`${prefix}-dex`);
            const conEl = document.getElementById(`${prefix}-con`);
            const intEl = document.getElementById(`${prefix}-int`);
            const wisEl = document.getElementById(`${prefix}-wis`);
            const chaEl = document.getElementById(`${prefix}-cha`);
            const xpEl = document.getElementById(`${prefix}-xp`);
            
            // Dungeon screen hero stats (prefixed with 'd')
            const dhpEl = document.getElementById(`d${prefix}-hp`);
            const dmaxhpEl = document.getElementById(`d${prefix}-maxhp`);
            const dxpEl = document.getElementById(`d${prefix}-xp`);
            const dstrEl = document.getElementById(`d${prefix}-str`);
            const ddexEl = document.getElementById(`d${prefix}-dex`);
            const dconEl = document.getElementById(`d${prefix}-con`);
            const dintEl = document.getElementById(`d${prefix}-int`);
            const dwisEl = document.getElementById(`d${prefix}-wis`);
            const dchaEl = document.getElementById(`d${prefix}-cha`);
            
            // Update title screen
            if (levelEl) levelEl.textContent = stats.level || 1;
            if (hpEl) hpEl.textContent = stats.hp || 0;
            if (maxhpEl) maxhpEl.textContent = stats.maxHp || 0;
            if (strEl) strEl.textContent = stats.str || 0;
            if (dexEl) dexEl.textContent = stats.dex || 0;
            if (conEl) conEl.textContent = stats.con || 0;
            if (intEl) intEl.textContent = stats.int || 0;
            if (wisEl) wisEl.textContent = stats.wis || 0;
            if (chaEl) chaEl.textContent = stats.cha || 0;
            if (xpEl) xpEl.textContent = stats.xp || 0;
            
            // Update dungeon screen
            if (dhpEl) dhpEl.textContent = stats.hp || 0;
            if (dmaxhpEl) dmaxhpEl.textContent = stats.maxHp || 0;
            if (dxpEl) dxpEl.textContent = stats.xp || 0;
            if (dstrEl) dstrEl.textContent = stats.str || 0;
            if (ddexEl) ddexEl.textContent = stats.dex || 0;
            if (dconEl) dconEl.textContent = stats.con || 0;
            if (dintEl) dintEl.textContent = stats.int || 0;
            if (dwisEl) dwisEl.textContent = stats.wis || 0;
            if (dchaEl) dchaEl.textContent = stats.cha || 0;
        }
        
        // Update dungeon menu hero stats from save
        function updateDungeonMenuHeroes() {
            // Clients use cached stats from host broadcasts, host uses localStorage
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                // Client: Display from cache
                updateHeroDisplay('zooko', multiplayerState.heroStatsCache.zooko || {});
                updateHeroDisplay('nate', multiplayerState.heroStatsCache.nate || {});
                updateHeroDisplay('zancas', multiplayerState.heroStatsCache.zancas || {});
                updateHeroDisplay('cyberaxe', multiplayerState.heroStatsCache.cyberaxe || {});
            } else {
                // Host or solo: Load from localStorage
                const sharedSave = loadSharedSave();
                if (!sharedSave || !sharedSave.heroes) return;
                
                updateHeroDisplay('zooko', sharedSave.heroes.zooko);
                updateHeroDisplay('nate', sharedSave.heroes.nate);
                updateHeroDisplay('zancas', sharedSave.heroes.zancas);
                updateHeroDisplay('cyberaxe', sharedSave.heroes.cyberaxe);
            }
        }
        
        // Refresh all game data and broadcast to clients
        function refreshGameData() {
            const sharedSave = loadSharedSave();
            
            if (!sharedSave) {
                showNotification('No save data found', 'error');
                return;
            }
            
            // Update local displays
            updateDungeonMenuHeroes();
            
            // If multiplayer host, broadcast current game state
            if (multiplayerState.enabled && multiplayerState.role === 'host' && battleState.active) {
                broadcastGameState();
                showNotification('Data refreshed and synced to all players', 'success');
            } else if (multiplayerState.enabled && multiplayerState.role === 'client') {
                showNotification('Data refreshed from cache', 'info');
            } else {
                showNotification('Data refreshed', 'success');
            }
        }
        
        // Start adventure - switch from title to dungeon menu
        function startAdventure() {
            // Check if save exists and warn user
            const existingSave = loadSharedSave();
            if (existingSave && (existingSave.arcadeState || existingSave.dungeonState)) {
                showConfirmation(
                    'START NEW ADVENTURE?',
                    'This will replace your current save game. Save to file first if you want to keep your progress!',
                    (confirmed) => {
                        if (!confirmed) return;
                        proceedWithNewAdventure();
                    }
                );
                return;
            }
            
            // No save exists, proceed directly
            proceedWithNewAdventure();
        }
        
        function proceedWithNewAdventure() {
            const titleScreen = document.getElementById('titleScreen');
            const dungeonMenuScreen = document.getElementById('dungeonMenuScreen');
            
            if (titleScreen) titleScreen.style.display = 'none';
            if (dungeonMenuScreen) dungeonMenuScreen.style.display = 'block';
            
            currentScreen = 'dungeonMenu';
            
            // Center music controls for dungeon menu
            document.getElementById('musicControls').classList.add('dungeonMenuActive');
            document.getElementById('musicTicker').classList.add('dungeonMenuActive');
            
            // Create fresh save
            let sharedSave = createDefaultSharedSave();
            saveSharedSave(sharedSave);
            
            // Sync dungeon level display
            if (sharedSave && sharedSave.arcadeState && sharedSave.arcadeState.level) {
                const dungeonMenuLevel = document.getElementById('dungeonMenuLevel');
                if (dungeonMenuLevel) {
                    dungeonMenuLevel.textContent = sharedSave.arcadeState.level;
                }
            }
            
            // Load hero stats from save to dungeon menu
            updateDungeonMenuHeroes();
            
            // Apply client UI restrictions
            applyClientUIRestrictions();
            
            // If multiplayer host, notify clients to start and send save data
            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                sendWebSocketMessage({ 
                    type: 'game_start', 
                    screen: 'dungeonMenu',
                    saveData: sharedSave
                });
            }
        }
        
        // Apply client UI restrictions (disable host-only buttons)
        function applyClientUIRestrictions() {
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                const exploreLevelBtn = document.getElementById('exploreLevelBtn');
                if (exploreLevelBtn) {
                    exploreLevelBtn.disabled = true;
                    exploreLevelBtn.style.opacity = '0.5';
                    exploreLevelBtn.style.cursor = 'not-allowed';
                    exploreLevelBtn.innerHTML = 'EXPLORE LEVEL<br>(HOST/PARTY LEADER ONLY)';
                }
            }
        }
        
        // Pause game
        function pauseGame() {
            if (currentScreen === 'title') return; // Can't pause on title screen
            
            isPaused = true;
            const pauseScreen = document.getElementById('pauseScreen');
            if (pauseScreen) pauseScreen.style.display = 'flex';
            
            // Show resync button only for clients in multiplayer
            const resyncBtn = document.getElementById('resyncBtn');
            if (resyncBtn) {
                resyncBtn.style.display = (multiplayerState.enabled && multiplayerState.role === 'client') ? 'block' : 'none';
            }
        }
        
        // Request resync from host (client only)
        function requestResync() {
            if (!multiplayerState.enabled || multiplayerState.role !== 'client') {
                showNotification('Resync only available for clients', 'error');
                return;
            }
            
            multiplayerState.awaitingResync = true;
            sendWebSocketMessage({ type: 'request_resync' });
            showNotification('Requesting resync from host...', 'info');
        }
        
        // Resume game
        function resumeGame() {
            isPaused = false;
            const pauseScreen = document.getElementById('pauseScreen');
            if (pauseScreen) pauseScreen.style.display = 'none';
        }
        
        // Save game from pause menu
        function saveGameFromPause() {
            try {
                let sharedSave = loadSharedSave();
                if (!sharedSave) {
                    // Create new save if none exists
                    sharedSave = createDefaultSharedSave();
                }
                
                // Update last played timestamp
                sharedSave.lastPlayed = Date.now();
                
                // Save to localStorage
                if (saveSharedSave(sharedSave)) {
                    alert('Game saved successfully!');
                    // Update button states to reflect save exists
                    updateTitleScreenButtons();
                } else {
                    alert('Failed to save game!');
                }
            } catch (e) {
                console.error('Save error:', e);
                alert('Error saving game: ' + e.message);
            }
        }
        
        // Download save file
        function downloadSaveFile() {
            try {
                const sharedSave = loadSharedSave();
                if (!sharedSave) {
                    alert('No save data to download!');
                    return;
                }
                
                // Update timestamp
                sharedSave.lastPlayed = Date.now();
                saveSharedSave(sharedSave);
                
                // Create filename with date/time
                const now = new Date();
                const dateStr = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
                const hours = now.getHours();
                const minutes = String(now.getMinutes()).padStart(2, '0');
                const ampm = hours >= 12 ? 'pm' : 'am';
                const hour12 = hours % 12 || 12;
                const timeStr = `${hour12}_${minutes}_${ampm}`;
                
                const level = sharedSave.arcadeState ? sharedSave.arcadeState.level : 1;
                const filename = `tunnels-save-level${level}-${dateStr}-${timeStr}.json`;
                
                // Download JSON
                const jsonString = JSON.stringify(sharedSave, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                alert(`Save file downloaded: ${filename}`);
            } catch (e) {
                console.error('Download error:', e);
                alert('Error downloading save file: ' + e.message);
            }
        }
        
        // Show settings from pause
        function showSettingsFromPause() {
            showSettings();
        }
        
        // Quit to menu
        function quitToMenu() {
            // Save game state before quitting
            const sharedSave = loadSharedSave();
            if (sharedSave) {
                // Update dungeon level if visible
                const dungeonLevelEl = document.getElementById('dungeonMenuLevel');
                if (dungeonLevelEl && sharedSave.dungeonState) {
                    sharedSave.dungeonState.currentLevel = parseInt(dungeonLevelEl.textContent) || 1;
                }
                sharedSave.lastPlayed = Date.now();
                saveSharedSave(sharedSave);
            }
            
            isPaused = false;
            currentScreen = 'title';
            
            const pauseScreen = document.getElementById('pauseScreen');
            const dungeonMenuScreen = document.getElementById('dungeonMenuScreen');
            const titleScreen = document.getElementById('titleScreen');
            const battleScreen = document.getElementById('battleScreen');
            
            if (pauseScreen) pauseScreen.style.display = 'none';
            if (dungeonMenuScreen) dungeonMenuScreen.style.display = 'none';
            if (battleScreen) battleScreen.style.display = 'none';
            if (titleScreen) titleScreen.style.display = 'block';
            
            // Reset music controls to title screen position (bottom left)
            document.getElementById('musicControls').classList.remove('dungeonMenuActive');
            document.getElementById('musicTicker').classList.remove('dungeonMenuActive');
            
            // Reload hero stats from save
            const savedData = loadSharedSave();
            const heroStatsEl = document.getElementById('heroStats');
            
            if (savedData && savedData.heroes) {
                // Show hero party
                if (heroStatsEl) heroStatsEl.style.display = 'block';
                
                // Update each hero's display
                updateHeroDisplay('zooko', savedData.heroes.zooko);
                updateHeroDisplay('nate', savedData.heroes.nate);
                updateHeroDisplay('zancas', savedData.heroes.zancas);
                updateHeroDisplay('cyberaxe', savedData.heroes.cyberaxe);
            } else {
                // Hide hero party when no save exists
                if (heroStatsEl) heroStatsEl.style.display = 'none';
            }
        }
        
        // ESC key listener
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                e.preventDefault();
                
                // Close all panels first
                const overlay = document.getElementById('overlay');
                const settingsPanel = document.getElementById('settingsPanel');
                const loadSavePanel = document.getElementById('loadSavePanel');
                
                if (overlay && overlay.style.display === 'block') {
                    closeAllPanels();
                    return;
                }
                
                // Toggle pause
                if (isPaused) {
                    resumeGame();
                } else {
                    pauseGame();
                }
            }
        });
        
        // ===== GAMEPAD FUNCTIONS =====
        function onGamepadConnected(e) {
            gamepadConnected = true;
            gamepadIndex = e.gamepad.index;
            console.log(`üéÆ Controller Connected: ${e.gamepad.id}`);
        }
        
        function onGamepadDisconnected(e) {
            if (e.gamepad.index === gamepadIndex) {
                gamepadConnected = false;
                gamepadIndex = null;
                gamepadButtonStates = {};
                console.log('üéÆ Controller Disconnected');
            }
        }
        
        function updateGamepad() {
            if (!gamepadConnected || gamepadIndex === null) return;
            
            // Don't process gamepad input while loading modal is visible
            const loadingModal = document.getElementById('loadingModal');
            if (loadingModal && loadingModal.style.display !== 'none') return;
            
            const now = Date.now();
            if (now - lastGamepadUpdate < gamepadUpdateInterval) return;
            lastGamepadUpdate = now;
            
            const gamepads = navigator.getGamepads();
            const gamepad = gamepads[gamepadIndex];
            
            if (!gamepad) return;
            
            // Process buttons
            gamepad.buttons.forEach((button, index) => {
                const wasPressed = gamepadButtonStates[index] || false;
                const isPressed = button.pressed;
                
                // Button just pressed (rising edge)
                if (isPressed && !wasPressed) {
                    handleGamepadButtonPress(index);
                }
                
                gamepadButtonStates[index] = isPressed;
            });
        }
        
        function handleGamepadButtonPress(buttonIndex) {
            // ===== SETTINGS PANEL NAVIGATION =====
            const settingsPanel = document.getElementById('settingsPanel');
            if (settingsPanel && settingsPanel.style.display === 'block') {
                // B button - Close
                if (buttonIndex === GamepadButtons.B) {
                    closeAllPanels();
                    return;
                }
                return; // Block all other inputs when settings is open
            }
            // ===== END SETTINGS PANEL NAVIGATION =====
            
            // ===== LOAD SAVE PANEL NAVIGATION =====
            const loadSavePanel = document.getElementById('loadSavePanel');
            if (loadSavePanel && loadSavePanel.style.display === 'block') {
                // B button - Close
                if (buttonIndex === GamepadButtons.B) {
                    closeAllPanels();
                    return;
                }
                return; // Block all other inputs when load save panel is open
            }
            // ===== END LOAD SAVE PANEL NAVIGATION =====
            
            // ===== TITLE SCREEN NAVIGATION =====
            if (currentScreen === 'title') {
                // A button - Start Adventure
                if (buttonIndex === GamepadButtons.A) {
                    startAdventure();
                    return;
                }
                // Y button - Settings
                else if (buttonIndex === GamepadButtons.Y) {
                    showSettings();
                    return;
                }
                // B button - Load Save File
                else if (buttonIndex === GamepadButtons.B) {
                    showLoadSave();
                    return;
                }
                // BACK button (SELECT) - Exit Portal
                else if (buttonIndex === GamepadButtons.SELECT) {
                    exitPortal();
                    return;
                }
            }
            // ===== END TITLE SCREEN NAVIGATION =====
            
            // ===== PAUSE MENU NAVIGATION =====
            if (isPaused) {
                // A button - Resume
                if (buttonIndex === GamepadButtons.A) {
                    resumeGame();
                    return;
                }
                // B button - Resume (also works)
                else if (buttonIndex === GamepadButtons.B) {
                    resumeGame();
                    return;
                }
                // Y button - Settings
                else if (buttonIndex === GamepadButtons.Y) {
                    showSettingsFromPause();
                    return;
                }
                // SELECT button - Quit to Menu
                else if (buttonIndex === GamepadButtons.SELECT) {
                    quitToMenu();
                    return;
                }
            }
            // ===== END PAUSE MENU NAVIGATION =====
            
            // START button - Pause/Resume
            if (buttonIndex === GamepadButtons.START) {
                if (currentScreen === 'title') return; // Can't pause on title screen
                
                if (isPaused) {
                    resumeGame();
                } else {
                    pauseGame();
                }
                return;
            }
        }
        
        // Poll gamepad in animation loop
        function gamepadLoop() {
            updateGamepad();
            requestAnimationFrame(gamepadLoop);
        }
        
        // Gamepad polling for Click to Enter
        function pollGamepadForClickToPlay() {
            const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
            for (let i = 0; i < gamepads.length; i++) {
                const gp = gamepads[i];
                if (gp && gp.buttons[0] && gp.buttons[0].pressed) { // A button
                    const clickToPlayPrompt = document.getElementById('clickToPlayPrompt');
                    if (clickToPlayPrompt && clickToPlayPrompt.style.display !== 'none') {
                        clickToPlayPrompt.click();
                        return;
                    }
                }
            }
            
            // Continue polling if loading modal is visible
            const loadingModal = document.getElementById('loadingModal');
            if (loadingModal && loadingModal.style.display !== 'none') {
                requestAnimationFrame(pollGamepadForClickToPlay);
            }
        }
        // ===== END GAMEPAD FUNCTIONS =====
        
        // Initialize on page load
        // Preload images and audio into browser cache
        function preloadAssets() {
            const imageList = [
                // Story intro background
                'story/intro/intro_a.png',
                // Character head icons
                'people/zooko_a_head_compressed.png',
                'people/Nate_a_head_compressed.png',
                'people/Zancas_a_head_compressed.png',
                'people/cyberaxe_a_head_compressed.png',
                // Hero sprite sheet animations
                'tunnelsofprivacy/heros/zooko_idle.png',
                'tunnelsofprivacy/heros/zooko_idle_a.png',
                'tunnelsofprivacy/heros/zooko_idle_b.png',
                'tunnelsofprivacy/heros/zooko_light_attack.png',
                'tunnelsofprivacy/heros/zooko_heavy_attack.png',
                'tunnelsofprivacy/heros/zooko_special_attack.png',
                'tunnelsofprivacy/heros/zooko_knockout.png',
                'tunnelsofprivacy/heros/zooko_hit.png',
                'tunnelsofprivacy/heros/zooko_def.png',
                'tunnelsofprivacy/heros/nate_idle.png',
                'tunnelsofprivacy/heros/nate_idle_a.png',
                'tunnelsofprivacy/heros/nate_idle_b.png',
                'tunnelsofprivacy/heros/nate_idle_c.png',
                'tunnelsofprivacy/heros/nate_light_attack.png',
                'tunnelsofprivacy/heros/nate_heavy_attack.png',
                'tunnelsofprivacy/heros/nate_special_attack.png',
                'tunnelsofprivacy/heros/nate_special_attack_a.png',
                'tunnelsofprivacy/heros/nate_knockout.png',
                'tunnelsofprivacy/heros/nate_hit.png',
                'tunnelsofprivacy/heros/nate_def.png',
                'tunnelsofprivacy/heros/nate_heal.png',
                'tunnelsofprivacy/heros/nate_taunt.png',
                'tunnelsofprivacy/heros/nate_myturn.png',
                'tunnelsofprivacy/heros/zancas_idle.png',
                'tunnelsofprivacy/heros/zancas_idle_a.png',
                'tunnelsofprivacy/heros/zancas_idle_b.png',
                'tunnelsofprivacy/heros/zancas_light_attack.png',
                'tunnelsofprivacy/heros/zancas_heavy_attack.png',
                'tunnelsofprivacy/heros/zancas_special_attack.png',
                'tunnelsofprivacy/heros/zancas_knockout.png',
                'tunnelsofprivacy/heros/zancas_hit.png',
                'tunnelsofprivacy/heros/zancas_def.png',
                'tunnelsofprivacy/heros/zancas_heal.png',
                'tunnelsofprivacy/heros/cyberaxe_idle.png',
                'tunnelsofprivacy/heros/cyberaxe_idle_a.png',
                'tunnelsofprivacy/heros/cyberaxe_idle_b.png',
                'tunnelsofprivacy/heros/cyberaxe_light_attack.png',
                'tunnelsofprivacy/heros/cyberaxe_heavy_attack.png',
                'tunnelsofprivacy/heros/cyberaxe_special_attack.png',
                'tunnelsofprivacy/heros/cyberaxe_knockout.png',
                'tunnelsofprivacy/heros/cyberaxe_hit.png',
                'tunnelsofprivacy/heros/cyberaxe_def.png'
            ];
            
            artTotal = imageList.length;
            assetsToLoad += imageList.length;
            
            // Preload images (also populates spriteSheetCache for animation system)
            imageList.forEach(imagePath => {
                const img = new Image();
                img.src = imagePath;
                img.addEventListener('load', () => {
                    console.log(`Preloaded: ${imagePath}`);
                    // Cache sprite sheets for animation system
                    if (imagePath.includes('tunnelsofprivacy/heros/')) {
                        spriteSheetCache[imagePath] = img;
                    }
                    artLoaded++;
                    assetsLoaded++;
                    updateLoadingProgress();
                }, { once: true });
                img.addEventListener('error', (e) => {
                    console.error(`Failed to preload: ${imagePath}`, e);
                    artLoaded++;
                    assetsLoaded++;
                    updateLoadingProgress();
                }, { once: true });
            });
            
            // Preload music if enabled
            if (musicEnabled && musicVolume > 0) {
                audioTotal = 1;
                assetsToLoad += 1;
                
                const musicPlayer = document.getElementById('musicPlayer');
                if (musicPlayer) {
                    musicPlayer.volume = Math.min(1.0, musicVolume / 100);
                    musicPlayer.preload = 'metadata'; // Changed from 'auto' to avoid hanging
                    
                    // Set a timeout in case music doesn't load
                    const musicTimeout = setTimeout(() => {
                        console.log('Music preload timeout - continuing anyway');
                        audioLoaded++;
                        assetsLoaded++;
                        updateLoadingProgress();
                    }, 3000); // 3 second timeout
                    
                    musicPlayer.addEventListener('loadedmetadata', () => {
                        console.log('Music metadata loaded');
                        clearTimeout(musicTimeout);
                        audioLoaded++;
                        assetsLoaded++;
                        updateLoadingProgress();
                    }, { once: true });
                    
                    musicPlayer.addEventListener('error', (e) => {
                        console.error('Failed to preload music', e);
                        clearTimeout(musicTimeout);
                        audioLoaded++;
                        assetsLoaded++;
                        updateLoadingProgress();
                    }, { once: true });
                    
                    musicPlayer.load();
                } else {
                    // Music player doesn't exist, skip it
                    audioLoaded++;
                    assetsLoaded++;
                    updateLoadingProgress();
                }
            }
            
            updateLoadingProgress();
        }
        
        // Update loading progress indicator
        function updateLoadingProgress() {
            const loadingIndicator = document.getElementById('loadingIndicator');
            const loadingBar = document.getElementById('loadingBar');
            const loadingArt = document.getElementById('loadingArt');
            const loadingSound = document.getElementById('loadingSound');
            
            if (loadingIndicator && assetsToLoad > 0) {
                const percent = Math.floor((assetsLoaded / assetsToLoad) * 100);
                loadingIndicator.textContent = `${percent}%`;
                
                if (loadingBar) {
                    loadingBar.style.width = `${percent}%`;
                    loadingBar.textContent = `${percent}%`;
                }
                
                // Update category counts
                if (loadingArt) {
                    loadingArt.innerHTML = `üé® Art: <span style="color: #8B45FF; font-weight: bold;">${artLoaded}/${artTotal}</span>`;
                }
                if (loadingSound) {
                    loadingSound.innerHTML = `üîä Sound: <span style="color: #8B45FF; font-weight: bold;">${audioLoaded}/${audioTotal}</span>`;
                }
            }
            
            checkAllAssetsReady();
        }
        
        function checkAllAssetsReady() {
            if (assetsToLoad > 0 && assetsLoaded >= assetsToLoad && !allAssetsReady) {
                allAssetsReady = true;
                
                const loadingIndicator = document.getElementById('loadingIndicator');
                const loadingBar = document.getElementById('loadingBar');
                const loadingModal = document.getElementById('loadingModal');
                const loadingNote = document.getElementById('loadingNote');
                const clickToPlayPrompt = document.getElementById('clickToPlayPrompt');
                
                if (loadingIndicator) {
                    loadingIndicator.textContent = '‚úì All Assets Ready!';
                    loadingIndicator.style.color = '#2ECC71';
                }
                
                if (loadingBar) {
                    loadingBar.style.width = '100%';
                    loadingBar.textContent = '100%';
                    loadingBar.style.background = 'linear-gradient(90deg, #2ECC71, #27AE60)';
                }
                
                if (loadingNote) {
                    loadingNote.style.display = 'none';
                }
                
                if (clickToPlayPrompt) {
                    clickToPlayPrompt.style.display = 'block';
                    
                    // Start gamepad polling for A button
                    pollGamepadForClickToPlay();
                    
                    const handleClick = () => {
                        // Start music when user clicks - always start with main theme
                        if (musicEnabled && musicVolume > 0 && !musicStarted) {
                            loadMusic(themeTracks[0]); // Always start with main theme (index 0)
                        }
                        
                        // Fade out and remove loading modal
                        if (loadingModal) {
                            loadingModal.style.opacity = '0';
                            loadingModal.style.transition = 'opacity 0.5s ease';
                            setTimeout(() => {
                                loadingModal.style.display = 'none';
                            }, 500);
                        }
                        
                        // Remove click handler
                        clickToPlayPrompt.removeEventListener('click', handleClick);
                        document.removeEventListener('keydown', handleKeyDown);
                    };
                    
                    const handleKeyDown = (e) => {
                        if (e.key === 'a' || e.key === 'A' || e.key === 'Enter') {
                            handleClick();
                        }
                    };
                    
                    clickToPlayPrompt.addEventListener('click', handleClick);
                    document.addEventListener('keydown', handleKeyDown);
                }
            }
        }
        
        // ===== MULTIPLAYER WEBSOCKET FUNCTIONS =====
        
        function connectWebSocket() {
            if (multiplayerState.ws && multiplayerState.ws.readyState === WebSocket.OPEN) {
                return; // Already connected
            }
            
            const wsUrl = `ws://${window.location.hostname}:8765`;
            console.log('[MP] Connecting to WebSocket:', wsUrl);
            
            multiplayerState.ws = new WebSocket(wsUrl);
            
            multiplayerState.ws.onopen = () => {
                console.log('[MP] WebSocket connected');
                multiplayerState.enabled = true;
            };
            
            multiplayerState.ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                handleWebSocketMessage(data);
            };
            
            multiplayerState.ws.onerror = (error) => {
                console.error('[MP] WebSocket error:', error);
                showNotification('Multiplayer connection error', 'error');
            };
            
            multiplayerState.ws.onclose = () => {
                console.log('[MP] WebSocket closed');
                if (multiplayerState.enabled && !multiplayerState.isReconnecting) {
                    showNotification('Disconnected from multiplayer', 'warning');
                    resetMultiplayerState();
                }
            };
        }
        
        function handleWebSocketMessage(data) {
            console.log('[MP] Received:', data);
            
            switch(data.type) {
                case 'room_created':
                    multiplayerState.roomCode = data.code;
                    multiplayerState.role = 'host';
                    multiplayerState.myPlayerId = data.player_id;
                    // Get player name from data (set by user on title screen)
                    if (data.players && data.players[0]) {
                        multiplayerState.playerName = data.players[0].name;
                    }
                    // Store initial player list
                    if (data.players) {
                        multiplayerState.connectedPlayers = data.players;
                    }
                    showNotification(`Room created: ${data.code}`, 'success');
                    // Host enters hero selection immediately
                    showHeroSelection();
                    break;
                
                case 'joined':
                    multiplayerState.roomCode = data.code;
                    multiplayerState.role = 'client';
                    multiplayerState.myPlayerId = data.player_id;
                    // Store player list
                    if (data.players) {
                        multiplayerState.connectedPlayers = data.players;
                        // Find my name from the list
                        const me = data.players.find(p => p.id === data.player_id);
                        if (me) {
                            multiplayerState.playerName = me.name;
                        }
                    }
                    
                    // Check if this is a reconnection
                    if (data.reconnected) {
                        multiplayerState.isReconnecting = true;
                        showNotification(`Reconnected to room: ${data.code}`, 'success');
                    } else {
                        multiplayerState.isReconnecting = false;
                        showNotification(`Joined room: ${data.code}`, 'success');
                    }
                    
                    // Show hero selection
                    showHeroSelection();
                    break;
                
                case 'error':
                    showNotification(data.message, 'error');
                    break;
                
                case 'players_update':
                    // Update connected players list
                    if (data.players) {
                        multiplayerState.connectedPlayers = data.players;
                    }
                    // Update hero selections if provided
                    if (data.heroes) {
                        updateHeroSelection({ heroes: data.heroes });
                    } else {
                        // Just update the player list display
                        updateConnectedPlayersListOnly();
                    }
                    break;
                
                case 'player_joined':
                    showNotification(`Player joined (${data.player_count} total)`, 'info');
                    break;
                
                case 'hero_selected':
                    // Update player list if provided
                    if (data.players) {
                        multiplayerState.connectedPlayers = data.players;
                    }
                    // Update hero selections
                    updateHeroSelection(data);
                    break;
                
                case 'player_action':
                    // Host receives client action
                    if (multiplayerState.role === 'host') {
                        processClientAction(data);
                    }
                    break;
                
                case 'request_resync':
                    // Client is requesting a full state resync
                    if (multiplayerState.role === 'host') {
                        console.log('[HOST] Client requested resync');
                        if (battleState.active) {
                            // Send full battle state
                            broadcastGameState();
                            showNotification('Resync sent to clients', 'info');
                        }
                    }
                    break;
                
                case 'state_update':
                    // Client receives state from host
                    if (multiplayerState.role === 'client') {
                        updateGameStateFromHost(data.state);
                    }
                    break;
                
                case 'battle_init':
                    // Client receives battle initialization from host
                    if (multiplayerState.role === 'client') {
                        initializeBattleFromHost(data.battleData);
                    }
                    break;
                
                case 'battle_end':
                    // Host notifies battle has ended
                    if (multiplayerState.role === 'client') {
                        const reason = data.reason;
                        if (reason === 'retreat') {
                            showBattleNotification('DEFEAT! ALL HEROES RETREATED!');
                        } else if (reason === 'defeat') {
                            showBattleNotification('DEFEAT! ALL HEROES FALLEN!');
                        }
                        
                        setTimeout(() => {
                            // Hide notification
                            const notification = document.getElementById('battleNotification');
                            if (notification) notification.style.display = 'none';
                            
                            // Client: Switch UI and display from cached stats
                            battleState.active = false;
                            currentScreen = 'dungeonMenu';
                            document.getElementById('battleScreen').style.display = 'none';
                            document.getElementById('dungeonMenuScreen').style.display = 'block';
                            
                            // Move music controls and ticker back to center bottom
                            document.getElementById('musicControls').classList.remove('battleActive');
                            document.getElementById('musicControls').classList.add('dungeonMenuActive');
                            document.getElementById('musicTicker').classList.remove('battleActive');
                            document.getElementById('musicTicker').classList.add('dungeonMenuActive');
                            
                            // Update dungeon menu from cached stats (already updated from state_update broadcasts)
                            updateDungeonMenuHeroes();
                            updateGoldDisplay();
                        }, 2000);
                    }
                    break;
                
                case 'kicked':
                    showNotification(data.message, 'error');
                    resetMultiplayerState();
                    break;
                
                case 'host_disconnected':
                    showNotification(data.message, 'error');
                    resetMultiplayerState();
                    currentScreen = 'title';
                    document.getElementById('battleScreen').style.display = 'none';
                    document.getElementById('dungeonMenuScreen').style.display = 'none';
                    document.getElementById('titleScreen').style.display = 'block';
                    break;
                
                case 'player_disconnected':
                    if (multiplayerState.role === 'host') {
                        handlePlayerDisconnect(data.player_id);
                    }
                    break;
                
                case 'request_sync':
                    // Client requesting full sync after reconnection
                    console.log('[HOST] Received request_sync from client');
                    console.log('[HOST] multiplayerState.role:', multiplayerState.role);
                    console.log('[HOST] currentScreen:', currentScreen);
                    
                    if (multiplayerState.role === 'host') {
                        // Transfer heroes back from host to reconnecting player
                        if (data.heroes && Array.isArray(data.heroes)) {
                            data.heroes.forEach(heroName => {
                                const heroKey = heroName.toLowerCase();
                                // Remove from host's control
                                const hostIndex = multiplayerState.myHeroes.indexOf(heroKey);
                                if (hostIndex > -1) {
                                    multiplayerState.myHeroes.splice(hostIndex, 1);
                                    showNotification(`${heroName} returned to player control`, 'info');
                                }
                            });
                        }
                        
                        const sharedSave = loadSharedSave();
                        console.log('[HOST] sharedSave exists:', !!sharedSave);
                        
                        if (sharedSave) {
                            console.log('[HOST] Sending sync_state to client');
                            // Send current save state to rejoining client
                            sendWebSocketMessage({ 
                                type: 'sync_state', 
                                screen: currentScreen,
                                saveData: sharedSave
                            });
                            
                            // If in battle, also send battle_init
                            if (currentScreen === 'battle' && battleState.active) {
                                setTimeout(() => {
                                    sendBattleInitToClients();
                                }, 100);
                            }
                        }
                    }
                    break;
                
                case 'sync_state':
                    console.log('[CLIENT] Received sync_state');
                    console.log('[CLIENT] data.screen:', data.screen);
                    console.log('[CLIENT] multiplayerState.role:', multiplayerState.role);
                    
                    // Client receiving sync after reconnection
                    if (multiplayerState.role === 'client') {
                        // Save host's save data
                        if (data.saveData) {
                            saveSharedSave(data.saveData);
                            
                            // Populate heroStatsCache
                            if (data.saveData.heroes) {
                                ['zooko', 'nate', 'zancas', 'cyberaxe'].forEach(heroKey => {
                                    const heroData = data.saveData.heroes[heroKey];
                                    if (heroData) {
                                        multiplayerState.heroStatsCache[heroKey] = {
                                            hp: heroData.hp,
                                            maxHp: heroData.maxHp,
                                            xp: heroData.xp,
                                            level: heroData.level,
                                            str: heroData.str,
                                            dex: heroData.dex,
                                            con: heroData.con,
                                            int: heroData.int,
                                            wis: heroData.wis,
                                            cha: heroData.cha
                                        };
                                    }
                                });
                            }
                        }
                        
                        // Hide modals and title screen
                        document.getElementById('titleScreen').style.display = 'none';
                        document.getElementById('heroSelectionModal').style.display = 'none';
                        document.getElementById('musicControls').classList.remove('heroSelectionActive');
                        
                        // Go to the screen where host is
                        if (data.screen === 'dungeonMenu') {
                            document.getElementById('battleScreen').style.display = 'none';
                            document.getElementById('musicTicker').classList.remove('battleActive');
                            document.getElementById('musicControls').classList.add('dungeonMenuActive');
                            document.getElementById('musicTicker').classList.add('dungeonMenuActive');
                            document.getElementById('dungeonMenuScreen').style.display = 'block';
                            currentScreen = 'dungeonMenu';
                            updateDungeonMenuHeroes();
                            applyClientUIRestrictions();
                            showNotification('Rejoined game!', 'success');
                        } else if (data.screen === 'battle') {
                            document.getElementById('dungeonMenuScreen').style.display = 'none';
                            document.getElementById('musicTicker').classList.remove('dungeonMenuActive');
                            document.getElementById('musicControls').classList.remove('dungeonMenuActive');
                            document.getElementById('battleScreen').style.display = 'block';
                            document.getElementById('musicTicker').classList.add('battleActive');
                            document.getElementById('musicControls').classList.add('battleActive');
                            currentScreen = 'battle';
                            showNotification('Rejoined battle - waiting for sync...', 'info');
                        }
                    }
                    break;
                
                case 'code_changed':
                    multiplayerState.roomCode = data.code;
                    showNotification(`Room code changed to: ${data.code}`, 'info');
                    // Update hero selection display if visible
                    const heroCodeDisplay = document.getElementById('heroSelectionCode');
                    if (heroCodeDisplay && heroCodeDisplay.textContent !== '******') {
                        heroCodeDisplay.textContent = data.code;
                    }
                    break;
                
                case 'skip_turn':
                    // Advance turn (force skip)
                    advanceTurn();
                    break;
                
                case 'game_start':
                    // Host started the game - clients follow
                    if (multiplayerState.role === 'client') {
                        // Save host's save data to local storage
                        if (data.saveData) {
                            saveSharedSave(data.saveData);
                            
                            // Populate heroStatsCache from saveData for client display
                            if (data.saveData.heroes) {
                                ['zooko', 'nate', 'zancas', 'cyberaxe'].forEach(heroKey => {
                                    const heroData = data.saveData.heroes[heroKey];
                                    if (heroData) {
                                        multiplayerState.heroStatsCache[heroKey] = {
                                            hp: heroData.hp,
                                            maxHp: heroData.maxHp,
                                            xp: heroData.xp,
                                            level: heroData.level,
                                            str: heroData.str,
                                            dex: heroData.dex,
                                            con: heroData.con,
                                            int: heroData.int,
                                            wis: heroData.wis,
                                            cha: heroData.cha
                                        };
                                    }
                                });
                            }
                            
                            // Cache gold from saveData for client display
                            if (data.saveData.dungeonState) {
                                multiplayerState.goldCache = data.saveData.dungeonState.gold || 0;
                            }
                        }
                        
                        document.getElementById('titleScreen').style.display = 'none';
                        document.getElementById('heroSelectionModal').style.display = 'none';
                        // Reset music controls position
                        document.getElementById('musicControls').classList.remove('heroSelectionActive');
                        
                        if (data.screen === 'dungeonMenu') {
                            document.getElementById('battleScreen').style.display = 'none';
                            document.getElementById('musicTicker').classList.remove('battleActive');
                            document.getElementById('musicControls').classList.add('dungeonMenuActive');
                            document.getElementById('musicTicker').classList.add('dungeonMenuActive');
                            document.getElementById('dungeonMenuScreen').style.display = 'block';
                            currentScreen = 'dungeonMenu';
                            
                            // Load hero stats from save
                            updateDungeonMenuHeroes();
                            updateGoldDisplay();
                            
                            // Apply client UI restrictions
                            applyClientUIRestrictions();
                        } else if (data.screen === 'battle') {
                            // Client waits for battle_init message from host
                            // Just show the screen, don't initialize yet
                            document.getElementById('dungeonMenuScreen').style.display = 'none';
                            document.getElementById('battleScreen').style.display = 'block';
                            document.getElementById('musicTicker').classList.add('battleActive');
                            document.getElementById('musicControls').classList.add('battleActive');
                            currentScreen = 'battle';
                            
                            // Initialize canvas
                            battleState.canvas = document.getElementById('battleCanvas');
                            battleState.ctx = battleState.canvas.getContext('2d');
                            battleState.canvas.width = window.innerWidth;
                            battleState.canvas.height = window.innerHeight - 180;
                            battleState.active = true;
                            
                            // Move music controls to battle position
                            document.getElementById('musicControls').classList.add('battleActive');
                            
                            showNotification('Waiting for host to initialize battle...', 'info');
                            return; // Wait for battle_init
                        } else {
                            // Fallback to dungeon menu for any other screen value
                            document.getElementById('battleScreen').style.display = 'none';
                            document.getElementById('musicTicker').classList.remove('battleActive');
                            document.getElementById('musicControls').classList.add('dungeonMenuActive');
                            document.getElementById('musicTicker').classList.add('dungeonMenuActive');
                            document.getElementById('dungeonMenuScreen').style.display = 'block';
                            currentScreen = 'dungeonMenu';
                            updateDungeonMenuHeroes();
                            updateGoldDisplay();
                            applyClientUIRestrictions();
                        }
                        showNotification('Host started the game!', 'success');
                    }
                    break;
                
                case 'chat_message':
                    // Receive chat message broadcast from host
                    if (multiplayerState.role === 'client' && data.message) {
                        // Skip if this is our own message (we already added it locally)
                        const myName = multiplayerState.playerName || 'Player';
                        if (data.message.senderName === myName && !data.message.isNpc) {
                            break;
                        }
                        // Add to local chat without re-broadcasting
                        chatState.messages.unshift(data.message);
                        if (chatState.messages.length > 50) {
                            chatState.messages.pop();
                        }
                        renderChatMessages();
                    }
                    break;
                
                case 'chat_request':
                    // Host receives chat request from client - process LLM and broadcast
                    if (multiplayerState.role === 'host') {
                        handleClientChatRequest(data);
                    }
                    break;
                
                case 'animation_sync':
                    // Client receives animation update from host
                    if (multiplayerState.role === 'client' && data.combatantName && data.animState) {
                        // Find the combatant by name
                        const combatant = battleState.heroes.find(h => h.name === data.combatantName) ||
                                          battleState.enemies.find(e => e.name === data.combatantName);
                        if (combatant) {
                            // Apply animation locally without re-broadcasting
                            setAnimationState(combatant, data.animState, data.playMode || 'pingpong', null, false);
                        }
                    }
                    break;
                
                default:
                    console.warn('[MP] Unhandled message type:', data.type, data);
                    break;
            }
            
            // Log message to debug panel
            logDebugMessage(data.type, data, 'in');
            updateDebugStatus();
        }
        
        // Handle chat request from client (host-only)
        async function handleClientChatRequest(data) {
            const playerName = data.playerName || 'Player';
            const message = data.message || '';
            
            // Get player's hero avatar
            const heroAvatar = 'people/zooko_a_head_compressed.png';
            
            // Add player message to chat (will broadcast)
            addChatMessage(playerName, 'player', heroAvatar, message, false);
            
            // Get NPC to respond
            const respondingNpc = battleState.enemies.find(e => e.hp > 0 && e.backstory);
            
            if (!respondingNpc) {
                addChatMessage('System', 'friendly', 'people/zooko_a_head_compressed.png', 
                    '*No one responds...*', true);
                return;
            }
            
            try {
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        npcName: respondingNpc.name,
                        backstory: respondingNpc.backstory || 'A mysterious creature.',
                        npcType: respondingNpc.isBoss ? 'boss' : 'mob',
                        conversation: chatState.messages.slice(0, 10).reverse(),
                        message: message,
                        playerName: playerName,
                        rpMode: settings.rpMode !== false
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    const npcType = respondingNpc.hostile ? 'hostile' : 
                        (respondingNpc.questable ? 'questable' : 'friendly');
                    
                    addChatMessage(
                        respondingNpc.name,
                        npcType,
                        respondingNpc.spritePath || 'people/zooko_a_head_compressed.png',
                        result.response,
                        true,
                        respondingNpc.voiceType
                    );
                }
            } catch (error) {
                console.error('Chat fetch error:', error);
            }
        }
        
        function sendWebSocketMessage(data) {
            console.log('[WS] Attempting to send:', data.type);
            if (multiplayerState.ws && multiplayerState.ws.readyState === WebSocket.OPEN) {
                multiplayerState.ws.send(JSON.stringify(data));
                console.log('[WS] Sent successfully:', data.type);
                logDebugMessage(data.type, data, 'out');
                updateDebugStatus();
            } else {
                console.error('[MP] WebSocket not connected. State:', multiplayerState.ws ? multiplayerState.ws.readyState : 'null');
            }
        }
        
        function createMultiplayerRoom() {
            // Get player name
            const playerNameInput = document.getElementById('multiplayerPlayerName');
            const playerName = playerNameInput.value.trim() || 'Player';
            multiplayerState.playerName = playerName;
            
            // Save player name to settings
            settings.playerName = playerName;
            saveSettings();
            
            // Close settings panel
            closeAllPanels();
            
            connectWebSocket();
            setTimeout(() => {
                sendWebSocketMessage({ type: 'create_room', player_name: playerName });
            }, 100);
        }
        
        function joinMultiplayerRoom() {
            const code = document.getElementById('joinRoomCodeInput').value.trim().toUpperCase();
            if (code.length !== 6) {
                showNotification('Please enter a 6-character room code', 'error');
                return;
            }
            
            connectWebSocket();
            setTimeout(() => {
                sendWebSocketMessage({ type: 'join_room', code });
            }, 100);
        }
        
        function quickJoinRoom() {
            const code = document.getElementById('titleJoinCode').value.trim().toUpperCase();
            if (code.length !== 6) {
                showNotification('Please enter a 6-character room code', 'error');
                return;
            }
            
            // Get player name
            const playerNameInput = document.getElementById('multiplayerPlayerName');
            const playerName = playerNameInput.value.trim() || 'Player';
            multiplayerState.playerName = playerName;
            
            // Save player name to settings
            settings.playerName = playerName;
            saveSettings();
            
            connectWebSocket();
            setTimeout(() => {
                sendWebSocketMessage({ type: 'join_room', code, player_name: playerName });
            }, 100);
        }
        
        function leaveRoom() {
            if (multiplayerState.ws) {
                multiplayerState.ws.close();
            }
            resetMultiplayerState();
            document.getElementById('connectionStatus').style.display = 'none';
            document.getElementById('joinRoomBtn').style.display = 'block';
            document.getElementById('leaveRoomBtn').style.display = 'none';
            showNotification('Left room', 'info');
        }
        
        function stopHosting() {
            if (multiplayerState.ws) {
                multiplayerState.ws.close();
            }
            resetMultiplayerState();
            document.getElementById('roomCodeDisplay').style.display = 'none';
            document.getElementById('createRoomBtn').style.display = 'block';
            document.getElementById('changeCodeBtn').style.display = 'none';
            document.getElementById('stopHostingBtn').style.display = 'none';
            document.getElementById('hostControlsBtn').style.display = 'none';
            showNotification('Stopped hosting', 'info');
        }
        
        function changeRoomCode() {
            if (confirm('Changing the room code will disconnect all players. Continue?')) {
                sendWebSocketMessage({ type: 'change_code' });
            }
        }
        
        function changeRoomCodeFromPanel() {
            closeHostControls();
            changeRoomCode();
        }
        
        function resetMultiplayerState() {
            multiplayerState.enabled = false;
            multiplayerState.role = null;
            multiplayerState.roomCode = null;
            multiplayerState.myHeroes = [];
            multiplayerState.myPlayerId = null;
            multiplayerState.playerHeroes = {};
            multiplayerState.connectedPlayers = [];
            if (multiplayerState.ws) {
                multiplayerState.ws.close();
                multiplayerState.ws = null;
            }
        }
        
        function toggleRoomCodeVisibility() {
            const codeSpan = document.getElementById('heroSelectionCode');
            const btn = event.target;
            
            if (codeSpan.textContent === '******') {
                codeSpan.textContent = multiplayerState.roomCode;
                btn.textContent = 'üëÅ HIDE';
            } else {
                codeSpan.textContent = '******';
                btn.textContent = 'üëÅ SHOW';
            }
        }
        
        function cancelHeroSelection() {
            if (confirm('Leave multiplayer session?')) {
                document.getElementById('heroSelectionModal').style.display = 'none';
                // Move music controls back to center
                document.getElementById('musicControls').classList.remove('heroSelectionActive');
                document.getElementById('musicTicker').classList.remove('battleActive');
                if (multiplayerState.role === 'host') {
                    stopHosting();
                } else {
                    leaveRoom();
                }
            }
        }
        
        function showHeroSelection() {
            document.getElementById('heroSelectionModal').style.display = 'block';
            // Move music controls to left
            document.getElementById('musicControls').classList.add('heroSelectionActive');
            document.getElementById('musicTicker').classList.add('battleActive');
            // Update room code display
            const codeDisplay = document.getElementById('heroSelectionCode');
            if (codeDisplay && multiplayerState.roomCode) {
                codeDisplay.textContent = multiplayerState.roomCode;
            }
            // Set player name input to current player name
            const nameInput = document.getElementById('playerNameInput');
            if (nameInput) {
                nameInput.value = multiplayerState.playerName;
            }
            
            // Show reconnect options if this is a reconnection
            const reconnectOptions = document.getElementById('reconnectOptions');
            const gameStartOptions = document.getElementById('gameStartOptions');
            if (multiplayerState.isReconnecting) {
                if (reconnectOptions) reconnectOptions.style.display = 'block';
                if (gameStartOptions) gameStartOptions.style.display = 'none';
            } else {
                if (reconnectOptions) reconnectOptions.style.display = 'none';
            }
        }
        
        function updatePlayerName() {
            const nameInput = document.getElementById('playerNameInput');
            const newName = nameInput.value.trim() || 'Player';
            multiplayerState.playerName = newName;
            
            // Always notify server of name change
            sendWebSocketMessage({ 
                type: 'update_name', 
                playerName: newName 
            });
        }
        
        function selectHero(heroName) {
            const card = document.querySelector(`[data-hero="${heroName}"]`);
            
            // If clicking own hero, deselect it
            if (multiplayerState.myHeroes.includes(heroName)) {
                multiplayerState.myHeroes = multiplayerState.myHeroes.filter(h => h !== heroName);
                card.classList.remove('selected');
                card.style.borderWidth = '3px';
                sendWebSocketMessage({ type: 'deselect_hero', hero: heroName });
                showNotification('Hero deselected', 'info');
                return;
            }
            
            // Check if already taken by someone else
            if (card.classList.contains('taken')) {
                showNotification('Hero already taken', 'error');
                return;
            }
            
            // Select new hero (no limit on how many per player)
            multiplayerState.myHeroes.push(heroName);
            card.classList.add('selected');
            card.style.borderWidth = '5px';
            
            // Get player name from input, or use current playerName from state
            const nameInput = document.getElementById('playerNameInput');
            const playerName = nameInput.value.trim() || multiplayerState.playerName;
            multiplayerState.playerName = playerName;
            
            sendWebSocketMessage({ 
                type: 'select_hero', 
                hero: heroName, 
                playerName: playerName 
            });
        }
        
        function updateHeroSelection(data) {
            // Reset all cards first
            document.querySelectorAll('.heroSelectCard').forEach(card => {
                card.classList.remove('taken');
                card.style.opacity = '1';
                card.style.cursor = 'pointer';
                card.querySelector('.heroTakenLabel').style.display = 'none';
                card.querySelector('.heroPlayerLabel').style.display = 'none';
            });
            
            // Update hero selection UI with player names
            Object.keys(data.heroes).forEach(hero => {
                const heroData = data.heroes[hero];
                const card = document.querySelector(`[data-hero="${hero}"]`);
                if (card && heroData) {
                    card.classList.add('taken');
                    card.style.opacity = '0.7';
                    
                    const playerLabel = card.querySelector('.heroPlayerLabel');
                    if (playerLabel) {
                        playerLabel.textContent = heroData.playerName || 'Player';
                        playerLabel.style.display = 'block';
                    }
                    
                    // Don't disable if it's my hero
                    if (!multiplayerState.myHeroes.includes(hero)) {
                        card.style.cursor = 'not-allowed';
                        card.querySelector('.heroTakenLabel').style.display = 'block';
                    }
                }
            });
            
            // Update connected players list
            updateConnectedPlayersList(data.heroes);
            
            // Update player count
            const playerCount = multiplayerState.connectedPlayers.length;
            const countDisplay = document.getElementById('playerCountDisplay');
            if (countDisplay) {
                countDisplay.textContent = `${playerCount}/4`;
            }
            
            // Update waiting message and show game start options when all 4 heroes selected
            const heroCount = Object.keys(data.heroes).length;
            const waitingMsg = document.getElementById('heroWaitingMessage');
            const gameStartOptions = document.getElementById('gameStartOptions');
            
            if (heroCount === 4) {
                if (waitingMsg) waitingMsg.style.display = 'none';
                if (gameStartOptions && multiplayerState.role === 'host') {
                    gameStartOptions.style.display = 'block';
                }
            } else {
                if (waitingMsg) {
                    waitingMsg.style.display = 'block';
                    waitingMsg.textContent = `Select heroes (${heroCount}/4 selected). Players can select multiple heroes.`;
                }
                if (gameStartOptions) gameStartOptions.style.display = 'none';
            }
            
            // Update multiplayer status indicator
            updateMultiplayerStatus();
        }
        
        function updateConnectedPlayersList(heroes) {
            const listContent = document.getElementById('playersListContent');
            if (!listContent) return;
            
            listContent.innerHTML = '';
            
            // Show all connected players
            if (multiplayerState.connectedPlayers.length === 0) {
                listContent.innerHTML = '<div style="color: #89A0B4; font-size: 12px;">No players connected</div>';
                return;
            }
            
            multiplayerState.connectedPlayers.forEach(player => {
                const playerBadge = document.createElement('div');
                playerBadge.style.cssText = 'padding: 6px 12px; background: rgba(42, 157, 143, 0.3); border: 1px solid #2A9D8F; border-radius: 5px; font-size: 12px; margin-bottom: 5px;';
                
                const heroText = player.heroes && player.heroes.length > 0 
                    ? ` ‚Üí ${player.heroes.map(h => h.toUpperCase()).join(', ')}` 
                    : ' ‚Üí (no heroes)';
                playerBadge.innerHTML = `<span style="color: #F2C94C;">${player.name}</span> <span style="color: #89A0B4;">${heroText}</span>`;
                listContent.appendChild(playerBadge);
            });
        }
        
        function updateConnectedPlayersListOnly() {
            // Update just the player list without touching hero cards
            const listContent = document.getElementById('playersListContent');
            if (!listContent) return;
            
            listContent.innerHTML = '';
            
            if (multiplayerState.connectedPlayers.length === 0) {
                listContent.innerHTML = '<div style="color: #89A0B4; font-size: 12px;">No players connected</div>';
                return;
            }
            
            multiplayerState.connectedPlayers.forEach(player => {
                const playerBadge = document.createElement('div');
                playerBadge.style.cssText = 'padding: 6px 12px; background: rgba(42, 157, 143, 0.3); border: 1px solid #2A9D8F; border-radius: 5px; font-size: 12px; margin-bottom: 5px;';
                
                const heroText = player.heroes && player.heroes.length > 0 
                    ? ` ‚Üí ${player.heroes.map(h => h.toUpperCase()).join(', ')}` 
                    : ' ‚Üí (no heroes)';
                playerBadge.innerHTML = `<span style="color: #F2C94C;">${player.name}</span> <span style="color: #89A0B4;">${heroText}</span>`;
                listContent.appendChild(playerBadge);
            });
        }
        
        function updateMultiplayerStatus() {
            const statusDiv = document.getElementById('multiplayerStatus');
            const statusText = document.getElementById('mpStatusText');
            
            if (multiplayerState.enabled && multiplayerState.roomCode) {
                statusDiv.style.display = 'block';
                const playerCount = multiplayerState.connectedPlayers.length;
                const role = multiplayerState.role === 'host' ? 'üëë HOST' : 'üéÆ CLIENT';
                statusText.textContent = `${role} | Room: ${multiplayerState.roomCode} | Players: ${playerCount}/4`;
            } else {
                statusDiv.style.display = 'none';
            }
        }
        
        function startMultiplayerBattle() {
            // This function is now handled by showing game start options
            // See continueGame(), loadSaveGame(), startNewAdventure()
        }
        
        // Multiplayer: Continue game from save (host only)
        function continueGameMultiplayer() {
            if (multiplayerState.role !== 'host') {
                showNotification('Only host can start the game', 'error');
                return;
            }
            
            // Ensure save exists
            let sharedSave = loadSharedSave();
            if (!sharedSave) {
                sharedSave = createDefaultSharedSave();
                saveSharedSave(sharedSave);
            }
            
            // Hide hero selection
            document.getElementById('heroSelectionModal').style.display = 'none';
            document.getElementById('musicControls').classList.remove('heroSelectionActive');
            document.getElementById('musicTicker').classList.remove('battleActive');
            
            // Center music controls for dungeon menu
            document.getElementById('musicControls').classList.add('dungeonMenuActive');
            document.getElementById('musicTicker').classList.add('dungeonMenuActive');
            
            // Update dungeon menu with save data
            updateDungeonMenuHeroes();
            
            // Show dungeon menu
            currentScreen = 'dungeonMenu';
            document.getElementById('titleScreen').style.display = 'none';
            document.getElementById('dungeonMenuScreen').style.display = 'block';
            
            // Notify all clients to start WITH save data
            sendWebSocketMessage({ 
                type: 'game_start', 
                screen: 'dungeonMenu', 
                mode: 'continue',
                saveData: sharedSave
            });
            
            showNotification('Continuing from last save...', 'success');
            
            // Pre-generate next encounter while in dungeon menu (host only)
            preGenerateNextEncounter();
        }
        
        function loadSaveGame() {
            if (multiplayerState.role !== 'host') {
                showNotification('Only host can start the game', 'error');
                return;
            }
            
            // Ensure save exists
            let sharedSave = loadSharedSave();
            if (!sharedSave) {
                sharedSave = createDefaultSharedSave();
                saveSharedSave(sharedSave);
            }
            
            // Hide hero selection
            document.getElementById('heroSelectionModal').style.display = 'none';
            document.getElementById('musicControls').classList.remove('heroSelectionActive');
            document.getElementById('musicControls').classList.add('dungeonMenuActive');
            document.getElementById('musicTicker').classList.remove('battleActive');
            document.getElementById('musicTicker').classList.add('dungeonMenuActive');
            
            // For now, just show dungeon menu - load game UI can be added later
            currentScreen = 'dungeonMenu';
            document.getElementById('titleScreen').style.display = 'none';
            document.getElementById('dungeonMenuScreen').style.display = 'block';
            
            // Update dungeon menu with save data
            updateDungeonMenuHeroes();
            
            // Notify all clients to start WITH save data
            sendWebSocketMessage({ 
                type: 'game_start', 
                screen: 'dungeonMenu', 
                mode: 'load',
                saveData: sharedSave
            });
            
            showNotification('Load game functionality - showing dungeon menu', 'info');
            
            // Pre-generate next encounter while in dungeon menu (host only)
            preGenerateNextEncounter();
        }
        
        function startNewAdventure() {
            if (multiplayerState.role !== 'host') {
                showNotification('Only host can start the game', 'error');
                return;
            }
            
            showConfirmation(
                'START NEW ADVENTURE?',
                'This will replace your local save game. All progress will be lost.',
                (confirmed) => {
                    if (!confirmed) return;
                    
                    // Hide hero selection
                    document.getElementById('heroSelectionModal').style.display = 'none';
                    document.getElementById('musicControls').classList.remove('heroSelectionActive');
                    document.getElementById('musicTicker').classList.remove('battleActive');
                    
                    // Create fresh save FIRST
                    const newSave = createDefaultSharedSave();
                    saveSharedSave(newSave);
                    
                    // Update dungeon menu with new save data
                    updateDungeonMenuHeroes();
                    
                    currentScreen = 'dungeonMenu';
                    document.getElementById('titleScreen').style.display = 'none';
                    document.getElementById('dungeonMenuScreen').style.display = 'block';
                    
                    // Center music controls
                    document.getElementById('musicControls').classList.remove('heroSelectionActive');
                    document.getElementById('musicControls').classList.add('dungeonMenuActive');
                    document.getElementById('musicTicker').classList.remove('battleActive');
                    document.getElementById('musicTicker').classList.add('dungeonMenuActive');
                    
                    // Notify all clients to start WITH save data
                    sendWebSocketMessage({ 
                        type: 'game_start', 
                        screen: 'dungeonMenu', 
                        mode: 'new',
                        saveData: newSave
                    });
                    
                    showNotification('Starting new adventure...', 'success');
                    
                    // Pre-generate next encounter while in dungeon menu (host only)
                    preGenerateNextEncounter();
                }
            );
        }
        
        function rejoinGame() {
            console.log('[REJOIN] rejoinGame() called');
            console.log('[REJOIN] multiplayerState.role:', multiplayerState.role);
            console.log('[REJOIN] multiplayerState.myHeroes:', multiplayerState.myHeroes);
            
            if (multiplayerState.role !== 'client') {
                showNotification('Only clients can rejoin', 'error');
                return;
            }
            
            if (multiplayerState.myHeroes.length === 0) {
                showNotification('Please select at least one hero', 'warning');
                return;
            }
            
            console.log('[REJOIN] Sending request_sync');
            
            // Request current game state from host
            sendWebSocketMessage({ 
                type: 'request_sync',
                heroes: multiplayerState.myHeroes
            });
            
            showNotification('Rejoining game...', 'info');
            multiplayerState.isReconnecting = false;
            
            // Don't hide anything here - let game_start handler manage all screen transitions
        }
        
        function showHostControls() {
            document.getElementById('hostControlsPanel').style.display = 'block';
            updatePlayerList();
        }
        
        function closeHostControls() {
            document.getElementById('hostControlsPanel').style.display = 'none';
        }
        
        function updatePlayerList() {
            const list = document.getElementById('playerList');
            list.innerHTML = '';
            
            multiplayerState.connectedPlayers.forEach(player => {
                const div = document.createElement('div');
                div.style.cssText = 'padding: 10px; margin-bottom: 10px; background: rgba(0,0,0,0.5); border-radius: 5px; display: flex; justify-content: space-between; align-items: center;';
                div.innerHTML = `
                    <div>
                        <div style="color: #F2C94C; font-size: 14px;">${player.hero || 'No hero selected'}</div>
                        <div style="color: #89A0B4; font-size: 11px;">Player ${player.id}</div>
                    </div>
                    <div>
                        <button onclick="skipPlayerTurn(${player.id})" style="padding: 5px 10px; margin-right: 5px; background: #F39C12; border: none; border-radius: 3px; color: white; cursor: pointer;">SKIP TURN</button>
                        <button onclick="kickPlayer(${player.id})" style="padding: 5px 10px; background: #EB5757; border: none; border-radius: 3px; color: white; cursor: pointer;">KICK</button>
                    </div>
                `;
                list.appendChild(div);
            });
            
            // Update multiplayer status indicator
            updateMultiplayerStatus();
        }
        
        function kickPlayer(playerId) {
            if (confirm('Kick this player?')) {
                sendWebSocketMessage({ type: 'kick_player', player_id: playerId });
            }
        }
        
        function skipPlayerTurn(playerId) {
            sendWebSocketMessage({ type: 'skip_turn', player_id: playerId });
        }
        
        function handlePlayerDisconnect(playerId) {
            // Find disconnected player info
            const disconnectedPlayer = multiplayerState.connectedPlayers.find(p => p.id === playerId);
            
            // Find heroes controlled by this player
            const disconnectedHeroes = [];
            if (disconnectedPlayer && disconnectedPlayer.heroes) {
                disconnectedPlayer.heroes.forEach(heroName => {
                    disconnectedHeroes.push(heroName);
                    // Transfer control to host
                    const hero = battleState.heroes?.find(h => h.name.toLowerCase() === heroName.toLowerCase());
                    if (hero) {
                        hero.aiControlled = false; // Host controls it, not AI
                    }
                    // Add to host's heroes (stored lowercase)
                    const heroLower = heroName.toLowerCase();
                    if (!multiplayerState.myHeroes.includes(heroLower)) {
                        multiplayerState.myHeroes.push(heroLower);
                    }
                });
            }
            
            if (disconnectedHeroes.length > 0) {
                showNotification(`Player disconnected - you now control: ${disconnectedHeroes.join(', ')}`, 'warning');
                // Update UI to enable buttons for these heroes
                if (battleState.active && battleState.currentHeroIndex !== undefined) {
                    updateHeroTurn();
                }
            }
            
            // Remove from connected players
            multiplayerState.connectedPlayers = multiplayerState.connectedPlayers.filter(p => p.id !== playerId);
        }
        
        function processClientAction(data) {
            // Host processes action from client
            const action = data.action;
            const target = data.target;
            const heroName = data.hero;
            const heroesArray = data.heroes;
            
            // Handle retreat - marks player's heroes as retreated
            if (action === 'retreat' && heroesArray) {
                heroesArray.forEach(hName => {
                    const hero = battleState.heroes.find(h => h.name.toLowerCase() === hName.toLowerCase());
                    if (hero) {
                        hero.retreated = true;
                    }
                });
                
                // Save all heroes for stat persistence (before filtering)
                // Merge with existing allHeroes to preserve previously retreated heroes
                if (battleState.allHeroes.length === 0) {
                    battleState.allHeroes = [...battleState.heroes];
                } else {
                    // Add any heroes not already in allHeroes
                    battleState.heroes.forEach(hero => {
                        if (!battleState.allHeroes.find(h => h.name === hero.name)) {
                            battleState.allHeroes.push(hero);
                        }
                    });
                }
                
                // Remove retreated heroes from arrays
                battleState.heroes = battleState.heroes.filter(h => !h.retreated);
                battleState.turnOrder = battleState.turnOrder.filter(combatant => {
                    if (battleState.heroes.includes(combatant)) return true;
                    if (battleState.enemies.includes(combatant)) return combatant.hp > 0;
                    return false;
                });
                
                updateBattleHeroCards();
                renderBattle();
                broadcastGameState();
                
                // Check if any heroes still alive
                if (battleState.heroes.length === 0) {
                    showBattleNotification('DEFEAT! ALL HEROES RETREATED!');
                    
                    // Notify all clients to end battle
                    sendWebSocketMessage({
                        type: 'battle_end',
                        reason: 'retreat'
                    });
                    
                    setTimeout(() => {
                        // Hide notification
                        const notification = document.getElementById('battleNotification');
                        if (notification) notification.style.display = 'none';
                        
                        endBattle();
                    }, 2000);
                } else {
                    // Reset turn if current combatant was removed
                    const currentCombatant = battleState.turnOrder[battleState.currentTurn];
                    if (!currentCombatant) {
                        battleState.currentTurn = 0;
                        updateBattleTurnInfo();
                    }
                }
                return;
            }
            
            // Find hero
            const hero = battleState.heroes.find(h => h.name.toLowerCase() === heroName.toLowerCase());
            if (!hero) return;
            
            // Execute action (existing battle logic)
            if (action === 'light' || action === 'heavy' || action === 'special') {
                const enemy = battleState.enemies[target];
                if (enemy) {
                    executeAttack(hero, enemy, action);
                }
            } else if (action === 'swap') {
                // Handle swap with target hero
                const targetHero = battleState.heroes[target];
                if (targetHero && targetHero !== hero) {
                    const tempX = hero.x;
                    const tempY = hero.y;
                    const tempPlatform = hero.platform;
                    
                    hero.x = targetHero.x;
                    hero.y = targetHero.y;
                    hero.platform = targetHero.platform;
                    
                    targetHero.x = tempX;
                    targetHero.y = tempY;
                    targetHero.platform = tempPlatform;
                    
                    showDiceRoll(`${hero.name} swapped positions with ${targetHero.name}!`);
                    advanceTurn();
                }
            } else if (action === 'defend') {
                hero.defending = true;
                showDiceRoll(`${hero.name} defends!`);
                advanceTurn();
            } else if (action === 'heal') {
                if (hero.healsRemaining > 0) {
                    const healAmount = Math.floor(hero.maxHp * 0.5);
                    hero.hp = Math.min(hero.maxHp, hero.hp + healAmount);
                    hero.healsRemaining--;
                    hero.usedHeal = true;
                    showDiceRoll(`${hero.name} heals for ${healAmount} HP! (1 action used)`);
                    updateBattleHeroCards();
                }
            } else if (action === 'taunt') {
                const chaModifier = calculateModifier(hero.stats?.cha || 10);
                const tauntRoll = rollD20() + chaModifier;
                const tauntDC = 12;
                
                if (tauntRoll >= tauntDC) {
                    hero.taunting = true;
                    hero.tauntTurns = 3;
                    showDiceRoll(`${hero.name} taunts! d20(${tauntRoll}) SUCCESS!`);
                } else {
                    showDiceRoll(`${hero.name} taunt fails! d20(${tauntRoll}) vs DC ${tauntDC}`);
                }
                advanceTurn();
            } else if (action === 'skip') {
                showDiceRoll(`${hero.name} skips turn.`);
                advanceTurn();
            }
            
            // Broadcast state to all clients
            broadcastGameState();
        }
        
        function broadcastGameState() {
            if (multiplayerState.role !== 'host') return;
            
            const canvas = battleState.canvas;
            
            const state = {
                turnOrder: battleState.turnOrder.map(c => ({ name: c.name, hp: c.hp })),
                heroes: battleState.heroes.map(h => ({
                    name: h.name,
                    hp: h.hp,
                    maxHp: h.maxHp,
                    xp: h.xp,
                    level: h.level,
                    healsRemaining: h.healsRemaining,
                    stats: h.stats,
                    x: h.x / canvas.width,
                    y: h.y / canvas.height,
                    platform: h.platform,
                    defending: h.defending,
                    taunting: h.taunting,
                    tauntTurns: h.tauntTurns || 0,
                    usedHeal: h.usedHeal || false,
                    facing: h.facing,
                    retreated: h.retreated || false,
                    color: h.color,
                    spritePath: h.spritePath,
                    initiative: h.initiative
                })),
                enemies: battleState.enemies.map(e => ({
                    name: e.name,
                    species: e.species,
                    hp: e.hp,
                    maxHp: e.maxHp,
                    ac: e.ac,
                    attackDamage: e.attackDamage,
                    speed: e.speed,
                    dex: e.dex,
                    hostile: e.hostile,
                    x: e.x / canvas.width,
                    y: e.y / canvas.height,
                    platform: e.platform,
                    facing: e.facing,
                    isMob: e.isMob,
                    isBoss: e.isBoss,
                    spritePath: e.spritePath,
                    backstory: e.backstory,
                    initiative: e.initiative,
                    goldDrop: e.goldDrop || 0
                })),
                // Include captive state for sync
                captiveNpc: battleState.captiveNpc ? {
                    name: battleState.captiveNpc.name,
                    rescued: battleState.captiveNpc.rescued,
                    hp: battleState.captiveNpc.hp || 1,
                    maxHp: battleState.captiveNpc.maxHp || 1,
                    goldReward: battleState.captiveNpc.goldReward || 0,
                    x: battleState.captiveNpc.x / canvas.width,
                    y: battleState.captiveNpc.y / canvas.height
                } : null,
                currentTurn: battleState.currentTurn,
                // Sync gold to clients
                gold: loadSharedSave()?.dungeonState?.gold || 0
            };
            
            sendWebSocketMessage({ type: 'state_update', state });
        }
        
        function updateGameStateFromHost(state) {
            // Client updates local state from host
            battleState.currentTurn = state.currentTurn;
            
            const canvas = battleState.canvas;
            
            // Rebuild heroes array to handle removals (retreats)
            battleState.heroes = state.heroes.map(heroData => {
                const existingHero = battleState.heroes.find(h => h.name === heroData.name);
                if (existingHero) {
                    // Update ALL fields from host state for complete sync
                    existingHero.hp = heroData.hp;
                    existingHero.maxHp = heroData.maxHp;
                    existingHero.xp = heroData.xp;
                    existingHero.level = heroData.level;
                    existingHero.healsRemaining = heroData.healsRemaining;
                    existingHero.stats = heroData.stats;
                    existingHero.x = heroData.x * canvas.width;
                    existingHero.y = (heroData.y * canvas.height) - 25;
                    existingHero.platform = heroData.platform;
                    existingHero.defending = heroData.defending;
                    existingHero.taunting = heroData.taunting;
                    existingHero.tauntTurns = heroData.tauntTurns || 0;
                    existingHero.usedHeal = heroData.usedHeal || false;
                    existingHero.facing = heroData.facing;
                    existingHero.retreated = heroData.retreated || false;
                    existingHero.color = heroData.color;
                    existingHero.spritePath = heroData.spritePath;
                    existingHero.initiative = heroData.initiative;
                    return existingHero;
                } else {
                    console.warn('[MP] Received unknown hero:', heroData.name);
                    return null;
                }
            }).filter(h => h !== null);
            
            // Update enemies - rebuild array to handle removals
            battleState.enemies = state.enemies.map(enemyData => {
                const existingEnemy = battleState.enemies.find(e => e.name === enemyData.name);
                if (existingEnemy) {
                    // Update ALL enemy fields from host state for complete sync
                    existingEnemy.hp = enemyData.hp;
                    existingEnemy.maxHp = enemyData.maxHp;
                    existingEnemy.ac = enemyData.ac;
                    existingEnemy.attackDamage = enemyData.attackDamage;
                    existingEnemy.speed = enemyData.speed;
                    existingEnemy.dex = enemyData.dex;
                    existingEnemy.hostile = enemyData.hostile;
                    existingEnemy.x = enemyData.x * canvas.width;
                    existingEnemy.y = (enemyData.y * canvas.height) - 25;
                    existingEnemy.platform = enemyData.platform;
                    existingEnemy.facing = enemyData.facing;
                    existingEnemy.isMob = enemyData.isMob;
                    existingEnemy.isBoss = enemyData.isBoss;
                    existingEnemy.spritePath = enemyData.spritePath;
                    existingEnemy.backstory = enemyData.backstory;
                    existingEnemy.initiative = enemyData.initiative;
                    existingEnemy.goldDrop = enemyData.goldDrop || 0;
                    existingEnemy.species = enemyData.species;
                    return existingEnemy;
                } else {
                    // This shouldn't happen in normal gameplay, but handle it
                    console.warn('[MP] Received unknown enemy:', enemyData.name);
                    return null;
                }
            }).filter(e => e !== null);
            
            // Update captive NPC state from host
            if (state.captiveNpc && battleState.captiveNpc) {
                battleState.captiveNpc.rescued = state.captiveNpc.rescued;
                battleState.captiveNpc.hp = state.captiveNpc.hp;
                battleState.captiveNpc.maxHp = state.captiveNpc.maxHp;
                battleState.captiveNpc.goldReward = state.captiveNpc.goldReward;
                if (state.captiveNpc.x !== undefined) {
                    battleState.captiveNpc.x = state.captiveNpc.x * canvas.width;
                    battleState.captiveNpc.y = state.captiveNpc.y * canvas.height;
                }
            }
            
            // Rebuild turn order to match host
            battleState.turnOrder = state.turnOrder.map(combatantData => {
                return battleState.heroes.find(h => h.name === combatantData.name) || 
                       battleState.enemies.find(e => e.name === combatantData.name);
            }).filter(c => c);
            
            // Update client hero stats cache from host state
            if (multiplayerState.role === 'client') {
                state.heroes.forEach(heroData => {
                    const heroKey = heroData.name.toLowerCase();
                    if (multiplayerState.heroStatsCache[heroKey] !== undefined) {
                        multiplayerState.heroStatsCache[heroKey] = {
                            hp: heroData.hp,
                            maxHp: heroData.maxHp,
                            xp: heroData.xp,
                            level: heroData.level,
                            str: heroData.stats?.str,
                            dex: heroData.stats?.dex,
                            con: heroData.stats?.con,
                            int: heroData.stats?.int,
                            wis: heroData.stats?.wis,
                            cha: heroData.stats?.cha
                        };
                    }
                });
            }
            
            // Check win condition for clients - change retreat button and show notification
            if (multiplayerState.role === 'client' && battleState.enemies.length === 0 && !battleState.won) {
                battleState.won = true;
                showBattleNotification('ROOM CLEARED!');
                const retreatBtn = document.querySelector('.battleButton.retreat');
                if (retreatBtn) {
                    retreatBtn.textContent = 'üö™ LEAVE';
                }
            }
            
            // Update gold cache for clients
            if (state.gold !== undefined) {
                multiplayerState.goldCache = state.gold;
                updateGoldDisplay();
            }
            
            // Check if this was a resync response
            if (multiplayerState.awaitingResync) {
                multiplayerState.awaitingResync = false;
                showNotification('‚úÖ Resynced with host!', 'success');
            }
            
            // Re-render
            renderBattle();
            updateBattleHeroCards();
            updateBattleEnemyCards();
            updateBattleTurnInfo();
            updateChatTargets();  // Refresh chat buttons when enemies die
        }
        
        function initializeBattleFromHost(battleData) {
            // Client receives full battle initialization from host
            // Ensure canvas is initialized
            if (!battleState.canvas) {
                battleState.canvas = document.getElementById('battleCanvas');
                battleState.ctx = battleState.canvas.getContext('2d');
                battleState.canvas.width = window.innerWidth;
                battleState.canvas.height = window.innerHeight - 180;
            }
            
            const canvas = battleState.canvas;
            
            // Set background
            battleState.backgroundPath = battleData.backgroundPath;
            battleState.backgroundImage = new Image();
            battleState.backgroundImage.onload = () => {
                renderBattle();
            };
            battleState.backgroundImage.onerror = () => {
                console.error('[MP ERROR] Background failed to load:', battleState.backgroundPath);
            };
            battleState.backgroundImage.src = battleState.backgroundPath;
            
            // Setup heroes with host's data
            battleState.heroes = battleData.heroes.map(hData => {
                const hero = {
                    name: hData.name,
                    hp: hData.hp,
                    maxHp: hData.maxHp,
                    xp: hData.xp,
                    healsRemaining: hData.healsRemaining,
                    stats: hData.stats,
                    color: hData.name === 'Zooko' ? '#F2C94C' : hData.name === 'Nate' ? '#E74C3C' : hData.name === 'Zancas' ? '#27AE60' : '#2E86DE',
                    x: hData.x * canvas.width,
                    y: (hData.y * canvas.height) - 25,
                    platform: hData.platform,
                    initiative: hData.initiative,
                    facing: 'center',
                    sprite: new Image(),
                    spritePath: hData.spritePath
                };
                hero.sprite.onload = () => {
                    renderBattle();
                };
                hero.sprite.onerror = () => {
                    console.error('[MP ERROR] Hero sprite failed:', hero.name, hero.spritePath);
                };
                hero.sprite.src = hero.spritePath + '?v=' + Date.now();
                return hero;
            });
            
            // Initialize animation controllers for heroes (so clients can receive animation_sync)
            battleState.heroes.forEach(hero => {
                const heroKey = hero.name.toLowerCase();
                let idlePath = HERO_ANIM_PATHS[heroKey]?.idle;
                // Handle array of idle variants - pick random one
                if (Array.isArray(idlePath)) {
                    idlePath = idlePath[Math.floor(Math.random() * idlePath.length)];
                }
                if (idlePath) {
                    initAnimation(hero, idlePath, 'pingpong');
                }
            });
            
            // Setup enemies with host's data
            battleState.enemies = battleData.enemies.map(eData => {
                const enemy = {
                    name: eData.name,
                    species: eData.species,
                    hp: eData.hp,
                    maxHp: eData.maxHp,
                    ac: eData.ac,
                    attackDamage: eData.attackDamage,
                    speed: eData.speed,
                    dex: eData.dex,
                    hostile: eData.hostile,
                    color: eData.isMob ? '#5C3317' : '#8B45FF',
                    x: eData.x * canvas.width,
                    y: (eData.y * canvas.height) - 25,
                    platform: eData.platform,
                    initiative: eData.initiative,
                    facing: 'center',
                    sprite: new Image(),
                    spritePath: eData.spritePath,
                    isMob: eData.isMob,
                    isBoss: eData.isBoss,
                    goldDrop: eData.goldDrop || 0,
                    backstory: eData.backstory
                };
                enemy.sprite.onload = () => {
                    renderBattle();
                };
                enemy.sprite.onerror = () => {
                    console.error('[MP ERROR] Enemy sprite failed:', enemy.name, enemy.spritePath);
                };
                enemy.sprite.src = enemy.spritePath + '?v=' + Date.now();
                return enemy;
            });
            
            // Setup turn order from host
            const allCombatants = [...battleState.heroes, ...battleState.enemies];
            battleState.turnOrder = battleData.turnOrder.map(name => 
                allCombatants.find(c => c.name === name)
            ).filter(c => c); // Filter out any not found
            
            if (battleState.turnOrder.length === 0) {
                console.error('[MP ERROR] Turn order is empty after initialization!');
            }
            
            // Setup captive NPC from host's data (full mob-like entity)
            if (battleData.captiveNpc) {
                battleState.captiveNpc = {
                    name: battleData.captiveNpc.name,
                    species: battleData.captiveNpc.species,
                    backstory: battleData.captiveNpc.backstory,
                    personality: battleData.captiveNpc.personality,
                    rescueReward: battleData.captiveNpc.rescueReward,
                    goldReward: battleData.captiveNpc.goldReward || battleData.captiveNpc.rescueReward?.gold || 0,
                    dialogueOnRescue: battleData.captiveNpc.dialogueOnRescue,
                    rescued: battleData.captiveNpc.rescued,
                    hp: battleData.captiveNpc.hp || 1,
                    maxHp: battleData.captiveNpc.maxHp || 1,
                    x: battleData.captiveNpc.x * canvas.width,
                    y: battleData.captiveNpc.y * canvas.height,
                    spritePath: battleData.captiveNpc.spritePath,
                    color: battleData.captiveNpc.color || '#F2C94C',
                    sprite: new Image(),
                    isCaptive: true,
                    isMob: false,
                    canChat: true,
                    hostile: false,
                    facing: battleData.captiveNpc.facing || 'center'
                };
                // Handle sprite load with graceful fallback
                battleState.captiveNpc.sprite.onerror = () => {
                    console.log('[MP] Captive sprite not found, using fallback circle');
                };
                battleState.captiveNpc.sprite.onload = () => {
                    renderBattle();
                };
                battleState.captiveNpc.sprite.src = battleState.captiveNpc.spritePath + '?v=' + Date.now();
                console.log('[MP] Captive NPC received:', battleState.captiveNpc.name);
            } else {
                battleState.captiveNpc = null;
            }
            
            battleState.currentTurn = battleData.currentTurn;
            battleState.active = true;
            battleState.targetingMode = false;
            battleState.pendingAction = null;
            
            // Update UI
            updateBattleTurnInfo();
            updateBattleHeroCards();
            updateBattleEnemyCards();
            renderBattle();
            
            // Show captive NPC notification if present (same as host)
            if (battleState.captiveNpc) {
                setTimeout(() => {
                    showBattleNotification(`A prisoner is here: ${battleState.captiveNpc.name}!`);
                }, 2000);
            }
            
            // Start battle animation loop for continuous updates
            function battleAnimationLoop() {
                if (battleState.active) {
                    renderBattle();
                    requestAnimationFrame(battleAnimationLoop);
                }
            }
            battleAnimationLoop();
            
            showNotification('Battle initialized!', 'success');
        }
        
        function showNotification(message, type = 'info') {
            // Simple notification system
            const color = type === 'error' ? '#EB5757' : type === 'success' ? '#27AE60' : type === 'warning' ? '#F39C12' : '#3498DB';
            showDiceRoll(message);
        }
        
        // ===== NETWORK DEBUG FUNCTIONS =====
        let debugMessageLog = [];
        const MAX_DEBUG_MESSAGES = 20;
        
        function toggleNetworkDebug() {
            const panel = document.getElementById('networkDebugPanel');
            const checkbox = document.getElementById('networkDebug');
            
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
                if (checkbox) checkbox.checked = true;
            } else {
                panel.style.display = 'none';
                if (checkbox) checkbox.checked = false;
            }
        }
        
        function logDebugMessage(type, data, direction = 'out') {
            const timestamp = new Date().toLocaleTimeString();
            const arrow = direction === 'out' ? '‚¨ÜÔ∏è' : '‚¨áÔ∏è';
            const color = direction === 'out' ? '#F39C12' : '#3498DB';
            
            debugMessageLog.push({
                timestamp,
                type,
                data,
                direction,
                arrow,
                color
            });
            
            // Keep only last 20 messages
            if (debugMessageLog.length > MAX_DEBUG_MESSAGES) {
                debugMessageLog.shift();
            }
            
            updateDebugLogDisplay();
        }
        
        function updateDebugLogDisplay() {
            const logDiv = document.getElementById('debugMessageLog');
            if (!logDiv) return;
            
            logDiv.innerHTML = debugMessageLog.map(msg => `
                <div style="margin-bottom: 8px; padding: 5px; border-left: 3px solid ${msg.color}; background: rgba(0,0,0,0.3);">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 3px;">
                        <span style="color: #89A0B4; font-size: 10px;">${msg.timestamp}</span>
                        <span style="font-size: 10px;">${msg.arrow} ${msg.type}</span>
                    </div>
                    <div style="color: #E9F0F7; font-size: 10px; word-break: break-word;">${JSON.stringify(msg.data, null, 2).slice(0, 200)}</div>
                </div>
            `).join('');
            
            // Auto-scroll to bottom
            logDiv.scrollTop = logDiv.scrollHeight;
        }
        
        function clearDebugLog() {
            debugMessageLog = [];
            updateDebugLogDisplay();
        }
        
        function updateDebugStatus() {
            const connStatus = document.getElementById('debugConnStatus');
            const roomState = document.getElementById('debugRoomState');
            
            if (connStatus) {
                if (multiplayerState.ws && multiplayerState.ws.readyState === WebSocket.OPEN) {
                    connStatus.textContent = '‚úÖ Connected';
                    connStatus.style.color = '#27AE60';
                } else {
                    connStatus.textContent = '‚ùå Disconnected';
                    connStatus.style.color = '#EB5757';
                }
            }
            
            if (roomState) {
                if (multiplayerState.enabled && multiplayerState.roomCode) {
                    const role = multiplayerState.role === 'host' ? 'üëë HOST' : 'üéÆ CLIENT';
                    const players = multiplayerState.connectedPlayers.length;
                    roomState.innerHTML = `
                        <div>${role}</div>
                        <div style="margin-top: 3px;">Code: <span style="color: #F2C94C; font-weight: bold;">${multiplayerState.roomCode}</span></div>
                        <div style="margin-top: 3px;">Players: ${players}/4</div>
                        <div style="margin-top: 3px;">My Heroes: <span style="color: #F2C94C;">${multiplayerState.myHeroes.join(', ') || 'None'}</span></div>
                    `;
                    roomState.style.color = '#2A9D8F';
                } else {
                    roomState.textContent = 'No room';
                    roomState.style.color = '#89A0B4';
                }
            }
        }
        
        // ===== END MULTIPLAYER FUNCTIONS =====
        
        function init() {
            console.log('Tunnels of Privacy - Initializing...');
            
            // Load settings
            loadSettings();
            console.log('Settings loaded:', settings);
            
            // Check TTS availability
            checkTTSAvailability();
            
            // ===== GAMEPAD SUPPORT =====
            // Handle gamepad connections
            window.addEventListener('gamepadconnected', onGamepadConnected);
            window.addEventListener('gamepaddisconnected', onGamepadDisconnected);
            // Start gamepad polling loop
            gamepadLoop();
            // ===== END GAMEPAD SUPPORT =====
            
            // Preload assets
            preloadAssets();
            
            // Start background animation
            startStoryIntroAnimation();
            
            // Load shared save and display hero stats
            const sharedSave = loadSharedSave();
            const heroStatsEl = document.getElementById('heroStats');
            
            if (sharedSave && sharedSave.heroes) {
                console.log('Loaded shared save with heroes:', sharedSave.heroes);
                
                // Show hero party
                if (heroStatsEl) heroStatsEl.style.display = 'block';
                
                // Update each hero's display
                updateHeroDisplay('zooko', sharedSave.heroes.zooko);
                updateHeroDisplay('nate', sharedSave.heroes.nate);
                updateHeroDisplay('zancas', sharedSave.heroes.zancas);
                updateHeroDisplay('cyberaxe', sharedSave.heroes.cyberaxe);
                
                // Update dungeon level from arcade level
                if (sharedSave.arcadeState && sharedSave.arcadeState.level) {
                    const arcadeLevel = sharedSave.arcadeState.level;
                    document.getElementById('dungeonLevel').textContent = arcadeLevel;
                    console.log('Dungeon depth set to arcade level:', arcadeLevel);
                } else {
                    console.log('No arcade level found - defaulting to level 1');
                }
            } else {
                console.log('No shared save found - hiding hero party');
                // Hide hero party when no save exists
                if (heroStatsEl) heroStatsEl.style.display = 'none';
            }
            
            // Update title screen button states
            updateTitleScreenButtons();
            
            console.log('Initialization complete. Portal system ready.');
        }
        
        // Run init when page loads
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
