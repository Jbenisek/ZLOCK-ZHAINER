<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <title>TUNNELS OF PRIVACY - Dungeon Crawler v0.4.08</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet" media="print" onload="this.media='all'; this.onload=null;">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        /* Custom Scrollbar Styling - Fantasy RPG Theme */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        
        ::-webkit-scrollbar-track {
            background: rgba(20, 10, 40, 0.6);
            border-radius: 5px;
            border: 1px solid rgba(139, 69, 255, 0.2);
        }
        
        ::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #8B45FF 0%, #6B35CC 50%, #4B2599 100%);
            border-radius: 5px;
            border: 1px solid rgba(139, 69, 255, 0.4);
            box-shadow: inset 0 0 5px rgba(255, 255, 255, 0.1);
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, #9B55FF 0%, #7B45DC 50%, #5B35A9 100%);
            box-shadow: 0 0 8px rgba(139, 69, 255, 0.5);
        }
        
        ::-webkit-scrollbar-corner {
            background: rgba(20, 10, 40, 0.6);
        }
        
        /* Firefox scrollbar styling */
        * {
            scrollbar-width: thin;
            scrollbar-color: #8B45FF rgba(20, 10, 40, 0.6);
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #0A0E12 0%, #1A1E2A 100%);
            color: #E9F0F7;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            cursor: default;
        }
        
        #gameContainer {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #titleScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 14, 18, 0.95);
            z-index: 100;
            pointer-events: none;
        }
        
        #dungeonMenuScreen {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0A0E12 0%, #1A1E2A 100%);
            z-index: 100;
        }
        
        #dungeonMenuBackground {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.25;
            background-size: 800% 1600%;
            background-position: 0% 0%;
            background-repeat: no-repeat;
            transition: opacity 1s ease-in-out;
        }
        
        #battleScreen {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a0f2e 0%, #0f0a1e 100%);
            z-index: 100;
        }
        
        #battleCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: calc(100% - 180px);
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        #battleNotification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(46, 204, 113, 0.95), rgba(39, 174, 96, 0.95));
            border: 4px solid #27AE60;
            border-radius: 12px;
            padding: 40px 60px;
            font-family: 'Inter', sans-serif;
            font-size: 48px;
            font-weight: 900;
            color: #FFFFFF;
            text-shadow: 0 4px 8px rgba(0, 0, 0, 0.6);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
            z-index: 1000;
            display: none;
            width: 700px;
            text-align: center;
            word-wrap: break-word;
            overflow-wrap: break-word;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 4px;
            animation: notificationPulse 0.5s ease-out;
        }
        
        @keyframes notificationPulse {
            0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        
        @keyframes slideInRight {
            0% { transform: translateY(-50%) translateX(100px); opacity: 0; }
            100% { transform: translateY(-50%) translateX(0); opacity: 1; }
        }
        
        #battleEnemyCards {
            position: absolute;
            top: 20px;
            left: 20px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            max-width: 170px;
            max-height: calc(100vh - 180px);
            overflow-y: auto;
            overflow-x: hidden;
            z-index: 10;
            scrollbar-width: none;  /* Firefox */
            -ms-overflow-style: none;  /* IE/Edge */
        }
        
        #battleEnemyCards::-webkit-scrollbar {
            display: none;  /* Chrome/Safari/Opera */
        }
        
        #battleEnemyCards.threeColumns {
            grid-template-columns: 1fr 1fr 1fr;
            max-width: 255px;
        }
        
        .battleEnemyCard {
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            border: 2px solid #E74C3C;
            border-radius: 6px;
            padding: 4px;
            width: 75px;
            backdrop-filter: blur(10px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
            cursor: pointer;
            transition: all 0.3s ease;
            transform-origin: top left;
        }
        
        .battleEnemyCard.enlarged {
            position: fixed;
            transform: scale(2);
            z-index: 1000;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.8);
        }
        
        .battleEnemyCard.boss {
            border-color: #8B45FF;
            box-shadow: 0 0 8px rgba(139, 69, 255, 0.4);
        }
        
        .battleEnemyCard.targetable {
            border-color: #FFD700;
            box-shadow: 0 0 12px rgba(255, 215, 0, 0.6);
            animation: cardPulse 1s infinite;
        }
        
        .battleEnemyCard:hover.targetable {
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.8);
        }
        
        @keyframes cardPulse {
            0%, 100% { box-shadow: 0 0 12px rgba(255, 215, 0, 0.6); }
            50% { box-shadow: 0 0 18px rgba(255, 215, 0, 0.9); }
        }
        
        .battleEnemyCard.dead {
            opacity: 0.4;
            cursor: not-allowed;
            filter: grayscale(100%);
        }
        
        .battleEnemyPortrait {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background-size: cover;
            background-position: center;
            border: 1px solid #E74C3C;
            margin: 0 auto 3px auto;
            box-shadow: 0 0 5px rgba(231, 76, 60, 0.4);
        }
        
        .battleEnemyCard.boss .battleEnemyPortrait {
            border-color: #8B45FF;
            box-shadow: 0 0 5px rgba(139, 69, 255, 0.4);
        }
        
        .battleEnemyName {
            font-family: 'Inter', sans-serif;
            font-size: 7px;
            font-weight: 700;
            text-align: center;
            margin-bottom: 2px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            color: #E74C3C;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .battleEnemyCard.boss .battleEnemyName {
            color: #8B45FF;
        }
        
        .battleEnemyStat {
            font-size: 6px;
            text-align: center;
            margin-bottom: 1px;
        }
        
        .battleEnemyCard.captive {
            border-color: #F2C94C;
            box-shadow: 0 0 8px rgba(242, 201, 76, 0.4);
        }
        
        .battleEnemyCard.captive .battleEnemyPortrait {
            border-color: #F2C94C;
            box-shadow: 0 0 5px rgba(242, 201, 76, 0.4);
            background-size: 250%;
            background-position: center 15%;
        }
        
        .battleEnemyCard.captive .battleEnemyName {
            color: #F2C94C;
            margin-top: -4px;
            position: relative;
            z-index: 10;
        }
        
        /* Enemy Privacy Breach Tooltip - They have no privacy! */
        #enemyPrivacyTooltip {
            position: fixed;
            width: 420px;
            background: linear-gradient(135deg, rgba(20, 5, 5, 0.98), rgba(40, 10, 10, 0.98));
            border: 2px solid #E74C3C;
            border-radius: 12px;
            padding: 15px 18px;
            z-index: 100000;
            pointer-events: none;
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.3s ease, transform 0.3s ease;
            box-shadow: 0 8px 32px rgba(231, 76, 60, 0.4), 0 0 60px rgba(139, 69, 255, 0.2);
            backdrop-filter: blur(10px);
            font-family: 'JetBrains Mono', monospace;
        }
        
        #enemyPrivacyTooltip.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        #enemyPrivacyTooltip .privacy-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(231, 76, 60, 0.5);
        }
        
        #enemyPrivacyTooltip .privacy-warning {
            color: #E74C3C;
            font-size: 10px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2px;
            animation: privacyBlink 1s ease-in-out infinite;
        }
        
        @keyframes privacyBlink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        #enemyPrivacyTooltip .privacy-title {
            color: #FF6B6B;
            font-size: 18px;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        #enemyPrivacyTooltip .privacy-subtitle {
            color: #E74C3C;
            font-size: 11px;
            font-style: italic;
            margin-top: 2px;
        }
        
        #enemyPrivacyTooltip .privacy-section {
            margin-bottom: 10px;
        }
        
        #enemyPrivacyTooltip .privacy-section-title {
            color: #E74C3C;
            font-size: 10px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        #enemyPrivacyTooltip .privacy-row {
            display: flex;
            justify-content: space-between;
            padding: 3px 0;
            border-bottom: 1px solid rgba(231, 76, 60, 0.15);
        }
        
        #enemyPrivacyTooltip .privacy-label {
            color: #89A0B4;
            font-size: 11px;
        }
        
        #enemyPrivacyTooltip .privacy-value {
            color: #FFD700;
            font-size: 11px;
            font-weight: 600;
            text-align: right;
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        #enemyPrivacyTooltip .privacy-value.embarrassing {
            color: #FF69B4;
        }
        
        #enemyPrivacyTooltip .privacy-value.password {
            color: #00FF00;
            font-family: 'Courier New', monospace;
        }
        
        #enemyPrivacyTooltip .privacy-backstory {
            color: #BFD1E0;
            font-size: 11px;
            line-height: 1.5;
            font-style: italic;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            border-left: 3px solid #E74C3C;
        }
        
        #enemyPrivacyTooltip .privacy-footer {
            margin-top: 12px;
            padding-top: 8px;
            border-top: 1px solid rgba(231, 76, 60, 0.3);
            text-align: center;
        }
        
        #enemyPrivacyTooltip .privacy-footer-text {
            color: #E74C3C;
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        /* ===== FOOD TRANSPARENCY TOOLTIP ===== */
        #foodTooltip {
            position: fixed;
            min-width: 280px;
            max-width: 340px;
            background: linear-gradient(135deg, rgba(5, 20, 5, 0.98), rgba(10, 40, 10, 0.98));
            border: 2px solid #27AE60;
            border-radius: 12px;
            padding: 15px 18px;
            z-index: 100000;
            pointer-events: none;
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.3s ease, transform 0.3s ease;
            box-shadow: 0 8px 32px rgba(39, 174, 96, 0.4), 0 0 60px rgba(139, 69, 255, 0.2);
            backdrop-filter: blur(10px);
            font-family: 'JetBrains Mono', monospace;
        }
        
        #foodTooltip.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        #foodTooltip .food-header {
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(39, 174, 96, 0.5);
        }
        
        #foodTooltip .food-label {
            color: #27AE60;
            font-size: 10px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        #foodTooltip .food-title {
            color: #2ECC71;
            font-size: 16px;
            font-weight: 800;
            margin-top: 2px;
        }
        
        #foodTooltip .food-section-title {
            color: #27AE60;
            font-size: 10px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin: 8px 0 5px 0;
        }
        
        #foodTooltip .food-row {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            font-size: 11px;
        }
        
        #foodTooltip .food-row-label {
            color: #89A0B4;
        }
        
        #foodTooltip .food-row-value {
            color: #F1C40F;
            font-weight: 600;
            max-width: 180px;
            text-align: right;
        }
        
        #foodTooltip .food-row-value.warning {
            color: #E74C3C;
        }
        
        #foodTooltip .food-backstory {
            color: #BFD1E0;
            font-size: 10px;
            line-height: 1.4;
            font-style: italic;
            padding: 6px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            border-left: 3px solid #27AE60;
            margin-top: 8px;
        }
        
        #foodTooltip .food-footer {
            margin-top: 10px;
            padding-top: 6px;
            border-top: 1px solid rgba(39, 174, 96, 0.3);
            text-align: center;
            color: #27AE60;
            font-size: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        /* ===== POTION TRANSPARENCY TOOLTIP ===== */
        #potionTooltip {
            position: fixed;
            min-width: 280px;
            max-width: 340px;
            background: linear-gradient(135deg, rgba(20, 5, 30, 0.98), rgba(40, 10, 50, 0.98));
            border: 2px solid #9B59B6;
            border-radius: 12px;
            padding: 15px 18px;
            z-index: 100000;
            pointer-events: none;
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.3s ease, transform 0.3s ease;
            box-shadow: 0 8px 32px rgba(155, 89, 182, 0.4), 0 0 60px rgba(41, 128, 185, 0.2);
            backdrop-filter: blur(10px);
            font-family: 'JetBrains Mono', monospace;
        }
        
        #potionTooltip.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        #potionTooltip .potion-header {
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(155, 89, 182, 0.5);
        }
        
        #potionTooltip .potion-label {
            color: #9B59B6;
            font-size: 10px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        #potionTooltip .potion-title {
            color: #BB8FCE;
            font-size: 16px;
            font-weight: 800;
            margin-top: 2px;
        }
        
        #potionTooltip .potion-section-title {
            color: #9B59B6;
            font-size: 10px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin: 8px 0 5px 0;
        }
        
        #potionTooltip .potion-row {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            font-size: 11px;
        }
        
        #potionTooltip .potion-row-label {
            color: #89A0B4;
        }
        
        #potionTooltip .potion-row-value {
            color: #3498DB;
            font-weight: 600;
            max-width: 180px;
            text-align: right;
        }
        
        #potionTooltip .potion-row-value.warning {
            color: #E74C3C;
        }
        
        #potionTooltip .potion-row-value.magic {
            color: #BB8FCE;
        }
        
        #potionTooltip .potion-backstory {
            color: #BFD1E0;
            font-size: 10px;
            line-height: 1.4;
            font-style: italic;
            padding: 6px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            border-left: 3px solid #9B59B6;
            margin-top: 8px;
        }
        
        #potionTooltip .potion-warning {
            color: #E74C3C;
            font-size: 9px;
            text-align: center;
            margin-top: 6px;
            padding: 4px;
            background: rgba(231, 76, 60, 0.1);
            border-radius: 4px;
        }
        
        #potionTooltip .potion-footer {
            margin-top: 10px;
            padding-top: 6px;
            border-top: 1px solid rgba(155, 89, 182, 0.3);
            text-align: center;
            color: #9B59B6;
            font-size: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        /* ===== ACHIEVEMENTS & BESTIARY PANELS ===== */
        #achievementsPanel, #bestiaryPanel {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(15, 10, 35, 0.98), rgba(30, 20, 50, 0.98));
            border: 3px solid #8B45FF;
            border-radius: 15px;
            padding: 20px 25px;
            z-index: 10002;
            max-width: 900px;
            width: 90%;
            max-height: 85vh;
            box-shadow: 0 10px 50px rgba(139, 69, 255, 0.4), 0 0 80px rgba(139, 69, 255, 0.3);
            backdrop-filter: blur(15px);
        }
        
        #bestiaryPanel {
            border-color: #E74C3C;
            box-shadow: 0 10px 50px rgba(231, 76, 60, 0.4), 0 0 80px rgba(139, 69, 255, 0.3);
        }
        
        .panelTitle {
            color: #8B45FF;
            font-size: 24px;
            font-weight: 900;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 3px;
            margin-bottom: 15px;
            text-shadow: 0 0 20px rgba(139, 69, 255, 0.5);
        }
        
        #bestiaryPanel .panelTitle {
            color: #E74C3C;
            text-shadow: 0 0 20px rgba(231, 76, 60, 0.5);
        }
        
        .panelCloseBtn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(255, 100, 100, 0.3);
            border: 2px solid #ff6b6b;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            color: #ff6b6b;
            font-size: 18px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }
        
        .panelCloseBtn:hover {
            background: rgba(255, 100, 100, 0.6);
            transform: scale(1.1);
        }
        
        /* Achievement Tabs */
        .achievementTabs {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 15px;
        }
        
        .achievementTab {
            padding: 10px 25px;
            background: rgba(139, 69, 255, 0.2);
            border: 2px solid #8B45FF;
            border-radius: 8px;
            color: #8B45FF;
            font-weight: 700;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .achievementTab:hover {
            background: rgba(139, 69, 255, 0.4);
            transform: translateY(-2px);
        }
        
        .achievementTab.active {
            background: #8B45FF;
            color: white;
            box-shadow: 0 4px 15px rgba(139, 69, 255, 0.5);
        }
        
        /* Bestiary Tabs */
        .bestiaryTab {
            padding: 10px 25px;
            background: rgba(231, 76, 60, 0.2);
            border: 2px solid #E74C3C;
            border-radius: 8px;
            color: #E74C3C;
            font-weight: 700;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .bestiaryTab:hover {
            background: rgba(231, 76, 60, 0.4);
            transform: translateY(-2px);
        }
        
        .bestiaryTab.active {
            background: #E74C3C;
            color: white;
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.5);
        }
        
        /* Achievement Grid */
        .achievementGrid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 6px;
        }
        
        .achievementItem {
            background: rgba(10, 14, 18, 0.6);
            border: 2px solid #26313B;
            border-radius: 6px;
            padding: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            transition: all 0.2s;
            cursor: default;
        }
        
        .achievementItem.unlocked {
            border-color: #8B45FF;
            background: linear-gradient(135deg, rgba(139, 69, 255, 0.2), rgba(179, 136, 255, 0.1));
            box-shadow: 0 2px 10px rgba(139, 69, 255, 0.3);
        }
        
        .achievementItem:hover {
            transform: translateY(-3px);
            filter: brightness(1.2);
        }
        
        .achievementIcon {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            flex-shrink: 0;
        }
        
        .achievementIcon.unlocked {
            background: #F2C94C;
            color: #0B0E12;
        }
        
        .achievementIcon.locked {
            background: #1B2836;
            color: #89A0B4;
        }
        
        .achievementName {
            font-size: 9px;
            font-weight: 700;
            text-align: center;
            color: #D4E3F0;
            line-height: 1.1;
        }
        
        .achievementItem.unlocked .achievementName {
            color: #B388FF;
        }
        
        /* Bestiary Grid */
        .bestiaryGrid {
            display: grid;
            grid-template-columns: repeat(11, 1fr);
            gap: 6px;
        }
        
        .bossEntry {
            background: rgba(10, 14, 18, 0.6);
            border: 2px solid #26313B;
            border-radius: 8px;
            padding: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            transition: all 0.2s;
            cursor: pointer;
            position: relative;
        }
        
        .bossEntry.defeated {
            border-color: #27AE60;
            background: linear-gradient(135deg, rgba(39, 174, 96, 0.15), rgba(46, 204, 113, 0.1));
        }
        
        .bossEntry.locked {
            opacity: 0.5;
            filter: grayscale(1);
        }
        
        .bossEntry:hover {
            transform: translateY(-2px) scale(1.05);
            z-index: 10;
        }
        
        .bossEntry:hover .bossTooltip {
            display: block;
        }
        
        .bossPortrait {
            width: 50px;
            height: 50px;
            border-radius: 6px;
            background-size: cover;
            background-position: center center;
            border: 2px solid #444;
        }
        
        .bossEntry.defeated .bossPortrait {
            border-color: #27AE60;
        }
        
        .bossEntry.locked .bossPortrait {
            background: #1B2836;
            border-color: #26313B;
        }
        
        .bossLevel {
            font-size: 10px;
            font-weight: 700;
            color: #89A0B4;
        }
        
        .bossEntry.defeated .bossLevel {
            color: #27AE60;
        }
        
        .bossTooltip {
            display: none;
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(10, 14, 18, 0.95);
            border: 2px solid #E74C3C;
            border-radius: 8px;
            padding: 10px;
            width: 180px;
            z-index: 100;
            margin-bottom: 8px;
        }
        
        .bossTooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 8px solid transparent;
            border-top-color: #E74C3C;
        }
        
        .bossTooltipName {
            color: #E74C3C;
            font-size: 12px;
            font-weight: 700;
            text-align: center;
            margin-bottom: 6px;
        }
        
        .bossTooltipStats {
            font-size: 10px;
            color: #BFD1E0;
            line-height: 1.4;
        }
        
        .panelProgress {
            text-align: center;
            margin-top: 15px;
            padding-top: 12px;
            border-top: 2px solid rgba(42, 157, 143, 0.3);
            font-size: 16px;
            font-weight: 700;
            color: #4ECDC4;
        }
        
        #bestiaryPanel .panelProgress {
            border-top-color: rgba(231, 76, 60, 0.3);
            color: #E74C3C;
        }
        /* ===== END ACHIEVEMENTS & BESTIARY PANELS ===== */
        
        /* Chat Window Styles */
        #battleChatWindow {
            position: absolute;
            bottom: 10px;
            right: 20px;
            width: 350px;
            height: 600px;
            background: rgba(10, 14, 18, 0.5);
            border: 2px solid #5865F2;
            border-radius: 12px;
            display: none;
            flex-direction: column;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            z-index: 100;
            transition: height 0.3s ease;
        }
        
        #battleChatWindow.compact {
            height: 300px;
        }
        
        #battleChatWindow.compact #chatTargetSelector,
        #battleChatWindow.compact #chatModelSelector {
            display: none;
        }
        
        #chatExpandBtn {
            background: none;
            border: none;
            color: white;
            font-size: 16px;
            cursor: pointer;
            padding: 0 5px;
            margin-right: 4px;
        }
        
        #chatExpandBtn:hover {
            color: #5865F2;
        }
        
        #chatHeader {
            padding: 10px 15px;
            background: linear-gradient(135deg, #5865F2, #4752C4);
            border-radius: 10px 10px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        #chatHeader span {
            color: white;
            font-weight: 700;
            font-size: 14px;
        }
        
        #chatCloseBtn {
            background: none;
            border: none;
            color: white;
            font-size: 18px;
            cursor: pointer;
            padding: 0 5px;
        }
        
        #ttsToggleLabel {
            display: flex;
            align-items: center;
            gap: 4px;
            cursor: pointer;
            color: white;
            margin-left: auto;
            margin-right: 8px;
            padding: 2px 6px;
            border-radius: 4px;
            background: rgba(255,255,255,0.1);
        }
        
        #ttsToggleLabel:hover {
            background: rgba(255,255,255,0.2);
        }
        
        #ttsToggle {
            width: 14px;
            height: 14px;
            cursor: pointer;
        }
        
        #chatMessages {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .chatMessage {
            display: flex;
            gap: 8px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }
        
        .chatAvatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background-size: cover;
            background-position: center;
            flex-shrink: 0;
            border: 2px solid #444;
        }
        
        .chatContent {
            flex: 1;
            min-width: 0;
        }
        
        .chatName {
            font-size: 12px;
            font-weight: 700;
            margin-bottom: 2px;
        }
        
        .chatName.hostile { color: #E74C3C; }
        .chatName.questable { color: #F2C94C; }
        .chatName.friendly { color: #27AE60; }
        .chatName.player { color: #FFFFFF; }
        
        .chatText {
            font-size: 13px;
            color: #BFD1E0;
            word-wrap: break-word;
            overflow-wrap: break-word;
            white-space: pre-wrap;
        }
        
        .typingCursor {
            color: #5865F2;
            animation: cursorBlink 0.5s infinite;
        }
        
        @keyframes cursorBlink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        #chatInputArea {
            padding: 10px;
            border-top: 1px solid #333;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        #chatTargetSelector {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            max-height: 80px;
            overflow-y: auto;
            padding: 4px 0;
        }
        
        .chatTargetBtn {
            padding: 3px 8px;
            font-size: 10px;
            border: 1px solid #444;
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.5);
            color: #aaa;
            cursor: pointer;
            white-space: nowrap;
            max-width: 100px;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .chatTargetBtn:hover {
            background: rgba(88, 101, 242, 0.3);
            border-color: #5865F2;
        }
        
        .chatTargetBtn.active {
            background: #5865F2;
            color: white;
            border-color: #5865F2;
        }
        
        .chatTargetBtn.hostile {
            border-color: #E74C3C;
        }
        
        .chatTargetBtn.hostile.active {
            background: #E74C3C;
        }
        
        .chatTargetBtn.friendly {
            border-color: #F2C94C;
        }
        
        .chatTargetBtn.friendly.active {
            background: #F2C94C;
            color: #000;
        }
        
        .chatTargetBtn.boss {
            border-color: #8B45FF;
        }
        
        .chatTargetBtn.boss.active {
            background: #8B45FF;
        }
        
        .chatTargetBtn.broadcast {
            border-color: #27AE60;
        }
        
        .chatTargetBtn.broadcast.active {
            background: #27AE60;
        }
        
        #chatInputRow {
            display: flex;
            gap: 8px;
        }
        
        #chatInput {
            flex: 1;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #444;
            border-radius: 6px;
            padding: 8px 12px;
            color: white;
            font-size: 13px;
            outline: none;
        }
        
        #chatInput:focus {
            border-color: #5865F2;
        }
        
        #chatSendBtn {
            background: #5865F2;
            border: none;
            border-radius: 6px;
            padding: 8px 15px;
            color: white;
            font-weight: 600;
            cursor: pointer;
        }
        
        #chatModelSelector {
            display: flex;
            gap: 3px;
            padding: 5px 10px;
            border-bottom: 1px solid #333;
            flex-wrap: wrap;
            align-items: center;
            position: relative;
            z-index: 10;
        }
        
        #chatModelSelector span {
            pointer-events: none;
            user-select: none;
        }
        
        .modelBtn {
            width: 24px;
            height: 24px;
            border: 1px solid #444;
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.5);
            color: #aaa;
            font-size: 11px;
            cursor: pointer;
            padding: 0;
            position: relative;
            z-index: 11;
        }
        
        .modelBtn:hover {
            background: rgba(88, 101, 242, 0.3);
            border-color: #5865F2;
        }
        
        .modelBtn.active {
            background: #5865F2;
            color: white;
            border-color: #5865F2;
        }
        
        .modelBtn.exhausted {
            opacity: 0.5;
            cursor: not-allowed;
            position: relative;
        }
        
        .modelBtn.exhausted::after {
            content: 'âœ•';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #E74C3C;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 0 0 2px black;
        }
        
        #chatSendBtn:hover {
            background: #4752C4;
        }
        
        #chatSendBtn:disabled {
            background: #333;
            cursor: not-allowed;
        }
        
        .battleEnemyStat {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: #BFD1E0;
            text-align: center;
            margin: 2px 0;
        }
        
        #battleUI {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 180px;
            background: linear-gradient(180deg, rgba(10, 14, 18, 0) 0%, rgba(10, 14, 18, 0.95) 20%, rgba(10, 14, 18, 0.98) 100%);
            display: flex;
            flex-direction: row;
            align-items: flex-end;
            justify-content: center;
            padding: 15px;
            gap: 15px;
        }
        
        #battleUILeft {
            display: flex;
            flex-direction: row;
            gap: 10px;
            flex-shrink: 0;
        }
        
        #battleUICenter {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            gap: 10px;
        }
        
        #battleUIRight {
            display: flex;
            flex-direction: row;
            gap: 10px;
            flex-shrink: 0;
        }
        
        .battleHeroCard {
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            border: 2px solid #2A9D8F;
            border-radius: 8px;
            padding: 8px;
            width: 140px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
        }
        
        .battleHeroCard.active {
            border-color: #F2C94C;
            box-shadow: 0 0 20px rgba(242, 201, 76, 0.6);
        }
        
        /* Character-specific card borders */
        #battleCardZooko {
            border-color: #F2C94C;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4), 0 0 10px rgba(242, 201, 76, 0.3);
        }
        #battleCardNate {
            border-color: #E74C3C;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4), 0 0 10px rgba(231, 76, 60, 0.3);
        }
        #battleCardZancas {
            border-color: #27AE60;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4), 0 0 10px rgba(39, 174, 96, 0.3);
        }
        #battleCardCyberAxe {
            border-color: #2E86DE;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4), 0 0 10px rgba(46, 134, 222, 0.3);
        }
        
        .battleHeroPortrait {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-size: cover;
            background-position: center;
            border: 2px solid #2A9D8F;
            margin: 0 auto 6px auto;
            box-shadow: 0 0 10px rgba(42, 157, 143, 0.4);
        }
        
        .battleHeroName {
            font-family: 'Inter', sans-serif;
            font-size: 11px;
            font-weight: 700;
            text-align: center;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .battleHeroStat {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: #BFD1E0;
            text-align: center;
            margin: 2px 0;
        }
        
        #battleTurnInfo {
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            color: #F2C94C;
            text-shadow: 0 0 10px rgba(242, 201, 76, 0.5);
            margin-bottom: 5px;
        }
        
        #battleActions {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 5px;
            width: 100%;
            max-width: 700px;
        }
        
        .battleButton {
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            border: 2px solid #2A9D8F;
            color: #E9F0F7;
            font-family: 'Inter', sans-serif;
            font-size: 10px;
            font-weight: 600;
            padding: 4px 4px;
            border-radius: 6px;
            cursor: pointer;
            pointer-events: all;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .battleButton:hover:not(:disabled) {
            background: linear-gradient(135deg, rgba(42, 157, 143, 0.3), rgba(42, 157, 143, 0.2));
            border-color: #3DBAA3;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(42, 157, 143, 0.4);
        }
        
        .battleButton:active:not(:disabled) {
            transform: translateY(0px) scale(0.95);
            box-shadow: 0 2px 8px rgba(42, 157, 143, 0.6);
        }
        
        .battleButton:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        .battleButton.attack-weak { border-color: #3498DB; }
        .battleButton.attack-weak:hover:not(:disabled) { 
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.3), rgba(52, 152, 219, 0.2));
            border-color: #5DADE2;
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
        }
        
        .battleButton.attack-strong { border-color: #E74C3C; }
        .battleButton.attack-strong:hover:not(:disabled) { 
            background: linear-gradient(135deg, rgba(231, 76, 60, 0.3), rgba(231, 76, 60, 0.2));
            border-color: #EC7063;
            box-shadow: 0 6px 20px rgba(231, 76, 60, 0.4);
        }
        
        .battleButton.special { border-color: #F39C12; }
        .battleButton.special:hover:not(:disabled) { 
            background: linear-gradient(135deg, rgba(243, 156, 18, 0.3), rgba(243, 156, 18, 0.2));
            border-color: #F8C471;
            box-shadow: 0 6px 20px rgba(243, 156, 18, 0.4);
        }
        
        .battleButton.defend { border-color: #27AE60; }
        .battleButton.defend:hover:not(:disabled) { 
            background: linear-gradient(135deg, rgba(39, 174, 96, 0.3), rgba(39, 174, 96, 0.2));
            border-color: #52BE80;
            box-shadow: 0 6px 20px rgba(39, 174, 96, 0.4);
        }
        
        .battleButton.heal { border-color: #9B59B6; }
        .battleButton.heal:hover:not(:disabled) { 
            background: linear-gradient(135deg, rgba(155, 89, 182, 0.3), rgba(155, 89, 182, 0.2));
            border-color: #AF7AC5;
            box-shadow: 0 6px 20px rgba(155, 89, 182, 0.4);
        }
        
        .battleButton.swap { border-color: #3498DB; }
        .battleButton.swap:hover:not(:disabled) { 
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.3), rgba(52, 152, 219, 0.2));
            border-color: #5DADE2;
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
        }
        
        .battleButton.taunt { border-color: #E67E22; }
        .battleButton.taunt:hover:not(:disabled) { 
            background: linear-gradient(135deg, rgba(230, 126, 34, 0.3), rgba(230, 126, 34, 0.2));
            border-color: #F39C12;
            box-shadow: 0 6px 20px rgba(230, 126, 34, 0.4);
        }
        
        .battleButton.retreat { border-color: #95A5A6; }
        .battleButton.retreat:hover:not(:disabled) { 
            background: linear-gradient(135deg, rgba(149, 165, 166, 0.3), rgba(149, 165, 166, 0.2));
            border-color: #BDC3C7;
            box-shadow: 0 6px 20px rgba(149, 165, 166, 0.4);
        }
        
        #pauseScreen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 14, 18, 0.98);
            z-index: 1000;
            pointer-events: all;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        #pauseTitle {
            font-size: 72px;
            font-weight: 900;
            color: #8B45FF;
            text-shadow: 0 0 40px rgba(139, 69, 255, 0.6);
            margin-bottom: 40px;
            letter-spacing: 8px;
        }
        
        #storyIntroBackground {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.3;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            transition: opacity 2s ease-in-out;
        }
        
        #title {
            display: none;
        }
        
        #subtitle {
            display: none;
        }
        
        /* Center Column - Main Menu Buttons */
        #menuButtonsCenter {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            pointer-events: none;
        }
        
        .menuButton {
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            border: 2px solid #2A9D8F;
            color: #E9F0F7;
            font-family: 'Inter', sans-serif;
            font-size: 18px;
            font-weight: 700;
            padding: 14px 40px;
            margin: 8px;
            cursor: pointer;
            transition: all 0.2s;
            border-radius: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
            width: 380px;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: all;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
        }
        
        .menuButton:hover {
            background: linear-gradient(135deg, rgba(20, 27, 34, 0.95), rgba(42, 157, 143, 0.2));
            box-shadow: 0 6px 25px rgba(42, 157, 143, 0.4);
            transform: translateY(-2px);
            border-color: #4ECDC4;
        }
        
        .menuButton:active {
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.98), rgba(15, 19, 24, 0.95));
            transform: translateY(0px);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }
        
        .menuButton:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        /* Explore Level Button with loading bar */
        #exploreLevelBtn {
            position: relative;
            overflow: hidden;
            z-index: 1;
        }
        
        #exploreLevelBtn .loadingBar {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, rgba(42, 157, 143, 0.4), rgba(78, 205, 196, 0.5));
            transition: width 0.3s ease-out;
            z-index: -1;
            border-radius: 6px;
        }
        
        #exploreLevelBtn.ready {
            border-color: #27AE60;
            box-shadow: 0 0 15px rgba(39, 174, 96, 0.5);
        }
        
        #exploreLevelBtn.ready .loadingBar {
            background: linear-gradient(90deg, rgba(39, 174, 96, 0.4), rgba(46, 204, 113, 0.5));
        }
        
        #exploreLevelBtn .btnText {
            position: relative;
            z-index: 2;
        }
        
        /* Level Store Button - Unlocked State */
        #levelStoreBtn.unlocked {
            background: linear-gradient(135deg, rgba(39, 174, 96, 0.4), rgba(39, 174, 96, 0.3));
            border-color: #27AE60;
            box-shadow: 0 0 15px rgba(39, 174, 96, 0.5);
            cursor: pointer;
            opacity: 1;
        }
        
        #levelStoreBtn.unlocked:hover {
            background: linear-gradient(135deg, rgba(39, 174, 96, 0.6), rgba(39, 174, 96, 0.5));
            border-color: #2ECC71;
            box-shadow: 0 5px 20px rgba(39, 174, 96, 0.6);
            transform: translateY(-2px);
        }
        
        #levelStoreBtn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .portalButton {
            background: linear-gradient(135deg, rgba(139, 69, 255, 0.4), rgba(139, 69, 255, 0.3));
            border-color: #8B45FF;
        }
        
        .portalButton:hover {
            background: linear-gradient(135deg, rgba(139, 69, 255, 0.6), rgba(139, 69, 255, 0.5));
            border-color: #A45FFF;
            box-shadow: 0 5px 20px rgba(139, 69, 255, 0.5);
        }
        
        /* Left Column - Hero Stats (Title Screen) */
        #heroStats {
            position: absolute;
            left: 60px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(20, 27, 34, 0.8);
            border: 2px solid #26313B;
            border-radius: 12px;
            padding: 25px;
            width: 320px;
            pointer-events: all;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
        }
        
        /* Hero Cards in Corners (Dungeon Menu) */
        .dungeonHeroCard {
            position: absolute;
            background: linear-gradient(135deg, rgba(39, 174, 96, 0.1), rgba(39, 174, 96, 0.05));
            border: 1px solid #27AE60;
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            width: 160px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
        }
        
        #dungeonZooko { top: 20px; left: 20px; border-color: #EB5757; box-shadow: 0 0 15px rgba(235, 87, 87, 0.3); }
        #dungeonNate { bottom: 80px; left: 20px; border-color: #F2C94C; box-shadow: 0 0 15px rgba(242, 201, 76, 0.3); }
        #dungeonZancas { top: 20px; right: 20px; border-color: #27AE60; box-shadow: 0 0 15px rgba(39, 174, 96, 0.3); }
        #dungeonCyberAxe { bottom: 80px; right: 20px; border-color: #2E86DE; box-shadow: 0 0 15px rgba(46, 134, 222, 0.3); }
        
        /* Narrator Button */
        #narratorBtn {
            position: absolute;
            top: 20px;
            right: 180px;
            background: linear-gradient(135deg, rgba(139, 69, 255, 0.4), rgba(75, 0, 130, 0.4));
            border: 2px solid #8B45FF;
            border-radius: 10px;
            padding: 10px 15px;
            color: #F2C94C;
            font-family: 'Cinzel Decorative', serif;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
            box-shadow: 0 0 15px rgba(139, 69, 255, 0.3);
            z-index: 50;
        }
        #narratorBtn:hover {
            background: linear-gradient(135deg, rgba(139, 69, 255, 0.6), rgba(75, 0, 130, 0.6));
            box-shadow: 0 0 25px rgba(139, 69, 255, 0.5);
            transform: scale(1.05);
        }
        #narratorBtn.playing {
            background: linear-gradient(135deg, rgba(235, 87, 87, 0.4), rgba(150, 50, 50, 0.4));
            border-color: #EB5757;
            box-shadow: 0 0 20px rgba(235, 87, 87, 0.4);
        }
        #narratorBtn.loading {
            opacity: 0.7;
            cursor: wait;
        }
        #narratorBtn .narratorIcon {
            font-size: 18px;
        }
        
        .heroRow {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 12px;
        }
        
        .heroCard {
            background: linear-gradient(135deg, rgba(39, 174, 96, 0.1), rgba(39, 174, 96, 0.05));
            border: 1px solid #27AE60;
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            position: relative;
        }
        
        .heroPortrait {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            margin: 0 auto 8px auto;
            background-size: cover;
            background-position: center;
            border: 2px solid #27AE60;
            box-shadow: 0 0 10px rgba(39, 174, 96, 0.4);
        }
        
        .heroName {
            font-weight: 700;
            font-size: 14px;
            color: #F2C94C;
            margin-bottom: 8px;
        }
        
        .heroStat {
            font-size: 11px;
            color: #ffffff;
            margin: 2px 0;
            font-family: 'JetBrains Mono', monospace;
            font-weight: 700;
        }
        
        .heroSelectStats {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            font-family: 'JetBrains Mono', monospace;
            font-size: 16px;
            text-align: center;
        }
        
        .heroSelectStats .stat-row {
            display: block;
            margin: 4px 0;
            color: #BFD1E0;
        }
        
        .heroSelectStats .stat-label {
            color: #89A0B4;
        }
        
        .heroSelectStats .hp-row {
            color: #ff6b6b;
            font-weight: bold;
            font-size: 17px;
            display: inline;
        }
        
        .heroSelectStats .ac-row {
            color: #6bb3ff;
            font-weight: bold;
            font-size: 17px;
            display: inline;
            margin-left: 15px;
        }
        
        .heroSelectStats .hp-ac-row {
            margin: 4px 0;
        }
        
        .heroSelectStats .xp-row {
            color: #F2C94C;
            font-size: 17px;
        }
        
        .heroSelectCard {
            position: relative;
            overflow: visible;
        }
        
        .heroSelectCard .heroTakenLabel {
            position: absolute;
            left: -5px;
            top: 55px;
            transform: translateY(-50%) rotate(-90deg);
            transform-origin: center center;
            font-size: 16px;
            font-weight: bold;
            letter-spacing: 2px;
            z-index: 10;
        }
        
        .heroSelectCard .heroPlayerLabel {
            position: absolute;
            right: -5px;
            top: 55px;
            transform: translateY(-50%) rotate(90deg);
            transform-origin: center center;
            font-size: 14px;
            font-weight: bold;
            white-space: nowrap;
            z-index: 10;
        }
        
        /* Party Inventory System */
        #inventoryPanel {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.98), rgba(20, 27, 34, 0.95));
            border: 3px solid #2D9CDB;
            border-radius: 16px;
            padding: 20px;
            z-index: 200;
            backdrop-filter: blur(15px);
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8), 0 0 30px rgba(45, 156, 219, 0.3);
            min-width: 400px;
        }
        
        #inventoryGrid {
            display: grid;
            grid-template-columns: 54px repeat(6, 54px) 54px;
            grid-template-rows: repeat(6, 54px);
            gap: 6px;
            margin: 15px 0;
        }
        
        .inventoryCell {
            width: 54px;
            height: 54px;
            background: linear-gradient(135deg, rgba(45, 156, 219, 0.15), rgba(20, 80, 120, 0.2));
            border: 2px solid rgba(45, 156, 219, 0.5);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .equipmentCell {
            width: 54px;
            height: 54px;
            background: linear-gradient(145deg, rgba(60, 60, 80, 0.4), rgba(40, 40, 60, 0.3));
            border: 2px dashed rgba(150, 150, 180, 0.5);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        
        .equipmentCell::before {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            right: 2px;
            bottom: 2px;
            border-radius: 8px;
            pointer-events: none;
        }
        
        .equipmentCell:hover {
            transform: scale(1.08);
            border-style: solid;
        }
        
        .equipmentCell .slotIcon {
            font-size: 20px;
            opacity: 0.4;
        }
        
        .inventoryCell:hover:not(.locked) {
            background: linear-gradient(135deg, rgba(45, 156, 219, 0.3), rgba(20, 80, 120, 0.4));
            transform: scale(1.05);
        }
        
        .inventoryCell.locked {
            background: linear-gradient(135deg, rgba(40, 40, 50, 0.4), rgba(30, 30, 40, 0.3));
            border-color: rgba(80, 80, 100, 0.3);
            cursor: not-allowed;
            opacity: 0.5;
        }
        
        .inventoryCell.locked::after {
            content: 'ðŸ”’';
            font-size: 16px;
            opacity: 0.4;
        }
        
        #inventoryLevelProgress {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
        }
        
        /* Dice Rolling System */
        .heroRollButton {
            display: none;
            margin-top: 8px;
            padding: 6px 12px;
            background: linear-gradient(135deg, rgba(242, 201, 76, 0.4), rgba(242, 201, 76, 0.2));
            border: 2px solid #F2C94C;
            border-radius: 6px;
            color: #F2C94C;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .heroRollButton:hover {
            background: linear-gradient(135deg, rgba(242, 201, 76, 0.6), rgba(242, 201, 76, 0.4));
            transform: scale(1.05);
        }
        
        .heroRollButton.visible {
            display: inline-block;
        }
        
        #diceRollModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 400;
            justify-content: center;
            align-items: center;
        }
        
        #diceRollModal.visible {
            display: flex;
        }
        
        .diceRollContainer {
            background: linear-gradient(135deg, #1a1f25, #0d1117);
            border: 3px solid #F2C94C;
            border-radius: 16px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            text-align: center;
        }
        
        .diceRollTitle {
            color: #F2C94C;
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 20px;
            font-family: 'Inter', sans-serif;
        }
        
        .diceStatRow {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }
        
        .diceStatName {
            color: #89A0B4;
            font-size: 16px;
            font-weight: bold;
            width: 50px;
            text-align: left;
        }
        
        .diceGroup {
            display: flex;
            gap: 8px;
        }
        
        .die {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #fff, #ddd);
            border: 2px solid #333;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            font-weight: bold;
            color: #111;
            font-family: 'JetBrains Mono', monospace;
            box-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .die.rolling {
            animation: diceRoll 0.1s infinite;
        }
        
        @keyframes diceRoll {
            0% { transform: rotate(0deg) scale(1); }
            25% { transform: rotate(10deg) scale(1.1); }
            50% { transform: rotate(0deg) scale(1); }
            75% { transform: rotate(-10deg) scale(1.1); }
            100% { transform: rotate(0deg) scale(1); }
        }
        
        .diceStatTotal {
            color: #F2C94C;
            font-size: 20px;
            font-weight: bold;
            width: 40px;
            text-align: right;
        }
        
        .diceRollActions {
            margin-top: 25px;
            display: flex;
            gap: 15px;
            justify-content: center;
        }
        
        .diceRollBtn {
            padding: 12px 30px;
            border-radius: 8px;
            font-family: 'Inter', sans-serif;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .diceRollBtn.roll {
            background: linear-gradient(135deg, rgba(242, 201, 76, 0.5), rgba(242, 201, 76, 0.3));
            border: 2px solid #F2C94C;
            color: #F2C94C;
        }
        
        .diceRollBtn.roll:hover {
            background: linear-gradient(135deg, rgba(242, 201, 76, 0.7), rgba(242, 201, 76, 0.5));
            transform: scale(1.05);
        }
        
        .diceRollBtn.accept {
            background: linear-gradient(135deg, rgba(39, 174, 96, 0.5), rgba(39, 174, 96, 0.3));
            border: 2px solid #27AE60;
            color: #27AE60;
        }
        
        .diceRollBtn.accept:hover {
            background: linear-gradient(135deg, rgba(39, 174, 96, 0.7), rgba(39, 174, 96, 0.5));
            transform: scale(1.05);
        }
        
        .diceRollBtn.cancel {
            background: linear-gradient(135deg, rgba(235, 87, 87, 0.5), rgba(235, 87, 87, 0.3));
            border: 2px solid #EB5757;
            color: #EB5757;
        }
        
        .diceRollBtn.cancel:hover {
            background: linear-gradient(135deg, rgba(235, 87, 87, 0.7), rgba(235, 87, 87, 0.5));
            transform: scale(1.05);
        }
        
        .derivedStats {
            margin-top: 15px;
            padding: 12px;
            background: rgba(242, 201, 76, 0.1);
            border: 1px solid rgba(242, 201, 76, 0.3);
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
        }
        
        .derivedStats span {
            font-size: 16px;
        }
        
        .derivedStats .hp-value {
            color: #ff6b6b;
            font-weight: bold;
        }
        
        .derivedStats .ac-value {
            color: #6bb3ff;
            font-weight: bold;
        }
        
        #versionDisplay {
            position: absolute;
            bottom: 20px;
            right: 20px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: #5A7A8F;
        }
        
        .comingSoon {
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            border-color: #EB5757;
            color: #EB5757;
        }
        
        .comingSoon:hover {
            background: linear-gradient(135deg, rgba(235, 87, 87, 0.2), rgba(235, 87, 87, 0.1));
            box-shadow: 0 6px 25px rgba(235, 87, 87, 0.4);
            transform: translateY(-2px);
            border-color: #FF6B6B;
        }
        
        /* Center Column - Level Display (at top of center buttons) */
        #dungeonLevelDisplay {
            text-align: center;
            padding: 15px;
            background: linear-gradient(135deg, rgba(139, 69, 255, 0.2), rgba(75, 0, 130, 0.2));
            border: 2px solid #8B45FF;
            border-radius: 10px;
            width: 380px;
            pointer-events: auto;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            margin-bottom: 20px;
            cursor: help;
        }
        
        #dungeonLevelDisplay:hover {
            border-color: #F2C94C;
            box-shadow: 0 0 20px rgba(242, 201, 76, 0.3);
        }
        
        .levelStatsGrid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 12px;
            text-align: left;
        }
        
        .levelStatItem {
            display: flex;
            justify-content: space-between;
            padding: 4px 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            font-size: 11px;
        }
        
        .levelStatLabel {
            color: #89A0B4;
        }
        
        .levelStatValue {
            color: #F2C94C;
            font-weight: bold;
            font-family: 'JetBrains Mono', monospace;
        }
        
        /* Music Ticker */
        #musicTicker {
            position: fixed;
            bottom: 10px;
            left: 10px;
            transform: translateX(0);
            background: rgba(42, 157, 143, 0.3);
            border: 2px solid #2A9D8F;
            border-radius: 8px;
            overflow: hidden;
            width: 400px;
            max-width: 25%;
            z-index: 500;
            pointer-events: auto;
            transition: left 0.3s ease, transform 0.3s ease;
        }
        
        /* Center ticker on dungeon menu */
        #musicTicker.dungeonMenuActive {
            left: 50%;
            transform: translateX(-50%);
        }
        
        /* Move ticker to bottom left during battle */
        #musicTicker.battleActive {
            left: 10px;
            transform: translateX(0);
        }
        
        #musicTickerWrapper {
            display: flex;
            width: fit-content;
            animation: scrollTicker 30s linear infinite;
        }
        
        #musicTicker:hover #musicTickerWrapper {
            animation-duration: 60s;
        }
        
        .tickerText {
            color: #F2C94C;
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            font-weight: 700;
            white-space: nowrap;
            padding-right: 100px;
        }
        
        @keyframes scrollTicker {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }
        
        /* Music Control Panel - Bottom of Screen Above Ticker */
        #musicControls {
            position: fixed;
            bottom: 65px;
            left: 10px;
            transform: translateX(0);
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            border: 2px solid #2A9D8F;
            border-radius: 8px;
            padding: 8px 12px;
            pointer-events: auto;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8);
            z-index: 500;
            transition: left 0.3s ease, transform 0.3s ease;
        }
        
        /* Center controls on dungeon menu */
        #musicControls.dungeonMenuActive {
            left: 50%;
            transform: translateX(-50%);
        }
        
        /* Move controls to bottom left during battle or hero selection */
        #musicControls.battleActive,
        #musicControls.heroSelectionActive {
            left: 10px;
            transform: translateX(0);
        }
        
        .musicControlTitle {
            margin: 0 0 10px 0;
            color: #2A9D8F;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            text-align: center;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .musicButton {
            padding: 8px 16px;
            background: linear-gradient(135deg, rgba(42, 157, 143, 0.4), rgba(42, 157, 143, 0.3));
            border: 2px solid #2A9D8F;
            color: #F2C94C;
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            font-weight: bold;
            margin: 3px 0;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 6px;
            width: 100%;
            text-align: center;
        }
        
        .musicButton:hover {
            background: linear-gradient(135deg, rgba(42, 157, 143, 0.6), rgba(42, 157, 143, 0.5));
            border-color: #2ECC71;
        }
        
        .musicButton:active {
            transform: translateY(1px);
        }
        
        .musicIconBtn {
            padding: 0;
            background: transparent;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .musicIconBtn:hover {
            transform: scale(1.15);
            filter: brightness(1.3);
        }
        
        .musicIconBtn:active {
            transform: scale(0.95);
        }
        
        .musicIconBtn .icon {
            width: 64px;
            height: 64px;
        }
        
        .volumeControl {
            margin: 10px 0 0 0;
        }
        
        .volumeLabel {
            color: #BFD1E0;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            display: block;
            margin-bottom: 4px;
        }
        
        .volumeSlider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(139, 69, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }
        
        .volumeSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #8B45FF;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(139, 69, 255, 0.5);
        }
        
        .volumeSlider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #8B45FF;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 5px rgba(139, 69, 255, 0.5);
        }
        
        #overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 14, 18, 0.9);
            z-index: 150;
            pointer-events: all;
        }
        
        #settingsPanel {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.98), rgba(20, 27, 34, 0.98));
            border: 3px solid #2A9D8F;
            border-radius: 15px;
            padding: 25px 30px;
            max-width: 800px;
            width: 90%;
            z-index: 1100;
            pointer-events: all;
            box-shadow: 0 10px 50px rgba(42, 157, 143, 0.4), 0 0 80px rgba(42, 157, 143, 0.2);
            backdrop-filter: blur(15px);
        }
        
        .settingsGrid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px 40px;
        }
        
        .settingsSection {
            background: rgba(42, 157, 143, 0.08);
            border: 1px solid rgba(42, 157, 143, 0.3);
            border-radius: 10px;
            padding: 15px;
        }
        
        .settingsSectionTitle {
            font-size: 14px;
            font-weight: 700;
            color: #2A9D8F;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(42, 157, 143, 0.3);
        }
        
        .settingsRow {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .settingsRow:last-child {
            margin-bottom: 0;
        }
        
        .settingsLabel {
            font-size: 13px;
            color: #D4E3F0;
            font-weight: 500;
        }
        
        .settingsHint {
            font-size: 9px;
            color: #89A0B4;
            margin-left: 8px;
        }
        
        .settingsSliderGroup {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .settingsSlider {
            width: 100px;
            height: 6px;
            border-radius: 3px;
            background: rgba(42, 157, 143, 0.2);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }
        
        .settingsSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #2A9D8F;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(42, 157, 143, 0.5);
        }
        
        .settingsSliderValue {
            font-size: 12px;
            font-weight: 700;
            min-width: 28px;
            text-align: right;
        }
        
        .settingsCheckbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #2A9D8F;
        }
        
        .settingsFooter {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid rgba(42, 157, 143, 0.3);
        }
        
        .settingsFooter button {
            flex: 1;
        }
        
        .panelTitle {
            font-size: 28px;
            font-weight: 900;
            color: #2A9D8F;
            margin-bottom: 20px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .settingRow {
            margin: 20px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .settingLabel {
            font-size: 18px;
            color: #E9F0F7;
        }
        
        input[type="range"] {
            width: 200px;
        }
        
        /* Loading Screen Styles */
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }
        
        @keyframes slowBlink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        /* ===== HACKATHON INFO TOOLTIPS ===== */
        #infoTooltip {
            position: fixed;
            max-width: 380px;
            background: linear-gradient(135deg, rgba(15, 10, 35, 0.98), rgba(30, 20, 50, 0.98));
            border: 2px solid #F2C94C;
            border-radius: 12px;
            padding: 15px 18px;
            z-index: 99999;
            pointer-events: none;
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.3s ease, transform 0.3s ease;
            box-shadow: 0 8px 32px rgba(242, 201, 76, 0.3), 0 0 60px rgba(139, 69, 255, 0.2);
            backdrop-filter: blur(10px);
        }
        
        #infoTooltip.visible {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }
        
        #infoTooltip .tooltip-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(242, 201, 76, 0.3);
        }
        
        #infoTooltip .tooltip-icon {
            font-size: 24px;
        }
        
        #infoTooltip .tooltip-title {
            color: #F2C94C;
            font-size: 16px;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        #infoTooltip .tooltip-body {
            color: #E0E0E0;
            font-size: 13px;
            line-height: 1.6;
        }
        
        #infoTooltip .tooltip-tag {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 700;
            margin-right: 5px;
            margin-top: 8px;
            text-transform: uppercase;
        }
        
        #infoTooltip .tag-ai { background: rgba(139, 69, 255, 0.4); color: #D4BBFF; border: 1px solid #8B45FF; }
        #infoTooltip .tag-free { background: rgba(46, 204, 113, 0.4); color: #A8F0C8; border: 1px solid #2ECC71; }
        #infoTooltip .tag-paid { background: rgba(231, 76, 60, 0.4); color: #F5A8A0; border: 1px solid #E74C3C; }
        #infoTooltip .tag-local { background: rgba(52, 152, 219, 0.4); color: #A8D4F0; border: 1px solid #3498DB; }
        #infoTooltip .tag-zcash { background: rgba(242, 201, 76, 0.4); color: #FFF4C8; border: 1px solid #F2C94C; }
        #infoTooltip .tag-multiplayer { background: rgba(155, 89, 182, 0.4); color: #E0C8F0; border: 1px solid #9B59B6; }
        
        #infoTooltip .tooltip-footer {
            margin-top: 10px;
            padding-top: 8px;
            border-top: 1px solid rgba(242, 201, 76, 0.2);
            font-size: 10px;
            color: #89A0B4;
            font-style: italic;
        }
        
        /* Slideshow dots */
        #infoTooltip .tooltip-dots {
            display: flex;
            gap: 6px;
            margin-left: auto;
        }
        
        #infoTooltip .tooltip-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(242, 201, 76, 0.3);
            border: 1px solid rgba(242, 201, 76, 0.5);
            cursor: pointer;
            pointer-events: auto;
            transition: all 0.2s ease;
        }
        
        #infoTooltip .tooltip-dot:hover {
            background: rgba(242, 201, 76, 0.6);
            transform: scale(1.2);
        }
        
        #infoTooltip .tooltip-dot.active {
            background: #F2C94C;
            box-shadow: 0 0 8px rgba(242, 201, 76, 0.8);
        }
        
        [data-tooltip] {
            position: relative;
        }
        /* ===== END HACKATHON INFO TOOLTIPS ===== */
        
        /* ===== CUSTOM ICON IMAGES ===== */
        .icon {
            display: inline-block;
            vertical-align: middle;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }
        .icon-xs { width: 12px; height: 12px; }
        .icon-sm { width: 16px; height: 16px; }
        .icon-md { width: 20px; height: 20px; }
        .icon-lg { width: 24px; height: 24px; }
        .icon-xl { width: 32px; height: 32px; }
        .icon-xxl { width: 48px; height: 48px; }
        .icon-arcade { background-image: url('tunnelsofprivacy/icons/arcade.png'); }
        .icon-back { background-image: url('tunnelsofprivacy/icons/back.png'); }
        .icon-camping { background-image: url('tunnelsofprivacy/icons/camping.png'); }
        .icon-combat { background-image: url('tunnelsofprivacy/icons/combat.png'); }
        .icon-diff-easy { background-image: url('tunnelsofprivacy/icons/difficulty_easy.png'); }
        .icon-diff-hard { background-image: url('tunnelsofprivacy/icons/difficulty_hard.png'); }
        .icon-diff-normal { background-image: url('tunnelsofprivacy/icons/difficulty_normal.png'); }
        .icon-donate { background-image: url('tunnelsofprivacy/icons/donate.png'); }
        .icon-dm { background-image: url('tunnelsofprivacy/icons/dungeon_master.png'); }
        .icon-explore { background-image: url('tunnelsofprivacy/icons/explore.png'); }
        .icon-gold { background-image: url('tunnelsofprivacy/icons/goldbag.png'); }
        .icon-heart { background-image: url('tunnelsofprivacy/icons/heart.png'); }
        .icon-help { background-image: url('tunnelsofprivacy/icons/help.png'); }
        .icon-inventory { background-image: url('tunnelsofprivacy/icons/inventory.png'); }
        .icon-loot { background-image: url('tunnelsofprivacy/icons/lootcrate.png'); }
        .icon-music-back { background-image: url('tunnelsofprivacy/icons/music_back.png'); }
        .icon-music-forward { background-image: url('tunnelsofprivacy/icons/music_forward.png'); }
        .icon-music-play { background-image: url('tunnelsofprivacy/icons/music_play.png'); }
        .icon-narrate { background-image: url('tunnelsofprivacy/icons/narrate.png'); }
        .icon-party-inv { background-image: url('tunnelsofprivacy/icons/party_inventory.png'); }
        .icon-quest { background-image: url('tunnelsofprivacy/icons/questlog.png'); }
        .icon-settings { background-image: url('tunnelsofprivacy/icons/settings.png'); }
        .icon-stairs-down { background-image: url('tunnelsofprivacy/icons/stairs_down.png'); }
        .icon-stairs-up { background-image: url('tunnelsofprivacy/icons/stairs_up.png'); }
        .icon-store { background-image: url('tunnelsofprivacy/icons/store.png'); }
        .icon-volume { background-image: url('tunnelsofprivacy/icons/volume.png'); }
        .icon-zcash { background-image: url('tunnelsofprivacy/icons/zcashbag.png'); }
        /* ===== END CUSTOM ICON IMAGES ===== */
    </style>
</head>
<body>
    <!-- Hackathon Info Tooltip -->
    <div id="infoTooltip"></div>
    
    <!-- Enemy Privacy Breach Tooltip - They have no privacy! -->
    <div id="enemyPrivacyTooltip"></div>
    
    <!-- Food Transparency Tooltip - Know what you're eating! -->
    <div id="foodTooltip"></div>
    <div id="potionTooltip"></div>
    
    <!-- Weapon Tooltip (for equipment slots) -->
    <div id="weaponTooltip" style="position: fixed; z-index: 10001; pointer-events: none; opacity: 0; transition: opacity 0.2s ease;"></div>
    
    <!-- Overlay for modal panels -->
    <div id="panelOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); z-index: 10001;" onclick="closeAllPanels()"></div>
    
    <!-- Achievements Panel -->
    <div id="achievementsPanel">
        <button class="panelCloseBtn" onclick="closeAchievementsPanel()">âœ•</button>
        <div class="panelTitle">ðŸ† ACHIEVEMENTS</div>
        <div class="achievementTabs">
            <button class="achievementTab active" onclick="showAchievementTab('achievements')">ACHIEVEMENTS</button>
            <button class="achievementTab" onclick="showAchievementTab('bestiary')" style="background: rgba(231, 76, 60, 0.2); border-color: #E74C3C; color: #E74C3C;">ðŸ‘¹ BESTIARY</button>
        </div>
        <div class="achievementTabs" style="margin-top: 10px;">
            <button class="achievementTab active" id="achieveTabPage1" onclick="showAchievementPage(1)">COMBAT / EXPLORE</button>
            <button class="achievementTab" id="achieveTabPage2" onclick="showAchievementPage(2)">ECONOMY / HEROES / SPECIAL</button>
        </div>
        <div id="achievementsList"></div>
        <div class="panelProgress" id="achievementsProgress">0/30 Unlocked</div>
    </div>
    
    <!-- Bestiary Panel -->
    <div id="bestiaryPanel">
        <button class="panelCloseBtn" onclick="closeBestiaryPanel()">âœ•</button>
        <div class="panelTitle">ðŸ‘¹ BESTIARY</div>
        <div class="achievementTabs">
            <button class="bestiaryTab" onclick="showAchievementTab('achievements')" style="background: rgba(42, 157, 143, 0.2); border-color: #2A9D8F; color: #2A9D8F;">ðŸ† ACHIEVEMENTS</button>
            <button class="bestiaryTab active" onclick="showAchievementTab('bestiary')">ðŸ‘¹ BESTIARY</button>
        </div>
        <div class="achievementTabs" style="margin-top: 10px;">
            <button class="bestiaryTab active" id="bestiaryTabEasy" onclick="showBestiaryPage('easy')">EASY (2-34)</button>
            <button class="bestiaryTab" id="bestiaryTabNormal" onclick="showBestiaryPage('normal')">NORMAL (35-67)</button>
            <button class="bestiaryTab" id="bestiaryTabHard" onclick="showBestiaryPage('hard')">HARD (68-100)</button>
        </div>
        <div id="bestiaryList"></div>
        <div class="panelProgress" id="bestiaryProgress">0/99 Bosses Defeated</div>
    </div>
    
    <!-- Loading Modal -->
    <div id="loadingModal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.95); display: flex; align-items: center; justify-content: center; z-index: 10000;">
        <div style="background: linear-gradient(135deg, #1a2332 0%, #0d1218 100%); padding: 40px 60px; border-radius: 15px; border: 2px solid #8B45FF; box-shadow: 0 10px 50px rgba(139, 69, 255, 0.5); text-align: center; min-width: 500px;">
            <div style="font-size: 48px; margin-bottom: 20px; animation: pulse 1.5s ease-in-out infinite;">ðŸ°</div>
            <div style="font-size: 24px; font-weight: bold; color: #8B45FF; margin-bottom: 10px;">TUNNELS OF PRIVACY</div>
            <div style="font-size: 14px; color: #F2C94C; margin-bottom: 15px; font-style: italic;">A Dungeon Crawler Adventure</div>
            <div id="loadingNote" style="font-size: 12px; color: #BFD1E0; margin-bottom: 20px; line-height: 1.5;">Loading assets... This may take a moment on first visit</div>
            
            <!-- Category breakdown -->
            <div style="margin-bottom: 15px; text-align: left; font-size: 13px; color: #BFD1E0;">
                <div id="loadingArt" style="margin-bottom: 5px;">ðŸŽ¨ Art: <span style="color: #8B45FF; font-weight: bold;">0/0</span></div>
                <div id="loadingSound" style="margin-bottom: 5px;"><span class="icon icon-sm icon-volume"></span> Sound: <span style="color: #8B45FF; font-weight: bold;">0/0</span></div>
            </div>
            
            <!-- Overall progress -->
            <div id="loadingIndicator" style="font-size: 18px; color: #2ECC71; margin-bottom: 20px; font-weight: bold;">0%</div>
            
            <div style="width: 100%; height: 30px; background: rgba(139, 69, 255, 0.2); border-radius: 15px; overflow: hidden; border: 1px solid #8B45FF;">
                <div id="loadingBar" style="height: 100%; width: 0%; background: linear-gradient(90deg, #8B45FF, #2ECC71); transition: width 0.3s ease; border-radius: 15px; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 14px;"></div>
            </div>
            
            <!-- Click to Play prompt (hidden until ready) -->
            <div id="clickToPlayPrompt" style="display: none; margin-top: 30px; font-size: 24px; color: #2ECC71; font-weight: bold; animation: slowBlink 2s ease-in-out infinite; cursor: pointer;">
                <div style="margin-bottom: 10px;">ðŸŽ® CLICK TO ENTER ðŸŽ®</div>
                <div style="font-size: 14px; color: #89A0B4;">
                    <span style="display: inline-block; padding: 5px 10px; background: rgba(52, 152, 219, 0.3); border-radius: 5px; margin-right: 5px;">MOUSE</span>
                    or
                    <span style="display: inline-block; padding: 5px 10px; background: rgba(46, 204, 113, 0.3); border-radius: 5px; margin-left: 5px;">ðŸŽ® A</span>
                </div>
            </div>
        </div>
    </div>
    
    <div id="gameContainer">
        <!-- Dungeon Menu Screen -->
        <div id="dungeonMenuScreen">
            <!-- Story Background Animation -->
            <div id="dungeonMenuBackground"></div>
            
            <!-- Narrator Button (Top Right) -->
            <button id="narratorBtn" onclick="toggleNarrator()" title="Listen to level narration">
                <img src="tunnelsofprivacy/icons/narrate.png" alt="" style="width: 48px; height: 48px; vertical-align: middle;">
                <span id="narratorBtnText">NARRATE</span>
            </button>
            
            <!-- Hero Cards in Corners -->
            <div class="dungeonHeroCard" id="dungeonZooko">
                <div class="heroPortrait" style="background-image: url('people/zooko_a_head_compressed.png'); border-color: #EB5757; box-shadow: 0 0 10px rgba(235, 87, 87, 0.4);"></div>
                <div class="heroName" style="color: #EB5757;">ZOOKO</div>
                <div class="heroStat" style="color: #ff6b6b; font-size: 12px; margin: 4px 0;">HP: <span id="dzooko-hp">0</span>/<span id="dzooko-maxhp">0</span></div>
                <div class="heroStat" style="color: #F2C94C; font-size: 11px; margin: 2px 0;">XP: <span id="dzooko-xp">0</span></div>
                <div class="heroStat">STR: <span id="dzooko-str">0</span>  INT: <span id="dzooko-int">0</span></div>
                <div class="heroStat">DEX: <span id="dzooko-dex">0</span>  WIS: <span id="dzooko-wis">0</span></div>
                <div class="heroStat">CON: <span id="dzooko-con">0</span>  CHA: <span id="dzooko-cha">0</span></div>
                <div class="heroEquipmentSlots" style="display: flex; gap: 4px; justify-content: center; margin-top: 8px; padding-top: 6px; border-top: 1px solid rgba(235, 87, 87, 0.3);">
                    <div class="heroEquipSlot" id="dzooko-weapon" data-hero="zooko" data-slottype="weapon" style="width: 36px; height: 36px; background: rgba(235, 87, 87, 0.15); border: 1px solid rgba(235, 87, 87, 0.5); border-radius: 6px; display: flex; align-items: center; justify-content: center; cursor: pointer;" title="Weapon"><img src="tunnelsofprivacy/items/zooko_staff.png" style="width: 80%; height: 80%; object-fit: contain;"></div>
                    <div class="heroEquipSlot" id="dzooko-armor" data-hero="zooko" data-slottype="armor" style="width: 36px; height: 36px; background: rgba(235, 87, 87, 0.15); border: 1px dashed rgba(235, 87, 87, 0.4); border-radius: 6px; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 14px; opacity: 0.5;" title="Armor">ðŸ›¡ï¸</div>
                    <div class="heroEquipSlot" id="dzooko-accessory" data-hero="zooko" data-slottype="accessory" style="width: 36px; height: 36px; background: rgba(235, 87, 87, 0.15); border: 1px dashed rgba(235, 87, 87, 0.4); border-radius: 6px; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 14px; opacity: 0.5;" title="Accessory">ðŸ’</div>
                </div>
            </div>
            
            <div class="dungeonHeroCard" id="dungeonNate">
                <div class="heroPortrait" style="background-image: url('people/Nate_a_head_compressed.png'); border-color: #F2C94C; box-shadow: 0 0 10px rgba(242, 201, 76, 0.4);"></div>
                <div class="heroName" style="color: #F2C94C;">NATE</div>
                <div class="heroStat" style="color: #ff6b6b; font-size: 12px; margin: 4px 0;">HP: <span id="dnate-hp">0</span>/<span id="dnate-maxhp">0</span></div>
                <div class="heroStat" style="color: #F2C94C; font-size: 11px; margin: 2px 0;">XP: <span id="dnate-xp">0</span></div>
                <div class="heroStat">STR: <span id="dnate-str">0</span>  INT: <span id="dnate-int">0</span></div>
                <div class="heroStat">DEX: <span id="dnate-dex">0</span>  WIS: <span id="dnate-wis">0</span></div>
                <div class="heroStat">CON: <span id="dnate-con">0</span>  CHA: <span id="dnate-cha">0</span></div>
                <div class="heroEquipmentSlots" style="display: flex; gap: 4px; justify-content: center; margin-top: 8px; padding-top: 6px; border-top: 1px solid rgba(242, 201, 76, 0.3);">
                    <div class="heroEquipSlot" id="dnate-weapon" data-hero="nate" data-slottype="weapon" style="width: 36px; height: 36px; background: rgba(242, 201, 76, 0.15); border: 1px solid rgba(242, 201, 76, 0.5); border-radius: 6px; display: flex; align-items: center; justify-content: center; cursor: pointer;" title="Weapon"><img src="tunnelsofprivacy/items/nate_zcash_zashi_walletpng.png" style="width: 80%; height: 80%; object-fit: contain;"></div>
                    <div class="heroEquipSlot" id="dnate-armor" data-hero="nate" data-slottype="armor" style="width: 36px; height: 36px; background: rgba(242, 201, 76, 0.15); border: 1px dashed rgba(242, 201, 76, 0.4); border-radius: 6px; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 14px; opacity: 0.5;" title="Armor">ðŸ›¡ï¸</div>
                    <div class="heroEquipSlot" id="dnate-accessory" data-hero="nate" data-slottype="accessory" style="width: 36px; height: 36px; background: rgba(242, 201, 76, 0.15); border: 1px dashed rgba(242, 201, 76, 0.4); border-radius: 6px; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 14px; opacity: 0.5;" title="Accessory">ðŸ’</div>
                </div>
            </div>
            
            <div class="dungeonHeroCard" id="dungeonZancas">
                <div class="heroPortrait" style="background-image: url('people/Zancas_a_head_compressed.png'); border-color: #27AE60; box-shadow: 0 0 10px rgba(39, 174, 96, 0.4);"></div>
                <div class="heroName" style="color: #27AE60;">ZANCAS</div>
                <div class="heroStat" style="color: #ff6b6b; font-size: 12px; margin: 4px 0;">HP: <span id="dzancas-hp">0</span>/<span id="dzancas-maxhp">0</span></div>
                <div class="heroStat" style="color: #F2C94C; font-size: 11px; margin: 2px 0;">XP: <span id="dzancas-xp">0</span></div>
                <div class="heroStat">STR: <span id="dzancas-str">0</span>  INT: <span id="dzancas-int">0</span></div>
                <div class="heroStat">DEX: <span id="dzancas-dex">0</span>  WIS: <span id="dzancas-wis">0</span></div>
                <div class="heroStat">CON: <span id="dzancas-con">0</span>  CHA: <span id="dzancas-cha">0</span></div>
                <div class="heroEquipmentSlots" style="display: flex; gap: 4px; justify-content: center; margin-top: 8px; padding-top: 6px; border-top: 1px solid rgba(39, 174, 96, 0.3);">
                    <div class="heroEquipSlot" id="dzancas-weapon" data-hero="zancas" data-slottype="weapon" style="width: 36px; height: 36px; background: rgba(39, 174, 96, 0.15); border: 1px solid rgba(39, 174, 96, 0.5); border-radius: 6px; display: flex; align-items: center; justify-content: center; cursor: pointer;" title="Weapon"><img src="tunnelsofprivacy/items/zancas_zingo_orb.png" style="width: 80%; height: 80%; object-fit: contain;"></div>
                    <div class="heroEquipSlot" id="dzancas-armor" data-hero="zancas" data-slottype="armor" style="width: 36px; height: 36px; background: rgba(39, 174, 96, 0.15); border: 1px dashed rgba(39, 174, 96, 0.4); border-radius: 6px; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 14px; opacity: 0.5;" title="Armor">ðŸ›¡ï¸</div>
                    <div class="heroEquipSlot" id="dzancas-accessory" data-hero="zancas" data-slottype="accessory" style="width: 36px; height: 36px; background: rgba(39, 174, 96, 0.15); border: 1px dashed rgba(39, 174, 96, 0.4); border-radius: 6px; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 14px; opacity: 0.5;" title="Accessory">ðŸ’</div>
                </div>
            </div>
            
            <div class="dungeonHeroCard" id="dungeonCyberAxe">
                <div class="heroPortrait" style="background-image: url('people/cyberaxe_a_head_compressed.png'); border-color: #2E86DE; box-shadow: 0 0 10px rgba(46, 134, 222, 0.4);"></div>
                <div class="heroName" style="color: #2E86DE;">CYBERAXE</div>
                <div class="heroStat" style="color: #ff6b6b; font-size: 12px; margin: 4px 0;">HP: <span id="dcyberaxe-hp">0</span>/<span id="dcyberaxe-maxhp">0</span></div>
                <div class="heroStat" style="color: #F2C94C; font-size: 11px; margin: 2px 0;">XP: <span id="dcyberaxe-xp">0</span></div>
                <div class="heroStat">STR: <span id="dcyberaxe-str">0</span>  INT: <span id="dcyberaxe-int">0</span></div>
                <div class="heroStat">DEX: <span id="dcyberaxe-dex">0</span>  WIS: <span id="dcyberaxe-wis">0</span></div>
                <div class="heroStat">CON: <span id="dcyberaxe-con">0</span>  CHA: <span id="dcyberaxe-cha">0</span></div>
                <div class="heroEquipmentSlots" style="display: flex; gap: 4px; justify-content: center; margin-top: 8px; padding-top: 6px; border-top: 1px solid rgba(46, 134, 222, 0.3);">
                    <div class="heroEquipSlot" id="dcyberaxe-weapon" data-hero="cyberaxe" data-slottype="weapon" style="width: 36px; height: 36px; background: rgba(46, 134, 222, 0.15); border: 1px solid rgba(46, 134, 222, 0.5); border-radius: 6px; display: flex; align-items: center; justify-content: center; cursor: pointer;" title="Weapon"><img src="tunnelsofprivacy/items/cyberaxe_axe.png" style="width: 80%; height: 80%; object-fit: contain;"></div>
                    <div class="heroEquipSlot" id="dcyberaxe-armor" data-hero="cyberaxe" data-slottype="armor" style="width: 36px; height: 36px; background: rgba(46, 134, 222, 0.15); border: 1px dashed rgba(46, 134, 222, 0.4); border-radius: 6px; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 14px; opacity: 0.5;" title="Armor">ðŸ›¡ï¸</div>
                    <div class="heroEquipSlot" id="dcyberaxe-accessory" data-hero="cyberaxe" data-slottype="accessory" style="width: 36px; height: 36px; background: rgba(46, 134, 222, 0.15); border: 1px dashed rgba(46, 134, 222, 0.4); border-radius: 6px; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 14px; opacity: 0.5;" title="Accessory">ðŸ’</div>
                </div>
            </div>
            
            <!-- Center Menu -->
            <div style="position: absolute; top: 42%; left: 50%; transform: translate(-50%, -50%); display: flex; flex-direction: column; align-items: center; gap: 12px;">
                <div style="text-align: center; padding: 15px; background: linear-gradient(135deg, rgba(139, 69, 255, 0.2), rgba(75, 0, 130, 0.2)); border: 2px solid #8B45FF; border-radius: 10px; width: 380px; backdrop-filter: blur(10px); box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4); margin-bottom: 10px;">
                    <div style="color: #BFD1E0; font-size: 14px; margin-bottom: 5px;">Dungeon Menu</div>
                    <div style="color: #F2C94C; font-size: 28px; font-weight: 900; text-shadow: 0 0 20px rgba(242, 201, 76, 0.5);">LEVEL <span id="dungeonMenuLevel">1</span></div>
                    <div style="color: #FFD700; font-size: 16px; font-weight: 700; margin-top: 5px;"><img src="tunnelsofprivacy/icons/goldbag.png" alt="" style="width: 64px; height: 64px; vertical-align: middle;"> <span id="dungeonMenuGold">0</span> Gold</div>
                    <div class="levelStatsGrid" style="margin-top: 10px;">
                        <div class="levelStatItem">
                            <span class="levelStatLabel">Rooms</span>
                            <span class="levelStatValue"><span id="dmRoomsExplored">0</span>/<span id="dmRoomsMax">?</span></span>
                        </div>
                        <div class="levelStatItem">
                            <span class="levelStatLabel">Boss</span>
                            <span class="levelStatValue"><span id="dmBossDefeated">0</span>/1</span>
                        </div>
                        <div class="levelStatItem">
                            <span class="levelStatLabel">Store</span>
                            <span class="levelStatValue"><span id="dmStoreVisited">0</span>/1</span>
                        </div>
                        <div class="levelStatItem">
                            <span class="levelStatLabel">Captives</span>
                            <span class="levelStatValue" id="dmCaptivesFreed">0</span>
                        </div>
                    </div>
                    <div style="margin-top: 8px; font-size: 10px; color: #89A0B4; border-top: 1px solid rgba(139, 69, 255, 0.3); padding-top: 6px;">
                        <span style="color: #8B45FF;">ðŸ‘¹</span> Bosses Defeated: <span id="dmTotalBossesDefeated" style="color: #F2C94C; font-weight: bold;">0</span>
                    </div>
                </div>
                
                <div style="display: flex; gap: 10px; width: 100%; justify-content: center;">
                    <button class="menuButton" id="exploreLevelBtn" onclick="startBattle()" style="flex: 1;">
                        <div class="loadingBar" id="exploreLoadingBar"></div>
                        <span class="btnText"><span class="icon icon-lg icon-combat"></span> EXPLORE LEVEL</span>
                    </button>
                    <button class="menuButton" id="stairsDownBtn2" onclick="changeLevel(1)" style="display: none; width: auto; min-width: 0; padding: 10px 16px; background: linear-gradient(135deg, rgba(39, 174, 96, 0.4), rgba(20, 100, 50, 0.4)); border-color: #27AE60;">
                        <span><span class="icon icon-md icon-stairs-down"></span> STAIRS</span>
                    </button>
                </div>
                <button class="menuButton" id="levelStoreBtn" onclick="enterLevelStore()" disabled>
                    <span id="levelStoreBtnText"><span class="icon icon-lg icon-store"></span> ENTER LEVEL STORE<br><span style="font-size: 12px; font-weight: 400;">(Not Found)</span></span>
                </button>
                <button class="menuButton" onclick="openInventory()"><span class="icon icon-lg icon-inventory"></span> INVENTORY</button>
                <button class="menuButton" id="campBtn" onclick="openCampPanel()"><span class="icon icon-lg icon-camping"></span> CAMP</button>
                <button class="menuButton" id="dungeonMastersBtn" onclick="toggleDungeonMasters()" style="background: linear-gradient(135deg, rgba(139, 69, 255, 0.4), rgba(75, 0, 130, 0.4));"><span class="icon icon-lg icon-dm"></span> DUNGEON MASTERS</button>
            </div>
            
            <!-- Camp Panel (Right Side) -->
            <div id="campPanel" style="display: none; position: absolute; top: 50%; right: 20px; transform: translateY(-50%); background: linear-gradient(135deg, rgba(20, 10, 40, 0.95), rgba(40, 20, 60, 0.95)); border: 3px solid #27AE60; border-radius: 15px; padding: 20px; backdrop-filter: blur(15px); box-shadow: 0 0 30px rgba(39, 174, 96, 0.4), inset 0 0 20px rgba(39, 174, 96, 0.1); min-width: 320px; z-index: 100;">
                <div style="text-align: center; margin-bottom: 15px;">
                    <div style="color: #27AE60; font-size: 20px; font-weight: 900; text-shadow: 0 0 15px rgba(39, 174, 96, 0.5);">ðŸ•ï¸ CAMP</div>
                    <button onclick="closeCampPanel()" style="position: absolute; top: 10px; right: 10px; background: rgba(255,100,100,0.3); border: 2px solid #ff6b6b; border-radius: 50%; width: 28px; height: 28px; color: #ff6b6b; font-size: 16px; cursor: pointer; font-weight: bold;">âœ•</button>
                </div>
                
                <!-- Rest Duration Selection -->
                <div style="text-align: center; margin-bottom: 15px;">
                    <div style="color: #BFD1E0; font-size: 14px; font-weight: 700; margin-bottom: 8px;">REST DURATION</div>
                    <div style="display: flex; gap: 8px; justify-content: center; align-items: center; flex-wrap: wrap;">
                        <button class="campDurationBtn" onclick="setCampDuration(1)" data-hours="1" style="padding: 8px 12px; background: rgba(39, 174, 96, 0.3); border: 2px solid #27AE60; border-radius: 8px; color: #27AE60; font-weight: bold; cursor: pointer;">1 Hr</button>
                        <button class="campDurationBtn" onclick="setCampDuration(2)" data-hours="2" style="padding: 8px 12px; background: rgba(39, 174, 96, 0.3); border: 2px solid #27AE60; border-radius: 8px; color: #27AE60; font-weight: bold; cursor: pointer;">2 Hrs</button>
                        <button class="campDurationBtn" onclick="setCampDuration(4)" data-hours="4" style="padding: 8px 12px; background: rgba(39, 174, 96, 0.3); border: 2px solid #27AE60; border-radius: 8px; color: #27AE60; font-weight: bold; cursor: pointer;">4 Hrs</button>
                        <button class="campDurationBtn active" onclick="setCampDuration(8)" data-hours="8" style="padding: 8px 12px; background: rgba(39, 174, 96, 0.6); border: 2px solid #27AE60; border-radius: 8px; color: white; font-weight: bold; cursor: pointer;">8 Hrs</button>
                    </div>
                </div>
                
                <!-- Health Regen Preview -->
                <div style="background: rgba(0,0,0,0.3); border-radius: 10px; padding: 12px; margin-bottom: 15px;">
                    <div style="color: #F2C94C; font-size: 14px; font-weight: 700; text-align: center; margin-bottom: 8px;"><span class="icon icon-md icon-heart"></span> HEALTH RESTORED</div>
                    <div style="display: flex; justify-content: space-around; font-size: 12px;">
                        <div style="text-align: center;">
                            <div style="color: #E74C3C; font-weight: bold;" id="campHealZooko">+16 HP</div>
                            <div style="color: #89A0B4;">Zooko</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="color: #E74C3C; font-weight: bold;" id="campHealNate">+16 HP</div>
                            <div style="color: #89A0B4;">Nate</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="color: #E74C3C; font-weight: bold;" id="campHealZancas">+16 HP</div>
                            <div style="color: #89A0B4;">Zancas</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="color: #E74C3C; font-weight: bold;" id="campHealCyberAxe">+16 HP</div>
                            <div style="color: #89A0B4;">CyberAxe</div>
                        </div>
                    </div>
                    <div style="text-align: center; margin-top: 8px; font-size: 11px; color: #27AE60;">
                        Base Regen: 2 HP per hour
                    </div>
                </div>
                
                <!-- Warning Note -->
                <div style="background: rgba(242, 201, 76, 0.15); border: 1px solid rgba(242, 201, 76, 0.4); border-radius: 8px; padding: 10px; margin-bottom: 15px;">
                    <div style="color: #F2C94C; font-size: 11px; text-align: center;">
                        âš ï¸ <strong>Warning:</strong> Longer rest periods have higher odds of encounters - good or bad!
                    </div>
                </div>
                
                <!-- Party Meals Section -->
                <div id="partyMealsSection" style="background: rgba(0,0,0,0.3); border-radius: 10px; padding: 12px; margin-bottom: 15px;">
                    <div style="color: #FF9F43; font-size: 14px; font-weight: 700; text-align: center; margin-bottom: 8px;">ðŸ– PARTY MEALS</div>
                    <div id="partyMealsList" style="max-height: 120px; overflow-y: auto; margin-bottom: 8px;">
                        <!-- Meals will be populated here -->
                        <div style="color: #89A0B4; font-size: 11px; text-align: center;">No meals in inventory</div>
                    </div>
                    <div style="text-align: center; font-size: 10px; color: #89A0B4;">
                        Buy meals at stores â€¢ Use at camp to heal party
                    </div>
                </div>
                
                <!-- Camp Button + Achievements Row -->
                <div style="display: flex; gap: 8px;">
                    <button id="startCampBtn" onclick="startCamping()" style="flex: 1; padding: 10px; font-size: 14px; background: linear-gradient(135deg, rgba(39, 174, 96, 0.5), rgba(39, 174, 96, 0.3)); border: 2px solid #27AE60; border-radius: 8px; color: #27AE60; font-weight: 700; cursor: pointer;">
                        ðŸ”¥ CAMP
                    </button>
                    <button onclick="showAchievementsPanelFromGame(); closeCampPanel();" style="flex: 1; padding: 10px; background: linear-gradient(135deg, rgba(139, 69, 255, 0.4), rgba(139, 69, 255, 0.2)); border: 2px solid #8B45FF; border-radius: 8px; color: #8B45FF; font-weight: 700; font-size: 14px; cursor: pointer;">ðŸ† ACHIEVEMENTS</button>
                </div>
            </div>
            
            <!-- Dungeon Masters Panel (Right Side) -->
            <div id="dungeonMastersPanel" style="display: none; position: absolute; top: 50%; right: 20px; transform: translateY(-50%); background: linear-gradient(135deg, rgba(20, 10, 40, 0.95), rgba(40, 20, 60, 0.95)); border: 3px solid #8B45FF; border-radius: 15px; padding: 20px; backdrop-filter: blur(15px); box-shadow: 0 0 30px rgba(139, 69, 255, 0.4), inset 0 0 20px rgba(139, 69, 255, 0.1); min-width: 280px;">
                <div style="text-align: center; margin-bottom: 15px;">
                    <div style="color: #F2C94C; font-size: 18px; font-weight: 900; text-shadow: 0 0 15px rgba(242, 201, 76, 0.5);"><span class="icon icon-lg icon-dm"></span> DUNGEON MASTERS</div>
                    <button onclick="toggleDungeonMasters()" style="position: absolute; top: 10px; right: 10px; background: rgba(255,100,100,0.3); border: 2px solid #ff6b6b; border-radius: 50%; width: 28px; height: 28px; color: #ff6b6b; font-size: 16px; cursor: pointer; font-weight: bold;">âœ•</button>
                </div>
                
                <!-- Next Room Preview -->
                <div id="nextRoomPreview" style="background: rgba(0,0,0,0.4); border: 2px solid rgba(139, 69, 255, 0.5); border-radius: 10px; padding: 12px; margin-bottom: 15px; text-align: center;">
                    <div style="font-size: 11px; color: #89A0B4; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 1px;">Next Room</div>
                    <div id="nextRoomType" style="font-size: 18px; font-weight: bold; color: #F2C94C;"><span class="icon icon-md icon-combat"></span> Combat</div>
                </div>
                
                <!-- Level Status -->
                <div style="background: rgba(0,0,0,0.3); border: 1px solid rgba(139, 69, 255, 0.3); border-radius: 8px; padding: 10px; margin-bottom: 15px;">
                    <div style="font-size: 11px; color: #89A0B4; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px; text-align: center;">Level Status</div>
                    <div style="display: flex; justify-content: space-between; font-size: 12px; color: #BFD1E0;">
                        <span>ðŸ‘¹ Boss:</span>
                        <span id="dmBossStatus" style="color: #EB5757; font-weight: bold;">Locked</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; font-size: 12px; color: #BFD1E0; margin-top: 4px;">
                        <span>ðŸ’€ Mini-Boss:</span>
                        <span id="dmMiniBossStatus" style="color: #89A0B4; font-weight: bold;">0/0</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; font-size: 12px; color: #BFD1E0; margin-top: 4px;">
                        <span>âš”ï¸ Encounters:</span>
                        <span id="dmEncountersStatus" style="color: #F2C94C; font-weight: bold;">0/0</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; font-size: 12px; color: #BFD1E0; margin-top: 4px;">
                        <span>ðŸ›’ Store:</span>
                        <span id="dmStoreStatus" style="color: #EB5757; font-weight: bold;">Not Found</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; font-size: 12px; color: #BFD1E0; margin-top: 4px;">
                        <span>ðŸ’¬ NPCs:</span>
                        <span id="dmNPCsStatus" style="color: #89A0B4; font-weight: bold;">0/0</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; font-size: 12px; color: #BFD1E0; margin-top: 4px;">
                        <span>ðŸ” Exploration:</span>
                        <span id="dmExplorationStatus" style="color: #89A0B4; font-weight: bold;">0/0</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; font-size: 12px; color: #BFD1E0; margin-top: 4px;">
                        <span>ðŸ”“ Captives:</span>
                        <span id="dmCaptivesStatus" style="color: #89A0B4; font-weight: bold;">0/0</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; font-size: 12px; color: #BFD1E0; margin-top: 4px;">
                        <span>âœ¨ Secrets:</span>
                        <span id="dmSecretsStatus" style="color: #89A0B4; font-weight: bold;">0/0</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; font-size: 12px; color: #BFD1E0; margin-top: 6px; padding-top: 6px; border-top: 1px solid rgba(139, 69, 255, 0.3);">
                        <span><span class="icon icon-sm icon-explore"></span> Rooms Left:</span>
                        <span id="dmRoomsRemaining" style="color: #F2C94C; font-weight: bold;">?</span>
                    </div>
                </div>
                
                <!-- Stairs & Fast Travel Combined -->
                <div style="text-align: center; margin-bottom: 12px;">
                    <div style="color: #BFD1E0; font-size: 12px; font-weight: 700; margin-bottom: 6px; text-shadow: 0 0 10px rgba(139, 69, 255, 0.5);">STAIRS / FAST TRAVEL</div>
                    <div style="display: flex; gap: 6px; justify-content: center; align-items: center;">
                        <button id="stairsUpBtn" class="menuButton" onclick="changeLevel(-1)" style="width: 50px; padding: 8px 6px; font-size: 12px;"><span class="icon icon-md icon-stairs-up"></span></button>
                        <button id="stairsDownBtn" class="menuButton" onclick="changeLevel(1)" style="width: 50px; padding: 8px 6px; font-size: 12px;"><span class="icon icon-md icon-stairs-down"></span></button>
                        <input type="number" id="fastTravelLevel" min="1" value="1" style="width: 50px; padding: 6px; font-size: 13px; text-align: center; background: rgba(0,0,0,0.5); border: 2px solid #8B45FF; border-radius: 5px; color: #F2C94C; font-family: 'JetBrains Mono', monospace;">
                        <button id="fastTravelBtn" class="menuButton" onclick="fastTravel()" style="width: 60px; padding: 8px 6px; font-size: 12px;">ðŸš€ GO</button>
                    </div>
                </div>
                
                <!-- Difficulty & Party Level Combined -->
                <div style="text-align: center; margin-bottom: 12px;">
                    <div style="color: #BFD1E0; font-size: 12px; font-weight: 700; margin-bottom: 6px; text-shadow: 0 0 10px rgba(139, 69, 255, 0.5);">DIFFICULTY / PARTY LEVEL</div>
                    <div style="display: flex; gap: 6px; justify-content: center; align-items: center;">
                        <button id="diffCasualBtn" class="menuButton" onclick="setDifficulty('casual')" style="width: auto; padding: 6px 8px; font-size: 11px;"><span class="icon icon-md icon-diff-easy"></span></button>
                        <button id="diffNormalBtn" class="menuButton" onclick="setDifficulty('normal')" style="width: auto; padding: 6px 8px; font-size: 11px;"><span class="icon icon-md icon-diff-normal"></span></button>
                        <button id="diffExpertBtn" class="menuButton" onclick="setDifficulty('expert')" style="width: auto; padding: 6px 8px; font-size: 11px;"><span class="icon icon-md icon-diff-hard"></span></button>
                        <input type="number" id="partyLevelInput" min="1" max="100" value="1" style="width: 50px; padding: 6px; font-size: 13px; text-align: center; background: rgba(0,0,0,0.5); border: 2px solid #F2C94C; border-radius: 5px; color: #F2C94C; font-family: 'JetBrains Mono', monospace;">
                        <button class="menuButton" onclick="setPartyLevel()" style="width: 60px; padding: 8px 6px; font-size: 12px; background: linear-gradient(135deg, rgba(242, 201, 76, 0.4), rgba(200, 150, 50, 0.4)); border-color: #F2C94C;">SET</button>
                    </div>
                </div>
                
                <!-- Set Gold -->
                <div style="text-align: center;">
                    <div style="color: #BFD1E0; font-size: 12px; font-weight: 700; margin-bottom: 6px; text-shadow: 0 0 10px rgba(139, 69, 255, 0.5);">SET GOLD</div>
                    <div style="display: flex; gap: 6px; justify-content: center; align-items: center;">
                        <span class="icon icon-lg icon-gold"></span>
                        <input type="number" id="setGoldInput" min="0" value="0" style="width: 80px; padding: 6px; font-size: 13px; text-align: center; background: rgba(0,0,0,0.5); border: 2px solid #F2C94C; border-radius: 5px; color: #F2C94C; font-family: 'JetBrains Mono', monospace;">
                        <button class="menuButton" onclick="setPartyGold()" style="width: 60px; padding: 8px 6px; font-size: 12px; background: linear-gradient(135deg, rgba(242, 201, 76, 0.4), rgba(200, 150, 50, 0.4)); border-color: #F2C94C;">SET</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Camping Screen -->
        <div id="campingScreen" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 500; background: #000;">
            <!-- Video Background -->
            <video id="campVideo" loop playsinline style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: 1;">
                <source src="" type="video/mp4">
            </video>
            
            <!-- Dark Overlay -->
            <div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.4); z-index: 2;"></div>
            
            <!-- Camp UI Overlay -->
            <div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 3; display: flex; flex-direction: column; align-items: center; justify-content: center;">
                <!-- Camp Title -->
                <div style="color: #F2C94C; font-size: 36px; font-weight: 900; text-shadow: 0 0 30px rgba(242, 201, 76, 0.8), 2px 2px 4px rgba(0,0,0,0.8); margin-bottom: 20px;">
                    <span class="icon icon-xxl icon-camping"></span> RESTING AT CAMP
                </div>
                
                <!-- Progress Info -->
                <div style="background: rgba(0,0,0,0.7); border: 2px solid #27AE60; border-radius: 15px; padding: 30px 50px; text-align: center; backdrop-filter: blur(10px);">
                    <div style="color: #27AE60; font-size: 24px; font-weight: bold; margin-bottom: 15px;">
                        <span id="campTimeRemaining">8</span> Hours Remaining
                    </div>
                    
                    <!-- Progress Bar -->
                    <div style="width: 300px; height: 20px; background: rgba(0,0,0,0.5); border-radius: 10px; overflow: hidden; margin-bottom: 20px;">
                        <div id="campProgressBar" style="width: 0%; height: 100%; background: linear-gradient(90deg, #27AE60, #2ECC71); transition: width 0.5s ease;"></div>
                    </div>
                    
                    <!-- Health Regen Status -->
                    <div style="color: #E74C3C; font-size: 18px; margin-bottom: 15px;">
                        <span class="icon icon-lg icon-heart"></span> +<span id="campHealedSoFar">0</span> HP Restored
                    </div>
                    
                    <!-- Cancel Button -->
                    <button onclick="cancelCamping()" style="padding: 12px 30px; background: rgba(231, 76, 60, 0.3); border: 2px solid #E74C3C; border-radius: 8px; color: #E74C3C; font-size: 14px; font-weight: bold; cursor: pointer;">
                        âŒ BREAK CAMP EARLY
                    </button>
                </div>
                
                <!-- Event Log -->
                <div id="campEventLog" style="margin-top: 20px; max-width: 500px; max-height: 150px; overflow-y: auto; background: rgba(0,0,0,0.6); border-radius: 10px; padding: 15px;">
                    <div style="color: #89A0B4; font-size: 12px; text-align: center;">The campfire crackles softly...</div>
                </div>
            </div>
        </div>
        
        <!-- Battle Screen -->
        <div id="battleScreen">
            <!-- Video Background (behind canvas) -->
            <video id="battleBackgroundVideo" loop muted playsinline style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: 0; display: none;">
                <source src="" type="video/mp4">
            </video>
            <canvas id="battleCanvas"></canvas>
            
            <!-- Battle Notification Banner -->
            <div id="battleNotification">ROOM CLEARED!</div>
            
            <!-- Gold Display (Top Center) -->
            <div id="battleGoldDisplay" style="position: absolute; top: 10px; left: 50%; transform: translateX(-50%); background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(30, 30, 30, 0.8)); border: 2px solid #FFD700; border-radius: 8px; padding: 8px 20px; z-index: 100; display: flex; align-items: center; gap: 8px;">
                <span class="icon icon-lg icon-gold"></span>
                <span id="battleGold" style="color: #FFD700; font-size: 18px; font-weight: 700; font-family: 'JetBrains Mono', monospace;">0</span>
            </div>
            
            <!-- Enemy Cards (Left Side) -->
            <div id="battleEnemyCards">
                <!-- Populated dynamically by updateBattleEnemyCards() -->
            </div>
            
            <div id="battleUI">
                <!-- Left Hero Cards: Zooko & Nate -->
                <div id="battleUILeft">
                    <div class="battleHeroCard" id="battleCardZooko">
                        <div style="position: relative; display: flex; justify-content: center;">
                            <div class="battleHeroPotions" id="bzooko-heals" style="position: absolute; left: 0; top: 50%; transform: translateY(-50%); display: flex; flex-direction: column; gap: 2px;">â¤ï¸<br>â¤ï¸</div>
                            <div class="battleHeroPortrait" style="background-image: url('people/zooko_a_head_compressed.png'); border-color: #F2C94C;"></div>
                            <div class="battleHeroRightStats" style="position: absolute; right: -2px; top: 50%; transform: translateY(-50%); display: flex; flex-direction: column; align-items: center; gap: 3px;">
                                <div class="acBadge" style="width: 32px; height: 32px; background-image: url('tunnelsofprivacy/icons/border.png'); background-size: contain; background-repeat: no-repeat; background-position: center; display: flex; align-items: center; justify-content: center; position: relative;" title="Armor Class">
                                    <span id="bzooko-ac" style="color: #6495ED; font-weight: bold; font-size: 12px; text-shadow: 0 0 4px rgba(100,149,237,0.8), 1px 1px 2px rgba(0,0,0,0.8);">12</span>
                                </div>
                                <div class="levelBadge" style="width: 32px; height: 32px; background-image: url('tunnelsofprivacy/icons/border.png'); background-size: contain; background-repeat: no-repeat; background-position: center; display: flex; align-items: center; justify-content: center; position: relative;" title="Hero Level">
                                    <span id="bzooko-level" style="color: #FFD700; font-weight: bold; font-size: 12px; text-shadow: 0 0 4px rgba(255,215,0,0.8), 1px 1px 2px rgba(0,0,0,0.8);">1</span>
                                </div>
                            </div>
                        </div>
                        <div class="battleHeroName" style="color: #F2C94C;">ZOOKO</div>
                        <div class="battleHeroStat" style="color: #ff6b6b;">HP: <span id="bzooko-hp">30</span>/<span id="bzooko-maxhp">30</span></div>
                        <div class="battleHeroStat" style="color: #FFD700;">XP: <span id="bzooko-xp">0</span></div>
                        <div class="battleHeroEquipSlots" style="display: flex; gap: 3px; justify-content: center; margin-top: 6px; padding-top: 4px; border-top: 1px solid rgba(244, 179, 40, 0.3);">
                            <div class="battleEquipSlot" id="bzooko-weapon" data-hero="zooko" data-slottype="weapon" style="width: 28px; height: 28px; background: rgba(244, 179, 40, 0.15); border: 1px solid rgba(244, 179, 40, 0.5); border-radius: 4px; display: flex; align-items: center; justify-content: center; cursor: pointer;" title="Weapon"><img src="tunnelsofprivacy/items/zooko_staff.png" style="width: 80%; height: 80%; object-fit: contain;"></div>
                            <div class="battleEquipSlot" id="bzooko-b-armor" data-hero="zooko" data-slottype="armor" style="width: 28px; height: 28px; background: rgba(244, 179, 40, 0.1); border: 1px dashed rgba(244, 179, 40, 0.3); border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 11px; opacity: 0.4;" title="Armor">ðŸ›¡ï¸</div>
                            <div class="battleEquipSlot" id="bzooko-b-accessory" data-hero="zooko" data-slottype="accessory" style="width: 28px; height: 28px; background: rgba(244, 179, 40, 0.1); border: 1px dashed rgba(244, 179, 40, 0.3); border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 11px; opacity: 0.4;" title="Accessory">ðŸ’</div>
                        </div>
                    </div>
                    <div class="battleHeroCard" id="battleCardNate">
                        <div style="position: relative; display: flex; justify-content: center;">
                            <div class="battleHeroPotions" id="bnate-heals" style="position: absolute; left: 0; top: 50%; transform: translateY(-50%); display: flex; flex-direction: column; gap: 2px;">â¤ï¸<br>â¤ï¸</div>
                            <div class="battleHeroPortrait" style="background-image: url('people/Nate_a_head_compressed.png'); border-color: #E74C3C;"></div>
                            <div class="battleHeroRightStats" style="position: absolute; right: -2px; top: 50%; transform: translateY(-50%); display: flex; flex-direction: column; align-items: center; gap: 3px;">
                                <div class="acBadge" style="width: 32px; height: 32px; background-image: url('tunnelsofprivacy/icons/border.png'); background-size: contain; background-repeat: no-repeat; background-position: center; display: flex; align-items: center; justify-content: center; position: relative;" title="Armor Class">
                                    <span id="bnate-ac" style="color: #6495ED; font-weight: bold; font-size: 12px; text-shadow: 0 0 4px rgba(100,149,237,0.8), 1px 1px 2px rgba(0,0,0,0.8);">14</span>
                                </div>
                                <div class="levelBadge" style="width: 32px; height: 32px; background-image: url('tunnelsofprivacy/icons/border.png'); background-size: contain; background-repeat: no-repeat; background-position: center; display: flex; align-items: center; justify-content: center; position: relative;" title="Hero Level">
                                    <span id="bnate-level" style="color: #FFD700; font-weight: bold; font-size: 12px; text-shadow: 0 0 4px rgba(255,215,0,0.8), 1px 1px 2px rgba(0,0,0,0.8);">1</span>
                                </div>
                            </div>
                        </div>
                        <div class="battleHeroName" style="color: #E74C3C;">NATE</div>
                        <div class="battleHeroStat" style="color: #ff6b6b;">HP: <span id="bnate-hp">28</span>/<span id="bnate-maxhp">30</span></div>
                        <div class="battleHeroStat" style="color: #FFD700;">XP: <span id="bnate-xp">0</span></div>
                        <div class="battleHeroEquipSlots" style="display: flex; gap: 3px; justify-content: center; margin-top: 6px; padding-top: 4px; border-top: 1px solid rgba(231, 76, 60, 0.3);">
                            <div class="battleEquipSlot" id="bnate-weapon" data-hero="nate" data-slottype="weapon" style="width: 28px; height: 28px; background: rgba(231, 76, 60, 0.15); border: 1px solid rgba(231, 76, 60, 0.5); border-radius: 4px; display: flex; align-items: center; justify-content: center; cursor: pointer;" title="Weapon"><img src="tunnelsofprivacy/items/nate_zcash_zashi_walletpng.png" style="width: 80%; height: 80%; object-fit: contain;"></div>
                            <div class="battleEquipSlot" id="bnate-b-armor" data-hero="nate" data-slottype="armor" style="width: 28px; height: 28px; background: rgba(231, 76, 60, 0.1); border: 1px dashed rgba(231, 76, 60, 0.3); border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 11px; opacity: 0.4;" title="Armor">ðŸ›¡ï¸</div>
                            <div class="battleEquipSlot" id="bnate-b-accessory" data-hero="nate" data-slottype="accessory" style="width: 28px; height: 28px; background: rgba(231, 76, 60, 0.1); border: 1px dashed rgba(231, 76, 60, 0.3); border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 11px; opacity: 0.4;" title="Accessory">ðŸ’</div>
                        </div>
                    </div>
                </div>
                
                <!-- Center Action Bar -->
                <div id="battleUICenter">
                    <div id="battleTurnInfo">ZOOKO'S TURN</div>
                    <div id="multiplayerStatus" style="display: none; background: rgba(42, 157, 143, 0.3); border: 2px solid #2A9D8F; border-radius: 5px; padding: 5px 10px; font-size: 11px; color: #2A9D8F; margin-bottom: 8px; text-align: center;">
                        ðŸŽ® <span id="mpStatusText">Multiplayer</span>
                    </div>
                    <div id="diceRollDisplay" style="display: block; background: linear-gradient(135deg, rgba(0,0,0,0.95), rgba(20,20,40,0.95)); color: #E0E0E0; padding: 12px 20px; border-radius: 12px; font-size: 14px; font-weight: bold; text-align: center; margin-bottom: 10px; border: 2px solid #7A8B9C; width: 500px; box-shadow: 0 0 20px rgba(122, 139, 156, 0.2), inset 0 0 20px rgba(122, 139, 156, 0.05); text-shadow: 0 0 10px rgba(224, 224, 224, 0.5), 0 0 20px rgba(224, 224, 224, 0.2); letter-spacing: 1px;">â³ Waiting to Roll...</div>
                    <div id="battleActions">
                        <button class="battleButton attack-weak" onclick="battleAction('light')">âš” LIGHT</button>
                        <button class="battleButton attack-strong" id="battleHeavyBtn" onclick="battleAction('heavy')">âš¡ HEAVY</button>
                        <button class="battleButton special" id="battleSpecialBtn" onclick="battleAction('special')">âœ¨ SPECIAL</button>
                        <button class="battleButton defend" onclick="battleAction('defend')">ðŸ›¡ DEFEND</button>
                        <button class="battleButton swap" onclick="battleAction('swap')">ðŸ”„ SWAP</button>
                        <button class="battleButton taunt" onclick="battleAction('taunt')">ðŸ—£ TAUNT</button>
                        <button class="battleButton heal" onclick="battleAction('heal')">ðŸ’š HEAL</button>
                        <button class="battleButton" id="battleSkipBtn" onclick="battleAction('skip')">â­ SKIP</button>
                        <button class="battleButton" id="battleTalkBtn" onclick="battleAction('talk')">ðŸ’¬ TALK</button>
                        <button class="battleButton retreat" id="battleRetreatBtn" onclick="battleAction('retreat')">ðŸƒ RETREAT</button>
                    </div>
                </div>
                
                <!-- Right Hero Cards: Zancas & CyberAxe -->
                <div id="battleUIRight">
                    <div class="battleHeroCard" id="battleCardZancas">
                        <div style="position: relative; display: flex; justify-content: center;">
                            <div class="battleHeroPotions" id="bzancas-heals" style="position: absolute; left: 0; top: 50%; transform: translateY(-50%); display: flex; flex-direction: column; gap: 2px;">â¤ï¸<br>â¤ï¸</div>
                            <div class="battleHeroPortrait" style="background-image: url('people/Zancas_a_head_compressed.png'); border-color: #27AE60;"></div>
                            <div class="battleHeroRightStats" style="position: absolute; right: -2px; top: 50%; transform: translateY(-50%); display: flex; flex-direction: column; align-items: center; gap: 3px;">
                                <div class="acBadge" style="width: 32px; height: 32px; background-image: url('tunnelsofprivacy/icons/border.png'); background-size: contain; background-repeat: no-repeat; background-position: center; display: flex; align-items: center; justify-content: center; position: relative;" title="Armor Class">
                                    <span id="bzancas-ac" style="color: #6495ED; font-weight: bold; font-size: 12px; text-shadow: 0 0 4px rgba(100,149,237,0.8), 1px 1px 2px rgba(0,0,0,0.8);">15</span>
                                </div>
                                <div class="levelBadge" style="width: 32px; height: 32px; background-image: url('tunnelsofprivacy/icons/border.png'); background-size: contain; background-repeat: no-repeat; background-position: center; display: flex; align-items: center; justify-content: center; position: relative;" title="Hero Level">
                                    <span id="bzancas-level" style="color: #FFD700; font-weight: bold; font-size: 12px; text-shadow: 0 0 4px rgba(255,215,0,0.8), 1px 1px 2px rgba(0,0,0,0.8);">1</span>
                                </div>
                            </div>
                        </div>
                        <div class="battleHeroName" style="color: #27AE60;">ZANCAS</div>
                        <div class="battleHeroStat" style="color: #ff6b6b;">HP: <span id="bzancas-hp">24</span>/<span id="bzancas-maxhp">26</span></div>
                        <div class="battleHeroStat" style="color: #FFD700;">XP: <span id="bzancas-xp">0</span></div>
                        <div class="battleHeroEquipSlots" style="display: flex; gap: 3px; justify-content: center; margin-top: 6px; padding-top: 4px; border-top: 1px solid rgba(39, 174, 96, 0.3);">
                            <div class="battleEquipSlot" id="bzancas-weapon" data-hero="zancas" data-slottype="weapon" style="width: 28px; height: 28px; background: rgba(39, 174, 96, 0.15); border: 1px solid rgba(39, 174, 96, 0.5); border-radius: 4px; display: flex; align-items: center; justify-content: center; cursor: pointer;" title="Weapon"><img src="tunnelsofprivacy/items/zancas_zingo_orb.png" style="width: 80%; height: 80%; object-fit: contain;"></div>
                            <div class="battleEquipSlot" id="bzancas-b-armor" data-hero="zancas" data-slottype="armor" style="width: 28px; height: 28px; background: rgba(39, 174, 96, 0.1); border: 1px dashed rgba(39, 174, 96, 0.3); border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 11px; opacity: 0.4;" title="Armor">ðŸ›¡ï¸</div>
                            <div class="battleEquipSlot" id="bzancas-b-accessory" data-hero="zancas" data-slottype="accessory" style="width: 28px; height: 28px; background: rgba(39, 174, 96, 0.1); border: 1px dashed rgba(39, 174, 96, 0.3); border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 11px; opacity: 0.4;" title="Accessory">ðŸ’</div>
                        </div>
                    </div>
                    <div class="battleHeroCard" id="battleCardCyberAxe">
                        <div style="position: relative; display: flex; justify-content: center;">
                            <div class="battleHeroPotions" id="bcyberaxe-heals" style="position: absolute; left: 0; top: 50%; transform: translateY(-50%); display: flex; flex-direction: column; gap: 2px;">â¤ï¸<br>â¤ï¸</div>
                            <div class="battleHeroPortrait" style="background-image: url('people/cyberaxe_a_head_compressed.png'); border-color: #2E86DE;"></div>
                            <div class="battleHeroRightStats" style="position: absolute; right: -2px; top: 50%; transform: translateY(-50%); display: flex; flex-direction: column; align-items: center; gap: 3px;">
                                <div class="acBadge" style="width: 32px; height: 32px; background-image: url('tunnelsofprivacy/icons/border.png'); background-size: contain; background-repeat: no-repeat; background-position: center; display: flex; align-items: center; justify-content: center; position: relative;" title="Armor Class">
                                    <span id="bcyberaxe-ac" style="color: #6495ED; font-weight: bold; font-size: 12px; text-shadow: 0 0 4px rgba(100,149,237,0.8), 1px 1px 2px rgba(0,0,0,0.8);">15</span>
                                </div>
                                <div class="levelBadge" style="width: 32px; height: 32px; background-image: url('tunnelsofprivacy/icons/border.png'); background-size: contain; background-repeat: no-repeat; background-position: center; display: flex; align-items: center; justify-content: center; position: relative;" title="Hero Level">
                                    <span id="bcyberaxe-level" style="color: #FFD700; font-weight: bold; font-size: 12px; text-shadow: 0 0 4px rgba(255,215,0,0.8), 1px 1px 2px rgba(0,0,0,0.8);">1</span>
                                </div>
                            </div>
                        </div>
                        <div class="battleHeroName" style="color: #2E86DE;">CYBERAXE</div>
                        <div class="battleHeroStat" style="color: #ff6b6b;">HP: <span id="bcyberaxe-hp">32</span>/<span id="bcyberaxe-maxhp">35</span></div>
                        <div class="battleHeroStat" style="color: #FFD700;">XP: <span id="bcyberaxe-xp">0</span></div>
                        <div class="battleHeroEquipSlots" style="display: flex; gap: 3px; justify-content: center; margin-top: 6px; padding-top: 4px; border-top: 1px solid rgba(46, 134, 222, 0.3);">
                            <div class="battleEquipSlot" id="bcyberaxe-weapon" data-hero="cyberaxe" data-slottype="weapon" style="width: 28px; height: 28px; background: rgba(46, 134, 222, 0.15); border: 1px solid rgba(46, 134, 222, 0.5); border-radius: 4px; display: flex; align-items: center; justify-content: center; cursor: pointer;" title="Weapon"><img src="tunnelsofprivacy/items/cyberaxe_axe.png" style="width: 80%; height: 80%; object-fit: contain;"></div>
                            <div class="battleEquipSlot" id="bcyberaxe-b-armor" data-hero="cyberaxe" data-slottype="armor" style="width: 28px; height: 28px; background: rgba(46, 134, 222, 0.1); border: 1px dashed rgba(46, 134, 222, 0.3); border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 11px; opacity: 0.4;" title="Armor">ðŸ›¡ï¸</div>
                            <div class="battleEquipSlot" id="bcyberaxe-b-accessory" data-hero="cyberaxe" data-slottype="accessory" style="width: 28px; height: 28px; background: rgba(46, 134, 222, 0.1); border: 1px dashed rgba(46, 134, 222, 0.3); border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 11px; opacity: 0.4;" title="Accessory">ðŸ’</div>
                        </div>
                    </div>
                    </div>
                </div>
            </div>
            
            <!-- Chat Window -->
            <div id="battleChatWindow">
                <div id="chatHeader">
                    <span>ðŸ’¬ Battle Chat</span>
                    <span id="chatStatus" style="font-size: 11px; color: #aaa;"></span>
                    <label id="ttsToggleLabel" title="Enable text-to-speech for NPC responses">
                        <input type="checkbox" id="ttsToggle" checked onchange="toggleTTS()">
                        <span class="icon icon-sm icon-narrate"></span>
                    </label>
                    <button id="chatExpandBtn" onclick="toggleChatExpand()" title="Expand/Shrink">â‡•</button>
                    <button id="chatCloseBtn" onclick="toggleChatWindow()">âœ•</button>
                </div>
                <div id="chatModelSelector">
                    <span style="font-size: 10px; color: #888; margin-right: 4px;">Free:</span>
                    <button class="modelBtn active" onclick="selectChatModel(2)" title="Groq Llama 3.1 8B (FREE)">2</button>
                    <button class="modelBtn" onclick="selectChatModel(4)" title="Groq Gemma 2 9B (FREE)">4</button>
                    <button class="modelBtn" onclick="selectChatModel(5)" title="Groq Mixtral 8x7B (FREE)">5</button>
                    <span style="font-size: 10px; color: #F39C12; margin-left: 6px; margin-right: 4px;">Paid:</span>
                    <button class="modelBtn" onclick="selectChatModel(1)" title="OpenRouter Mistral Nemo ($)" style="border-color: #F39C12;">1</button>
                    <button class="modelBtn" onclick="selectChatModel(3)" title="Groq Llama 3.3 70B ($)" style="border-color: #F39C12;">3</button>
                    <button class="modelBtn" onclick="selectChatModel(6)" title="OpenRouter Llama 3.1 8B ($)" style="border-color: #F39C12;">6</button>
                    <button class="modelBtn" onclick="selectChatModel(7)" title="OpenRouter Gemma 2 9B ($)" style="border-color: #F39C12;">7</button>
                    <button class="modelBtn" onclick="selectChatModel(8)" title="OpenRouter Qwen 2.5 7B ($)" style="border-color: #F39C12;">8</button>
                    <button class="modelBtn" onclick="selectChatModel(9)" title="OpenRouter L3 Lunaris 8B ($)" style="border-color: #F39C12;">9</button>
                    <span id="chatCostDisplay" style="margin-left: 8px; font-size: 11px; color: #4CAF50;">$0.000000 | 0 tok</span>
                </div>
                <div id="chatMessages"></div>
                <div id="chatInputArea">
                    <div id="chatTargetSelector">
                        <button class="chatTargetBtn broadcast active" onclick="selectChatTarget(null)" title="Speak to everyone">ðŸ“¢ ALL</button>
                        <!-- Entity buttons populated dynamically -->
                    </div>
                    <div id="chatInputRow">
                        <input type="text" id="chatInput" placeholder="Say something..." onkeypress="if(event.key==='Enter')sendChatMessage()">
                        <button id="chatSendBtn" onclick="sendChatMessage()">Send</button>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="titleScreen">
            <!-- Story Intro Background Animation -->
            <div id="storyIntroBackground" data-tooltip-id="titleBackground"></div>
            
            <div id="title">TUNNELS OF PRIVACY</div>
            <div id="subtitle">A Dungeon Crawler Adventure</div>
            
            <!-- Center Column - Menu Buttons, Music Controls -->
            <div id="menuButtonsCenter">
                <button id="startAdventureBtn" class="menuButton" onclick="startAdventure()">START ADVENTURE<span style="display: inline-block; width: 26px; height: 26px; background: #27AE60; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">A</span></button>
                <button id="continueBtn" class="menuButton comingSoon" disabled onclick="continueGame()">CONTINUE<span style="display: inline-block; width: 26px; height: 26px; background: #EB5757; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">A</span></button>
                <button class="menuButton" onclick="showLoadSave()">LOAD SAVE FILE<span style="display: inline-block; width: 26px; height: 26px; background: #3498DB; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">B</span></button>
                <button class="menuButton" onclick="showAchievementsPanel()">ðŸ† ACHIEVEMENTS<span style="display: inline-block; width: 26px; height: 26px; background: #F39C12; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">Y</span></button>
                <button class="menuButton" onclick="showSettings()"><span class="icon icon-md icon-settings"></span> SETTINGS<span style="display: inline-block; width: 26px; height: 26px; background: #2A9D8F; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">X</span></button>
                <button id="enterArcadeBtn" class="menuButton portalButton" onclick="exitPortal()">
                    <div style="display: flex; align-items: center; justify-content: space-between; width: 100%;">
                        <div style="text-align: left; display: flex; align-items: center; gap: 8px;">
                            <span class="icon icon-lg icon-arcade"></span>
                            <div>
                                <div style="font-size: 18px; font-weight: 700;">ENTER ARCADE</div>
                                <div style="font-size: 10px; font-weight: 400; margin-top: 2px;">(ZLOCK ZHAINER)</div>
                            </div>
                        </div>
                        <span style="display: inline-block; padding: 4px 10px; background: #8B45FF; border-radius: 5px; font-weight: bold; color: white; font-size: 12px;"><span class="icon icon-sm icon-back"></span></span>
                    </div>
                </button>
            </div>
            
            <div id="versionDisplay">Tunnels of Privacy v0.4.02 â€¢ Portal System Active</div>
            
            <!-- About/Donate Button (Bottom Right) -->
            <div id="aboutDonateBtn" style="
                position: absolute;
                bottom: 20px;
                right: 20px;
                width: 200px;
                background: rgba(10, 14, 18, 0.8);
                border: 2px solid #2D9CDB;
                border-radius: 10px;
                padding: 12px;
                backdrop-filter: blur(10px);
                cursor: pointer;
                transition: all 0.3s ease;
                text-align: center;
                pointer-events: all;
                z-index: 100;
            " onclick="showAbout()" onmouseenter="this.style.borderColor='#F2C94C'; this.style.boxShadow='0 0 15px rgba(242, 201, 76, 0.4)';" onmouseleave="this.style.borderColor='#2D9CDB'; this.style.boxShadow='none';">
                <div style="font-size: 14px; font-weight: 700; color: #F2C94C; margin-bottom: 3px;">ABOUT / DONATE</div>
                <div style="font-size: 11px; color: #89A0B4;">Support Development</div>
            </div>
            
            <!-- YouTube Intro Video Link -->
            <a href="https://www.youtube.com/watch?v=R967tFtDSME" target="_blank" style="
                position: absolute;
                right: 60px;
                top: 50%;
                transform: translateY(-50%);
                width: 320px;
                background: linear-gradient(135deg, rgba(10, 14, 18, 0.98), rgba(20, 27, 34, 0.95));
                border: 3px solid #FF0000;
                border-radius: 16px;
                padding: 0;
                overflow: hidden;
                text-decoration: none;
                transition: all 0.3s ease;
                box-shadow: 0 8px 32px rgba(255, 0, 0, 0.4);
                cursor: pointer;
                pointer-events: all;
                z-index: 100;
            " onmouseover="this.style.transform='translateY(-50%) scale(1.05)'; this.style.boxShadow='0 12px 40px rgba(255, 0, 0, 0.6)'; this.style.borderColor='#FF3333';" onmouseout="this.style.transform='translateY(-50%) scale(1)'; this.style.boxShadow='0 8px 32px rgba(255, 0, 0, 0.4)'; this.style.borderColor='#FF0000';">
                <!-- YouTube Thumbnail -->
                <div style="position: relative; width: 100%; height: 180px; background: #000;">
                    <img src="https://img.youtube.com/vi/R967tFtDSME/maxresdefault.jpg" style="width: 100%; height: 100%; object-fit: cover;" alt="Intro Video">
                    <!-- Play Button Overlay -->
                    <div style="
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        width: 68px;
                        height: 48px;
                        background: rgba(255, 0, 0, 0.9);
                        border-radius: 14px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        transition: all 0.3s ease;
                    ">
                        <div style="
                            width: 0;
                            height: 0;
                            border-left: 18px solid white;
                            border-top: 12px solid transparent;
                            border-bottom: 12px solid transparent;
                            margin-left: 4px;
                        "></div>
                    </div>
                </div>
                <!-- Video Info -->
                <div style="padding: 16px; text-align: center;">
                    <div style="
                        font-family: 'JetBrains Mono', monospace;
                        font-size: 18px;
                        font-weight: 900;
                        color: #8B45FF;
                        margin-bottom: 8px;
                        text-transform: uppercase;
                        letter-spacing: 1px;
                    ">ðŸŽ¬ Watch Intro</div>
                    <div style="
                        font-family: 'JetBrains Mono', monospace;
                        font-size: 13px;
                        color: #89A0B4;
                        line-height: 1.4;
                    ">The TUNNELS OF PRIVACY<br>animated intro video</div>
                    <div style="
                        margin-top: 12px;
                        padding: 8px 16px;
                        background: rgba(255, 0, 0, 0.15);
                        border: 1px solid #FF0000;
                        border-radius: 8px;
                        font-family: 'JetBrains Mono', monospace;
                        font-size: 12px;
                        font-weight: 700;
                        color: #FF6B6B;
                        display: inline-block;
                    ">â–¶ WATCH ON YOUTUBE</div>
                </div>
            </a>
            
            <!-- Story Audio Buttons (Below YouTube Panel) -->
            <div style="
                position: absolute;
                right: 60px;
                top: calc(50% + 180px);
                width: 320px;
                display: flex;
                flex-direction: column;
                gap: 10px;
                pointer-events: all;
                z-index: 100;
            ">
                <!-- Read me the Story Button -->
                <button id="storyVoiceBtn" onclick="toggleStoryVoice()" style="
                    width: 100%;
                    padding: 14px 20px;
                    background: linear-gradient(135deg, rgba(139, 69, 255, 0.4), rgba(139, 69, 255, 0.2));
                    border: 2px solid #8B45FF;
                    border-radius: 10px;
                    color: #8B45FF;
                    font-family: 'JetBrains Mono', monospace;
                    font-size: 14px;
                    font-weight: 700;
                    cursor: pointer;
                    transition: all 0.3s ease;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    gap: 10px;
                " onmouseover="this.style.background='linear-gradient(135deg, rgba(139, 69, 255, 0.6), rgba(139, 69, 255, 0.4))'; this.style.boxShadow='0 0 20px rgba(139, 69, 255, 0.4)';" onmouseout="this.style.background='linear-gradient(135deg, rgba(139, 69, 255, 0.4), rgba(139, 69, 255, 0.2))'; this.style.boxShadow='none';">
                    <span id="storyVoiceIcon">ðŸ“–</span> Read Me the Story
                </button>
                
                <!-- Hear from the King Button -->
                <button id="kingVoiceBtn" onclick="toggleKingVoice()" style="
                    width: 100%;
                    padding: 14px 20px;
                    background: linear-gradient(135deg, rgba(242, 201, 76, 0.4), rgba(242, 201, 76, 0.2));
                    border: 2px solid #F2C94C;
                    border-radius: 10px;
                    color: #F2C94C;
                    font-family: 'JetBrains Mono', monospace;
                    font-size: 14px;
                    font-weight: 700;
                    cursor: pointer;
                    transition: all 0.3s ease;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    gap: 10px;
                " onmouseover="this.style.background='linear-gradient(135deg, rgba(242, 201, 76, 0.6), rgba(242, 201, 76, 0.4))'; this.style.boxShadow='0 0 20px rgba(242, 201, 76, 0.4)';" onmouseout="this.style.background='linear-gradient(135deg, rgba(242, 201, 76, 0.4), rgba(242, 201, 76, 0.2))'; this.style.boxShadow='none';">
                    <span id="kingVoiceIcon">ðŸ‘‘</span> Hear from the King
                </button>
                
                <!-- Hero Intro Video Buttons - 2x2 Grid -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; width: 100%; margin-top: 5px;">
                    <!-- Zooko -->
                    <button onclick="playHeroIntroVideo('zooko')" style="
                        padding: 10px 15px;
                        background: linear-gradient(135deg, rgba(242, 201, 76, 0.4), rgba(242, 201, 76, 0.2));
                        border: 2px solid #F2C94C;
                        border-radius: 8px;
                        color: #F2C94C;
                        font-family: 'JetBrains Mono', monospace;
                        font-size: 12px;
                        font-weight: 700;
                        cursor: pointer;
                        transition: all 0.3s ease;
                    " onmouseover="this.style.background='linear-gradient(135deg, rgba(242, 201, 76, 0.6), rgba(242, 201, 76, 0.4))'; this.style.boxShadow='0 0 15px rgba(242, 201, 76, 0.4)';" onmouseout="this.style.background='linear-gradient(135deg, rgba(242, 201, 76, 0.4), rgba(242, 201, 76, 0.2))'; this.style.boxShadow='none';">
                        Zooko
                    </button>
                    <!-- Nate -->
                    <button onclick="playHeroIntroVideo('nate')" style="
                        padding: 10px 15px;
                        background: linear-gradient(135deg, rgba(231, 76, 60, 0.4), rgba(231, 76, 60, 0.2));
                        border: 2px solid #E74C3C;
                        border-radius: 8px;
                        color: #E74C3C;
                        font-family: 'JetBrains Mono', monospace;
                        font-size: 12px;
                        font-weight: 700;
                        cursor: pointer;
                        transition: all 0.3s ease;
                    " onmouseover="this.style.background='linear-gradient(135deg, rgba(231, 76, 60, 0.6), rgba(231, 76, 60, 0.4))'; this.style.boxShadow='0 0 15px rgba(231, 76, 60, 0.4)';" onmouseout="this.style.background='linear-gradient(135deg, rgba(231, 76, 60, 0.4), rgba(231, 76, 60, 0.2))'; this.style.boxShadow='none';">
                        Nate
                    </button>
                    <!-- Zancas -->
                    <button onclick="playHeroIntroVideo('zancas')" style="
                        padding: 10px 15px;
                        background: linear-gradient(135deg, rgba(39, 174, 96, 0.4), rgba(39, 174, 96, 0.2));
                        border: 2px solid #27AE60;
                        border-radius: 8px;
                        color: #27AE60;
                        font-family: 'JetBrains Mono', monospace;
                        font-size: 12px;
                        font-weight: 700;
                        cursor: pointer;
                        transition: all 0.3s ease;
                    " onmouseover="this.style.background='linear-gradient(135deg, rgba(39, 174, 96, 0.6), rgba(39, 174, 96, 0.4))'; this.style.boxShadow='0 0 15px rgba(39, 174, 96, 0.4)';" onmouseout="this.style.background='linear-gradient(135deg, rgba(39, 174, 96, 0.4), rgba(39, 174, 96, 0.2))'; this.style.boxShadow='none';">
                        Zancas
                    </button>
                    <!-- CyberAxe -->
                    <button onclick="playHeroIntroVideo('cyberaxe')" style="
                        padding: 10px 15px;
                        background: linear-gradient(135deg, rgba(46, 134, 222, 0.4), rgba(46, 134, 222, 0.2));
                        border: 2px solid #2E86DE;
                        border-radius: 8px;
                        color: #2E86DE;
                        font-family: 'JetBrains Mono', monospace;
                        font-size: 12px;
                        font-weight: 700;
                        cursor: pointer;
                        transition: all 0.3s ease;
                    " onmouseover="this.style.background='linear-gradient(135deg, rgba(46, 134, 222, 0.6), rgba(46, 134, 222, 0.4))'; this.style.boxShadow='0 0 15px rgba(46, 134, 222, 0.4)';" onmouseout="this.style.background='linear-gradient(135deg, rgba(46, 134, 222, 0.4), rgba(46, 134, 222, 0.2))'; this.style.boxShadow='none';">
                        CyberAxe
                    </button>
                </div>
            </div>
            
            <!-- Multiplayer Controls (Top Left) -->
            <div style="position: absolute; top: 20px; left: 20px; display: flex; flex-direction: column; gap: 10px; align-items: flex-start; pointer-events: all; z-index: 100;">
                <!-- Create Room Button -->
                <button class="menuButton" onclick="createMultiplayerRoom()" style="padding: 10px 20px; font-size: 14px; margin: 0; pointer-events: all; background: linear-gradient(135deg, rgba(42, 157, 143, 0.4), rgba(42, 157, 143, 0.3)); border-color: #2A9D8F; white-space: nowrap; width: 250px;">ðŸŽ® CREATE ROOM</button>
                
                <!-- Room Code Input and Join Button -->
                <div style="display: flex; gap: 10px; align-items: stretch;">
                    <input type="text" id="titleJoinCode" placeholder="CODE" maxlength="6" onkeypress="if(event.key==='Enter') quickJoinRoom()" style="width: 90px; padding: 10px; background: rgba(0,0,0,0.7); border: 2px solid #2A9D8F; border-radius: 5px; color: #F2C94C; font-size: 14px; text-align: center; letter-spacing: 2px; font-family: 'JetBrains Mono', monospace; text-transform: uppercase; pointer-events: all;">
                    <button class="menuButton" onclick="quickJoinRoom()" style="padding: 10px 15px; font-size: 14px; margin: 0; pointer-events: all; white-space: nowrap; width: 150px;">JOIN</button>
                </div>
                
                <!-- Player Name Input -->
                <div style="display: flex; flex-direction: column; gap: 5px; align-items: flex-start;">
                    <input type="text" id="multiplayerPlayerName" placeholder="Enter your Player Name" maxlength="20" style="width: 250px; padding: 10px; background: rgba(0,0,0,0.7); border: 2px solid #2A9D8F; border-radius: 5px; color: #E9F0F7; font-size: 14px; font-family: 'Inter', sans-serif; pointer-events: all;">
                    <div style="color: #F2C94C; font-size: 10px; font-style: italic; margin-top: -2px;">Changing will Reset Join in Progress</div>
                </div>
            </div>
        </div>
        
        <!-- Network Debug Panel -->
        <div id="networkDebugPanel" style="display: none; position: fixed; top: 10px; right: 10px; width: 400px; max-height: 500px; overflow-y: auto; background: rgba(10, 14, 18, 0.95); border: 2px solid #2A9D8F; border-radius: 8px; padding: 15px; z-index: 150; font-family: 'JetBrains Mono', monospace; font-size: 11px;">
            <div style="font-size: 14px; font-weight: bold; color: #2A9D8F; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center;">
                <span>ðŸŒ NETWORK DEBUG</span>
                <button onclick="toggleNetworkDebug()" style="background: #EB5757; border: none; border-radius: 3px; color: white; padding: 3px 8px; cursor: pointer; font-size: 10px;">âœ•</button>
            </div>
            
            <div style="margin-bottom: 10px; padding: 8px; background: rgba(0,0,0,0.5); border-radius: 5px;">
                <div style="color: #89A0B4; margin-bottom: 5px;">Connection Status:</div>
                <div id="debugConnStatus" style="color: #F2C94C; font-weight: bold;">Disconnected</div>
            </div>
            
            <div style="margin-bottom: 10px; padding: 8px; background: rgba(0,0,0,0.5); border-radius: 5px;">
                <div style="color: #89A0B4; margin-bottom: 5px;">Room State:</div>
                <div id="debugRoomState" style="color: #2A9D8F;">No room</div>
            </div>
            
            <div style="margin-bottom: 10px;">
                <div style="color: #89A0B4; margin-bottom: 5px; display: flex; justify-content: space-between;">
                    <span>Message Log (Last 20):</span>
                    <button onclick="clearDebugLog()" style="background: #E74C3C; border: none; border-radius: 3px; color: white; padding: 2px 6px; cursor: pointer; font-size: 9px;">CLEAR</button>
                </div>
                <div id="debugMessageLog" style="max-height: 300px; overflow-y: auto; background: rgba(0,0,0,0.7); border: 1px solid #2A9D8F; border-radius: 5px; padding: 8px;"></div>
            </div>
        </div>
        
        <!-- Music Control Panel - Bottom Above Ticker (OUTSIDE titleScreen so always visible) -->
        <div id="musicControls">
            <div style="display: flex; align-items: center; gap: 12px;">
                <img src="tunnelsofprivacy/icons/volume.png" alt="" style="width: 48px; height: 48px;">
                <button onclick="musicPrevious()" class="musicIconBtn" title="Previous Track"><img src="tunnelsofprivacy/icons/music_back.png" alt="Previous" style="width: 64px; height: 64px;"></button>
                <button id="musicPlayPauseBtn" onclick="musicPlayPause()" class="musicIconBtn" title="Play/Pause"><img id="playPauseIcon" src="tunnelsofprivacy/icons/music_play.png" alt="Play" style="width: 64px; height: 64px;"></button>
                <button onclick="musicNext()" class="musicIconBtn" title="Next Track"><img src="tunnelsofprivacy/icons/music_forward.png" alt="Next" style="width: 64px; height: 64px;"></button>
                <input type="range" class="volumeSlider" id="volumeSlider" min="1" max="150" value="40" oninput="updateVolume()" style="width: 80px;">
                <span id="volumeSliderValue" style="color: #2D9CDB; font-family: 'JetBrains Mono', monospace; font-size: 10px; font-weight: bold; min-width: 24px;">40</span>
            </div>
        </div>
        
        <!-- Music Ticker (OUTSIDE titleScreen so always visible) -->
        <div id="musicTicker">
            <div id="musicTickerWrapper">
                <span class="tickerText" id="musicTickerText1">â™« Theme Song â™«</span>
                <span class="tickerText" id="musicTickerText2">â™« Theme Song â™«</span>
            </div>
        </div>
    </div>
    
    <!-- Pause Screen -->
    <div id="pauseScreen">
        <div id="pauseTitle">PAUSED</div>
        <button class="menuButton" onclick="resumeGame()">RESUME<span style="display: inline-block; width: 26px; height: 26px; background: #E74C3C; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">B</span></button>
        <button class="menuButton" onclick="saveGameFromPause()" style="background: linear-gradient(135deg, rgba(46, 134, 222, 0.4), rgba(46, 134, 222, 0.3)); border-color: #3498DB;">SAVE GAME<span style="display: inline-block; width: 26px; height: 26px; background: #3498DB; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">ðŸ’¾</span></button>
        <button class="menuButton" onclick="downloadSaveFile()" style="background: linear-gradient(135deg, rgba(39, 174, 96, 0.4), rgba(39, 174, 96, 0.3)); border-color: #27AE60;">SAVE GAME FILE<span style="display: inline-block; width: 26px; height: 26px; background: #27AE60; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">â¬‡</span></button>
        <button class="menuButton" onclick="showSettingsFromPause()"><span class="icon icon-md icon-settings"></span> SETTINGS<span style="display: inline-block; width: 26px; height: 26px; background: #F39C12; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">Y</span></button>
        <button class="menuButton" onclick="showAchievementsPanelFromGame()" style="background: linear-gradient(135deg, rgba(42, 157, 143, 0.4), rgba(42, 157, 143, 0.3)); border-color: #2A9D8F;">ðŸ† ACHIEVEMENTS<span style="display: inline-block; width: 26px; height: 26px; background: #2A9D8F; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">A</span></button>
        <button class="menuButton" id="resyncBtn" onclick="requestResync()" style="display: none; background: linear-gradient(135deg, rgba(155, 89, 182, 0.4), rgba(155, 89, 182, 0.3)); border-color: #9B59B6;">ðŸ”„ RESYNC FROM HOST<span style="display: inline-block; width: 26px; height: 26px; background: #9B59B6; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">â†»</span></button>
        <button class="menuButton" id="hostControlsBtn" onclick="showHostControls()" style="display: none; background: linear-gradient(135deg, rgba(42, 157, 143, 0.4), rgba(42, 157, 143, 0.3)); border-color: #2A9D8F;">HOST CONTROLS<span style="display: inline-block; width: 26px; height: 26px; background: #2A9D8F; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">ðŸŽ®</span></button>
        <button class="menuButton" onclick="quitToMenu()">QUIT TO MENU<span style="display: inline-block; padding: 4px 10px; background: #555; border-radius: 5px; margin-left: 10px; font-weight: bold; color: white; font-size: 12px;">â—€</span></button>
    </div>
    
    <!-- Non-Combat Room Screen (Store, NPC, Secret, Exploration) -->
    <div id="nonCombatRoomScreen" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(135deg, #0a0a1a 0%, #1a1a2e 50%, #16213e 100%); z-index: 50;">
        <!-- Video Background for Store -->
        <video id="storeBackgroundVideo" loop playsinline style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: 0; display: none;">
            <source src="" type="video/mp4">
        </video>
        <!-- Room Background (static image fallback) -->
        <div id="nonCombatBackground" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-size: cover; background-position: center; opacity: 0.3;"></div>
        
        <!-- Room Content Container -->
        <div style="position: relative; z-index: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; padding: 40px;">
            
            <!-- Room Type Header -->
            <div id="nonCombatRoomHeader" style="text-align: center; margin-bottom: 30px;">
                <div id="nonCombatRoomIcon" style="font-size: 64px; margin-bottom: 10px;"><span class="icon icon-xxl icon-store"></span></div>
                <div id="nonCombatRoomTitle" style="color: #F2C94C; font-size: 32px; font-weight: 900; text-shadow: 0 0 20px rgba(242, 201, 76, 0.5);">STORE</div>
                <div id="nonCombatRoomSubtitle" style="color: #89A0B4; font-size: 16px; margin-top: 5px;">A merchant awaits...</div>
            </div>
            
            <!-- Room Content Area -->
            <div id="nonCombatRoomContent" style="background: rgba(0,0,0,0.7); border: 3px solid #8B45FF; border-radius: 15px; padding: 30px; max-width: 1400px; width: 95%; max-height: 70vh; overflow-y: auto; backdrop-filter: blur(10px);">
                <!-- Content populated dynamically based on room type -->
                <div id="storeContent" style="display: none;">
                    
                    <!-- Shielded Gold Display -->
                    <div style="display: flex; justify-content: center; margin-bottom: 20px;">
                        <div style="background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 215, 0, 0.1)); padding: 12px 24px; border-radius: 12px; border: 2px solid #FFD700; display: flex; align-items: center; gap: 12px;">
                            <span class="icon icon-md icon-gold"></span>
                            <span style="color: #89A0B4; font-size: 14px; font-weight: bold;">PARTY GOLD:</span>
                            <span id="storeGoldDisplay" style="color: #FFD700; font-size: 24px; font-weight: 900; letter-spacing: 2px; font-family: 'JetBrains Mono', monospace; min-width: 80px; text-align: center;">ðŸ›¡ï¸ðŸ›¡ï¸ðŸ›¡ï¸ðŸ›¡ï¸</span>
                            <button onclick="toggleStoreGoldVisibility()" id="storeGoldToggleBtn" style="background: linear-gradient(135deg, rgba(155, 89, 182, 0.4), rgba(155, 89, 182, 0.2)); border: 2px solid #9B59B6; border-radius: 6px; color: #BB8FCE; cursor: pointer; font-size: 12px; padding: 6px 12px; font-weight: bold; transition: all 0.2s;">ðŸ›¡ï¸ REVEAL</button>
                        </div>
                    </div>
                    
                    <!-- 3-Column Store Layout -->
                    <div style="display: grid; grid-template-columns: 1fr 520px 1fr; gap: 20px; align-items: start;">
                        
                        <!-- LEFT: Merchant's Shop (Items) -->
                        <div id="merchantShop" style="background: rgba(39, 174, 96, 0.15); border: 2px solid #27AE60; border-radius: 12px; padding: 15px;">
                            <div style="color: #27AE60; font-size: 16px; font-weight: 900; text-align: center; margin-bottom: 12px; text-shadow: 0 0 10px rgba(39, 174, 96, 0.5);">ðŸ›’ MERCHANT'S WARES</div>
                            <div id="storeItems" style="display: flex; flex-direction: column; gap: 12px; max-height: 500px; overflow-y: auto; padding-right: 5px;">
                                <!-- Store items populated dynamically -->
                            </div>
                        </div>
                        
                        <!-- CENTER: Party Inventory -->
                        <div id="storeInventorySection" style="background: rgba(45, 156, 219, 0.15); border: 2px solid #2D9CDB; border-radius: 12px; padding: 15px;">
                            <div style="color: #2D9CDB; font-size: 16px; font-weight: 900; text-align: center; margin-bottom: 8px; text-shadow: 0 0 10px rgba(45, 156, 219, 0.5);"><span class="icon icon-md icon-loot"></span> PARTY INVENTORY</div>
                            <!-- Hero Legend -->
                            <div style="display: flex; gap: 10px; justify-content: center; margin-bottom: 8px; font-size: 10px; font-family: 'JetBrains Mono', monospace;">
                                <span style="color: #F2C94C;">â— Zooko</span>
                                <span style="color: #E74C3C;">â— Nate</span>
                                <span style="color: #27AE60;">â— Zancas</span>
                                <span style="color: #2E86DE;">â— CyberAxe</span>
                            </div>
                            <div id="storeInventoryGrid" style="display: grid; grid-template-columns: 54px repeat(6, 54px) 54px; grid-template-rows: repeat(6, 54px); gap: 4px; justify-content: center;"></div>
                        </div>
                        
                        <!-- RIGHT: Equipment Shop (Upgrades & Enchantments) -->
                        <div id="equipmentShop" style="background: rgba(155, 89, 182, 0.15); border: 2px solid #9B59B6; border-radius: 12px; padding: 15px;">
                            <div style="color: #9B59B6; font-size: 16px; font-weight: 900; text-align: center; margin-bottom: 12px; text-shadow: 0 0 10px rgba(155, 89, 182, 0.5);">âš’ï¸ EQUIPMENT SHOP</div>
                            
                            <!-- Hero Selection for Equipment -->
                            <div style="display: flex; gap: 5px; justify-content: center; margin-bottom: 12px;">
                                <button class="equipHeroBtn" onclick="selectEquipHero('zooko')" data-hero="zooko" style="padding: 6px 12px; background: rgba(242, 201, 76, 0.3); border: 2px solid #F2C94C; border-radius: 6px; color: #F2C94C; cursor: pointer; font-size: 11px; font-weight: bold;">Zooko</button>
                                <button class="equipHeroBtn" onclick="selectEquipHero('nate')" data-hero="nate" style="padding: 6px 12px; background: rgba(231, 76, 60, 0.2); border: 2px solid #E74C3C; border-radius: 6px; color: #E74C3C; cursor: pointer; font-size: 11px; font-weight: bold;">Nate</button>
                                <button class="equipHeroBtn" onclick="selectEquipHero('zancas')" data-hero="zancas" style="padding: 6px 12px; background: rgba(39, 174, 96, 0.2); border: 2px solid #27AE60; border-radius: 6px; color: #27AE60; cursor: pointer; font-size: 11px; font-weight: bold;">Zancas</button>
                                <button class="equipHeroBtn" onclick="selectEquipHero('cyberaxe')" data-hero="cyberaxe" style="padding: 6px 12px; background: rgba(46, 134, 222, 0.2); border: 2px solid #2E86DE; border-radius: 6px; color: #2E86DE; cursor: pointer; font-size: 11px; font-weight: bold;">CyberAxe</button>
                            </div>
                            
                            <!-- Current Equipment Display -->
                            <div id="currentEquipDisplay" style="background: rgba(0,0,0,0.4); border-radius: 8px; padding: 10px; margin-bottom: 12px;">
                                <div id="equipHeroName" style="color: #F2C94C; font-size: 14px; font-weight: bold; text-align: center; margin-bottom: 8px;">Select a Hero</div>
                                <div id="equipWeaponInfo" style="color: #E0E0E0; font-size: 12px; text-align: center;">
                                    <div>Weapon: <span id="equipWeaponLevel" style="color: #9B59B6;">Lv 0</span></div>
                                    <div>Enchant: <span id="equipEnchantName" style="color: #F39C12;">None</span></div>
                                </div>
                            </div>
                            
                            <!-- Upgrade Section -->
                            <div style="margin-bottom: 12px;">
                                <div style="color: #9B59B6; font-size: 13px; font-weight: bold; margin-bottom: 6px;">â¬†ï¸ UPGRADES</div>
                                <div id="upgradeOptions" style="display: flex; flex-direction: column; gap: 6px; max-height: 120px; overflow-y: auto;">
                                    <!-- Upgrade options populated dynamically -->
                                </div>
                            </div>
                            
                            <!-- Enchantment Section -->
                            <div>
                                <div style="color: #F39C12; font-size: 13px; font-weight: bold; margin-bottom: 6px;">âœ¨ ENCHANTMENTS</div>
                                <div id="enchantOptions" style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px; max-height: 150px; overflow-y: auto;">
                                    <!-- Enchantment options populated dynamically -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- NPC Event Content (max-width: 400px to match button width) -->
                <div id="npcContent" style="display: none; max-width: 400px; margin: 0 auto;">
                    <div id="npcName" style="color: #3498DB; font-size: 24px; font-weight: bold; text-align: center; margin-bottom: 10px;">NPC Name</div>
                    <div id="npcDialogue" style="color: #E0E0E0; font-size: 16px; text-align: center; margin-bottom: 20px; line-height: 1.6;">"Hello there!"</div>
                    <div id="npcChoices" style="display: flex; flex-direction: column; gap: 15px; align-items: center; max-width: 400px; margin: 0 auto;">
                        <!-- Good Choice: Help -->
                        <button class="menuButton" id="npcHelpBtn" onclick="npcChoiceHelp()" style="width: 100%; background: linear-gradient(135deg, rgba(46, 204, 113, 0.4), rgba(46, 204, 113, 0.3)); border-color: #2ECC71; padding: 15px;">
                            <div style="font-size: 18px; font-weight: bold;">ðŸ¤ HELP THEM</div>
                            <div id="npcHelpCost" style="font-size: 14px; color: #E74C3C; margin-top: 5px;">Cost: 50 Gold</div>
                            <div id="npcHelpReward" style="font-size: 14px; color: #2ECC71; margin-top: 3px;">Reward: +100 XP</div>
                        </button>
                        <!-- Bad Choice: Rob -->
                        <button class="menuButton" id="npcRobBtn" onclick="npcChoiceRob()" style="width: 100%; background: linear-gradient(135deg, rgba(231, 76, 60, 0.4), rgba(231, 76, 60, 0.3)); border-color: #E74C3C; padding: 15px;">
                            <div style="font-size: 18px; font-weight: bold;">ðŸ’° ROB THEM</div>
                            <div id="npcRobReward" style="font-size: 14px; color: #F1C40F; margin-top: 5px;">Steal: 75 Gold</div>
                            <div style="font-size: 14px; color: #95A5A6; margin-top: 3px;">No XP gained</div>
                        </button>
                        <!-- Zcash Choice: Tell about Zcash -->
                        <button class="menuButton" id="npcZcashBtn" onclick="npcChoiceZcash()" style="width: 100%; background: linear-gradient(135deg, rgba(242, 201, 76, 0.4), rgba(242, 201, 76, 0.3)); border-color: #F2C94C; padding: 15px;">
                            <div style="font-size: 18px; font-weight: bold;">ðŸ’³ TELL THEM ABOUT ZCASH</div>
                            <div style="font-size: 14px; color: #F2C94C; margin-top: 5px;">Spread the word!</div>
                            <div id="npcZcashReward" style="font-size: 14px; color: #2ECC71; margin-top: 3px;">Reward: +100 XP</div>
                        </button>
                        <!-- Neutral Choice: Ignore -->
                        <button class="menuButton" id="npcIgnoreBtn" onclick="npcChoiceIgnore()" style="width: 100%; background: linear-gradient(135deg, rgba(149, 165, 166, 0.4), rgba(149, 165, 166, 0.3)); border-color: #95A5A6; padding: 15px;">
                            <div style="font-size: 18px; font-weight: bold;">ðŸš¶ IGNORE</div>
                            <div style="font-size: 14px; color: #95A5A6; margin-top: 5px;">Walk away without interacting</div>
                        </button>
                    </div>
                    <div id="npcChoiceMade" style="display: none; text-align: center; padding: 20px; margin-top: 15px; border-radius: 10px;">
                        <div id="npcChoiceResult" style="font-size: 18px; font-weight: bold;"></div>
                    </div>
                </div>
                
                <div id="secretContent" style="display: none;">
                    <div id="secretDescription" style="color: #F1C40F; font-size: 18px; text-align: center; margin-bottom: 20px;">You found something!</div>
                    <div id="secretReward" style="text-align: center; padding: 20px; background: rgba(241, 196, 15, 0.2); border-radius: 10px; border: 2px solid #F1C40F;">
                        <div style="font-size: 48px; margin-bottom: 10px;">âœ¨</div>
                        <div id="secretRewardText" style="color: #F1C40F; font-size: 20px; font-weight: bold;">Reward!</div>
                    </div>
                </div>
                
                <!-- Exploration Event Content (max-width: 450px to match button width) -->
                <div id="explorationContent" style="display: none; max-width: 450px; margin: 0 auto;">
                    <div id="explorationDescription" style="color: #9B59B6; font-size: 18px; text-align: center; margin-bottom: 15px;">An interesting discovery...</div>
                    <div id="explorationChallenge" style="text-align: center; padding: 15px; background: rgba(155, 89, 182, 0.2); border-radius: 10px; border: 2px solid #9B59B6; margin-bottom: 20px; max-width: 450px;">
                        <div id="explorationChallengeText" style="color: #E0E0E0; font-size: 16px;">Difficulty: 1</div>
                        <div id="explorationSuccessChance" style="color: #2ECC71; font-size: 14px; margin-top: 5px;">Success Chance: 75%</div>
                    </div>
                    <div id="explorationChoices" style="display: flex; flex-direction: column; gap: 15px; align-items: center; max-width: 450px; margin: 0 auto;">
                        <!-- Send One Hero -->
                        <button class="menuButton" id="explorationSendOneBtn" onclick="explorationSendOne()" style="width: 100%; background: linear-gradient(135deg, rgba(52, 152, 219, 0.4), rgba(52, 152, 219, 0.3)); border-color: #3498DB; padding: 15px;">
                            <div style="font-size: 18px; font-weight: bold;">ðŸ§‘ SEND ONE HERO</div>
                            <div id="explorationOneXp" style="font-size: 14px; color: #2ECC71; margin-top: 5px;">Success: +100 XP (one hero)</div>
                            <div id="explorationOneFail" style="font-size: 14px; color: #E74C3C; margin-top: 3px;">Fail: -25 HP (one hero)</div>
                        </button>
                        <!-- Send Entire Party -->
                        <button class="menuButton" id="explorationSendPartyBtn" onclick="explorationSendParty()" style="width: 100%; background: linear-gradient(135deg, rgba(46, 204, 113, 0.4), rgba(46, 204, 113, 0.3)); border-color: #2ECC71; padding: 15px;">
                            <div style="font-size: 18px; font-weight: bold;">ðŸ‘¥ SEND ENTIRE PARTY</div>
                            <div id="explorationPartyXp" style="font-size: 14px; color: #2ECC71; margin-top: 5px;">Success: +200 XP (split)</div>
                            <div id="explorationPartyFail" style="font-size: 14px; color: #E74C3C; margin-top: 3px;">Fail: -15 HP (all heroes)</div>
                        </button>
                        <!-- Retreat -->
                        <button class="menuButton" id="explorationRetreatBtn" onclick="explorationRetreat()" style="width: 100%; background: linear-gradient(135deg, rgba(149, 165, 166, 0.4), rgba(149, 165, 166, 0.3)); border-color: #95A5A6; padding: 15px;">
                            <div style="font-size: 18px; font-weight: bold;">ðŸš¶ RETREAT</div>
                            <div style="font-size: 14px; color: #95A5A6; margin-top: 5px;">Leave without attempting</div>
                        </button>
                    </div>
                    <div id="explorationChoiceMade" style="display: none; text-align: center; padding: 20px; margin-top: 15px; border-radius: 10px;">
                        <div id="explorationChoiceResult" style="font-size: 18px; font-weight: bold;"></div>
                    </div>
                </div>
            </div>
            
            <!-- Leave Button -->
            <div style="margin-top: 30px;">
                <button class="menuButton" id="nonCombatLeaveBtn" onclick="leaveNonCombatRoom()" style="background: linear-gradient(135deg, rgba(231, 76, 60, 0.4), rgba(231, 76, 60, 0.3)); border-color: #E74C3C; font-size: 18px; padding: 15px 40px;">
                    <span class="icon icon-lg icon-explore"></span> LEAVE ROOM
                </button>
                <div id="nonCombatWaitingMsg" style="display: none; color: #F39C12; font-size: 14px; margin-top: 10px; text-align: center;">
                    â³ Waiting for host to leave...
                </div>
            </div>
        </div>
    </div>
    
    <!-- Zcash Video Overlay (NPC Encounter) -->
    <div id="zcashVideoOverlay" onclick="closeZcashVideo()" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.95); z-index: 400; justify-content: center; align-items: center; cursor: pointer;">
        <video id="zcashVideo" style="max-width: 90%; max-height: 90%; border-radius: 10px; box-shadow: 0 0 30px rgba(242, 201, 76, 0.5);">
            <source src="tunnelsofprivacy/videos/nate_zashi.mp4" type="video/mp4">
        </video>
        <div style="position: absolute; bottom: 20px; color: #95A5A6; font-size: 14px;">Click anywhere to skip</div>
    </div>
    
    <!-- Help Video Overlay (NPC Encounter - Good Choice) -->
    <div id="helpVideoOverlay" onclick="closeHelpVideo()" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.95); z-index: 400; justify-content: center; align-items: center; cursor: pointer;">
        <video id="helpVideo" style="max-width: 90%; max-height: 90%; border-radius: 10px; box-shadow: 0 0 30px rgba(46, 204, 113, 0.5);">
            <source src="tunnelsofprivacy/videos/zooko_cup.mp4" type="video/mp4">
        </video>
        <div style="position: absolute; bottom: 20px; color: #95A5A6; font-size: 14px;">Click anywhere to skip</div>
    </div>
    
    <!-- Exploration Video Overlay (Send One Hero / Send Party) -->
    <div id="explorationVideoOverlay" onclick="closeExplorationVideo()" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.95); z-index: 400; justify-content: center; align-items: center; cursor: pointer;">
        <video id="explorationVideo" style="max-width: 90%; max-height: 90%; border-radius: 10px; box-shadow: 0 0 30px rgba(155, 89, 182, 0.5);">
            <source id="explorationVideoSource" src="" type="video/mp4">
        </video>
        <div style="position: absolute; bottom: 20px; color: #95A5A6; font-size: 14px;">Click anywhere to skip</div>
    </div>
    
    <!-- Hero Intro Video Overlay -->
    <div id="heroIntroVideoOverlay" onclick="closeHeroIntroVideo()" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.95); z-index: 400; justify-content: center; align-items: center; cursor: pointer;">
        <video id="heroIntroVideo" style="max-width: 90%; max-height: 90%; border-radius: 10px; box-shadow: 0 0 30px rgba(139, 69, 255, 0.5);">
            <source id="heroIntroVideoSource" src="" type="video/mp4">
        </video>
        <div style="position: absolute; bottom: 20px; color: #95A5A6; font-size: 14px;">Click anywhere to close</div>
    </div>
    
    <!-- Hero Selection Modal (Multiplayer) -->
    <div id="heroSelectionModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.95); z-index: 300; pointer-events: all;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; max-width: 1000px; width: 95%;">
            <div id="heroSelectionTitle" style="color: #2A9D8F; font-size: 32px; font-weight: 900; margin-bottom: 15px; text-shadow: 0 0 20px rgba(42, 157, 143, 0.5);">SELECT YOUR HERO</div>
            
            <!-- Player Name Input -->
            <div style="margin-bottom: 15px;">
                <input type="text" id="playerNameInput" placeholder="Enter your name..." maxlength="20" style="width: 300px; padding: 10px 15px; background: rgba(0,0,0,0.7); border: 2px solid #2A9D8F; border-radius: 5px; color: #F2C94C; font-size: 16px; text-align: center; font-family: 'JetBrains Mono', monospace;" oninput="updatePlayerName()">
            </div>
            
            <!-- Room Info Bar -->
            <div style="margin-bottom: 20px; display: flex; justify-content: center; align-items: center; gap: 20px; flex-wrap: wrap;">
                <div style="background: rgba(42, 157, 143, 0.2); padding: 8px 16px; border-radius: 8px; border: 2px solid #2A9D8F;">
                    <span style="color: #89A0B4; font-size: 11px; margin-right: 8px;">ROOM:</span>
                    <span id="heroSelectionCode" style="color: #F2C94C; font-size: 18px; font-weight: bold; letter-spacing: 3px; font-family: 'JetBrains Mono', monospace;">------</span>
                    <button onclick="toggleRoomCodeVisibility()" style="background: none; border: none; color: #2A9D8F; cursor: pointer; font-size: 14px; margin-left: 8px; padding: 0;">ðŸ‘</button>
                </div>
                <div id="playerCountBox" style="background: rgba(42, 157, 143, 0.2); padding: 8px 16px; border-radius: 8px; border: 2px solid #2A9D8F;">
                    <span style="color: #89A0B4; font-size: 11px; margin-right: 8px;">PLAYERS:</span>
                    <span id="playerCountDisplay" style="color: #F2C94C; font-size: 18px; font-weight: bold;">1/4</span>
                </div>
                <div style="background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 215, 0, 0.1)); padding: 8px 16px; border-radius: 8px; border: 2px solid #FFD700;">
                    <span style="color: #89A0B4; font-size: 11px; margin-right: 8px;"><span class="icon icon-sm icon-gold"></span> GOLD:</span>
                    <span id="sel-party-gold-top" style="color: #FFD700; font-size: 18px; font-weight: bold;">0</span>
                </div>
            </div>
            
            <!-- Connected Players List -->
            <div id="connectedPlayersList" style="margin-bottom: 20px; padding: 15px; background: rgba(0,0,0,0.5); border-radius: 8px; border: 2px solid #2A9D8F; max-height: 120px; overflow-y: auto;">
                <div style="color: #89A0B4; font-size: 12px; margin-bottom: 10px; text-transform: uppercase;">Connected Players:</div>
                <div id="playersListContent" style="display: flex; flex-wrap: wrap; gap: 10px; justify-content: center;">
                    <!-- Dynamically populated -->
                </div>
            </div>
            
            <div id="heroSelectionGrid" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; margin-bottom: 20px;">
                <!-- Zooko -->
                <div class="heroSelectCard" data-hero="zooko" onclick="selectHero('zooko')" style="cursor: pointer; padding: 15px; background: linear-gradient(135deg, rgba(242, 201, 76, 0.2), rgba(242, 201, 76, 0.1)); border: 3px solid #F2C94C; border-radius: 12px; transition: all 0.3s;">
                    <div style="width: 80px; height: 80px; margin: 0 auto 10px; background-image: url('people/zooko_a_head_compressed.png'); background-size: cover; background-position: center; border-radius: 50%; border: 3px solid #F2C94C;"></div>
                    <div style="color: #F2C94C; font-size: 16px; font-weight: bold;">ZOOKO</div>
                    <div class="heroPlayerLabel" style="display: none; color: #2A9D8F;"></div>
                    <div class="heroTakenLabel" style="display: none; color: #EB5757;">TAKEN</div>
                    <div class="heroSelectStats">
                        <div class="stat-row hp-ac-row"><span class="hp-row">HP: <span id="sel-zooko-hp">22</span>/<span id="sel-zooko-maxhp">25</span></span><span class="ac-row">AC: <span id="sel-zooko-ac">12</span></span></div>
                        <div class="stat-row xp-row">XP: <span id="sel-zooko-xp">0</span> (Lv<span id="sel-zooko-level">1</span>)</div>
                        <div class="stat-row"><span class="stat-label">STR:</span><span id="sel-zooko-str">8</span> <span class="stat-label">INT:</span><span id="sel-zooko-int">15</span></div>
                        <div class="stat-row"><span class="stat-label">DEX:</span><span id="sel-zooko-dex">11</span> <span class="stat-label">WIS:</span><span id="sel-zooko-wis">13</span></div>
                        <div class="stat-row"><span class="stat-label">CON:</span><span id="sel-zooko-con">10</span> <span class="stat-label">CHA:</span><span id="sel-zooko-cha">9</span></div>
                        <button class="heroRollButton" data-hero="zooko" onclick="event.stopPropagation(); openDiceRollModal('zooko')">ðŸŽ² ROLL STATS</button>
                    </div>
                </div>
                <!-- Nate -->
                <div class="heroSelectCard" data-hero="nate" onclick="selectHero('nate')" style="cursor: pointer; padding: 15px; background: linear-gradient(135deg, rgba(231, 76, 60, 0.2), rgba(231, 76, 60, 0.1)); border: 3px solid #E74C3C; border-radius: 12px; transition: all 0.3s;">
                    <div style="width: 80px; height: 80px; margin: 0 auto 10px; background-image: url('people/Nate_a_head_compressed.png'); background-size: cover; background-position: center; border-radius: 50%; border: 3px solid #E74C3C;"></div>
                    <div style="color: #E74C3C; font-size: 16px; font-weight: bold;">NATE</div>
                    <div class="heroPlayerLabel" style="display: none; color: #2A9D8F;"></div>
                    <div class="heroTakenLabel" style="display: none; color: #EB5757;">TAKEN</div>
                    <div class="heroSelectStats">
                        <div class="stat-row hp-ac-row"><span class="hp-row">HP: <span id="sel-nate-hp">28</span>/<span id="sel-nate-maxhp">30</span></span><span class="ac-row">AC: <span id="sel-nate-ac">14</span></span></div>
                        <div class="stat-row xp-row">XP: <span id="sel-nate-xp">0</span> (Lv<span id="sel-nate-level">1</span>)</div>
                        <div class="stat-row"><span class="stat-label">STR:</span><span id="sel-nate-str">14</span> <span class="stat-label">INT:</span><span id="sel-nate-int">10</span></div>
                        <div class="stat-row"><span class="stat-label">DEX:</span><span id="sel-nate-dex">12</span> <span class="stat-label">WIS:</span><span id="sel-nate-wis">9</span></div>
                        <div class="stat-row"><span class="stat-label">CON:</span><span id="sel-nate-con">13</span> <span class="stat-label">CHA:</span><span id="sel-nate-cha">11</span></div>
                        <button class="heroRollButton" data-hero="nate" onclick="event.stopPropagation(); openDiceRollModal('nate')">ðŸŽ² ROLL STATS</button>
                    </div>
                </div>
                <!-- Zancas -->
                <div class="heroSelectCard" data-hero="zancas" onclick="selectHero('zancas')" style="cursor: pointer; padding: 15px; background: linear-gradient(135deg, rgba(39, 174, 96, 0.2), rgba(39, 174, 96, 0.1)); border: 3px solid #27AE60; border-radius: 12px; transition: all 0.3s;">
                    <div style="width: 80px; height: 80px; margin: 0 auto 10px; background-image: url('people/Zancas_a_head_compressed.png'); background-size: cover; background-position: center; border-radius: 50%; border: 3px solid #27AE60;"></div>
                    <div style="color: #27AE60; font-size: 16px; font-weight: bold;">ZANCAS</div>
                    <div class="heroPlayerLabel" style="display: none; color: #2A9D8F;"></div>
                    <div class="heroTakenLabel" style="display: none; color: #EB5757;">TAKEN</div>
                    <div class="heroSelectStats">
                        <div class="stat-row hp-ac-row"><span class="hp-row">HP: <span id="sel-zancas-hp">24</span>/<span id="sel-zancas-maxhp">26</span></span><span class="ac-row">AC: <span id="sel-zancas-ac">13</span></span></div>
                        <div class="stat-row xp-row">XP: <span id="sel-zancas-xp">0</span> (Lv<span id="sel-zancas-level">1</span>)</div>
                        <div class="stat-row"><span class="stat-label">STR:</span><span id="sel-zancas-str">10</span> <span class="stat-label">INT:</span><span id="sel-zancas-int">12</span></div>
                        <div class="stat-row"><span class="stat-label">DEX:</span><span id="sel-zancas-dex">15</span> <span class="stat-label">WIS:</span><span id="sel-zancas-wis">14</span></div>
                        <div class="stat-row"><span class="stat-label">CON:</span><span id="sel-zancas-con">11</span> <span class="stat-label">CHA:</span><span id="sel-zancas-cha">8</span></div>
                        <button class="heroRollButton" data-hero="zancas" onclick="event.stopPropagation(); openDiceRollModal('zancas')">ðŸŽ² ROLL STATS</button>
                    </div>
                </div>
                <!-- CyberAxe -->
                <div class="heroSelectCard" data-hero="cyberaxe" onclick="selectHero('cyberaxe')" style="cursor: pointer; padding: 15px; background: linear-gradient(135deg, rgba(46, 134, 222, 0.2), rgba(46, 134, 222, 0.1)); border: 3px solid #2E86DE; border-radius: 12px; transition: all 0.3s;">
                    <div style="width: 80px; height: 80px; margin: 0 auto 10px; background-image: url('people/cyberaxe_a_head_compressed.png'); background-size: cover; background-position: center; border-radius: 50%; border: 3px solid #2E86DE;"></div>
                    <div style="color: #2E86DE; font-size: 16px; font-weight: bold;">CYBERAXE</div>
                    <div class="heroPlayerLabel" style="display: none; color: #2A9D8F;"></div>
                    <div class="heroTakenLabel" style="display: none; color: #EB5757;">TAKEN</div>
                    <div class="heroSelectStats">
                        <div class="stat-row hp-ac-row"><span class="hp-row">HP: <span id="sel-cyberaxe-hp">32</span>/<span id="sel-cyberaxe-maxhp">35</span></span><span class="ac-row">AC: <span id="sel-cyberaxe-ac">15</span></span></div>
                        <div class="stat-row xp-row">XP: <span id="sel-cyberaxe-xp">0</span> (Lv<span id="sel-cyberaxe-level">1</span>)</div>
                        <div class="stat-row"><span class="stat-label">STR:</span><span id="sel-cyberaxe-str">16</span> <span class="stat-label">INT:</span><span id="sel-cyberaxe-int">8</span></div>
                        <div class="stat-row"><span class="stat-label">DEX:</span><span id="sel-cyberaxe-dex">10</span> <span class="stat-label">WIS:</span><span id="sel-cyberaxe-wis">11</span></div>
                        <div class="stat-row"><span class="stat-label">CON:</span><span id="sel-cyberaxe-con">14</span> <span class="stat-label">CHA:</span><span id="sel-cyberaxe-cha">10</span></div>
                        <button class="heroRollButton" data-hero="cyberaxe" onclick="event.stopPropagation(); openDiceRollModal('cyberaxe')">ðŸŽ² ROLL STATS</button>
                    </div>
                </div>
            </div>
            <div id="heroWaitingMessage" style="color: #89A0B4; font-size: 14px; margin-bottom: 15px;">Click heroes to select. Players can select multiple heroes.</div>
            <div id="reconnectOptions" style="display: none; margin-bottom: 15px;">
                <div style="color: #2A9D8F; font-size: 16px; margin-bottom: 15px; font-weight: bold;">ðŸ”„ Reconnecting to Game in Progress</div>
                <div style="display: flex; flex-direction: column; gap: 10px; max-width: 400px; margin: 0 auto;">
                    <button class="menuButton" onclick="rejoinGame()" style="padding: 15px; font-size: 14px; background: linear-gradient(135deg, rgba(42, 157, 143, 0.4), rgba(42, 157, 143, 0.3)); border-color: #2A9D8F;">REJOIN GAME</button>
                    <div style="color: #89A0B4; font-size: 12px; font-style: italic; margin-top: 5px;">Select your heroes above, then click to rejoin</div>
                </div>
            </div>
            <div id="gameStartOptions" style="display: none; margin-bottom: 15px;">
                <div id="gameStartPhase1" style="display: block;">
                    <div style="color: #F2C94C; font-size: 14px; margin-bottom: 10px; font-weight: bold;">All heroes selected!</div>
                    <div style="display: flex; gap: 8px; justify-content: center;">
                        <button onclick="cancelHeroSelection()" style="width: 110px; padding: 10px 0; font-size: 12px; background: linear-gradient(135deg, rgba(235, 87, 87, 0.5), rgba(235, 87, 87, 0.3)); border: 2px solid #EB5757; border-radius: 6px; color: #fff; cursor: pointer; font-family: 'Inter', sans-serif; font-weight: 600;">BACK</button>
                        <button onclick="continueGame()" style="width: 110px; padding: 10px 0; font-size: 12px; background: linear-gradient(135deg, rgba(42, 157, 143, 0.5), rgba(42, 157, 143, 0.3)); border: 2px solid #2A9D8F; border-radius: 6px; color: #fff; cursor: pointer; font-family: 'Inter', sans-serif; font-weight: 600;">CONTINUE</button>
                        <button onclick="loadSaveGame()" style="width: 110px; padding: 10px 0; font-size: 12px; background: linear-gradient(135deg, rgba(46, 134, 222, 0.5), rgba(46, 134, 222, 0.3)); border: 2px solid #2E86DE; border-radius: 6px; color: #fff; cursor: pointer; font-family: 'Inter', sans-serif; font-weight: 600;">LOAD SAVE</button>
                        <button onclick="enterRollPhase()" style="width: 110px; padding: 10px 0; font-size: 12px; background: linear-gradient(135deg, rgba(242, 201, 76, 0.5), rgba(242, 201, 76, 0.3)); border: 2px solid #F2C94C; border-radius: 6px; color: #fff; cursor: pointer; font-family: 'Inter', sans-serif; font-weight: 600;">NEW GAME</button>
                    </div>
                    <div style="color: #EB5757; font-size: 10px; font-style: italic; margin-top: 6px;">âš  NEW GAME replaces local save</div>
                </div>
                <div id="gameStartPhase2" style="display: none;">
                    <div style="color: #F2C94C; font-size: 14px; margin-bottom: 6px; font-weight: bold;">ðŸŽ² ROLL YOUR STATS!</div>
                    <div id="rollPhaseStatus" style="color: #89A0B4; font-size: 12px; margin-bottom: 10px;">Waiting for all players to roll stats...</div>
                    <div style="display: flex; gap: 8px; justify-content: center;">
                        <button onclick="cancelRollPhase()" style="width: 110px; padding: 10px 0; font-size: 12px; background: linear-gradient(135deg, rgba(235, 87, 87, 0.5), rgba(235, 87, 87, 0.3)); border: 2px solid #EB5757; border-radius: 6px; color: #fff; cursor: pointer; font-family: 'Inter', sans-serif; font-weight: 600;">BACK</button>
                        <button id="launchGameBtn" onclick="launchNewGame()" disabled style="width: 130px; padding: 10px 0; font-size: 12px; background: linear-gradient(135deg, rgba(39, 174, 96, 0.3), rgba(39, 174, 96, 0.2)); border: 2px solid #27AE60; border-radius: 6px; color: #666; cursor: not-allowed; font-family: 'Inter', sans-serif; font-weight: 600;">ðŸš€ LAUNCH GAME</button>
                    </div>
                </div>
            </div>
            <div id="heroSelectionBackBtn" style="display: flex; gap: 15px; justify-content: center;">
                <button onclick="cancelHeroSelection()" style="width: 110px; padding: 10px 0; font-size: 12px; background: linear-gradient(135deg, rgba(235, 87, 87, 0.5), rgba(235, 87, 87, 0.3)); border: 2px solid #EB5757; border-radius: 6px; color: #fff; cursor: pointer; font-family: 'Inter', sans-serif; font-weight: 600;">BACK</button>
            </div>
        </div>
    </div>
    
    <!-- Dice Roll Modal -->
    <div id="diceRollModal">
        <div class="diceRollContainer">
            <div class="diceRollTitle">ðŸŽ² ROLL STATS FOR <span id="diceRollHeroName">HERO</span></div>
            
            <div id="diceStatRows">
                <!-- STR -->
                <div class="diceStatRow" data-stat="str">
                    <div class="diceStatName">STR</div>
                    <div class="diceGroup">
                        <div class="die" data-die="1">-</div>
                        <div class="die" data-die="2">-</div>
                        <div class="die" data-die="3">-</div>
                    </div>
                    <div class="diceStatTotal">-</div>
                </div>
                <!-- DEX -->
                <div class="diceStatRow" data-stat="dex">
                    <div class="diceStatName">DEX</div>
                    <div class="diceGroup">
                        <div class="die" data-die="1">-</div>
                        <div class="die" data-die="2">-</div>
                        <div class="die" data-die="3">-</div>
                    </div>
                    <div class="diceStatTotal">-</div>
                </div>
                <!-- CON -->
                <div class="diceStatRow" data-stat="con">
                    <div class="diceStatName">CON</div>
                    <div class="diceGroup">
                        <div class="die" data-die="1">-</div>
                        <div class="die" data-die="2">-</div>
                        <div class="die" data-die="3">-</div>
                    </div>
                    <div class="diceStatTotal">-</div>
                </div>
                <!-- INT -->
                <div class="diceStatRow" data-stat="int">
                    <div class="diceStatName">INT</div>
                    <div class="diceGroup">
                        <div class="die" data-die="1">-</div>
                        <div class="die" data-die="2">-</div>
                        <div class="die" data-die="3">-</div>
                    </div>
                    <div class="diceStatTotal">-</div>
                </div>
                <!-- WIS -->
                <div class="diceStatRow" data-stat="wis">
                    <div class="diceStatName">WIS</div>
                    <div class="diceGroup">
                        <div class="die" data-die="1">-</div>
                        <div class="die" data-die="2">-</div>
                        <div class="die" data-die="3">-</div>
                    </div>
                    <div class="diceStatTotal">-</div>
                </div>
                <!-- CHA -->
                <div class="diceStatRow" data-stat="cha">
                    <div class="diceStatName">CHA</div>
                    <div class="diceGroup">
                        <div class="die" data-die="1">-</div>
                        <div class="die" data-die="2">-</div>
                        <div class="die" data-die="3">-</div>
                    </div>
                    <div class="diceStatTotal">-</div>
                </div>
            </div>
            
            <div class="derivedStats">
                <span><span class="hp-value">HP: <span id="diceRollHP">-</span></span></span>
                <span><span class="ac-value">AC: <span id="diceRollAC">-</span></span></span>
                <span style="color: #F2C94C; font-weight: bold;">TOTAL: <span id="diceRollTotal">-</span>/108</span>
            </div>
            
            <div class="diceRollActions">
                <button class="diceRollBtn cancel" onclick="closeDiceRollModal()">CANCEL</button>
                <button class="diceRollBtn roll" onclick="rollAllDice()">ðŸŽ² ROLL</button>
                <button class="diceRollBtn accept" onclick="acceptRolledStats()">âœ“ ACCEPT</button>
            </div>
        </div>
    </div>
    
    <!-- Host Controls Panel -->
    <div id="hostControlsPanel" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9)); border: 2px solid #2A9D8F; border-radius: 12px; padding: 25px; max-width: 500px; width: 85vw; z-index: 300; pointer-events: all; box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8); backdrop-filter: blur(10px);">
        <div class="panelTitle" style="color: #2A9D8F;">ðŸŽ® HOST CONTROLS</div>
        <div id="playerList" style="margin: 20px 0; max-height: 300px; overflow-y: auto;">
            <!-- Dynamically populated -->
        </div>
        <div style="display: flex; gap: 10px; margin-top: 20px;">
            <button class="menuButton" onclick="changeRoomCodeFromPanel()" style="flex: 1; padding: 10px; font-size: 13px;">CHANGE CODE</button>
            <button class="menuButton" onclick="closeHostControls()" style="flex: 1; padding: 10px; font-size: 13px; background: linear-gradient(135deg, rgba(235, 87, 87, 0.4), rgba(235, 87, 87, 0.3)); border-color: #EB5757;">CLOSE</button>
        </div>
    </div>
    
    <!-- Confirmation Modal -->
    <div id="confirmationModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); z-index: 400; pointer-events: all;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; background: linear-gradient(135deg, rgba(26, 26, 46, 0.95), rgba(13, 13, 26, 0.95)); border: 3px solid #F2C94C; border-radius: 15px; padding: 40px 60px; box-shadow: 0 10px 50px rgba(0, 0, 0, 0.9);">
            <div id="confirmationTitle" style="color: #F2C94C; font-size: 28px; font-weight: 900; margin-bottom: 20px; text-shadow: 0 0 15px rgba(242, 201, 76, 0.5); text-transform: uppercase; letter-spacing: 2px;">CONFIRM ACTION</div>
            <div id="confirmationMessage" style="color: #89A0B4; font-size: 16px; margin-bottom: 30px; line-height: 1.5;">Are you sure?</div>
            <div style="display: flex; gap: 20px; justify-content: center;">
                <button onclick="confirmModalAction(false)" style="padding: 12px 30px; font-size: 16px; font-weight: bold; background: linear-gradient(135deg, rgba(231, 76, 60, 0.4), rgba(192, 57, 43, 0.4)); border: 2px solid #E74C3C; border-radius: 8px; color: #FFFFFF; cursor: pointer; text-transform: uppercase; letter-spacing: 1px; transition: all 0.2s;">CANCEL</button>
                <button onclick="confirmModalAction(true)" style="padding: 12px 30px; font-size: 16px; font-weight: bold; background: linear-gradient(135deg, rgba(46, 204, 113, 0.4), rgba(39, 174, 96, 0.4)); border: 2px solid #27AE60; border-radius: 8px; color: #FFFFFF; cursor: pointer; text-transform: uppercase; letter-spacing: 1px; transition: all 0.2s;">YES</button>
            </div>
        </div>
    </div>
    
    <!-- Overlay for modal panels -->
    <div id="overlay" onclick="closeAllPanels()"></div>
    
    <!-- Party Inventory Panel -->
    <div id="inventoryPanel">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <div style="color: #2D9CDB; font-size: 20px; font-weight: 900; text-shadow: 0 0 15px rgba(45, 156, 219, 0.5);"><span class="icon icon-lg icon-loot"></span> PARTY INVENTORY</div>
            <button onclick="closeInventory()" style="background: rgba(255,100,100,0.3); border: 2px solid #ff6b6b; border-radius: 50%; width: 28px; height: 28px; color: #ff6b6b; font-size: 16px; cursor: pointer; font-weight: bold;">âœ•</button>
        </div>
        
        <!-- Hero Legend -->
        <div style="display: flex; gap: 12px; justify-content: center; margin-bottom: 10px; font-size: 11px; font-family: 'JetBrains Mono', monospace;">
            <span style="color: #F2C94C;">â— Zooko</span>
            <span style="color: #E74C3C;">â— Nate</span>
            <span style="color: #27AE60;">â— Zancas</span>
            <span style="color: #2E86DE;">â— CyberAxe</span>
        </div>
        
        <!-- Inventory Grid (6x6 = 36 cells) -->
        <div id="inventoryGrid"></div>
        
        <!-- Level Progress -->
        <div id="inventoryLevelProgress">
            <span style="color: #BFD1E0;">Party Level: <span style="color: #F2C94C; font-weight: bold;">1</span></span>
            <span style="color: #5A7A8F; font-size: 11px;">Slots: 16/36 â€¢ Next +2 at Lv10</span>
        </div>
    </div>
    
    <!-- Settings Panel -->
    <div id="settingsPanel">
        <button class="panelCloseBtn" onclick="closeAllPanels()">âœ•</button>
        <div class="panelTitle" style="color: #2A9D8F; text-shadow: 0 0 20px rgba(42, 157, 143, 0.5);">âš™ï¸ SETTINGS</div>
        
        <div class="settingsGrid">
            <!-- Audio Section -->
            <div class="settingsSection">
                <div class="settingsSectionTitle">ðŸ”Š Audio</div>
                
                <div class="settingsRow">
                    <span class="settingsLabel">Music Enabled</span>
                    <input type="checkbox" id="musicEnabled" class="settingsCheckbox" checked onchange="updateSettings()">
                </div>
                
                <div class="settingsRow">
                    <span class="settingsLabel">Music Volume</span>
                    <div class="settingsSliderGroup">
                        <input type="range" id="musicVolume" class="settingsSlider" min="1" max="150" value="40" oninput="updateSettings()">
                        <span id="musicVolumeValue" class="settingsSliderValue" style="color: #2D9CDB;">40</span>
                    </div>
                </div>
                
                <div class="settingsRow">
                    <span class="settingsLabel">Background Sound</span>
                    <div class="settingsSliderGroup">
                        <input type="range" id="bgSoundVolume" class="settingsSlider" min="0" max="100" value="25" oninput="updateSettings()">
                        <span id="bgSoundVolumeValue" class="settingsSliderValue" style="color: #27AE60;">25</span>
                    </div>
                </div>
                
                <div class="settingsRow">
                    <span class="settingsLabel">Voice Volume</span>
                    <div class="settingsSliderGroup">
                        <input type="range" id="voiceVolume" class="settingsSlider" min="0" max="100" value="90" oninput="updateSettings()">
                        <span id="voiceVolumeValue" class="settingsSliderValue" style="color: #9B59B6;">90</span>
                    </div>
                </div>
                
                <div class="settingsRow">
                    <span class="settingsLabel">SFX Volume</span>
                    <div class="settingsSliderGroup">
                        <input type="range" id="sfxVolume" class="settingsSlider" min="0" max="100" value="50" oninput="updateSettings()">
                        <span id="sfxVolumeValue" class="settingsSliderValue" style="color: #E67E22;">50</span>
                    </div>
                </div>
            </div>
            
            <!-- Music Types Section -->
            <div class="settingsSection">
                <div class="settingsSectionTitle">ðŸŽµ Music Types</div>
                
                <div class="settingsRow">
                    <span class="settingsLabel">Theme Songs<span class="settingsHint">Zcash themes</span></span>
                    <input type="checkbox" id="themeMusicEnabled" class="settingsCheckbox" checked onchange="updateSettings()">
                </div>
                
                <div class="settingsRow">
                    <span class="settingsLabel">Zone Music<span class="settingsHint">Changes per dungeon</span></span>
                    <input type="checkbox" id="zoneMusicEnabled" class="settingsCheckbox" checked onchange="updateSettings()">
                </div>
            </div>
            
            <!-- AI Settings Section -->
            <div class="settingsSection">
                <div class="settingsSectionTitle">ðŸ¤– AI Settings</div>
                
                <div class="settingsRow">
                    <span class="settingsLabel">NPC Free Will Chat<span class="settingsHint">Auto chat</span></span>
                    <input type="checkbox" id="llmFreeWill" class="settingsCheckbox" onchange="updateSettings()">
                </div>
                
                <div class="settingsRow">
                    <span class="settingsLabel">Use Paid LLM<span class="settingsHint">Better quality</span></span>
                    <input type="checkbox" id="llmUsePaid" class="settingsCheckbox" onchange="updateSettings()">
                </div>
                
                <div class="settingsRow">
                    <span class="settingsLabel">Roleplay Mode<span class="settingsHint">*emotes*</span></span>
                    <input type="checkbox" id="rpMode" class="settingsCheckbox" onchange="updateSettings()" checked>
                </div>
            </div>
            
            <!-- Debug Section -->
            <div class="settingsSection">
                <div class="settingsSectionTitle">ðŸ”§ Debug</div>
                
                <div class="settingsRow">
                    <span class="settingsLabel">Show Hitboxes</span>
                    <input type="checkbox" id="showHitboxes" class="settingsCheckbox" onchange="updateSettings()">
                </div>
                
                <div class="settingsRow">
                    <span class="settingsLabel">Network Debug</span>
                    <input type="checkbox" id="networkDebug" class="settingsCheckbox" onchange="toggleNetworkDebug()">
                </div>
                
                <div class="settingsRow">
                    <span class="settingsLabel">Diag Mode<span class="settingsHint" style="color: #EB5757;">5 HP enemies</span></span>
                    <input type="checkbox" id="diagMode" class="settingsCheckbox" onchange="updateSettings()">
                </div>
            </div>
        </div>
        
        <div style="margin-top: 15px; padding: 10px; background: rgba(42, 157, 143, 0.1); border-radius: 8px; font-size: 11px; color: #89A0B4; text-align: center;">
            ðŸ’¡ Settings are saved independently for Tunnels of Privacy
        </div>
        
        <div class="settingsFooter">
            <button class="menuButton" onclick="clearCache()" style="padding: 10px; font-size: 13px; background: linear-gradient(135deg, rgba(235, 87, 87, 0.4), rgba(235, 87, 87, 0.3)); border-color: #EB5757;">CLEAR CACHE <span style="display: inline-block; width: 22px; height: 22px; background: #EB5757; border-radius: 50%; text-align: center; line-height: 22px; margin-left: 8px; font-weight: bold; color: white; font-size: 12px;">X</span></button>
            <button class="menuButton" onclick="closeAllPanels()" style="padding: 10px; font-size: 13px;">CLOSE <span style="display: inline-block; width: 22px; height: 22px; background: #E74C3C; border-radius: 50%; text-align: center; line-height: 22px; margin-left: 8px; font-weight: bold; color: white; font-size: 12px;">B</span></button>
        </div>
        
        <div style="display: block; width: 100%; margin-top: 12px; text-align: center; font-family: 'JetBrains Mono', monospace; font-size: 10px; color: #5A7A8F;">
            Tunnels of Privacy v0.3.90
        </div>
    </div>
    
    <!-- About/Donate Panel -->
    <div id="aboutPanel" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9)); border: 2px solid #2D9CDB; border-radius: 12px; padding: 25px; max-width: 500px; width: 85vw; z-index: 200; pointer-events: all; box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8); backdrop-filter: blur(10px);">
        <div class="panelTitle">ABOUT / DONATE</div>
        <div style="font-family: 'Inter', sans-serif; color: #D4E3F0; line-height: 1.8; text-align: center;">
            <div style="margin-bottom: 25px;">
                <div style="font-size: 18px; font-weight: 700; color: #F2C94C; margin-bottom: 10px;">Created by CyberAxe</div>
                <div style="font-size: 16px; margin-bottom: 5px;">
                    <a href="https://www.OutlandishlyCrafted.com" target="_blank" style="color: #2D9CDB; text-decoration: none; font-weight: 600;">www.OutlandishlyCrafted.com</a>
                </div>
            </div>
            
            <div style="margin-bottom: 25px; padding-top: 20px; border-top: 2px solid #26313B;">
                <div style="font-size: 16px; font-weight: 700; color: #27AE60; margin-bottom: 10px;">Report Bugs & Get Support</div>
                <div style="font-size: 14px;">
                    <a href="https://github.com/Jbenisek/ZLOCK-ZHAINER" target="_blank" style="color: #2D9CDB; text-decoration: none; font-weight: 600;">github.com/Jbenisek/ZLOCK-ZHAINER</a>
                </div>
            </div>
            
            <div style="margin-bottom: 20px; padding-top: 20px; border-top: 2px solid #26313B;">
                <div style="font-size: 18px; font-weight: 700; color: #EB5757; margin-bottom: 15px;">Donate and Support</div>
                <div style="font-size: 11px; font-family: 'JetBrains Mono', monospace; background: rgba(0, 0, 0, 0.3); padding: 12px; border-radius: 8px; word-break: break-all; color: #F2C94C; margin-bottom: 15px;">
                    u1gvnthgukm0ecnan3tgj3h6pdhrmmv8zyqx8ayup9yg9er4t5l7nesas6leavc4x3rsj98n65nn2w3ekzur9yejadlmv7k4vjgu8kp58q
                </div>
                <div>
                    <img src="items/CyberAxeZcashWalletQR.PNG" alt="Zcash Donation QR Code" style="max-width: 200px; border: 2px solid #26313B; border-radius: 8px; background: white; padding: 10px;">
                </div>
            </div>
        </div>
        <button class="menuButton" onclick="closeAllPanels()" style="width: 100%; margin-top: 20px;">CLOSE<span style="display: inline-block; width: 26px; height: 26px; background: #E74C3C; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">B</span></button>
    </div>
    
    <!-- Confirmation Dialog Panel -->
    <div id="confirmDialog" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, rgba(10, 14, 18, 0.98), rgba(20, 27, 34, 0.95)); border: 3px solid #EB5757; border-radius: 12px; padding: 30px; max-width: 450px; width: 85vw; z-index: 1200; pointer-events: all; box-shadow: 0 10px 50px rgba(0, 0, 0, 0.9), 0 0 30px rgba(235, 87, 87, 0.3); backdrop-filter: blur(15px);">
        <div style="text-align: center;">
            <div style="font-size: 48px; margin-bottom: 15px;">âš ï¸</div>
            <div class="panelTitle" style="color: #EB5757; margin-bottom: 15px;" id="confirmDialogTitle">CONFIRM ACTION</div>
            <div style="font-family: 'Inter', sans-serif; color: #D4E3F0; font-size: 16px; line-height: 1.6; margin-bottom: 25px;" id="confirmDialogMessage">
                Are you sure you want to proceed?
            </div>
            <div style="display: flex; gap: 15px; justify-content: center;">
                <button class="menuButton" id="confirmDialogYes" style="flex: 1; background: linear-gradient(135deg, rgba(235, 87, 87, 0.4), rgba(180, 60, 60, 0.4)); border-color: #EB5757;">
                    YES, DELETE
                </button>
                <button class="menuButton" id="confirmDialogNo" style="flex: 1; background: linear-gradient(135deg, rgba(39, 174, 96, 0.4), rgba(30, 130, 70, 0.4)); border-color: #27AE60;">
                    CANCEL
                </button>
            </div>
        </div>
    </div>
    
    <!-- Info Dialog Panel (replaces alert) -->
    <div id="infoDialog" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, rgba(10, 14, 18, 0.98), rgba(20, 27, 34, 0.95)); border: 3px solid #27AE60; border-radius: 12px; padding: 30px; max-width: 450px; width: 85vw; z-index: 1200; pointer-events: all; box-shadow: 0 10px 50px rgba(0, 0, 0, 0.9), 0 0 30px rgba(39, 174, 96, 0.3); backdrop-filter: blur(15px);">
        <div style="text-align: center;">
            <div style="font-size: 48px; margin-bottom: 15px;" id="infoDialogIcon">âœ…</div>
            <div class="panelTitle" style="color: #27AE60; margin-bottom: 15px;" id="infoDialogTitle">SUCCESS</div>
            <div style="font-family: 'Inter', sans-serif; color: #D4E3F0; font-size: 16px; line-height: 1.6; margin-bottom: 25px;" id="infoDialogMessage">
                Operation completed successfully.
            </div>
            <button class="menuButton" id="infoDialogOk" style="width: 100%;">
                OK
            </button>
        </div>
    </div>
    
    <!-- Load Save Panel -->
    <div id="loadSavePanel" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9)); border: 2px solid #3498DB; border-radius: 12px; padding: 25px; max-width: 600px; width: 85vw; z-index: 200; pointer-events: all; box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8); backdrop-filter: blur(10px);">
        <div class="panelTitle" style="color: #3498DB;">LOAD SAVE FILE</div>
        
        <div style="margin: 15px 0; padding: 15px; background: rgba(52, 152, 219, 0.1); border-radius: 8px; border: 1px solid rgba(52, 152, 219, 0.3);">
            <div style="color: #BFD1E0; font-family: 'JetBrains Mono', monospace; font-size: 12px; margin-bottom: 10px;">
                ðŸ“¥ Import save file from arcade game or previous dungeon run
            </div>
            <input type="file" id="saveFileInput" accept=".json" style="display: block; width: 100%; padding: 10px; background: rgba(10, 14, 18, 0.8); border: 2px solid #3498DB; border-radius: 6px; color: #E9F0F7; font-family: 'JetBrains Mono', monospace; font-size: 12px; cursor: pointer; margin-bottom: 10px;">
            <button class="menuButton" onclick="loadSaveFile()" style="width: 100%; margin: 0;">LOAD FILE<span style="display: inline-block; width: 26px; height: 26px; background: #27AE60; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">A</span></button>
        </div>
        
        <div style="margin: 15px 0; padding: 10px; background: rgba(241, 196, 15, 0.1); border-radius: 5px; font-size: 11px; color: #89A0B4;">
            ðŸ’¡ You can export save files from the arcade game's settings menu. This allows you to continue your adventure with the same hero stats and progress.
        </div>
        
        <button class="menuButton" onclick="closeAllPanels()" style="margin-top: 15px; width: 100%; padding: 12px; font-size: 14px;">CLOSE<span style="display: inline-block; width: 26px; height: 26px; background: #E74C3C; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">B</span></button>
    </div>

    <script>
        // Portal System - localStorage keys with "top_" prefix
        const STORAGE_KEYS = {
            SETTINGS: 'top_tunnels_settings',
            SHARED_SAVE: 'top_shared_save'
        };
        
        const GAME_VERSION = 'v0.4.08';
        
        // ===== HACKATHON INFO TOOLTIP SYSTEM =====
        const TOOLTIP_DELAY = 800; // ms before tooltip appears
        const TOOLTIP_SLIDE_INTERVAL = 6000; // ms between slides
        let tooltipTimeout = null;
        let tooltipSlideInterval = null;
        let currentTooltipElement = null;
        let currentTooltipId = null;
        let currentSlideIndex = 0;
        
        // Tooltip definitions - each tooltip has multiple slides (Zcash/Lore first, then AI/Tech)
        const TOOLTIP_DATA = {
            // Battle Actions
            'exploreLevelBtn': {
                slides: [
                    {
                        icon: 'ðŸ’›',
                        title: 'Privacy-First Exploration',
                        body: 'The <strong>Tunnels of Privacy</strong> are ancient passages where personal data is protected. Each level represents the fight against surveillance and data harvesting in a world where privacy is treasure.',
                        tags: ['zcash'],
                        footer: 'Zcash: Privacy is a human right'
                    },
                    {
                        icon: 'ðŸ¤–',
                        title: 'AI-Powered Encounters',
                        body: 'Uses <strong>LLM (Large Language Model)</strong> to pre-generate unique encounters. Boss names, stats, personalities, and dialogue are all AI-created in real-time.<br><br>ðŸ”Œ <strong>API:</strong> OpenRouter + Groq<br>ðŸŽ¯ <strong>9 Models</strong> to choose from',
                        tags: ['ai', 'paid'],
                        footer: 'OpenRouter & Groq APIs â€¢ 9 models available'
                    }
                ]
            },
            'battleTalkBtn': {
                slides: [
                    {
                        icon: 'ðŸ’›',
                        title: 'Negotiate for Privacy',
                        body: 'Some enemies can be <strong>reasoned with or bribed</strong>. In the Zcash universe, not every conflict requires violence - sometimes privacy can be bought, traded, or persuaded.',
                        tags: ['zcash'],
                        footer: 'Diplomacy: A tool for the wise adventurer'
                    },
                    {
                        icon: 'ðŸ—£ï¸',
                        title: 'Local Text-to-Speech',
                        body: 'Uses <strong>Piper TTS</strong> - a completely FREE, locally-hosted neural text-to-speech engine. No cloud API needed! Voices run 100% on your machine.',
                        tags: ['ai', 'free', 'local'],
                        footer: 'Free feature: Piper TTS auto-installs on first use'
                    }
                ]
            },
            'battleHeavyBtn': {
                slides: [
                    {
                        icon: 'âš”ï¸',
                        title: 'Fight for Freedom',
                        body: 'Heavy attacks represent the <strong>direct action</strong> needed to protect privacy. Sometimes you must fight surveillance head-on with overwhelming force.',
                        tags: ['free'],
                        footer: 'Privacy worth fighting for'
                    },
                    {
                        icon: 'ðŸŽ²',
                        title: 'D&D Combat System',
                        body: 'Full <strong>D&D 5e-style</strong> dice rolling: d20 for attack rolls vs AC, damage dice (1d6/2d6/3d6), stat modifiers. All combat math follows tabletop RPG rules.',
                        tags: ['free'],
                        footer: 'Real dice mechanics with critical hits and misses'
                    }
                ]
            },
            'battleSpecialBtn': {
                slides: [
                    {
                        icon: 'ðŸ’›',
                        title: 'Zero-Knowledge Powers',
                        body: 'Each hero\'s special ability is inspired by <strong>cryptographic concepts</strong>. Zooko\'s shield (encryption), Nate\'s fury (brute force), Zancas\'s precision (targeted proofs), CyberAxe\'s storm (distributed attack).',
                        tags: ['zcash'],
                        footer: 'Crypto-powered heroes!'
                    },
                    {
                        icon: 'âœ¨',
                        title: 'AI Particle Effects',
                        body: 'Each hero has unique special attacks with <strong>AI-generated particle effects</strong> created using a custom particle editor tool.',
                        tags: ['ai', 'free'],
                        footer: 'Effects created with particle_editor.html'
                    }
                ]
            },
            // Dungeon Menu
            'dungeonMastersBtn': {
                slides: [
                    {
                        icon: 'ðŸŽ²',
                        title: 'Dungeon Master',
                        body: 'Like a tabletop RPG <strong>Game Master</strong>, the host controls the adventure. Choose difficulty, navigate levels, and guide your party through the Tunnels of Privacy.',
                        tags: ['free'],
                        footer: 'Host = Dungeon Master'
                    },
                    {
                        icon: 'ðŸ‘¥',
                        title: 'WebSocket Multiplayer',
                        body: 'Host-only panel for <strong>level navigation</strong> and <strong>difficulty settings</strong>. Clients see updates in real-time via WebSocket sync.',
                        tags: ['multiplayer', 'free'],
                        footer: 'Real-time sync for all players'
                    }
                ]
            },
            'diffCasualBtn': {
                slides: [
                    {
                        icon: 'ðŸŒ¼',
                        title: 'Casual Mode',
                        body: 'For those new to privacy advocacy - <strong>easier enemies</strong> let you learn the ropes while enjoying the story and Zcash lore.',
                        tags: ['free'],
                        footer: 'Everyone deserves privacy education'
                    },
                    {
                        icon: 'ðŸ“Š',
                        title: 'Dynamic Difficulty',
                        body: 'Loads different <strong>boss stat JSON files</strong> based on difficulty. Casual has lower boss HP, damage, and ability modifiers.',
                        tags: ['free'],
                        footer: 'Boss data: bosses_data_easy.json'
                    }
                ]
            },
            'diffNormalBtn': {
                slides: [
                    {
                        icon: 'âš”ï¸',
                        title: 'Normal Mode',
                        body: 'The standard challenge - <strong>balanced difficulty</strong> for experienced privacy advocates ready to defend their data.',
                        tags: ['free'],
                        footer: 'The intended experience'
                    },
                    {
                        icon: 'ðŸ“Š',
                        title: 'Dynamic Difficulty',
                        body: 'Loads different <strong>boss stat JSON files</strong> based on difficulty. Normal has balanced boss stats.',
                        tags: ['free'],
                        footer: 'Boss data: bosses_data_normal.json'
                    }
                ]
            },
            'diffExpertBtn': {
                slides: [
                    {
                        icon: 'ðŸ’€',
                        title: 'Expert Mode',
                        body: 'For hardened cypherpunks only - <strong>brutal enemies</strong> that test your strategic thinking and party coordination.',
                        tags: ['free'],
                        footer: 'Privacy is worth the struggle'
                    },
                    {
                        icon: 'ðŸ“Š',
                        title: 'Dynamic Difficulty',
                        body: 'Loads different <strong>boss stat JSON files</strong> based on difficulty. Expert has higher boss HP, damage, and abilities.',
                        tags: ['free'],
                        footer: 'Boss data: bosses_data_hard.json'
                    }
                ]
            },
            // Music & Audio
            'musicTicker': {
                slides: [
                    {
                        icon: 'ðŸ’›',
                        title: 'Learn About Zcash',
                        body: 'The ticker displays <strong>real Zcash ecosystem facts</strong>! Learn about shielded transactions, zero-knowledge proofs, the Zcash Foundation, and privacy technology while you play.',
                        tags: ['zcash', 'free'],
                        footer: 'Education through entertainment'
                    },
                    {
                        icon: 'ðŸ“š',
                        title: 'Dynamic Fact System',
                        body: 'Facts loaded from <strong>ticker_facts.json</strong> - a curated database of Zcash knowledge. New facts appear with each song change.',
                        tags: ['free'],
                        footer: 'Facts rotate with each track'
                    }
                ]
            },
            'musicControls': {
                slides: [
                    {
                        icon: 'ðŸŽµ',
                        title: 'Tunnels of Doom Tribute',
                        body: 'Music inspired by <strong>Hank Mishkoff\'s</strong> iconic theme song for the TI-99/4A classic <strong>Tunnels of Doom</strong> (1982). The original drew from D&D, Infocom Adventures, and Wizardry.',
                        tags: ['free'],
                        footer: 'Remixed with permission from Hank Mishkoff'
                    },
                    {
                        icon: 'ðŸ¤–',
                        title: 'AI-Remixed Music',
                        body: 'All 10 theme tracks were <strong>AI-remixed</strong> using AiVideo.com, reimagining the classic Tunnels of Doom sound for a modern cyberpunk-fantasy atmosphere.',
                        tags: ['ai', 'paid'],
                        footer: 'Music: AiVideo.com â€¢ Original: Hank Mishkoff'
                    }
                ]
            },
            // Story & Visuals
            'dungeonMenuBackground': {
                slides: [
                    {
                        icon: 'ðŸ“–',
                        title: 'The Zcash Story',
                        body: 'The story follows heroes fighting to protect <strong>financial privacy</strong> in a world where personal data has become currency. Privacy is treasure, and those who steal it become corrupted.',
                        tags: ['zcash'],
                        footer: 'Privacy: The ultimate treasure'
                    },
                    {
                        icon: 'ðŸŽ¬',
                        title: 'AI Story Animations',
                        body: '<strong>Sprite atlas animations</strong> (8Ã—16 = 128 frames at 16fps) play as backgrounds. All sequences were AI-generated as video, then converted to sprite sheets.<br><br>ðŸŽ¥ <strong>Video:</strong> AiVideo.com<br>ðŸ“– <strong>Story:</strong> ChatGPT',
                        tags: ['ai', 'paid'],
                        footer: 'Video by AiVideo.com â€¢ Story by ChatGPT'
                    }
                ]
            },
            // Heroes - with proper Zcash bios
            'dungeonZooko': {
                slides: [
                    {
                        icon: 'ðŸ’›',
                        title: 'Zooko Wilcox-O\'Hearn',
                        body: '<strong>Named after the founder of Zcash</strong>. The real Zooko is a cryptographer and cypherpunk who created Zcash to give everyone access to private, digital money. In-game, Zooko is the party\'s wise protector.',
                        tags: ['zcash'],
                        footer: 'Role: Guardian â€¢ Shield abilities'
                    },
                    {
                        icon: 'ðŸŽ¨',
                        title: 'AI-Generated Hero Art',
                        body: 'All character portraits, sprites, and animations were <strong>AI-generated</strong> using licensed assets and image generation tools from Envato.com.',
                        tags: ['ai', 'paid'],
                        footer: 'Art: Envato.com'
                    }
                ]
            },
            'dungeonNate': {
                slides: [
                    {
                        icon: 'ðŸ’›',
                        title: 'Nathan Wilcox',
                        body: '<strong>Named after Zcash\'s former CTO</strong>. Nathan helped build the technical foundation of Zcash and led engineering efforts. In-game, Nate is the fierce warrior who charges into battle.',
                        tags: ['zcash'],
                        footer: 'Role: Warrior â€¢ Heavy damage dealer'
                    },
                    {
                        icon: 'ðŸŽ¨',
                        title: 'AI-Generated Hero Art',
                        body: 'All character portraits, sprites, and animations were <strong>AI-generated</strong> using licensed assets and image generation tools from Envato.com.',
                        tags: ['ai', 'paid'],
                        footer: 'Art: Envato.com'
                    }
                ]
            },
            'dungeonZancas': {
                slides: [
                    {
                        icon: 'ðŸ’›',
                        title: 'Josh "Zancas" Wilcox',
                        body: '<strong>Named after Zcash developer Josh Wilcox (zancas)</strong>. Josh created Zingo Wallet and contributed to numerous Zcash projects. In-game, Zancas represents precision, innovation, and relentless dedication to privacy tools.',
                        tags: ['zcash'],
                        footer: 'Role: Rogue â€¢ Precision striker'
                    },
                    {
                        icon: 'ðŸŽ¨',
                        title: 'AI-Generated Hero Art',
                        body: 'All character portraits, sprites, and animations were <strong>AI-generated</strong> using licensed assets and image generation tools from Envato.com.',
                        tags: ['ai', 'paid'],
                        footer: 'Art: Envato.com'
                    }
                ]
            },
            'dungeonCyberAxe': {
                slides: [
                    {
                        icon: 'ðŸ’›',
                        title: 'Community Champion',
                        body: '<strong>CyberAxe represents the Zcash community</strong> - the developers, advocates, and users who power the network. Electric abilities symbolize the distributed, unstoppable nature of decentralized privacy.',
                        tags: ['zcash'],
                        footer: 'Role: Mage â€¢ Electric storm attacks'
                    },
                    {
                        icon: 'ðŸŽ¨',
                        title: 'AI-Generated Hero Art',
                        body: 'All character portraits, sprites, and animations were <strong>AI-generated</strong> using licensed assets and image generation tools from Envato.com.',
                        tags: ['ai', 'paid'],
                        footer: 'Art: Envato.com'
                    }
                ]
            },
            // Version/Credits
            'versionDisplay': {
                slides: [
                    {
                        icon: 'ðŸ’›',
                        title: 'Zcash Hackathon 2025',
                        body: 'Built to showcase <strong>Zcash values</strong>: privacy, freedom, and the right to transact without surveillance. The game teaches crypto concepts through gameplay and story.',
                        tags: ['zcash'],
                        footer: 'Privacy is normal. Privacy is freedom.'
                    },
                    {
                        icon: 'ðŸ¤–',
                        title: '100% AI-Developed Game',
                        body: '<strong>EVERYTHING</strong> in this game was AI-generated:<br>â€¢ Code: GitHub Copilot (Claude)<br>â€¢ Art: AI image generation<br>â€¢ Music: Suno AI<br>â€¢ Story: ChatGPT<br>â€¢ Video: AiVideo.com<br>â€¢ Sound FX: AI audio tools',
                        tags: ['ai'],
                        footer: 'Built for Zcash Hackathon 2025'
                    }
                ]
            },
            // Multiplayer
            'heroSelectionCode': {
                slides: [
                    {
                        icon: 'ðŸ‘¥',
                        title: 'Party Up!',
                        body: 'Join forces with up to <strong>4 players</strong> to explore the Tunnels together. Each player controls one hero - coordinate your attacks and protect each other!',
                        tags: ['multiplayer', 'free'],
                        footer: 'Stronger together'
                    },
                    {
                        icon: 'ðŸŒ',
                        title: 'WebSocket Multiplayer',
                        body: 'Real-time <strong>4-player co-op</strong> using WebSocket connections. Host creates room, clients join with 6-character code. Turn-based combat with live state sync.',
                        tags: ['multiplayer', 'free'],
                        footer: 'Python WebSocket server on port 8765'
                    }
                ]
            },
            // ===== TITLE SCREEN TOOLTIPS =====
            'dungeonLevelDisplay': {
                slides: [
                    {
                        icon: 'ðŸ°',
                        title: 'Dungeon Depth',
                        body: 'Your current <strong>depth in the Tunnels of Privacy</strong>. Deeper levels have stronger enemies but better rewards. Each level has rooms to explore, a boss to defeat, and captives to rescue.',
                        tags: ['zcash', 'free'],
                        footer: 'Descend deeper to find greater treasures'
                    },
                    {
                        icon: 'ðŸ“Š',
                        title: 'Level Progress',
                        body: '<strong>Track your exploration:</strong><br>â€¢ Rooms: Encounters completed<br>â€¢ Boss: Level guardian status<br>â€¢ Store: Merchant visited<br>â€¢ Captives: NPCs rescued<br>â€¢ Total Bosses: Career defeats',
                        tags: ['free'],
                        footer: 'Clear the boss to descend deeper'
                    }
                ]
            },
            'startAdventureBtn': {
                slides: [
                    {
                        icon: 'âš”ï¸',
                        title: 'Begin Your Quest',
                        body: 'Enter the <strong>Tunnels of Privacy</strong> - ancient passages where financial freedom is defended. Lead your party of heroes against surveillance, data harvesters, and corrupted entities.',
                        tags: ['zcash', 'free'],
                        footer: 'Protect the right to privacy!'
                    },
                    {
                        icon: 'ðŸŽ®',
                        title: 'Dungeon Crawler RPG',
                        body: '<strong>Turn-based combat</strong> with D&D mechanics, AI-generated encounters, procedural levels, and persistent hero progression. Single player or 4-player co-op!',
                        tags: ['ai', 'multiplayer', 'free'],
                        footer: 'Progress saves automatically'
                    }
                ]
            },
            'enterArcadeBtn': {
                slides: [
                    {
                        icon: 'ðŸŽ¯',
                        title: 'ZLOCK CONSENSUS',
                        body: 'The <strong>other half of this universe</strong>! ZLOCK CONSENSUS is a 3D puzzle arcade game where the same heroes solve block puzzles. Your hero stats carry between both games!',
                        tags: ['zcash', 'free'],
                        footer: 'Portal System: Shared heroes & progress'
                    },
                    {
                        icon: 'ðŸ•¹ï¸',
                        title: '3D Puzzle Game',
                        body: '<strong>Three.js-powered</strong> arcade puzzler with falling blocks, combos, and special abilities. Same 4 heroes, different gameplay. XP earned in either game levels up your characters!',
                        tags: ['ai', 'free'],
                        footer: 'Built with Three.js â€¢ WebGL renderer'
                    }
                ]
            },
            'aboutDonateBtn': {
                slides: [
                    {
                        icon: 'ðŸ’›',
                        title: 'Support Zcash',
                        body: 'This game was created to <strong>spread awareness about Zcash</strong> and financial privacy. Donations help fund continued development and more educational content.',
                        tags: ['zcash'],
                        footer: 'Every ZEC helps!'
                    },
                    {
                        icon: 'ðŸ™',
                        title: 'About This Project',
                        body: 'A <strong>Zcash Hackathon 2025</strong> entry demonstrating how AI can create complete games. 100% AI-developed: code, art, music, story, and more. Open source and free to play!',
                        tags: ['ai', 'free'],
                        footer: 'Made with â¤ï¸ for the Zcash community'
                    }
                ]
            },
            'titleBackground': {
                slides: [
                    {
                        icon: 'ðŸ“–',
                        title: 'The Story',
                        body: 'In a world where <strong>personal data became currency</strong>, privacy itself is treasure. The Tunnels are ancient passages where defenders of financial freedom fight back against surveillance.',
                        tags: ['zcash'],
                        footer: 'A tale of privacy vs surveillance'
                    },
                    {
                        icon: 'ðŸŽ¬',
                        title: 'AI Story Animations',
                        body: '<strong>Sprite atlas animations</strong> (8Ã—16 = 128 frames) created by converting AI-generated video to sprite sheets. Background tells the story while you play!',
                        tags: ['ai', 'paid'],
                        footer: 'Video: AiVideo.com â€¢ Story: ChatGPT'
                    }
                ]
            }
        };
        
        // Initialize tooltip system
        function initTooltipSystem() {
            const tooltip = document.getElementById('infoTooltip');
            if (!tooltip) return;
            
            // Add wheel event listener to tooltip for slide navigation
            tooltip.addEventListener('wheel', handleTooltipWheel, { passive: false });
            
            // Add event listeners to all elements with tooltip data
            Object.keys(TOOLTIP_DATA).forEach(elementId => {
                const element = document.getElementById(elementId);
                if (element) {
                    element.addEventListener('mouseenter', (e) => showTooltipDelayed(e, elementId));
                    element.addEventListener('mouseleave', hideTooltip);
                    element.addEventListener('mousemove', updateTooltipPosition);
                }
            });
            
            // Also handle elements by class
            document.querySelectorAll('[data-tooltip-id]').forEach(element => {
                const tooltipId = element.getAttribute('data-tooltip-id');
                if (TOOLTIP_DATA[tooltipId]) {
                    element.addEventListener('mouseenter', (e) => showTooltipDelayed(e, tooltipId));
                    element.addEventListener('mouseleave', hideTooltip);
                    element.addEventListener('mousemove', updateTooltipPosition);
                }
            });
        }
        
        function showTooltipDelayed(event, tooltipId) {
            clearTimeout(tooltipTimeout);
            clearInterval(tooltipSlideInterval);
            currentTooltipElement = event.target;
            currentTooltipId = tooltipId;
            currentSlideIndex = 0;
            
            tooltipTimeout = setTimeout(() => {
                showTooltip(event, tooltipId);
            }, TOOLTIP_DELAY);
        }
        
        function showTooltip(event, tooltipId) {
            const tooltip = document.getElementById('infoTooltip');
            const data = TOOLTIP_DATA[tooltipId];
            if (!tooltip || !data || !data.slides) return;
            
            currentSlideIndex = 0;
            renderTooltipSlide(tooltip, data, currentSlideIndex);
            
            updateTooltipPosition(event);
            tooltip.classList.add('visible');
            
            // Start slideshow if multiple slides
            if (data.slides.length > 1) {
                clearInterval(tooltipSlideInterval);
                tooltipSlideInterval = setInterval(() => {
                    currentSlideIndex = (currentSlideIndex + 1) % data.slides.length;
                    renderTooltipSlide(tooltip, data, currentSlideIndex);
                }, TOOLTIP_SLIDE_INTERVAL);
            }
        }
        
        function renderTooltipSlide(tooltip, data, slideIndex) {
            const slide = data.slides[slideIndex];
            if (!slide) return;
            
            // Build tags HTML
            let tagsHtml = '';
            if (slide.tags) {
                slide.tags.forEach(tag => {
                    const tagLabels = {
                        'ai': 'ðŸ¤– AI-Generated',
                        'free': 'âœ… Free',
                        'paid': 'ðŸ’³ Paid API',
                        'local': 'ðŸ’» Local',
                        'zcash': 'ðŸ’› Zcash',
                        'multiplayer': 'ðŸ‘¥ Multiplayer'
                    };
                    tagsHtml += `<span class="tooltip-tag tag-${tag}">${tagLabels[tag] || tag}</span>`;
                });
            }
            
            // Build slide dots HTML
            let dotsHtml = '';
            if (data.slides.length > 1) {
                dotsHtml = '<div class="tooltip-dots">';
                for (let i = 0; i < data.slides.length; i++) {
                    dotsHtml += `<span class="tooltip-dot ${i === slideIndex ? 'active' : ''}" onclick="goToTooltipSlide(${i})"></span>`;
                }
                dotsHtml += '</div>';
            }
            
            tooltip.innerHTML = `
                <div class="tooltip-header">
                    <span class="tooltip-icon">${slide.icon}</span>
                    <span class="tooltip-title">${slide.title}</span>
                    ${dotsHtml}
                </div>
                <div class="tooltip-body">
                    ${slide.body}
                    <div style="margin-top: 8px;">${tagsHtml}</div>
                </div>
                ${slide.footer ? `<div class="tooltip-footer">â„¹ï¸ ${slide.footer}</div>` : ''}
            `;
        }
        
        function goToTooltipSlide(index) {
            const tooltip = document.getElementById('infoTooltip');
            const data = TOOLTIP_DATA[currentTooltipId];
            if (!tooltip || !data || !data.slides) return;
            
            currentSlideIndex = index;
            renderTooltipSlide(tooltip, data, currentSlideIndex);
            
            // Reset the interval timer
            if (data.slides.length > 1) {
                clearInterval(tooltipSlideInterval);
                tooltipSlideInterval = setInterval(() => {
                    currentSlideIndex = (currentSlideIndex + 1) % data.slides.length;
                    renderTooltipSlide(tooltip, data, currentSlideIndex);
                }, TOOLTIP_SLIDE_INTERVAL);
            }
        }
        
        function handleTooltipWheel(event) {
            const data = TOOLTIP_DATA[currentTooltipId];
            if (!data || !data.slides || data.slides.length <= 1) return;
            
            event.preventDefault();
            
            // Scroll down = next slide, scroll up = previous slide
            if (event.deltaY > 0) {
                currentSlideIndex = (currentSlideIndex + 1) % data.slides.length;
            } else {
                currentSlideIndex = (currentSlideIndex - 1 + data.slides.length) % data.slides.length;
            }
            
            const tooltip = document.getElementById('infoTooltip');
            renderTooltipSlide(tooltip, data, currentSlideIndex);
            
            // Reset the interval timer
            clearInterval(tooltipSlideInterval);
            tooltipSlideInterval = setInterval(() => {
                currentSlideIndex = (currentSlideIndex + 1) % data.slides.length;
                renderTooltipSlide(tooltip, data, currentSlideIndex);
            }, TOOLTIP_SLIDE_INTERVAL);
        }
        
        function updateTooltipPosition(event) {
            const tooltip = document.getElementById('infoTooltip');
            if (!tooltip) return;
            
            const padding = 15;
            let x = event.clientX + padding;
            let y = event.clientY + padding;
            
            // Keep tooltip on screen
            const rect = tooltip.getBoundingClientRect();
            if (x + rect.width > window.innerWidth - padding) {
                x = event.clientX - rect.width - padding;
            }
            if (y + rect.height > window.innerHeight - padding) {
                y = event.clientY - rect.height - padding;
            }
            
            tooltip.style.left = `${x}px`;
            tooltip.style.top = `${y}px`;
        }
        
        function hideTooltip() {
            clearTimeout(tooltipTimeout);
            clearInterval(tooltipSlideInterval);
            const tooltip = document.getElementById('infoTooltip');
            if (tooltip) {
                tooltip.classList.remove('visible');
            }
            currentTooltipElement = null;
            currentTooltipId = null;
            currentSlideIndex = 0;
        }
        // ===== END HACKATHON INFO TOOLTIP SYSTEM =====
        
        // ===== ENEMY PRIVACY BREACH SYSTEM =====
        // Enemies use public ledgers and have NO privacy - we expose everything!
        
        const PRIVACY_DATA = {
            // Mother's maiden names (all fake of course)
            maidenNames: [
                'Blockchain', 'Nakamoto', 'Buterin', 'Hoskinson', 'Szabo', 'Finney',
                'McAfee', 'Ver', 'Wright', 'Antonopoulos', 'Pomp', 'Saylor',
                'Gensler', 'Munger', 'Dimon', 'Yellen', 'Powell', 'Lagarde',
                'Silvergate', 'FTX', 'Celsius', 'Luna', 'Terra', 'Three Arrows'
            ],
            // Bad passwords
            passwords: [
                'password123', '123456789', 'letmein', 'bitcoin', 'ethereum',
                'hodl2themoon', 'ilovecrypto', 'notmykeys', 'trustme', 'admin',
                'qwerty123', 'dragon', 'monkey', 'abc123', 'password1',
                '12345678', 'iloveyou', 'princess', 'sunshine', 'welcome',
                'shadow', 'football', 'michael', 'ninja', 'mustang',
                'supersecret', 'p@ssw0rd', 'changeme', 'default', 'letmein123',
                'goldenbull', 'tothemoon', 'buythedip', 'wagmi', 'ngmi'
            ],
            // Last meals
            meals: [
                'cold ramen from 3 days ago', 'stolen goblin cheese', 'raw cave mushrooms',
                'a suspicious potion they found', 'their own toenails', 'dungeon moss',
                'adventurer leftovers', 'pickled bat wings', 'stale bread crust',
                'mystery meat (don\'t ask)', 'expired milk', 'floor candy',
                'a boot they found', 'cave spider eggs', 'moldy cheese',
                'unidentified slime', 'old pizza crusts', 'regret and sadness',
                'the last adventurer\'s lunch', 'fermented goblin juice',
                'crystallized tears', 'burnt toast', 'raw potatoes', 'ice soup'
            ],
            // Time since last "relations"
            relations: [
                'Never (too busy hoarding gold)', '47 years, 3 months, 2 days',
                'What\'s that?', 'Before the great blockchain war',
                'They claim "last week" but nobody believes them',
                'Sometime during the Byzantine era', 'Error: Data not found',
                'Their diary says "soon" for 200 years', 'Ask their imaginary friend',
                'The prophecy says "eventually"', 'When pigs fly (so never)',
                'Before Bitcoin existed', 'In their dreams only',
                'Last decade, maybe?', 'It\'s complicated...',
                'During the last bull run (so 2 years)', 'Pending transaction...',
                'When gas fees were low (so never)', 'Before the rugpull',
                'They\'re on a waitlist', 'Their mom says "someday"',
                '404: Romance Not Found', 'Blocked by firewall'
            ],
            // Boss backstories
            bossBackstories: [
                'Once a promising DeFi developer who lost everything in a rugpull. Now guards this dungeon out of spite.',
                'Former Bitcoin maximalist who went mad after the 2022 crash. Blames all adventurers for not buying the dip.',
                'Used to run a successful NFT marketplace until everyone realized JPEGs aren\'t worth millions.',
                'Was rejected from the Zcash Foundation for "excessive evil tendencies." Holds a grudge.',
                'Claims to be Satoshi Nakamoto. Nobody believes them. The rejection drove them to villainy.',
                'Lost their life savings to a "guaranteed 10000x gem" Telegram group. Now robs adventurers.',
                'Former crypto influencer whose audience discovered they paper-traded. Fled to the dungeons in shame.',
                'Believed they could "time the market." They could not. Now they guard treasure they can\'t spend.',
                'Created a meme coin called $EVIL. It pumped, then dumped. They kept the evil, lost the money.',
                'Once tried to explain blockchain to their family at Thanksgiving. Became a dungeon boss the next day.'
            ],
            // Mob backstories
            mobBackstories: [
                'Just following orders. Doesn\'t even get dental.',
                'Was promised equity in the dungeon. Got paid in exposure instead.',
                'Applied for a desk job. This was the only callback.',
                'Student loans. So many student loans.',
                'Their LinkedIn says "Dungeon Minion | Aspiring Boss"',
                'Dropped out of evil henchman school. Parents disappointed.',
                'Has a side hustle selling dungeon souvenirs.',
                'Just here for the health insurance.',
                'Actually wanted to be a bard. Life had other plans.',
                'Roommate with three other minions. Rent is still too high.'
            ],
            // Embarrassing fears
            fears: [
                'Public speaking', 'Commitment', 'Being audited',
                'Smart contracts', 'Tax season', 'Private keys',
                'Hardware wallets', 'KYC verification', 'SEC investigations',
                'Ledger updates', 'Seed phrases', 'The IRS',
                'Angry adventurers', 'Performance reviews', 'Mondays',
                'Stairs', 'Shielded transactions', 'Zcash holders'
            ],
            // Browser history (embarrassing)
            browserHistory: [
                'how to be scary tutorial', 'why do adventurers keep beating me',
                'boss motivation quotes', 'evil laugh practice videos',
                'is hoarding gold a personality', 'dungeon interior design ideas',
                'cheap minion recruitment', 'how to make friends (evil edition)',
                'adventurer weaknesses wikihow', 'therapy for dungeon bosses',
                'how to file dungeon taxes', 'best evil monologue examples',
                'why does nobody like me quiz', 'free evil lair blueprints',
                'how to sound menacing', 'villain support group near me'
            ]
        };
        
        // Cache for generated enemy privacy data (so it stays consistent)
        const enemyPrivacyCache = new Map();
        
        function generateEnemyPrivacyData(enemy) {
            // Check cache first
            const cacheKey = `${enemy.name}_${enemy.level || 1}`;
            if (enemyPrivacyCache.has(cacheKey)) {
                return enemyPrivacyCache.get(cacheKey);
            }
            
            // Seeded random based on enemy name for consistency
            const seed = enemy.name.split('').reduce((a, c) => a + c.charCodeAt(0), 0);
            const rand = (arr) => arr[(seed + arr.length) % arr.length];
            const randNum = (min, max) => min + (seed % (max - min + 1));
            
            // Generate 1-5 passwords
            const numPasswords = 1 + (seed % 5);
            const passwords = [];
            for (let i = 0; i < numPasswords; i++) {
                const pwIndex = (seed + i * 7) % PRIVACY_DATA.passwords.length;
                passwords.push(PRIVACY_DATA.passwords[pwIndex] + (i > 0 ? (seed % 99) : ''));
            }
            
            // Pick backstory based on boss vs mob
            const backstory = enemy.isBoss || !enemy.isMob 
                ? PRIVACY_DATA.bossBackstories[(seed) % PRIVACY_DATA.bossBackstories.length]
                : PRIVACY_DATA.mobBackstories[(seed) % PRIVACY_DATA.mobBackstories.length];
            
            const data = {
                realName: `${enemy.name.split(' ')[0]}icus McEvil${seed % 100}`,
                age: randNum(23, 847),
                mothersMaidenName: rand(PRIVACY_DATA.maidenNames),
                passwords: passwords,
                lastMeal: rand(PRIVACY_DATA.meals),
                lastRelations: rand(PRIVACY_DATA.relations),
                backstory: backstory,
                ssn: `${randNum(100,999)}-${randNum(10,99)}-${randNum(1000,9999)}`,
                creditScore: randNum(300, 450), // Always bad
                fear: rand(PRIVACY_DATA.fears),
                browserHistory: rand(PRIVACY_DATA.browserHistory),
                walletBalance: `${randNum(0, 5)}.${randNum(0,99).toString().padStart(2,'0')} BTC (all traceable)`,
                taxStatus: seed % 3 === 0 ? 'DELINQUENT' : seed % 3 === 1 ? 'AUDITED' : 'FRAUDULENT'
            };
            
            // Cache it
            enemyPrivacyCache.set(cacheKey, data);
            return data;
        }
        
        function showEnemyPrivacyTooltip(event, enemy) {
            const tooltip = document.getElementById('enemyPrivacyTooltip');
            if (!tooltip || !enemy) return;
            
            // Track privacy breach views for achievement
            updateAchievementStats('privacyBreachesViewed', 1);
            
            const data = generateEnemyPrivacyData(enemy);
            const isBoss = enemy.isBoss || !enemy.isMob;
            
            tooltip.innerHTML = `
                <div class="privacy-header">
                    <div>
                        <div class="privacy-warning">âš ï¸ PRIVACY BREACH DETECTED âš ï¸</div>
                        <div class="privacy-title">${enemy.name}</div>
                        <div class="privacy-subtitle">${isBoss ? 'ðŸ‘‘ Dungeon Boss' : 'ðŸ‘¹ Minion'} â€¢ No Privacy Detected</div>
                    </div>
                </div>
                
                <div class="privacy-section">
                    <div class="privacy-section-title">ðŸ“‹ EXPOSED PERSONAL DATA</div>
                    <div class="privacy-row">
                        <span class="privacy-label">Legal Name:</span>
                        <span class="privacy-value">${data.realName}</span>
                    </div>
                    <div class="privacy-row">
                        <span class="privacy-label">Age:</span>
                        <span class="privacy-value">${data.age} years old</span>
                    </div>
                    <div class="privacy-row">
                        <span class="privacy-label">Mother's Maiden Name:</span>
                        <span class="privacy-value">${data.mothersMaidenName}</span>
                    </div>
                    <div class="privacy-row">
                        <span class="privacy-label">SSN:</span>
                        <span class="privacy-value password">${data.ssn}</span>
                    </div>
                    <div class="privacy-row">
                        <span class="privacy-label">Credit Score:</span>
                        <span class="privacy-value embarrassing">${data.creditScore} (POOR)</span>
                    </div>
                    <div class="privacy-row">
                        <span class="privacy-label">Tax Status:</span>
                        <span class="privacy-value embarrassing">${data.taxStatus}</span>
                    </div>
                </div>
                
                <div class="privacy-section">
                    <div class="privacy-section-title">ðŸ” LEAKED PASSWORDS (${data.passwords.length})</div>
                    ${data.passwords.map(pw => `
                        <div class="privacy-row">
                            <span class="privacy-label">Password:</span>
                            <span class="privacy-value password">${pw}</span>
                        </div>
                    `).join('')}
                </div>
                
                <div class="privacy-section">
                    <div class="privacy-section-title">ðŸ’° FINANCIAL DATA</div>
                    <div class="privacy-row">
                        <span class="privacy-label">Wallet Balance:</span>
                        <span class="privacy-value">${data.walletBalance}</span>
                    </div>
                    <div class="privacy-row">
                        <span class="privacy-label">Gold on Hand:</span>
                        <span class="privacy-value" style="color: #FFD700;">${enemy.goldDrop || 0} gold</span>
                    </div>
                </div>
                
                <div class="privacy-section">
                    <div class="privacy-section-title">ðŸ˜³ EMBARRASSING INFO</div>
                    <div class="privacy-row">
                        <span class="privacy-label">Last Meal:</span>
                        <span class="privacy-value embarrassing">${data.lastMeal}</span>
                    </div>
                    <div class="privacy-row">
                        <span class="privacy-label">Last Relations:</span>
                        <span class="privacy-value embarrassing">${data.lastRelations}</span>
                    </div>
                    <div class="privacy-row">
                        <span class="privacy-label">Secret Fear:</span>
                        <span class="privacy-value embarrassing">${data.fear}</span>
                    </div>
                    <div class="privacy-row">
                        <span class="privacy-label">Recent Search:</span>
                        <span class="privacy-value embarrassing">"${data.browserHistory}"</span>
                    </div>
                </div>
                
                <div class="privacy-section">
                    <div class="privacy-section-title">ðŸ“– BACKSTORY (LEAKED)</div>
                    <div class="privacy-backstory">${data.backstory}</div>
                </div>
                
                <div class="privacy-section">
                    <div class="privacy-section-title">âš”ï¸ COMBAT STATS</div>
                    <div class="privacy-row">
                        <span class="privacy-label">HP:</span>
                        <span class="privacy-value" style="color: #ff6b6b;">${enemy.hp}/${enemy.maxHp}</span>
                    </div>
                    <div class="privacy-row">
                        <span class="privacy-label">AC:</span>
                        <span class="privacy-value">${enemy.ac || 10}</span>
                    </div>
                    <div class="privacy-row">
                        <span class="privacy-label">Damage:</span>
                        <span class="privacy-value">${enemy.minDamage || 1}-${enemy.maxDamage || 4}</span>
                    </div>
                </div>
                
                <div class="privacy-footer">
                    <div class="privacy-footer-text">ðŸ”“ This entity uses a PUBLIC LEDGER â€¢ All data is PERMANENTLY VISIBLE</div>
                </div>
            `;
            
            // Position tooltip
            const padding = 15;
            let x = event.clientX + padding;
            let y = event.clientY + padding;
            
            // Keep on screen
            tooltip.style.left = `${x}px`;
            tooltip.style.top = `${y}px`;
            tooltip.classList.add('visible');
            
            // Adjust if off screen
            setTimeout(() => {
                const rect = tooltip.getBoundingClientRect();
                if (rect.right > window.innerWidth - padding) {
                    tooltip.style.left = `${event.clientX - rect.width - padding}px`;
                }
                if (rect.bottom > window.innerHeight - padding) {
                    tooltip.style.top = `${Math.max(padding, event.clientY - rect.height - padding)}px`;
                }
            }, 10);
        }
        
        function hideEnemyPrivacyTooltip() {
            const tooltip = document.getElementById('enemyPrivacyTooltip');
            if (tooltip) {
                tooltip.classList.remove('visible');
            }
        }
        
        function updateEnemyPrivacyTooltipPosition(event) {
            const tooltip = document.getElementById('enemyPrivacyTooltip');
            if (!tooltip || !tooltip.classList.contains('visible')) return;
            
            const padding = 15;
            let x = event.clientX + padding;
            let y = event.clientY + padding;
            
            const rect = tooltip.getBoundingClientRect();
            if (x + rect.width > window.innerWidth - padding) {
                x = event.clientX - rect.width - padding;
            }
            if (y + rect.height > window.innerHeight - padding) {
                y = Math.max(padding, event.clientY - rect.height - padding);
            }
            
            tooltip.style.left = `${x}px`;
            tooltip.style.top = `${y}px`;
        }
        // ===== END ENEMY PRIVACY BREACH SYSTEM =====
        
        // ===== FOOD TRANSPARENCY SYSTEM =====
        // Because you deserve to know what's in your dungeon food!
        
        const FOOD_DATA = {
            // Bug parts found in grain-based foods
            bugParts: [
                '3 cricket legs', '1 weevil thorax', '2 moth antennae', 'trace amounts of beetle',
                '0.5 cockroach wings', '4 grain mite fragments', 'flour beetle residue',
                'a suspicious crunch', 'FDA-approved insect parts', '1 whole aphid (bonus protein)'
            ],
            // Plant backstories
            plantBackstories: [
                'Grew up in a field dreaming of becoming a flower. Became bread instead.',
                'Was the runt of the crop. The other vegetables never let it forget.',
                'Spent 6 months in soil contemplating existence. Still no answers.',
                'Had a beautiful view of the sunset every day. Then harvest came.',
                'Made friends with a ladybug. That ladybug is also in this bread.',
                'Voted "Most Likely to Photosynthesize" by its peers.',
                'Its seeds came from a long line of organic produce. Very proud of this.'
            ],
            // Animal backstories for meat
            animalBackstories: [
                'Lived a simple life. Enjoyed grass. Had no idea what a "dungeon" was.',
                'Name was Bessie. Had dreams. Those dreams are now your stew.',
                'Was employee of the month at the farm. Three times.',
                'Left behind 2 calves and a disappointed farmer.',
                'Spent its final days looking at clouds. It was peaceful.',
                'Once escaped the farm for 3 hours. Best day of its life.',
                'Its mother always said it would amount to something. She was right.',
                'Had a favorite spot by the fence. The new cow uses it now.'
            ],
            // Fish backstories
            fishBackstories: [
                'Swam upstream for years. Was going somewhere. Never arrived.',
                'Had a school of friends. They\'re also on the menu.',
                'Saw a shiny thing. That was the last thing it saw.',
                'Believed it was the chosen one. Technically correct.',
                'Spent its whole life avoiding hooks. One bad day.',
                'Its tank-mate Gary still wonders what happened.'
            ],
            // Chicken backstories
            chickenBackstories: [
                'Crossed the road once. Nobody knows why. Now it\'s dinner.',
                'Laid 847 eggs. That wasn\'t enough apparently.',
                'Had opinions about corn. Strong opinions.',
                'Was the alpha of the coop. Pecking order meant nothing in the end.',
                'Dreamed of flying. Achieved it briefly. Into the pot.'
            ],
            // Mysterious ingredients
            mysteryIngredients: [
                'unidentified protein', 'essence of dungeon', 'adventurer seasoning',
                'ground mystery', 'compressed nutrients', 'edible matter',
                'certified organic something', 'definitely not poison', 'chef\'s secret'
            ],
            // Dungeon-specific additives
            dungeonAdditives: [
                'torch soot for color', 'cave moss for fiber', 'mineral water (from puddles)',
                'ambient despair', 'trace cobwebs', 'dungeon atmosphere',
                'the souls of defeated enemies', 'ground gemstones (for sparkle)',
                'hope (trace amounts)'
            ],
            // Expiry status
            expiryStatus: [
                'Best by: Who knows?', 'Expired 3 weeks ago', 'Technically still edible',
                'Questionable but aromatic', 'Fresh-ish', 'Aged to perfection (hopefully)',
                'Best not to ask', 'The mold adds flavor', 'Preserved by magic (probably)'
            ]
        };
        
        // Generate food transparency data based on item
        function generateFoodData(item) {
            const seed = item.name.split('').reduce((a, c) => a + c.charCodeAt(0), 0);
            const rand = (arr) => arr[(seed) % arr.length];
            const randOffset = (arr, offset) => arr[(seed + offset) % arr.length];
            
            const data = {
                bugParts: rand(FOOD_DATA.bugParts),
                dungeonAdditive: rand(FOOD_DATA.dungeonAdditives),
                expiry: rand(FOOD_DATA.expiryStatus),
                mysteryIngredient: rand(FOOD_DATA.mysteryIngredients)
            };
            
            // Pick backstory based on food type
            const name = item.name.toLowerCase();
            if (name.includes('fish')) {
                data.backstory = rand(FOOD_DATA.fishBackstories);
                data.sourceType = 'ðŸŸ Fish';
            } else if (name.includes('chicken') || name.includes('roast')) {
                data.backstory = rand(FOOD_DATA.chickenBackstories);
                data.sourceType = 'ðŸ” Poultry';
            } else if (name.includes('steak') || name.includes('dragon') || name.includes('meat')) {
                data.backstory = rand(FOOD_DATA.animalBackstories);
                data.sourceType = 'ðŸ¥© Meat';
            } else if (name.includes('bread') || name.includes('craps') || name.includes('scraps')) {
                data.backstory = rand(FOOD_DATA.plantBackstories);
                data.bugParts = randOffset(FOOD_DATA.bugParts, 3); // Extra bugs in bread
                data.sourceType = 'ðŸŒ¾ Grain';
            } else if (name.includes('veggi') || name.includes('fresh')) {
                data.backstory = rand(FOOD_DATA.plantBackstories);
                data.sourceType = 'ðŸ¥¬ Vegetable';
            } else if (name.includes('feast') || name.includes('banquet') || name.includes('divine')) {
                data.backstory = 'A legendary meal. Multiple creatures contributed. None of them volunteered.';
                data.sourceType = 'ðŸ‘‘ Premium';
            } else if (name.includes('potion')) {
                data.backstory = 'Brewed by someone who definitely washed their hands. Probably.';
                data.sourceType = 'âš—ï¸ Alchemical';
                data.bugParts = 'None (we think)';
            } else {
                data.backstory = rand(FOOD_DATA.plantBackstories);
                data.sourceType = 'ðŸ½ï¸ Mixed';
            }
            
            return data;
        }
        
        function showFoodTooltip(event, item) {
            const tooltip = document.getElementById('foodTooltip');
            if (!tooltip || !item) return;
            
            const data = generateFoodData(item);
            
            tooltip.innerHTML = `
                <div class="food-header">
                    <div class="food-label">ðŸ” FOOD TRANSPARENCY REPORT</div>
                    <div class="food-title">${item.name}</div>
                </div>
                
                <div class="food-section-title">ðŸ“‹ Ingredient Analysis</div>
                <div class="food-row">
                    <span class="food-row-label">Source:</span>
                    <span class="food-row-value">${data.sourceType}</span>
                </div>
                <div class="food-row">
                    <span class="food-row-label">Bug Content:</span>
                    <span class="food-row-value warning">${data.bugParts}</span>
                </div>
                <div class="food-row">
                    <span class="food-row-label">Dungeon Additive:</span>
                    <span class="food-row-value">${data.dungeonAdditive}</span>
                </div>
                <div class="food-row">
                    <span class="food-row-label">Mystery Ingredient:</span>
                    <span class="food-row-value">${data.mysteryIngredient}</span>
                </div>
                <div class="food-row">
                    <span class="food-row-label">Freshness:</span>
                    <span class="food-row-value warning">${data.expiry}</span>
                </div>
                
                <div class="food-section-title">ðŸ“– Origin Story</div>
                <div class="food-backstory">${data.backstory}</div>
                
                <div class="food-footer">ðŸŒ¿ Transparency is a Right â€¢ Know Your Food ðŸŒ¿</div>
            `;
            
            tooltip.classList.add('visible');
            updateFoodTooltipPosition(event);
        }
        
        function hideFoodTooltip() {
            const tooltip = document.getElementById('foodTooltip');
            if (tooltip) {
                tooltip.classList.remove('visible');
            }
        }
        
        function updateFoodTooltipPosition(event) {
            const tooltip = document.getElementById('foodTooltip');
            if (!tooltip || !tooltip.classList.contains('visible')) return;
            
            const padding = 15;
            let x = event.clientX + padding;
            let y = event.clientY + padding;
            
            const rect = tooltip.getBoundingClientRect();
            if (x + rect.width > window.innerWidth - padding) {
                x = event.clientX - rect.width - padding;
            }
            if (y + rect.height > window.innerHeight - padding) {
                y = Math.max(padding, event.clientY - rect.height - padding);
            }
            
            tooltip.style.left = `${x}px`;
            tooltip.style.top = `${y}px`;
        }
        
        // Set up food tooltip hover events for inventory cells with food items
        function setupFoodTooltips(container) {
            if (!container) return;
            
            container.querySelectorAll('[data-slot]').forEach(cell => {
                const slotIndex = parseInt(cell.dataset.slot);
                const item = partyInventory.items[slotIndex];
                
                // Only attach to cells with party_meal items
                if (!item || item.type !== 'party_meal') return;
                
                cell.addEventListener('mouseenter', (e) => {
                    showFoodTooltip(e, item);
                });
                
                cell.addEventListener('mousemove', (e) => {
                    updateFoodTooltipPosition(e);
                });
                
                cell.addEventListener('mouseleave', () => {
                    hideFoodTooltip();
                });
            });
        }
        // ===== END FOOD TRANSPARENCY SYSTEM =====
        
        // ===== POTION TRANSPARENCY SYSTEM =====
        // Because you deserve to know what's in your magical elixirs!
        
        const POTION_DATA = {
            // Base ingredients
            baseIngredients: [
                'distilled moonwater', 'cave fungus extract', 'luminescent moss juice',
                'liquified starlight', 'concentrated hope', 'purified dungeon tears',
                'fermented mystery', 'condensed magic vapor', 'ancient spring water'
            ],
            // Active compounds
            activeCompounds: [
                'essence of phoenix feather', 'crystallized dragon breath', 'unicorn sweat (ethically sourced)',
                'ground fairy wings (they grew back)', 'troll regeneration factor', 'basilisk tear extract',
                'bottled determination', 'powdered miracle', 'concentrated "please work"'
            ],
            // Questionable additives
            additives: [
                'red dye #47 (for that healing look)', 'artificial strawberry flavor', 'glitter (non-toxic)',
                'placebo particles', 'hope flavoring', 'essence of marketing',
                'customer confidence extract', 'sparkle dust (cosmetic only)', 'brand loyalty enhancer'
            ],
            // Brewing methods
            brewingMethods: [
                'Stirred counterclockwise under a full moon', 'Whispered ancient words during brewing',
                'Aged in a wizard\'s beard for 3 months', 'Blessed by a slightly drunk cleric',
                'Fermented in absolute darkness', 'Shaken, not stirred (very important)',
                'Left near a magic crystal until it "felt right"', 'Brewed during a solar eclipse (or just cloudy)',
                'Made with love (and some other stuff)'
            ],
            // Alchemist backgrounds
            alchemists: [
                'a wizard who failed chemistry but passed vibes', 'an ex-snake-oil salesman turned legitimate',
                'a very optimistic goblin', 'someone who read half a potion book',
                'a reformed poison maker', 'an AI trained on 3 recipe scrolls',
                'a hedge witch with a 60% success rate', 'a dwarf who was "pretty sure" about the measurements',
                'an elf who eyeballed all the ingredients'
            ],
            // Side effects
            sideEffects: [
                'May cause temporary optimism', 'Slight tingling is normal (we think)',
                'Do not operate siege weapons after consumption', 'May attract butterflies',
                'Occasional prophetic dreams (unrelated)', 'Your burps might sparkle',
                'Hair may temporarily change color', 'Sudden urge to fight dragons (ignore this)',
                'Enhanced appreciation for nature', 'Brief sense of invincibility (do not test)'
            ],
            // Efficacy claims
            efficacy: [
                'Clinically tested on volunteers (they survived)', 'Approved by 3 out of 4 wizards',
                'Works 60% of the time, every time', 'Better than nothing, probably',
                'Endorsed by a famous adventurer (name withheld)', 'Satisfaction somewhat guaranteed',
                'As seen in Ye Olde Alchemy Weekly', 'Winner of "Most Drinkable" award',
                'Now with 20% more magic (unverified)'
            ],
            // Container conditions
            containerNotes: [
                'Bottle recycled from previous potion (washed... mostly)', 'Cork has been pre-chewed for easy opening',
                'Glowing is normal, flickering is fine, screaming is rare', 'Some settling of magic may occur',
                'If seal is broken, contents are still probably fine', 'Best consumed before the label fades',
                'Store away from direct prophecy', 'Do not expose to strong opinions',
                'Shake well (or don\'t, we\'re not sure it matters)'
            ]
        };
        
        // Generate potion transparency data
        function generatePotionData(item) {
            const seed = (item.name || 'Health Potion').split('').reduce((a, c) => a + c.charCodeAt(0), 0);
            const rand = (arr) => arr[seed % arr.length];
            const randOffset = (arr, offset) => arr[(seed + offset) % arr.length];
            
            return {
                baseIngredient: rand(POTION_DATA.baseIngredients),
                activeCompound: randOffset(POTION_DATA.activeCompounds, 1),
                additive: randOffset(POTION_DATA.additives, 2),
                brewingMethod: randOffset(POTION_DATA.brewingMethods, 3),
                alchemist: randOffset(POTION_DATA.alchemists, 4),
                sideEffect: randOffset(POTION_DATA.sideEffects, 5),
                efficacy: randOffset(POTION_DATA.efficacy, 6),
                containerNote: randOffset(POTION_DATA.containerNotes, 7)
            };
        }
        
        function showPotionTooltip(event, item) {
            const tooltip = document.getElementById('potionTooltip');
            if (!tooltip || !item) return;
            
            const data = generatePotionData(item);
            
            tooltip.innerHTML = `
                <div class="potion-header">
                    <div class="potion-label">âš—ï¸ ALCHEMICAL ANALYSIS REPORT</div>
                    <div class="potion-title">${item.name || 'Health Potion'}</div>
                </div>
                
                <div class="potion-section-title">ðŸ§ª Composition</div>
                <div class="potion-row">
                    <span class="potion-row-label">Base:</span>
                    <span class="potion-row-value">${data.baseIngredient}</span>
                </div>
                <div class="potion-row">
                    <span class="potion-row-label">Active Compound:</span>
                    <span class="potion-row-value magic">${data.activeCompound}</span>
                </div>
                <div class="potion-row">
                    <span class="potion-row-label">Additive:</span>
                    <span class="potion-row-value warning">${data.additive}</span>
                </div>
                
                <div class="potion-section-title">ðŸ“œ Brewing Details</div>
                <div class="potion-row">
                    <span class="potion-row-label">Method:</span>
                    <span class="potion-row-value">${data.brewingMethod}</span>
                </div>
                <div class="potion-row">
                    <span class="potion-row-label">Brewed By:</span>
                    <span class="potion-row-value">${data.alchemist}</span>
                </div>
                <div class="potion-row">
                    <span class="potion-row-label">Efficacy:</span>
                    <span class="potion-row-value magic">${data.efficacy}</span>
                </div>
                
                <div class="potion-section-title">âš ï¸ Consumer Information</div>
                <div class="potion-backstory">${data.containerNote}</div>
                <div class="potion-warning">âš ï¸ Side Effect: ${data.sideEffect}</div>
                
                <div class="potion-footer">âœ¨ Alchemy Guild Certified â€¢ Drink Responsibly âœ¨</div>
            `;
            
            tooltip.classList.add('visible');
            updatePotionTooltipPosition(event);
        }
        
        function hidePotionTooltip() {
            const tooltip = document.getElementById('potionTooltip');
            if (tooltip) {
                tooltip.classList.remove('visible');
            }
        }
        
        function updatePotionTooltipPosition(event) {
            const tooltip = document.getElementById('potionTooltip');
            if (!tooltip || !tooltip.classList.contains('visible')) return;
            
            const padding = 15;
            let x = event.clientX + padding;
            let y = event.clientY + padding;
            
            const rect = tooltip.getBoundingClientRect();
            if (x + rect.width > window.innerWidth - padding) {
                x = event.clientX - rect.width - padding;
            }
            if (y + rect.height > window.innerHeight - padding) {
                y = Math.max(padding, event.clientY - rect.height - padding);
            }
            
            tooltip.style.left = `${x}px`;
            tooltip.style.top = `${y}px`;
        }
        
        // Set up potion tooltip hover events for inventory cells with consumable items
        function setupPotionTooltips(container) {
            if (!container) return;
            
            container.querySelectorAll('[data-slot]').forEach(cell => {
                const slotIndex = parseInt(cell.dataset.slot);
                const item = partyInventory.items[slotIndex];
                
                // Only attach to cells with consumable (potion) items
                if (!item || item.type !== 'consumable') return;
                
                cell.addEventListener('mouseenter', (e) => {
                    showPotionTooltip(e, item);
                });
                
                cell.addEventListener('mousemove', (e) => {
                    updatePotionTooltipPosition(e);
                });
                
                cell.addEventListener('mouseleave', () => {
                    hidePotionTooltip();
                });
            });
        }
        // ===== END POTION TRANSPARENCY SYSTEM =====
        
        // ===== ACHIEVEMENTS & BESTIARY SYSTEM =====
        const STORAGE_KEY_ACHIEVEMENTS = 'top_achievements';
        const STORAGE_KEY_BESTIARY = 'top_bestiary';
        
        // Achievement definitions
        const ACHIEVEMENTS = [
            // Combat Achievements
            { id: 'first_blood', name: 'First Blood', desc: 'Defeat your first enemy', icon: 'âš”ï¸', category: 'combat' },
            { id: 'boss_slayer_1', name: 'Boss Slayer', desc: 'Defeat your first boss', icon: 'ðŸ‘‘', category: 'combat' },
            { id: 'boss_slayer_10', name: 'Boss Hunter', desc: 'Defeat 10 bosses', icon: 'ðŸ†', category: 'combat' },
            { id: 'boss_slayer_50', name: 'Boss Exterminator', desc: 'Defeat 50 bosses', icon: 'ðŸ’€', category: 'combat' },
            { id: 'boss_slayer_99', name: 'Boss Annihilator', desc: 'Defeat all 99 unique bosses', icon: 'ðŸ”¥', category: 'combat' },
            { id: 'critical_king', name: 'Critical King', desc: 'Land 100 critical hits', icon: 'ðŸ’¥', category: 'combat' },
            { id: 'dodge_master', name: 'Dodge Master', desc: 'Dodge 50 attacks', icon: 'ðŸ’¨', category: 'combat' },
            { id: 'perfect_battle', name: 'Flawless Victory', desc: 'Win a boss battle without taking damage', icon: 'âœ¨', category: 'combat' },
            
            // Exploration Achievements
            { id: 'explorer_10', name: 'Novice Explorer', desc: 'Clear 10 rooms', icon: 'ðŸšª', category: 'explore' },
            { id: 'explorer_100', name: 'Dungeon Delver', desc: 'Clear 100 rooms', icon: 'ðŸ—ºï¸', category: 'explore' },
            { id: 'explorer_500', name: 'Master Explorer', desc: 'Clear 500 rooms', icon: 'ðŸ›ï¸', category: 'explore' },
            { id: 'deep_dive_25', name: 'Deep Diver', desc: 'Reach dungeon level 25', icon: 'â¬‡ï¸', category: 'explore' },
            { id: 'deep_dive_50', name: 'Abyss Walker', desc: 'Reach dungeon level 50', icon: 'ðŸŒ‘', category: 'explore' },
            { id: 'deep_dive_100', name: 'Bottom Feeder', desc: 'Reach dungeon level 100', icon: 'ðŸ•³ï¸', category: 'explore' },
            
            // Economy Achievements
            { id: 'gold_1000', name: 'Coin Collector', desc: 'Collect 1,000 gold total', icon: 'ðŸª™', category: 'economy' },
            { id: 'gold_10000', name: 'Wealthy Adventurer', desc: 'Collect 10,000 gold total', icon: 'ðŸ’°', category: 'economy' },
            { id: 'gold_100000', name: 'Dragon Hoarder', desc: 'Collect 100,000 gold total', icon: 'ðŸ‰', category: 'economy' },
            { id: 'shop_regular', name: 'Frequent Shopper', desc: 'Visit 10 stores', icon: 'ðŸ›’', category: 'economy' },
            { id: 'weapon_upgrade', name: 'Upgraded', desc: 'Upgrade a weapon', icon: 'â¬†ï¸', category: 'economy' },
            { id: 'weapon_max', name: 'Master Smith', desc: 'Max out a weapon', icon: 'ðŸ”¨', category: 'economy' },
            
            // Hero Achievements
            { id: 'level_10', name: 'Getting Stronger', desc: 'Reach hero level 10', icon: 'ðŸ’ª', category: 'hero' },
            { id: 'level_25', name: 'Veteran', desc: 'Reach hero level 25', icon: 'ðŸŽ–ï¸', category: 'hero' },
            { id: 'level_50', name: 'Champion', desc: 'Reach hero level 50', icon: 'ðŸ‘‘', category: 'hero' },
            { id: 'healer', name: 'Healer', desc: 'Heal 1,000 HP total', icon: 'â¤ï¸â€ðŸ©¹', category: 'hero' },
            { id: 'rescuer_10', name: 'Rescuer', desc: 'Free 10 captives', icon: 'ðŸ”“', category: 'hero' },
            
            // Special Achievements
            { id: 'night_owl', name: 'Night Owl', desc: 'Play at 3 AM', icon: 'ðŸ¦‰', category: 'special' },
            { id: 'marathon', name: 'Marathon Runner', desc: 'Play for 2 hours straight', icon: 'ðŸƒ', category: 'special' },
            { id: 'privacy_advocate', name: 'Privacy Advocate', desc: 'View 50 enemy privacy breaches', icon: 'ðŸ”’', category: 'special' }
        ];
        
        // Boss data for bestiary (levels 2-100)
        const BOSS_DATA = [];
        for (let level = 2; level <= 100; level++) {
            // Boss names based on level ranges
            const bossNames = {
                2: 'Metadata Swarm Mass', 3: 'Open Ledger Golem', 4: 'Leak-Channel Imp',
                5: 'Fingerprint Fiend', 6: 'Cookie Stalker', 7: 'Browser Phantom',
                8: 'Data Broker Beast', 9: 'Spyware Specter', 10: 'Tracker Titan',
                11: 'Keylogger Kraken', 12: 'Phishing Phantom', 13: 'Ransomware Reaper',
                14: 'Botnet Behemoth', 15: 'Zero-Day Zealot', 16: 'Backdoor Basilisk',
                17: 'Rootkit Revenant', 18: 'Trojan Tyrant', 19: 'Worm Warden',
                20: 'Virus Vanguard', 21: 'Adware Aberration', 22: 'Scareware Shade',
                23: 'Cryptojacker', 24: 'Man-in-Middle Monster', 25: 'SQL Injector',
                26: 'XSS Executor',
                100: 'Auric Hoard Dragon'
            };
            
            // Get boss name - known names for 2-26, generated for rest
            let bossName = bossNames[level];
            if (!bossName) {
                const prefixes = ['Shadow', 'Dark', 'Corrupted', 'Malicious', 'Invasive', 'Lurking', 'Hidden', 'Surveilling'];
                const types = ['Watcher', 'Harvester', 'Tracker', 'Leaker', 'Breacher', 'Collector', 'Stalker', 'Exposer'];
                const prefix = prefixes[(level * 7) % prefixes.length];
                const type = types[(level * 13) % types.length];
                bossName = `${prefix} ${type} ${level}`;
            }
            
            // Determine if we have art (levels 2-100 - complete!)
            const hasArt = (level >= 2 && level <= 100);
            const spritePath = hasArt 
                ? `tunnelsofprivacy/bosses/lvl${level}/boss_lvl${level}.png`
                : null;
            
            BOSS_DATA.push({
                level: level,
                name: bossName,
                spritePath: spritePath,
                hasArt: hasArt
            });
        }
        
        // Achievement state
        let achievementState = {
            unlocked: {},
            stats: {
                enemiesDefeated: 0,
                bossesDefeated: 0,
                criticalHits: 0,
                dodges: 0,
                roomsCleared: 0,
                goldCollected: 0,
                storesVisited: 0,
                captivesFreed: 0,
                hpHealed: 0,
                privacyBreachesViewed: 0,
                sessionStartTime: Date.now()
            }
        };
        
        // Bestiary state - tracks which bosses have been defeated
        let bestiaryState = {
            defeated: {} // keyed by level number
        };
        
        // Load achievement state from localStorage
        function loadAchievementState() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY_ACHIEVEMENTS);
                if (saved) {
                    const parsed = JSON.parse(saved);
                    achievementState.unlocked = parsed.unlocked || {};
                    achievementState.stats = { ...achievementState.stats, ...parsed.stats };
                }
            } catch (e) {
                console.error('Failed to load achievements:', e);
            }
        }
        
        // Save achievement state
        function saveAchievementState() {
            try {
                localStorage.setItem(STORAGE_KEY_ACHIEVEMENTS, JSON.stringify(achievementState));
            } catch (e) {
                console.error('Failed to save achievements:', e);
            }
        }
        
        // Load bestiary state
        function loadBestiaryState() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY_BESTIARY);
                if (saved) {
                    bestiaryState = JSON.parse(saved);
                }
            } catch (e) {
                console.error('Failed to load bestiary:', e);
            }
        }
        
        // Save bestiary state
        function saveBestiaryState() {
            try {
                localStorage.setItem(STORAGE_KEY_BESTIARY, JSON.stringify(bestiaryState));
            } catch (e) {
                console.error('Failed to save bestiary:', e);
            }
        }
        
        // Unlock an achievement
        function unlockAchievement(achievementId) {
            if (achievementState.unlocked[achievementId]) return; // Already unlocked
            
            const achievement = ACHIEVEMENTS.find(a => a.id === achievementId);
            if (!achievement) return;
            
            achievementState.unlocked[achievementId] = {
                unlockedAt: Date.now()
            };
            saveAchievementState();
            
            // Show notification
            showAchievementNotification(achievement);
            
            // Play sound if available
            if (typeof playSound === 'function') {
                playSound('UI_Victory');
            }
        }
        
        // Show achievement notification
        function showAchievementNotification(achievement) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 100px;
                right: 20px;
                background: linear-gradient(135deg, rgba(42, 157, 143, 0.95), rgba(39, 174, 96, 0.95));
                border: 3px solid #F2C94C;
                border-radius: 12px;
                padding: 15px 20px;
                z-index: 100000;
                display: flex;
                align-items: center;
                gap: 15px;
                box-shadow: 0 5px 30px rgba(242, 201, 76, 0.5);
                animation: slideInRight 0.5s ease, fadeOut 0.5s ease 3.5s forwards;
                font-family: 'JetBrains Mono', monospace;
            `;
            notification.innerHTML = `
                <div style="width: 50px; height: 50px; background: #F2C94C; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 28px;">${achievement.icon}</div>
                <div>
                    <div style="color: #F2C94C; font-size: 12px; font-weight: 700; text-transform: uppercase; letter-spacing: 1px;">Achievement Unlocked!</div>
                    <div style="color: white; font-size: 16px; font-weight: 700;">${achievement.name}</div>
                    <div style="color: rgba(255,255,255,0.8); font-size: 12px;">${achievement.desc}</div>
                </div>
            `;
            document.body.appendChild(notification);
            
            // Remove after animation
            setTimeout(() => notification.remove(), 4000);
        }
        
        // Mark boss as defeated in bestiary
        function markBossDefeated(level) {
            if (level < 2 || level > 100) return;
            
            // Normalize to 2-100 range (bosses repeat after 100)
            const normalizedLevel = ((level - 2) % 99) + 2;
            
            if (!bestiaryState.defeated[normalizedLevel]) {
                bestiaryState.defeated[normalizedLevel] = {
                    defeatedAt: Date.now(),
                    originalLevel: level
                };
                saveBestiaryState();
                
                // Check for boss-related achievements
                const totalDefeated = Object.keys(bestiaryState.defeated).length;
                if (totalDefeated >= 1) unlockAchievement('boss_slayer_1');
                if (totalDefeated >= 10) unlockAchievement('boss_slayer_10');
                if (totalDefeated >= 50) unlockAchievement('boss_slayer_50');
                if (totalDefeated >= 99) unlockAchievement('boss_slayer_99');
            }
        }
        
        // Show achievements panel
        let currentAchievementPage = 1;
        
        function showAchievementsPanel() {
            document.getElementById('panelOverlay').style.display = 'block';
            document.getElementById('achievementsPanel').style.display = 'block';
            document.getElementById('bestiaryPanel').style.display = 'none';
            showAchievementPage(currentAchievementPage);
        }
        
        // Show achievement page (1 or 2)
        function showAchievementPage(page) {
            currentAchievementPage = page;
            
            // Update tab buttons
            document.getElementById('achieveTabPage1').classList.toggle('active', page === 1);
            document.getElementById('achieveTabPage2').classList.toggle('active', page === 2);
            
            renderAchievementsList(page);
        }
        
        // Close achievements panel
        function closeAchievementsPanel() {
            document.getElementById('panelOverlay').style.display = 'none';
            document.getElementById('achievementsPanel').style.display = 'none';
        }
        
        // Show achievements panel from in-game (pause menu, camp, etc.)
        function showAchievementsPanelFromGame() {
            document.getElementById('panelOverlay').style.display = 'block';
            document.getElementById('achievementsPanel').style.display = 'block';
            document.getElementById('bestiaryPanel').style.display = 'none';
            showAchievementPage(currentAchievementPage);
        }
        
        // Show bestiary panel
        function showBestiaryPanel() {
            document.getElementById('panelOverlay').style.display = 'block';
            document.getElementById('bestiaryPanel').style.display = 'block';
            document.getElementById('achievementsPanel').style.display = 'none';
            renderBestiaryList('easy');
        }
        
        // Close bestiary panel
        function closeBestiaryPanel() {
            document.getElementById('panelOverlay').style.display = 'none';
            document.getElementById('bestiaryPanel').style.display = 'none';
        }
        
        // Close all panels
        function closeAllPanels() {
            document.getElementById('panelOverlay').style.display = 'none';
            document.getElementById('achievementsPanel').style.display = 'none';
            document.getElementById('bestiaryPanel').style.display = 'none';
        }
        
        // Switch between achievements and bestiary tabs
        function showAchievementTab(tab) {
            if (tab === 'achievements') {
                showAchievementsPanel();
            } else {
                showBestiaryPanel();
            }
        }
        
        // Show bestiary page (easy/normal/hard)
        function showBestiaryPage(page) {
            // Update tab buttons
            document.getElementById('bestiaryTabEasy').classList.toggle('active', page === 'easy');
            document.getElementById('bestiaryTabNormal').classList.toggle('active', page === 'normal');
            document.getElementById('bestiaryTabHard').classList.toggle('active', page === 'hard');
            
            renderBestiaryList(page);
        }
        
        // Render achievements list
        function renderAchievementsList(page = 1) {
            const list = document.getElementById('achievementsList');
            if (!list) return;
            
            // Page 1: Combat + Explore, Page 2: Economy + Heroes + Special
            const page1Categories = ['combat', 'explore'];
            const page2Categories = ['economy', 'hero', 'special'];
            const activeCategories = page === 1 ? page1Categories : page2Categories;
            
            const categories = {
                combat: { name: 'Combat', achievements: [] },
                explore: { name: 'Exploration', achievements: [] },
                economy: { name: 'Economy', achievements: [] },
                hero: { name: 'Heroes', achievements: [] },
                special: { name: 'Special', achievements: [] }
            };
            
            // Group achievements by category
            ACHIEVEMENTS.forEach(a => {
                if (categories[a.category]) {
                    categories[a.category].achievements.push(a);
                }
            });
            
            let html = '';
            let totalUnlocked = 0;
            
            // Count total unlocked across ALL categories for progress bar
            Object.entries(categories).forEach(([key, cat]) => {
                totalUnlocked += cat.achievements.filter(a => achievementState.unlocked[a.id]).length;
            });
            
            // Render only categories for current page
            activeCategories.forEach(key => {
                const cat = categories[key];
                const catUnlocked = cat.achievements.filter(a => achievementState.unlocked[a.id]).length;
                
                html += `
                    <div style="margin-bottom: 12px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; padding-bottom: 4px; border-bottom: 2px solid #B388FF;">
                            <span style="color: #B388FF; font-size: 13px; font-weight: 700; text-transform: uppercase;">${cat.name}</span>
                            <span style="color: #BFD1E0; font-size: 11px;">${catUnlocked}/${cat.achievements.length}</span>
                        </div>
                        <div class="achievementGrid">
                `;
                
                cat.achievements.forEach(achievement => {
                    const isUnlocked = achievementState.unlocked[achievement.id];
                    html += `
                        <div class="achievementItem ${isUnlocked ? 'unlocked' : ''}" title="${achievement.desc}">
                            <div class="achievementIcon ${isUnlocked ? 'unlocked' : 'locked'}">
                                ${isUnlocked ? achievement.icon : 'ðŸ”’'}
                            </div>
                            <div class="achievementName">${achievement.name}</div>
                        </div>
                    `;
                });
                
                html += '</div></div>';
            });
            
            list.innerHTML = html;
            document.getElementById('achievementsProgress').textContent = `${totalUnlocked}/${ACHIEVEMENTS.length} Unlocked`;
        }
        
        // Render bestiary list
        function renderBestiaryList(page) {
            const list = document.getElementById('bestiaryList');
            if (!list) return;
            
            // Determine level range based on page
            let startLevel, endLevel;
            if (page === 'easy') {
                startLevel = 2;
                endLevel = 34;
            } else if (page === 'normal') {
                startLevel = 35;
                endLevel = 67;
            } else {
                startLevel = 68;
                endLevel = 100;
            }
            
            const bosses = BOSS_DATA.filter(b => b.level >= startLevel && b.level <= endLevel);
            const totalDefeated = Object.keys(bestiaryState.defeated).length;
            
            let html = '<div class="bestiaryGrid">';
            
            bosses.forEach(boss => {
                const isDefeated = bestiaryState.defeated[boss.level];
                const portraitStyle = boss.hasArt 
                    ? `background-image: url('${boss.spritePath}');`
                    : `background: linear-gradient(135deg, #2a2a4a, #1a1a2e); display: flex; align-items: center; justify-content: center; font-size: 20px; color: #666;`;
                
                html += `
                    <div class="bossEntry ${isDefeated ? 'defeated' : ''} ${!boss.hasArt ? 'noart' : ''}">
                        <div class="bossPortrait" style="${portraitStyle}">
                            ${!boss.hasArt ? '?' : ''}
                        </div>
                        <div class="bossLevel">Lv ${boss.level}</div>
                        <div class="bossTooltip">
                            <div class="bossTooltipName">${isDefeated ? boss.name : '???'}</div>
                            <div class="bossTooltipStats">
                                ${isDefeated ? `<div>âœ“ Defeated</div>` : `<div style="color: #E74C3C;">Not yet defeated</div>`}
                                <div style="margin-top: 4px; color: #89A0B4;">Level ${boss.level} Boss</div>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            list.innerHTML = html;
            
            // Update progress
            document.getElementById('bestiaryProgress').textContent = `${totalDefeated}/99 Bosses Defeated`;
        }
        
        // Check and unlock time-based achievements
        function checkTimeAchievements() {
            const now = new Date();
            const hour = now.getHours();
            
            // Night Owl - playing at 3 AM
            if (hour === 3) {
                unlockAchievement('night_owl');
            }
            
            // Marathon - 2 hours straight
            const sessionDuration = Date.now() - achievementState.stats.sessionStartTime;
            if (sessionDuration >= 2 * 60 * 60 * 1000) {
                unlockAchievement('marathon');
            }
        }
        
        // Update achievement stats (call after relevant game events)
        function updateAchievementStats(statName, amount = 1) {
            if (!achievementState.stats[statName]) {
                achievementState.stats[statName] = 0;
            }
            achievementState.stats[statName] += amount;
            saveAchievementState();
            
            // Check for stat-based achievements
            const stats = achievementState.stats;
            
            if (statName === 'enemiesDefeated' && stats.enemiesDefeated >= 1) {
                unlockAchievement('first_blood');
            }
            if (statName === 'criticalHits' && stats.criticalHits >= 100) {
                unlockAchievement('critical_king');
            }
            if (statName === 'dodges' && stats.dodges >= 50) {
                unlockAchievement('dodge_master');
            }
            if (statName === 'roomsCleared') {
                if (stats.roomsCleared >= 10) unlockAchievement('explorer_10');
                if (stats.roomsCleared >= 100) unlockAchievement('explorer_100');
                if (stats.roomsCleared >= 500) unlockAchievement('explorer_500');
            }
            if (statName === 'goldCollected') {
                if (stats.goldCollected >= 1000) unlockAchievement('gold_1000');
                if (stats.goldCollected >= 10000) unlockAchievement('gold_10000');
                if (stats.goldCollected >= 100000) unlockAchievement('gold_100000');
            }
            if (statName === 'storesVisited' && stats.storesVisited >= 10) {
                unlockAchievement('shop_regular');
            }
            if (statName === 'captivesFreed' && stats.captivesFreed >= 10) {
                unlockAchievement('rescuer_10');
            }
            if (statName === 'hpHealed' && stats.hpHealed >= 1000) {
                unlockAchievement('healer');
            }
            if (statName === 'privacyBreachesViewed' && stats.privacyBreachesViewed >= 50) {
                unlockAchievement('privacy_advocate');
            }
        }
        
        // Check dungeon level achievements
        function checkDungeonLevelAchievements(level) {
            if (level >= 25) unlockAchievement('deep_dive_25');
            if (level >= 50) unlockAchievement('deep_dive_50');
            if (level >= 100) unlockAchievement('deep_dive_100');
        }
        
        // Check hero level achievements
        function checkHeroLevelAchievements(heroLevel) {
            if (heroLevel >= 10) unlockAchievement('level_10');
            if (heroLevel >= 25) unlockAchievement('level_25');
            if (heroLevel >= 50) unlockAchievement('level_50');
        }
        
        // Initialize achievements system
        function initAchievementsSystem() {
            loadAchievementState();
            loadBestiaryState();
            
            // Reset session start time
            achievementState.stats.sessionStartTime = Date.now();
            
            // Check time-based achievements periodically
            setInterval(checkTimeAchievements, 60000);
        }
        
        // Add CSS animation for notification
        const achievementAnimStyle = document.createElement('style');
        achievementAnimStyle.textContent = `
            @keyframes slideInRight {
                from { transform: translateX(100%); opacity: 0; }
                to { transform: translateX(0); opacity: 1; }
            }
            @keyframes fadeOut {
                from { opacity: 1; }
                to { opacity: 0; }
            }
        `;
        document.head.appendChild(achievementAnimStyle);
        // ===== END ACHIEVEMENTS & BESTIARY SYSTEM =====
        
        // ===== LEVEL PROGRESS TRACKING =====
        let levelProgress = {
            roomsExplored: 0,
            roomsMax: '?',
            bossDefeated: false,
            storeVisited: false,
            captivesFreed: 0,
            totalBossesDefeated: 0
        };
        
        function resetLevelProgress() {
            levelProgress.roomsExplored = 0;
            levelProgress.roomsMax = '?';
            levelProgress.bossDefeated = false;
            levelProgress.storeVisited = false;
            levelProgress.captivesFreed = 0;
            updateLevelProgressDisplay();
            saveLevelProgress();
            broadcastLevelProgress();
        }
        
        function updateLevelProgressDisplay() {
            // Update the level stats in the dungeon level display (title screen)
            const roomsExploredEl = document.getElementById('levelRoomsExplored');
            const roomsMaxEl = document.getElementById('levelRoomsMax');
            const bossDefeatedEl = document.getElementById('levelBossDefeated');
            const storeVisitedEl = document.getElementById('levelStoreVisited');
            const captivesFreedEl = document.getElementById('levelCaptivesFreed');
            const totalBossesEl = document.getElementById('totalBossesDefeated');
            
            if (roomsExploredEl) roomsExploredEl.textContent = levelProgress.roomsExplored;
            if (roomsMaxEl) roomsMaxEl.textContent = levelProgress.roomsMax;
            if (bossDefeatedEl) bossDefeatedEl.textContent = levelProgress.bossDefeated ? '1' : '0';
            if (storeVisitedEl) storeVisitedEl.textContent = levelProgress.storeVisited ? '1' : '0';
            if (captivesFreedEl) captivesFreedEl.textContent = levelProgress.captivesFreed;
            if (totalBossesEl) totalBossesEl.textContent = levelProgress.totalBossesDefeated;
            
            // Update the level stats in the dungeon menu (dm = dungeon menu)
            const dmRoomsExploredEl = document.getElementById('dmRoomsExplored');
            const dmRoomsMaxEl = document.getElementById('dmRoomsMax');
            const dmBossDefeatedEl = document.getElementById('dmBossDefeated');
            const dmStoreVisitedEl = document.getElementById('dmStoreVisited');
            const dmCaptivesFreedEl = document.getElementById('dmCaptivesFreed');
            const dmTotalBossesEl = document.getElementById('dmTotalBossesDefeated');
            
            if (dmRoomsExploredEl) dmRoomsExploredEl.textContent = levelProgress.roomsExplored;
            if (dmRoomsMaxEl) dmRoomsMaxEl.textContent = levelProgress.roomsMax;
            if (dmBossDefeatedEl) dmBossDefeatedEl.textContent = levelProgress.bossDefeated ? '1' : '0';
            if (dmStoreVisitedEl) dmStoreVisitedEl.textContent = levelProgress.storeVisited ? '1' : '0';
            if (dmCaptivesFreedEl) dmCaptivesFreedEl.textContent = levelProgress.captivesFreed;
            if (dmTotalBossesEl) dmTotalBossesEl.textContent = levelProgress.totalBossesDefeated;
        }
        
        function incrementRoomsExplored() {
            levelProgress.roomsExplored++;
            updateLevelProgressDisplay();
            saveLevelProgress();
            broadcastLevelProgress();
            
            // Mark the current room as explored in the level layout
            if (preGeneratedEncounter.currentRoomId) {
                markRoomExplored(preGeneratedEncounter.currentRoomId);
                console.log(`[RoomTracking] Marked room ${preGeneratedEncounter.currentRoomId} as explored (combat cleared)`);
            }
        }
        
        function markBossDefeated() {
            levelProgress.bossDefeated = true;
            levelProgress.totalBossesDefeated++;
            updateLevelProgressDisplay();
            saveLevelProgress();
            broadcastLevelProgress();
            
            // Get current dungeon level for bestiary
            const currentLevel = parseInt(document.getElementById('dungeonLevel')?.textContent || document.getElementById('dungeonMenuLevel')?.textContent) || 1;
            
            // Mark in bestiary (only levels 2-100, repeating after that)
            if (currentLevel >= 2) {
                markBossDefeatedInBestiary(currentLevel);
            }
            
            // Mark boss room as explored in level layout
            if (currentLevelLayout && currentLevelLayout.bossRoom) {
                currentLevelLayout.bossRoom.explored = true;
                saveLevelLayout();
                console.log('[RoomTracking] Boss room marked as explored');
            }
            
            // Also save to sharedSave bossesDefeated array
            try {
                const sharedSave = loadSharedSave();
                if (sharedSave && sharedSave.dungeonState && sharedSave.dungeonState.questProgress) {
                    if (!sharedSave.dungeonState.questProgress.bossesDefeated.includes(currentLevel)) {
                        sharedSave.dungeonState.questProgress.bossesDefeated.push(currentLevel);
                        saveSharedSave(sharedSave);
                    }
                }
            } catch (e) {
                console.error('[LevelProgress] Error saving boss defeat:', e);
            }
        }
        
        // Wrapper for bestiary marking (separate from levelProgress)
        function markBossDefeatedInBestiary(level) {
            if (typeof markBossDefeated === 'function' && level >= 2) {
                // Normalize to 2-100 range (bosses repeat after 100)
                const normalizedLevel = ((level - 2) % 99) + 2;
                
                if (!bestiaryState.defeated[normalizedLevel]) {
                    bestiaryState.defeated[normalizedLevel] = {
                        defeatedAt: Date.now(),
                        originalLevel: level
                    };
                    saveBestiaryState();
                    
                    // Check for boss-related achievements
                    const totalDefeated = Object.keys(bestiaryState.defeated).length;
                    if (totalDefeated >= 1) unlockAchievement('boss_slayer_1');
                    if (totalDefeated >= 10) unlockAchievement('boss_slayer_10');
                    if (totalDefeated >= 50) unlockAchievement('boss_slayer_50');
                    if (totalDefeated >= 99) unlockAchievement('boss_slayer_99');
                    
                    console.log(`[Bestiary] Boss at level ${level} (normalized: ${normalizedLevel}) marked as defeated. Total: ${totalDefeated}/99`);
                }
            }
        }
        
        function markStoreVisited() {
            levelProgress.storeVisited = true;
            updateAchievementStats('storesVisited', 1);
            updateLevelProgressDisplay();
            saveLevelProgress();
            broadcastLevelProgress();
        }
        
        function incrementCaptivesFreed() {
            levelProgress.captivesFreed++;
            updateAchievementStats('captivesFreed', 1);
            updateLevelProgressDisplay();
            saveLevelProgress();
            broadcastLevelProgress();
        }
        
        function loadTotalBossesDefeated() {
            try {
                const sharedSave = loadSharedSave();
                if (sharedSave && sharedSave.dungeonState && sharedSave.dungeonState.questProgress) {
                    levelProgress.totalBossesDefeated = sharedSave.dungeonState.questProgress.bossesDefeated.length || 0;
                }
            } catch (e) {
                console.error('[LevelProgress] Error loading boss count:', e);
            }
            updateLevelProgressDisplay();
        }
        
        // Save current level progress to sharedSave
        function saveLevelProgress() {
            // Only host saves in multiplayer
            if (multiplayerState.enabled && multiplayerState.role === 'client') return;
            
            try {
                const sharedSave = loadSharedSave();
                if (sharedSave && sharedSave.dungeonState) {
                    const currentLevel = parseInt(document.getElementById('dungeonLevel')?.textContent || document.getElementById('dungeonMenuLevel')?.textContent) || 1;
                    
                    // Initialize levelProgress storage if not exists
                    if (!sharedSave.dungeonState.levelProgress) {
                        sharedSave.dungeonState.levelProgress = {};
                    }
                    
                    // Save current level's progress
                    sharedSave.dungeonState.levelProgress[currentLevel] = {
                        roomsExplored: levelProgress.roomsExplored,
                        bossDefeated: levelProgress.bossDefeated,
                        storeVisited: levelProgress.storeVisited,
                        captivesFreed: levelProgress.captivesFreed
                    };
                    
                    saveSharedSave(sharedSave);
                }
            } catch (e) {
                console.error('[LevelProgress] Error saving level progress:', e);
            }
        }
        
        // Load level progress for current level from sharedSave
        function loadLevelProgress() {
            try {
                const sharedSave = loadSharedSave();
                const currentLevel = parseInt(document.getElementById('dungeonLevel')?.textContent || document.getElementById('dungeonMenuLevel')?.textContent) || 1;
                
                // Load total bosses defeated
                if (sharedSave && sharedSave.dungeonState && sharedSave.dungeonState.questProgress) {
                    levelProgress.totalBossesDefeated = sharedSave.dungeonState.questProgress.bossesDefeated.length || 0;
                }
                
                // Load this level's progress if exists
                if (sharedSave && sharedSave.dungeonState && sharedSave.dungeonState.levelProgress && sharedSave.dungeonState.levelProgress[currentLevel]) {
                    const saved = sharedSave.dungeonState.levelProgress[currentLevel];
                    levelProgress.roomsExplored = saved.roomsExplored || 0;
                    levelProgress.bossDefeated = saved.bossDefeated || false;
                    levelProgress.storeVisited = saved.storeVisited || false;
                    levelProgress.captivesFreed = saved.captivesFreed || 0;
                } else {
                    // No saved progress for this level - reset
                    levelProgress.roomsExplored = 0;
                    levelProgress.bossDefeated = false;
                    levelProgress.storeVisited = false;
                    levelProgress.captivesFreed = 0;
                }
                
                updateLevelProgressDisplay();
            } catch (e) {
                console.error('[LevelProgress] Error loading level progress:', e);
            }
        }
        
        // Broadcast level progress to all clients (host only)
        function broadcastLevelProgress() {
            if (!multiplayerState.enabled || multiplayerState.role !== 'host') return;
            
            // Send EVERYTHING - simple full sync for 4 players max
            sendWebSocketMessage({
                type: 'level_progress_update',
                progress: levelProgress,
                levelLayout: currentLevelLayout
            });
        }
        
        // Client receives level progress from host
        function updateLevelProgressFromHost(progress, levelLayout) {
            // Full sync - just copy everything
            if (progress) {
                levelProgress.roomsExplored = progress.roomsExplored || 0;
                levelProgress.roomsMax = progress.roomsMax || '?';
                levelProgress.bossDefeated = progress.bossDefeated || false;
                levelProgress.storeVisited = progress.storeVisited || false;
                levelProgress.captivesFreed = progress.captivesFreed || 0;
                levelProgress.totalBossesDefeated = progress.totalBossesDefeated || 0;
            }
            
            // Full layout sync - client gets exact same data as host
            if (levelLayout) {
                currentLevelLayout = levelLayout;
            }
            
            // Update all UI
            updateLevelProgressDisplay();
            updateDungeonMastersStatus();
            updateStoreButtonState();
        }
        // ===== END LEVEL PROGRESS TRACKING =====
        
        // ===== LEVEL LAYOUT SYSTEM =====
        // Defines the structure of each dungeon level - rooms, encounters, stores, etc.
        let currentLevelLayout = null;
        
        // Room types for level generation
        const ROOM_TYPES = {
            COMBAT: 'combat',           // Standard combat room with mobs
            BOSS: 'boss',               // Level boss room
            MINI_BOSS: 'miniBoss',      // Mini-boss encounter
            STORE: 'store',             // Shop/merchant room
            NPC: 'npc',                 // Non-combat NPC interaction
            EXPLORATION: 'exploration', // Exploration/puzzle room
            SECRET: 'secret',           // Hidden room (requires discovery)
            CAPTIVE: 'captive'          // Room with captive NPC to rescue
        };
        
        // Generate level layout based on dungeon level
        function generateLevelLayout(level) {
            // Base room counts that scale with level
            const baseRooms = 4 + Math.floor(level / 3); // 4 rooms at level 1, increases every 3 levels
            const maxRooms = Math.min(baseRooms, 12); // Cap at 12 rooms per level
            
            // Calculate room distribution
            const combatRooms = Math.max(2, Math.floor(maxRooms * 0.4)); // 40% combat
            const miniBossRooms = level >= 3 ? Math.min(Math.floor(level / 5), 2) : 0; // Mini-bosses start at level 3
            const npcRooms = Math.max(1, Math.floor(maxRooms * 0.15)); // 15% NPC
            const explorationRooms = Math.max(1, Math.floor(maxRooms * 0.15)); // 15% exploration
            const secretRooms = Math.random() < 0.3 + (level * 0.02) ? 1 : 0; // 30%+ chance of secret room
            const hasStore = level === 1 ? true : Math.random() < 0.6 + (level * 0.02); // Always on level 1, 60%+ chance otherwise
            const captiveRooms = Math.random() < 0.25 ? 1 : 0; // 25% chance of captive
            
            // Build rooms array
            const rooms = [];
            let roomId = 1;
            
            // Always add the boss room (last room to be encountered)
            rooms.push({
                id: roomId++,
                type: ROOM_TYPES.BOSS,
                explored: false,
                accessible: false, // Boss unlocks after other rooms explored
                data: null // Will be populated by LLM
            });
            
            // Add mini-boss rooms
            for (let i = 0; i < miniBossRooms; i++) {
                rooms.push({
                    id: roomId++,
                    type: ROOM_TYPES.MINI_BOSS,
                    explored: false,
                    accessible: true,
                    data: null
                });
            }
            
            // Add combat rooms
            for (let i = 0; i < combatRooms; i++) {
                rooms.push({
                    id: roomId++,
                    type: ROOM_TYPES.COMBAT,
                    explored: false,
                    accessible: true,
                    data: null
                });
            }
            
            // Add store if present
            if (hasStore) {
                rooms.push({
                    id: roomId++,
                    type: ROOM_TYPES.STORE,
                    explored: false,
                    accessible: true,
                    data: null
                });
            }
            
            // Add NPC rooms
            for (let i = 0; i < npcRooms; i++) {
                rooms.push({
                    id: roomId++,
                    type: ROOM_TYPES.NPC,
                    explored: false,
                    accessible: true,
                    data: null
                });
            }
            
            // Add exploration rooms
            for (let i = 0; i < explorationRooms; i++) {
                rooms.push({
                    id: roomId++,
                    type: ROOM_TYPES.EXPLORATION,
                    explored: false,
                    accessible: true,
                    data: null
                });
            }
            
            // Add captive room if present
            if (captiveRooms > 0) {
                rooms.push({
                    id: roomId++,
                    type: ROOM_TYPES.CAPTIVE,
                    explored: false,
                    accessible: true,
                    data: null
                });
            }
            
            // Add secret rooms (not initially accessible)
            for (let i = 0; i < secretRooms; i++) {
                rooms.push({
                    id: roomId++,
                    type: ROOM_TYPES.SECRET,
                    explored: false,
                    accessible: false, // Must be discovered
                    discoveryHint: generateSecretRoomHint(),
                    data: null
                });
            }
            
            // Shuffle non-boss rooms to randomize encounter order
            const bossRoom = rooms.find(r => r.type === ROOM_TYPES.BOSS);
            const otherRooms = rooms.filter(r => r.type !== ROOM_TYPES.BOSS);
            shuffleArray(otherRooms);
            
            const layout = {
                level: level,
                totalRooms: rooms.length,
                accessibleRooms: rooms.filter(r => r.accessible).length,
                rooms: otherRooms, // Boss is separate
                bossRoom: bossRoom,
                hasStore: hasStore,
                storeFound: false,
                secretRoomsTotal: secretRooms,
                secretRoomsFound: 0,
                roomQueue: [...otherRooms.filter(r => r.accessible)], // Queue of accessible unexplored rooms
                generatedAt: Date.now()
            };
            
            return layout;
        }
        
        // Generate hint for finding secret rooms
        function generateSecretRoomHint() {
            const hints = [
                'A draft of cold air seeps through a crack in the wall...',
                'Strange markings on the floor point toward a shadowy corner...',
                'The echo of your footsteps sounds hollow near one wall...',
                'A faint glow emanates from behind loose stones...',
                'Dust patterns suggest something has moved here recently...'
            ];
            return hints[Math.floor(Math.random() * hints.length)];
        }
        
        // Shuffle array in place (Fisher-Yates)
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }
        
        // Get the next room to explore based on level layout
        // Boss is always in the pool - odds increase as rooms are cleared
        // With 10 rooms + boss: first room = 1/11 chance of boss, last room = 100% boss
        function getNextRoomFromLayout() {
            if (!currentLevelLayout) return null;
            
            // Get unexplored rooms (not including boss)
            let availableRooms = currentLevelLayout.rooms.filter(r => {
                if (r.explored) return false;
                if (!r.accessible) return false;
                // If store already found, don't include store rooms
                if (r.type === ROOM_TYPES.STORE && currentLevelLayout.storeFound) return false;
                return true;
            });
            
            // Check if boss is available (not explored)
            const bossAvailable = currentLevelLayout.bossRoom && !currentLevelLayout.bossRoom.explored;
            
            // If no regular rooms left, return boss if available
            if (availableRooms.length === 0) {
                if (bossAvailable) {
                    return currentLevelLayout.bossRoom;
                }
                // All rooms explored including boss
                return null;
            }
            
            // Boss probability: 1 / (remaining rooms + 1)
            // 10 rooms left = 1/11 chance, 5 rooms left = 1/6 chance, 0 rooms left = 100%
            if (bossAvailable) {
                const bossChance = 1 / (availableRooms.length + 1);
                if (Math.random() < bossChance) {
                    return currentLevelLayout.bossRoom;
                }
            }
            
            // Calculate room selection weights for remaining rooms
            // If store hasn't been found and few rooms left, increase store odds
            const roomWeights = availableRooms.map(room => {
                let weight = 1;
                
                if (room.type === ROOM_TYPES.STORE && !currentLevelLayout.storeFound) {
                    // Increase store weight as fewer rooms remain
                    const remainingRatio = availableRooms.length / currentLevelLayout.accessibleRooms;
                    weight = remainingRatio < 0.3 ? 5 : (remainingRatio < 0.5 ? 3 : 1);
                }
                
                return { room, weight };
            });
            
            // Weighted random selection
            const totalWeight = roomWeights.reduce((sum, rw) => sum + rw.weight, 0);
            let random = Math.random() * totalWeight;
            
            for (const rw of roomWeights) {
                random -= rw.weight;
                if (random <= 0) {
                    return rw.room;
                }
            }
            
            // Fallback to first available
            return availableRooms[0];
        }
        
        // Get the next room TYPE as a string for encounter generation
        // This is used by preGenerateNextEncounter() to determine what kind of content to generate
        function getNextRoomType() {
            // Get the next room from the layout
            const nextRoom = getNextRoomFromLayout();
            
            // If no room or no layout, default to combat
            if (!nextRoom) {
                preGeneratedEncounter.currentRoomId = null;
                return 'combat';
            }
            
            // Store the room ID so we can mark it explored when cleared
            preGeneratedEncounter.currentRoomId = nextRoom.id;
            console.log(`[RoomTracking] Selected room ${nextRoom.id} (${nextRoom.type})`);
            
            // Map internal room types to the encounter generation types
            const typeMapping = {
                [ROOM_TYPES.COMBAT]: 'combat',
                [ROOM_TYPES.BOSS]: 'boss',
                [ROOM_TYPES.MINI_BOSS]: 'mini_boss',
                [ROOM_TYPES.STORE]: 'store',
                [ROOM_TYPES.NPC]: 'npc',
                [ROOM_TYPES.EXPLORATION]: 'exploration',
                [ROOM_TYPES.SECRET]: 'secret',
                [ROOM_TYPES.CAPTIVE]: 'combat' // Captive rooms have combat + captive
            };
            
            return typeMapping[nextRoom.type] || 'combat';
        }
        
        // Mark a room as explored
        function markRoomExplored(roomId) {
            if (!currentLevelLayout) return;
            
            const room = currentLevelLayout.rooms.find(r => r.id === roomId);
            if (room) {
                room.explored = true;
                
                // Update store found flag
                if (room.type === ROOM_TYPES.STORE) {
                    currentLevelLayout.storeFound = true;
                }
                
                // Update secret room count
                if (room.type === ROOM_TYPES.SECRET) {
                    currentLevelLayout.secretRoomsFound++;
                }
            }
            
            // Check boss room
            if (currentLevelLayout.bossRoom && currentLevelLayout.bossRoom.id === roomId) {
                currentLevelLayout.bossRoom.explored = true;
            }
            
            // Save layout and update UI
            saveLevelLayout();
            updateDungeonMastersStatus();
            
            // Broadcast to clients in multiplayer
            broadcastLevelProgress();
        }
        
        // Save level layout to sharedSave
        function saveLevelLayout() {
            if (multiplayerState.enabled && multiplayerState.role === 'client') return;
            
            try {
                const sharedSave = loadSharedSave();
                if (sharedSave && sharedSave.dungeonState) {
                    if (!sharedSave.dungeonState.levelLayouts) {
                        sharedSave.dungeonState.levelLayouts = {};
                    }
                    sharedSave.dungeonState.levelLayouts[currentLevelLayout.level] = currentLevelLayout;
                    saveSharedSave(sharedSave);
                }
            } catch (e) {
                console.error('[LevelLayout] Error saving:', e);
            }
        }
        
        // Load level layout from sharedSave or generate new
        function loadOrGenerateLevelLayout(level) {
            try {
                const sharedSave = loadSharedSave();
                
                // Check if layout exists for this level
                if (sharedSave?.dungeonState?.levelLayouts?.[level]) {
                    currentLevelLayout = sharedSave.dungeonState.levelLayouts[level];
                    console.log(`[LevelLayout] Loaded existing layout for level ${level}:`, currentLevelLayout.totalRooms, 'rooms');
                    
                    // FIX: Level 1 must always have a store - regenerate if missing
                    if (level === 1 && !currentLevelLayout.hasStore) {
                        console.log(`[LevelLayout] Level 1 missing store - regenerating layout`);
                        currentLevelLayout = generateLevelLayout(level);
                        saveLevelLayout();
                    }
                } else {
                    // Generate new layout
                    currentLevelLayout = generateLevelLayout(level);
                    console.log(`[LevelLayout] Generated new layout for level ${level}:`, currentLevelLayout.totalRooms, 'rooms');
                    saveLevelLayout();
                }
                
                // FIX: Level 1 store should be auto-discovered so player can enter immediately
                if (level === 1 && currentLevelLayout.hasStore && !currentLevelLayout.storeFound) {
                    currentLevelLayout.storeFound = true;
                    // Generate store data if not present
                    if (!currentLevelLayout.discoveredStoreData) {
                        currentLevelLayout.discoveredStoreData = {
                            merchantName: getRandomMerchantName(),
                            items: generateStoreItems(level),
                            greeting: getRandomMerchantGreeting()
                        };
                    }
                    saveLevelLayout();
                    console.log(`[LevelLayout] Level 1 store auto-discovered`);
                }
                
                // Update level progress max rooms display
                levelProgress.roomsMax = currentLevelLayout.totalRooms;
                updateLevelProgressDisplay();
                
                // Update store button state based on whether store is found
                updateStoreButtonState();
                
                // Update DM panel status (and stairs button visibility)
                updateDungeonMastersStatus();
                
            } catch (e) {
                console.error('[LevelLayout] Error loading/generating:', e);
                currentLevelLayout = generateLevelLayout(level);
            }
        }
        
        // Alias for initializeLevelLayout - used by stairs and game start
        function initializeLevelLayout(level) {
            loadOrGenerateLevelLayout(level);
        }
        
        // Get room type display name
        function getRoomTypeName(type) {
            const names = {
                [ROOM_TYPES.COMBAT]: 'Combat Room',
                [ROOM_TYPES.BOSS]: 'Boss Chamber',
                [ROOM_TYPES.MINI_BOSS]: 'Mini-Boss Lair',
                [ROOM_TYPES.STORE]: 'Merchant\'s Den',
                [ROOM_TYPES.NPC]: 'Meeting Hall',
                [ROOM_TYPES.EXPLORATION]: 'Mysterious Chamber',
                [ROOM_TYPES.SECRET]: 'Hidden Room',
                [ROOM_TYPES.CAPTIVE]: 'Prison Cell'
            };
            return names[type] || 'Unknown Room';
        }
        
        // Check if level is complete (all non-secret rooms explored + boss defeated)
        function isLevelComplete() {
            if (!currentLevelLayout) return false;
            
            const requiredRooms = currentLevelLayout.rooms.filter(r => r.type !== ROOM_TYPES.SECRET);
            const allExplored = requiredRooms.every(r => r.explored);
            const bossDefeated = currentLevelLayout.bossRoom.explored;
            
            return allExplored && bossDefeated;
        }
        // ===== END LEVEL LAYOUT SYSTEM =====
        
        // ===== RANDOM PLAYER NAME GENERATOR =====
        const PLAYER_FIRST_NAMES = ['Crypto', 'Shadow', 'Pixel', 'Neon', 'Quantum', 'Cyber', 'Nova', 'Phoenix', 'Storm', 'Blaze'];
        const PLAYER_LAST_NAMES = ['Wolf', 'Hawk', 'Dragon', 'Knight', 'Hunter', 'Blade', 'Rider', 'Walker', 'Guard', 'Seeker'];
        
        function generateRandomPlayerName() {
            const first = PLAYER_FIRST_NAMES[Math.floor(Math.random() * PLAYER_FIRST_NAMES.length)];
            const last = PLAYER_LAST_NAMES[Math.floor(Math.random() * PLAYER_LAST_NAMES.length)];
            return `${first}${last}`;
        }
        
        // ===== MULTIPLAYER STATE =====
        let multiplayerState = {
            enabled: false,
            role: null, // 'host' or 'client'
            roomCode: null,
            ws: null,
            myHeroes: [], // Array of hero names this player controls
            myPlayerId: null,
            playerName: generateRandomPlayerName(),
            playerHeroes: {}, // { hero_name: { playerId, playerName } }
            connectedPlayers: [], // [ { id, hero, name } ]
            isReconnecting: false,
            // Client-only: Cache of hero stats from host broadcasts
            heroStatsCache: {
                zooko: null,
                nate: null,
                zancas: null,
                cyberaxe: null
            },
            // Client-only: Cache of gold from host
            goldCache: 0,
            // Client-only: Cache of party meals from host
            partyMealsCache: [],
            // Rolled hero stats from dice rolling (new game only)
            rolledHeroStats: {}
        };
        
        // ===== GAMEPAD SUPPORT =====
        let gamepadConnected = false;
        let gamepadIndex = null;
        let gamepadButtonStates = {};
        let gamepadAxisDeadzone = 0.25;
        let lastGamepadUpdate = 0;
        const gamepadUpdateInterval = 16; // ~60Hz polling
        
        // Button mapping (standard gamepad layout)
        const GamepadButtons = {
            A: 0,           // Bottom face button (A on Xbox, X on PlayStation)
            B: 1,           // Right face button (B on Xbox, Circle on PlayStation)
            X: 2,           // Left face button (X on Xbox, Square on PlayStation)
            Y: 3,           // Top face button (Y on Xbox, Triangle on PlayStation)
            LB: 4,          // Left bumper
            RB: 5,          // Right bumper
            LT: 6,          // Left trigger
            RT: 7,          // Right trigger
            SELECT: 8,      // Select/Back/Share
            START: 9,       // Start/Menu/Options
            L3: 10,         // Left stick button
            R3: 11,         // Right stick button
            DPAD_UP: 12,
            DPAD_DOWN: 13,
            DPAD_LEFT: 14,
            DPAD_RIGHT: 15
        };
        
        // Axis mapping
        const GamepadAxes = {
            LEFT_X: 0,
            LEFT_Y: 1,
            RIGHT_X: 2,
            RIGHT_Y: 3
        };
        // ===== END GAMEPAD SUPPORT =====
        
        // Music System
        let currentMusic = null;
        let musicEnabled = true;
        let musicVolume = 40; // Music volume (1-150)
        let sfxVolume = 50; // SFX volume (0-100, default 50%)
        let musicStarted = false;
        let currentTrackIndex = 0;
        let mainThemePlayed = false; // Track if main theme has played
        let zoneMusicEnabled = true; // Zone tracks toggle
        let themeMusicEnabled = true; // Theme songs toggle
        let musicAnimationFrameId = null;
        let currentMusicZone = -1; // Track current zone for music switching
        let userPausedMusic = false; // Track if user manually paused
        
        // ===== SFX AUDIO SYSTEM =====
        // Sound effect paths
        const SFX_PATHS = {
            // Boss sounds
            bossAttack: 'tunnelsofprivacy/sounds/bosses/Generic_boss_slashing_attack__fast_whoosh_of_a_lar.mp3',
            bossHit: 'tunnelsofprivacy/sounds/bosses/Generic_boss_melee_impact_for_a_fantasy_pixel-art_.mp3',
            bossDie: 'tunnelsofprivacy/sounds/bosses/Generic_boss_roar-into-attack__short_monstrous_roa.mp3',
            bossMagic: 'tunnelsofprivacy/sounds/bosses/Generic_boss_magical_blast_hit__rising_arcane_char.mp3',
            bossProjectile: 'tunnelsofprivacy/sounds/bosses/Generic_boss_projectile_impact__quick_air_whip__sh.mp3',
            // Mob sounds
            mobAttack: 'tunnelsofprivacy/sounds/mobs/Generic_small_mob_claw_slash_attack__fast__thin_wh.mp3',
            mobHit: 'tunnelsofprivacy/sounds/mobs/Generic_small_mob_melee_hit_for_a_fantasy_pixel-ar.mp3',
            mobDie: 'tunnelsofprivacy/sounds/mobs/Generic_small_mob_death_or_defeat_sound__brief_cre.mp3',
            mobMagic: 'tunnelsofprivacy/sounds/mobs/Generic_small_mob_magic_or_spit_projectile_impact_.mp3',
            mobGroup: 'tunnelsofprivacy/sounds/mobs/Generic_small_mob_group_hit__several_tiny_impacts_.mp3',
            // Hero sounds - Zooko
            zookoLight: 'tunnelsofprivacy/sounds/heros/Four-second_light_attack_sound_for_Zooko_in_retro_.mp3',
            zookoHeavy: 'tunnelsofprivacy/sounds/heros/Four-second_heavy_attack_sound_for_Zooko_in_retro_.mp3',
            zookoSpecial: 'tunnelsofprivacy/sounds/heros/Four-second_special_attack_sound_for_Zooko_in_retr.mp3',
            zookoHeal: 'tunnelsofprivacy/sounds/heros/Four-second_heal_sound_for_Zooko_in_a_retro_16-bit.mp3',
            zookoHit: 'tunnelsofprivacy/sounds/heros/Four-second_hit_reaction_for_Zooko_in_a_retro_16-b.mp3',
            zookoKnockout: 'tunnelsofprivacy/sounds/heros/Four-second_knockout_sound_for_Zooko__stronger_arc.mp3',
            zookoSwap: 'tunnelsofprivacy/sounds/heros/Four-second_swap-location_sound_for_Zooko__elegant.mp3',
            zookoTaunt: 'tunnelsofprivacy/sounds/heros/Four-second_taunt_sound_for_Zooko__short_confident.mp3',
            // Hero sounds - Nate
            nateLight: 'tunnelsofprivacy/sounds/heros/Four-second_light_attack_sound_for_Nate_in_retro_1.mp3',
            nateHeavy: 'tunnelsofprivacy/sounds/heros/Four-second_heavy_attack_sound_for_Nate_in_retro_1.mp3',
            nateSpecial: 'tunnelsofprivacy/sounds/heros/Four-second_special_attack_sound_for_Nate_in_retro.mp3',
            nateHeal: 'tunnelsofprivacy/sounds/heros/Four-second_heal_sound_for_Nate_in_a_retro_16-bit_.mp3',
            nateHit: 'tunnelsofprivacy/sounds/heros/Four-second_hit_reaction_for_Nate_in_a_retro_16-bi.mp3',
            nateKnockout: 'tunnelsofprivacy/sounds/heros/Four-second_knockout_sound_for_Nate__heavier_impac.mp3',
            nateSwap: 'tunnelsofprivacy/sounds/heros/Four-second_swap-location_sound_for_Nate__data-war.mp3',
            nateTaunt: 'tunnelsofprivacy/sounds/heros/Four-second_taunt_sound_for_Nate__smug_teen_hacker.mp3',
            // Hero sounds - Zancas
            zancasLight: 'tunnelsofprivacy/sounds/heros/Four-second_light_attack_sound_for_Zancas_in_retro.mp3',
            zancasHeavy: 'tunnelsofprivacy/sounds/heros/Four-second_heavy_attack_sound_for_Zancas_in_retro.mp3',
            zancasSpecial: 'tunnelsofprivacy/sounds/heros/Four-second_special_attack_sound_for_Zancas_in_ret.mp3',
            zancasHeal: 'tunnelsofprivacy/sounds/heros/Four-second_heal_sound_for_Zancas_in_a_retro_16-bi.mp3',
            zancasHit: 'tunnelsofprivacy/sounds/heros/Four-second_hit_reaction_for_Zancas_in_a_retro_16-.mp3',
            zancasKnockout: 'tunnelsofprivacy/sounds/heros/Four-second_knockout_sound_for_Zancas__heavier_bod.mp3',
            zancasSwap: 'tunnelsofprivacy/sounds/heros/Four-second_swap-location_sound_for_Zancas__spirit.mp3',
            zancasTaunt: 'tunnelsofprivacy/sounds/heros/Four-second_taunt_sound_for_Zancas__calm_but_chall.mp3',
            // Hero sounds - CyberAxe
            cyberaxeLight: 'tunnelsofprivacy/sounds/heros/Four-second_light_attack_sound_for_CyberAxe_in_ret.mp3',
            cyberaxeHeavy: 'tunnelsofprivacy/sounds/heros/Four-second_heavy_attack_sound_for_CyberAxe_in_ret.mp3',
            cyberaxeSpecial: 'tunnelsofprivacy/sounds/heros/Four-second_special_attack_sound_for_CyberAxe_in_r.mp3',
            cyberaxeHeal: 'tunnelsofprivacy/sounds/heros/Four-second_heal_sound_for_CyberAxe_in_a_retro_16-.mp3',
            cyberaxeHit: 'tunnelsofprivacy/sounds/heros/Four-second_hit_reaction_for_CyberAxe_in_a_retro_1.mp3',
            cyberaxeKnockout: 'tunnelsofprivacy/sounds/heros/Four-second_knockout_sound_for_CyberAxe__massive_a.mp3',
            cyberaxeSwap: 'tunnelsofprivacy/sounds/heros/Four-second_swap-location_sound_for_CyberAxe__heav.mp3',
            cyberaxeTaunt: 'tunnelsofprivacy/sounds/heros/Four-second_taunt_sound_for_CyberAxe__bold_warrior.mp3',
            // Camp sounds
            campEat: 'tunnelsofprivacy/sounds/camp/Four-second_fantasy_RPG_party_eating_SFX__UI_click.mp3',
            // Mob sounds
            mobAttack: 'tunnelsofprivacy/sounds/mobs/Generic_small_mob_claw_slash_attack__fast__thin_wh.mp3',
            mobHit: 'tunnelsofprivacy/sounds/mobs/Generic_small_mob_melee_hit_for_a_fantasy_pixel-ar.mp3',
            mobDie: 'tunnelsofprivacy/sounds/mobs/Generic_small_mob_death_or_defeat_sound__brief_cre.mp3',
            // Boss sounds
            bossAttack: 'tunnelsofprivacy/sounds/bosses/Generic_boss_roar-into-attack__short_monstrous_roa.mp3',
            bossHit: 'tunnelsofprivacy/sounds/bosses/Generic_boss_melee_impact_for_a_fantasy_pixel-art_.mp3',
            bossDie: 'tunnelsofprivacy/sounds/bosses/Generic_boss_magical_blast_hit__rising_arcane_char.mp3',
            // UI sounds
            uiClick: 'tunnelsofprivacy/sounds/ui/Soft__smooth_UI_button_click_for_a_fantasy_RPG_men.mp3',
            uiConfirm: 'tunnelsofprivacy/sounds/ui/Smooth_UI_confirm_accept_sound_for_a_fantasy_RPG__.mp3',
            uiCancel: 'tunnelsofprivacy/sounds/ui/Smooth_UI_back_cancel_sound_for_a_fantasy_RPG__sof.mp3',
            uiHover: 'tunnelsofprivacy/sounds/ui/Smooth_UI_hover_focus_sound_for_a_fantasy_RPG__ver.mp3',
            uiSlider: 'tunnelsofprivacy/sounds/ui/Smooth_UI_slider_or_value_change_sound_for_a_fanta.mp3'
        };
        
        // Audio pool for SFX (prevents creating new Audio objects constantly)
        const sfxPool = {};
        const SFX_POOL_SIZE = 3; // Number of audio instances per sound
        
        // Initialize SFX pool
        function initSfxPool() {
            for (const [key, path] of Object.entries(SFX_PATHS)) {
                sfxPool[key] = [];
                for (let i = 0; i < SFX_POOL_SIZE; i++) {
                    const audio = new Audio(path);
                    audio.preload = 'auto';
                    sfxPool[key].push(audio);
                }
            }
        }
        
        // Play a sound effect
        function playSfx(sfxKey) {
            if (!sfxPool[sfxKey] || sfxVolume === 0) return;
            
            // Find an available audio instance (not currently playing)
            const pool = sfxPool[sfxKey];
            let audio = pool.find(a => a.paused || a.ended);
            
            // If all are playing, use the first one (interrupt oldest)
            if (!audio) {
                audio = pool[0];
            }
            
            // Reset and play
            audio.currentTime = 0;
            audio.volume = Math.min(1.0, sfxVolume / 100);
            audio.play().catch(e => {
                // Ignore autoplay errors
            });
        }
        
        // Play hero attack sound based on hero name and attack type
        function playHeroAttackSfx(heroName, attackType) {
            const name = heroName.toLowerCase();
            let sfxKey;
            
            if (attackType === 'light') {
                sfxKey = name + 'Light';
            } else if (attackType === 'heavy') {
                sfxKey = name + 'Heavy';
            } else if (attackType === 'special') {
                sfxKey = name + 'Special';
            }
            
            if (sfxKey && sfxPool[sfxKey]) {
                playSfx(sfxKey);
            }
        }
        
        // Play enemy sound based on enemy type and action
        function playEnemySfx(enemy, action) {
            const isBoss = !enemy.isMob;
            let sfxKey;
            
            if (action === 'attack') {
                sfxKey = isBoss ? 'bossAttack' : 'mobAttack';
            } else if (action === 'hit') {
                sfxKey = isBoss ? 'bossHit' : 'mobHit';
            } else if (action === 'die') {
                sfxKey = isBoss ? 'bossDie' : 'mobDie';
            }
            
            if (sfxKey) {
                playSfx(sfxKey);
            }
        }
        // ===== END SFX AUDIO SYSTEM =====
        
        // ===== CANVAS2D PARTICLE SYSTEM =====
        // Particle system that reads JSON effect files from effect/ folder
        // Supports sprite-based particles with texture atlases
        
        const particleSystem = {
            emitters: [],           // Active particle emitters
            atlasCache: {},         // Cached atlas images
            effectCache: {},        // Cached effect JSON configs
            tintedSpriteCache: {},  // Cached pre-tinted sprites by key
            tintedSpriteCacheKeys: [], // LRU tracking for cache eviction
            MAX_TINT_CACHE: 100,    // Max cached tinted sprites
            MAX_EMITTERS: 30,       // Max concurrent emitters
            MAX_TOTAL_PARTICLES: 500, // Max total particles across all emitters
            lastTime: 0,            // For delta time calculation
            // Reusable offscreen canvas for color tinting (performance optimization)
            _offscreen: null,
            _offCtx: null,
            
            // Get or create reusable offscreen canvas
            getOffscreenCanvas(size) {
                const needed = Math.ceil(size);
                if (!this._offscreen || this._offscreen.width < needed || this._offscreen.height < needed) {
                    this._offscreen = document.createElement('canvas');
                    this._offscreen.width = Math.max(needed, 128);
                    this._offscreen.height = Math.max(needed, 128);
                    this._offCtx = this._offscreen.getContext('2d');
                }
                return { canvas: this._offscreen, ctx: this._offCtx, size: needed };
            },
            
            // Load an effect JSON file
            async loadEffect(effectPath) {
                if (this.effectCache[effectPath]) {
                    return this.effectCache[effectPath];
                }
                
                try {
                    const response = await fetch(effectPath);
                    if (!response.ok) throw new Error(`Failed to load ${effectPath}`);
                    const effectData = await response.json();
                    this.effectCache[effectPath] = effectData;
                    
                    // Preload atlas if sprite-based
                    if (effectData.atlasPath && effectData.particleType === 'sprite') {
                        await this.loadAtlas(effectData.atlasPath);
                    }
                    
                    return effectData;
                } catch (err) {
                    console.error('Failed to load particle effect:', effectPath, err);
                    return null;
                }
            },
            
            // Load atlas image
            loadAtlas(atlasPath) {
                return new Promise((resolve, reject) => {
                    if (this.atlasCache[atlasPath]) {
                        resolve(this.atlasCache[atlasPath]);
                        return;
                    }
                    
                    const img = new Image();
                    img.onload = () => {
                        this.atlasCache[atlasPath] = img;
                        resolve(img);
                    };
                    img.onerror = () => {
                        console.error('Failed to load particle atlas:', atlasPath);
                        reject(new Error(`Failed to load ${atlasPath}`));
                    };
                    img.src = atlasPath;
                });
            },
            
            // Spawn a particle effect at a position
            async spawn(effectPath, x, y, options = {}) {
                // Enforce emitter limit
                if (this.emitters.length >= this.MAX_EMITTERS) {
                    console.warn('Max emitters reached, skipping spawn');
                    return null;
                }
                
                const effectData = await this.loadEffect(effectPath);
                if (!effectData) return null;
                
                const emitter = {
                    id: Date.now() + Math.random(),
                    effectData: effectData,
                    x: x,
                    y: y,
                    scale: options.scale || 1,
                    rotation: options.rotation || 0,
                    particles: [],
                    emitTimer: 0,
                    emitDuration: effectData.emitDuration || 1,
                    emitElapsed: 0,
                    active: true,
                    loop: options.loop || false, // NEW: Loop the emitter
                    followTarget: options.followTarget || null, // NEW: Object with x,y to follow
                    onComplete: options.onComplete || null,
                    colorOverride: options.colorOverride || null // NEW: Override particle color with enchantment
                };
                
                this.emitters.push(emitter);
                return emitter;
            },
            
            // Spawn a looping particle effect that follows a target
            async spawnLooping(effectPath, target, options = {}) {
                return await this.spawn(effectPath, target.x || 0, target.y || 0, {
                    ...options,
                    loop: true,
                    followTarget: target
                });
            },
            
            // Spawn a projectile particle effect that travels from start to end
            async spawnProjectile(effectPath, startX, startY, endX, endY, options = {}) {
                const effectData = await this.loadEffect(effectPath);
                if (!effectData) return null;
                
                // Calculate direction and distance
                const dx = endX - startX;
                const dy = endY - startY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const duration = options.duration || 0.5; // Time to travel in seconds
                
                // Calculate velocity needed to reach target in duration
                const speed = distance / duration;
                const dirX = dx / distance;
                const dirY = dy / distance;
                
                // Create a modified effect data with overridden velocity
                const projectileEffectData = {
                    ...effectData,
                    // Override velocity direction to point at target
                    velocityDirX: dirX * speed / 20, // Divide by WORLD_TO_PIXEL since createParticle multiplies
                    velocityDirY: dirY * speed / 20,
                    velocity: 0, // Use velocityDir directly, no random spread velocity
                    spread: options.spread !== undefined ? options.spread : 15, // Small spread for variation
                    emitDuration: duration * 0.8, // Emit for 80% of travel time
                    lifetime: duration * 1.2 // Particles live slightly longer than travel
                };
                
                const emitter = {
                    id: Date.now() + Math.random(),
                    effectData: projectileEffectData,
                    x: startX,
                    y: startY,
                    scale: options.scale || 1,
                    rotation: options.rotation || 0,
                    particles: [],
                    emitTimer: 0,
                    emitDuration: projectileEffectData.emitDuration,
                    emitElapsed: 0,
                    active: true,
                    loop: false,
                    followTarget: null,
                    isProjectile: true,
                    targetX: endX,
                    targetY: endY,
                    onComplete: options.onComplete || null,
                    colorOverride: options.colorOverride || null
                };
                
                this.emitters.push(emitter);
                return emitter;
            },
            
            // Spawn a rising particle effect that moves from bottom to top (for heavy attacks)
            async spawnRising(effectPath, x, y, options = {}) {
                const effectData = await this.loadEffect(effectPath);
                if (!effectData) return null;
                
                const duration = options.duration || 2.0; // Time to rise in seconds
                const riseDistance = options.riseDistance || 300; // Pixels to rise
                const speed = riseDistance / duration;
                
                // Create a modified effect data with upward velocity
                const risingEffectData = {
                    ...effectData,
                    // Override velocity to go straight up (negative Y)
                    velocityDirX: 0,
                    velocityDirY: -speed / 20, // Negative Y = upward, divide by WORLD_TO_PIXEL
                    velocity: 0, // Use velocityDir directly
                    spread: options.spread !== undefined ? options.spread : 20, // Some horizontal spread
                    emitDuration: duration * 0.6, // Emit for 60% of rise time
                    lifetime: duration * 1.5, // Particles live longer to rise off screen
                    gravity: effectData.gravity ? effectData.gravity * 0.3 : 0 // Reduce gravity effect
                };
                
                const emitter = {
                    id: Date.now() + Math.random(),
                    effectData: risingEffectData,
                    x: x,
                    y: y, // Start at bottom of target
                    scale: options.scale || 1,
                    rotation: options.rotation || 0,
                    particles: [],
                    emitTimer: 0,
                    emitDuration: risingEffectData.emitDuration,
                    emitElapsed: 0,
                    active: true,
                    loop: false,
                    followTarget: null,
                    isRising: true,
                    onComplete: options.onComplete || null,
                    colorOverride: options.colorOverride || null
                };
                
                this.emitters.push(emitter);
                return emitter;
            },
            
            // Stop a specific emitter
            stopEmitter(emitter) {
                if (emitter) {
                    emitter.active = false;
                    emitter.loop = false;
                }
            },
            
            // Remove emitter by id
            removeEmitter(emitterId) {
                const index = this.emitters.findIndex(e => e.id === emitterId);
                if (index !== -1) {
                    this.emitters.splice(index, 1);
                }
            },
            
            // Create a single particle
            createParticle(emitter) {
                const ed = emitter.effectData;
                const scale = emitter.scale;
                
                // Scale factor to convert 3D world units to pixels
                const WORLD_TO_PIXEL = 20;
                
                // Calculate velocity (matching arcade particle editor)
                const spreadRad = (ed.spread || 0) * Math.PI / 180;
                const theta = (Math.random() - 0.5) * spreadRad;
                
                // Base direction with velocity magnitude
                const baseVelX = (ed.velocityDirX || 0) * WORLD_TO_PIXEL;
                const baseVelY = (ed.velocityDirY || 0) * WORLD_TO_PIXEL;
                const velocity = (ed.velocity || 0) * WORLD_TO_PIXEL;
                
                // Add spread randomness (matching arcade)
                const velX = baseVelX + Math.sin(theta) * velocity;
                const velY = baseVelY + Math.cos(theta) * velocity;
                
                // Parse colors - use enchantment color override if provided
                let startColor, endColor;
                if (emitter.colorOverride) {
                    // Use enchantment color for both start and end (brighter start, dimmer end)
                    const baseColor = this.parseColor(emitter.colorOverride);
                    startColor = baseColor;
                    // Create slightly dimmer end color
                    endColor = {
                        r: Math.floor(baseColor.r * 0.6),
                        g: Math.floor(baseColor.g * 0.6),
                        b: Math.floor(baseColor.b * 0.6)
                    };
                } else {
                    startColor = this.parseColor(ed.colorStart || '#ffffff');
                    endColor = this.parseColor(ed.colorEnd || '#ffffff');
                }
                
                // Calculate initial rotation (matching arcade)
                const spawnRotationRad = ((ed.spawnRotation || 0) * Math.PI) / 180;
                const initialRotation = ed.randomRotation ? Math.random() * Math.PI * 2 : spawnRotationRad;
                const rotSpeed = ed.randomRotationSpeed ? (ed.rotationSpeed || 0) * (Math.random() - 0.5) : (ed.rotationSpeed || 0);
                
                // Turbulence per particle (matching arcade) - scaled to pixels
                const turbulence = {
                    x: (Math.random() - 0.5) * (ed.turbulence || 0) * WORLD_TO_PIXEL,
                    y: (Math.random() - 0.5) * (ed.turbulence || 0) * WORLD_TO_PIXEL
                };
                
                return {
                    // Offset from emitter position
                    offsetX: 0,
                    offsetY: 0,
                    // Velocity
                    velX: velX,
                    velY: velY,
                    // Turbulence (added to velocity each frame)
                    turbulence: turbulence,
                    // Lifecycle
                    life: 0,
                    maxLife: ed.lifetime || 1,
                    dead: false,
                    // Size (in world units, scaled by emitter.scale when rendering)
                    sizeStart: ed.sizeStart || 1,
                    sizeEnd: ed.sizeEnd || 1,
                    // Color
                    startColor: startColor,
                    endColor: endColor,
                    // Opacity
                    opacityStart: ed.opacityStart !== undefined ? ed.opacityStart : 1,
                    opacityEnd: ed.opacityEnd !== undefined ? ed.opacityEnd : 0,
                    // Rotation
                    rotation: initialRotation,
                    rotationSpeed: rotSpeed
                };
            },
            
            // Parse hex color to {r, g, b}
            parseColor(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                if (result) {
                    return {
                        r: parseInt(result[1], 16),
                        g: parseInt(result[2], 16),
                        b: parseInt(result[3], 16)
                    };
                }
                // Try short hex
                const short = /^#?([a-f\d])([a-f\d])([a-f\d])$/i.exec(hex);
                if (short) {
                    return {
                        r: parseInt(short[1] + short[1], 16),
                        g: parseInt(short[2] + short[2], 16),
                        b: parseInt(short[3] + short[3], 16)
                    };
                }
                return { r: 255, g: 255, b: 255 };
            },
            
            // Interpolate between two values
            lerp(a, b, t) {
                return a + (b - a) * t;
            },
            
            // Update all emitters and particles
            update(deltaTime) {
                const dt = deltaTime / 1000; // Convert to seconds
                
                for (let i = this.emitters.length - 1; i >= 0; i--) {
                    const emitter = this.emitters[i];
                    if (!emitter.active) {
                        // Remove inactive non-looping emitters with no particles
                        if (!emitter.loop && emitter.particles.length === 0) {
                            this.emitters.splice(i, 1);
                        }
                        continue;
                    }
                    
                    const ed = emitter.effectData;
                    
                    // Update emitter position if following a target
                    if (emitter.followTarget) {
                        emitter.x = emitter.followTarget.x || emitter.x;
                        emitter.y = emitter.followTarget.y || emitter.y;
                        // Update scale based on target's depth
                        if (emitter.followTarget.y !== undefined && battleState?.canvas?.height) {
                            emitter.scale = 0.6 + (emitter.followTarget.y / battleState.canvas.height) * 0.4;
                        }
                    }
                    
                    // Emit new particles (matching arcade logic)
                    if (emitter.emitElapsed < emitter.emitDuration) {
                        // Accumulator pattern: emissionRate = particles per second
                        emitter.particleAccumulator = (emitter.particleAccumulator || 0) + (ed.emissionRate || 1) * dt;
                        
                        // Count total particles across all emitters for global limit
                        const totalParticles = this.emitters.reduce((sum, e) => sum + e.particles.length, 0);
                        
                        // Emit particles while accumulator >= 1, capped at particleCount max AND global limit
                        while (emitter.particleAccumulator >= 1 && 
                               emitter.particles.length < (ed.particleCount || 10) &&
                               totalParticles + emitter.particles.length < this.MAX_TOTAL_PARTICLES) {
                            emitter.particles.push(this.createParticle(emitter));
                            emitter.particleAccumulator -= 1;
                        }
                        emitter.emitElapsed += dt;
                    } else if (emitter.loop) {
                        // Reset for looping
                        emitter.emitElapsed = 0;
                        emitter.particleAccumulator = 0;
                    }
                    
                    // Update particles (matching arcade logic)
                    // Scale factor to convert 3D world units to pixels
                    const WORLD_TO_PIXEL = 20;
                    
                    for (let j = emitter.particles.length - 1; j >= 0; j--) {
                        const p = emitter.particles[j];
                        p.life += dt;
                        
                        // Remove dead particles
                        if (p.life >= p.maxLife) {
                            p.dead = true;
                            emitter.particles.splice(j, 1);
                            continue;
                        }
                        
                        // Update velocity with turbulence (matching arcade)
                        p.velX += p.turbulence.x * dt;
                        p.velY += p.turbulence.y * dt;
                        
                        // Apply gravity to velocity (scaled to pixels)
                        p.velY += (ed.gravity || 0) * WORLD_TO_PIXEL * dt;
                        
                        // Update offset from emitter position (matching arcade)
                        p.offsetX += p.velX * dt;
                        p.offsetY += p.velY * dt;
                        
                        // Update rotation
                        p.rotation += p.rotationSpeed * dt;
                    }
                    
                    // Remove completed non-looping emitters
                    if (!emitter.loop && emitter.emitElapsed >= emitter.emitDuration && emitter.particles.length === 0) {
                        if (emitter.onComplete) emitter.onComplete();
                        this.emitters.splice(i, 1);
                    }
                }
            },
            
            // Render all particles to a canvas context
            render(ctx) {
                ctx.save();
                
                for (const emitter of this.emitters) {
                    const ed = emitter.effectData;
                    const atlas = ed.atlasPath ? this.atlasCache[ed.atlasPath] : null;
                    const isSprite = ed.particleType === 'sprite' && atlas;
                    
                    // Set blend mode
                    if (ed.blendMode === 'additive') {
                        ctx.globalCompositeOperation = 'lighter';
                    } else {
                        ctx.globalCompositeOperation = 'source-over';
                    }
                    
                    for (const p of emitter.particles) {
                        if (p.dead) continue;
                        
                        const t = p.life / p.maxLife; // 0 to 1 progress
                        
                        // Interpolate size (scaled by emitter scale)
                        // Multiply by 20 to convert from 3D world units to reasonable pixel sizes
                        const size = this.lerp(p.sizeStart, p.sizeEnd, t) * emitter.scale * 20;
                        if (size <= 0) continue;
                        
                        // Interpolate opacity
                        const opacity = this.lerp(p.opacityStart, p.opacityEnd, t);
                        if (opacity <= 0) continue;
                        
                        // Interpolate color
                        const r = Math.floor(this.lerp(p.startColor.r, p.endColor.r, t));
                        const g = Math.floor(this.lerp(p.startColor.g, p.endColor.g, t));
                        const b = Math.floor(this.lerp(p.startColor.b, p.endColor.b, t));
                        
                        // Calculate world position (emitter position + particle offset)
                        const worldX = emitter.x + p.offsetX * emitter.scale;
                        const worldY = emitter.y + p.offsetY * emitter.scale;
                        
                        ctx.save();
                        ctx.translate(worldX, worldY);
                        ctx.rotate(p.rotation);
                        ctx.globalAlpha = opacity;
                        
                        if (isSprite) {
                            // Draw sprite from atlas using UV coordinates
                            // Flip Y coordinate to match arcade/editor orientation
                            const uvX = ed.uvStartX || 0;
                            const uvY = ed.uvStartY || 0;
                            const uvW = (ed.uvEndX || 1) - uvX;
                            const uvH = (ed.uvEndY || 1) - uvY;
                            
                            // Flip Y axis to match editor
                            const flippedUvY = 1 - uvY - uvH;
                            
                            const srcX = uvX * atlas.width;
                            const srcY = flippedUvY * atlas.height;
                            const srcW = uvW * atlas.width;
                            const srcH = uvH * atlas.height;
                            
                            // Generate cache key for this tinted sprite
                            const blendKey = ed.blendMode === 'additive' ? 'a' : 'm';
                            const cacheKey = `${ed.atlasPath}_${Math.round(srcX)}_${Math.round(srcY)}_${size}_${r}_${g}_${b}_${blendKey}`;
                            
                            let tintedCanvas = this.tintedSpriteCache[cacheKey];
                            
                            if (!tintedCanvas) {
                                // Create and cache the tinted sprite
                                tintedCanvas = document.createElement('canvas');
                                tintedCanvas.width = size;
                                tintedCanvas.height = size;
                                const tintCtx = tintedCanvas.getContext('2d');
                                
                                // Draw sprite to canvas
                                tintCtx.globalCompositeOperation = 'source-over';
                                tintCtx.drawImage(
                                    atlas,
                                    srcX, srcY, srcW, srcH,
                                    0, 0, size, size
                                );
                                
                                // Apply color tint
                                if (ed.blendMode === 'additive') {
                                    tintCtx.globalCompositeOperation = 'lighter';
                                } else {
                                    tintCtx.globalCompositeOperation = 'multiply';
                                }
                                tintCtx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                                tintCtx.fillRect(0, 0, size, size);
                                
                                // Restore alpha from original sprite
                                tintCtx.globalCompositeOperation = 'destination-in';
                                tintCtx.drawImage(
                                    atlas,
                                    srcX, srcY, srcW, srcH,
                                    0, 0, size, size
                                );
                                
                                // Cache it with LRU eviction
                                this.tintedSpriteCache[cacheKey] = tintedCanvas;
                                this.tintedSpriteCacheKeys.push(cacheKey);
                                
                                // Evict oldest if over limit
                                if (this.tintedSpriteCacheKeys.length > this.MAX_TINT_CACHE) {
                                    const oldKey = this.tintedSpriteCacheKeys.shift();
                                    delete this.tintedSpriteCache[oldKey];
                                }
                            }
                            
                            // Draw the cached tinted sprite to main canvas (single drawImage!)
                            ctx.drawImage(tintedCanvas, -size / 2, -size / 2);
                        } else {
                            // Draw colored circle fallback
                            ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                            ctx.beginPath();
                            ctx.arc(0, 0, size / 2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        ctx.restore();
                    }
                }
                
                ctx.restore();
            },
            
            // Clear all particles
            clear() {
                this.emitters = [];
            },
            
            // Check if any particles are active
            hasActiveParticles() {
                return this.emitters.length > 0;
            }
        };
        
        // Helper function to spawn effect by name
        async function spawnParticleEffect(effectName, x, y, scale = 1) {
            const effectPath = `effect/${effectName}.json`;
            return await particleSystem.spawn(effectPath, x, y, { scale: scale });
        }
        
        // Preload common particle effects
        async function preloadParticleEffects() {
            const commonEffects = [
                'effect/red_break_a.json',
                'effect/blue_break_a.json',
                'effect/green_break_a.json',
                'effect/yellow_break_a.json',
                'effect/combo_a.json',
                'effect/zooko_special.json',
                'effect/nate_special.json',
                'effect/zancas_special.json',
                'effect/cyberaxe_electric.json',
                // Hero idle effects
                'tunnelsofprivacy/effects/heros/zooko_idle.json',
                'tunnelsofprivacy/effects/heros/nate_idle.json',
                'tunnelsofprivacy/effects/heros/zancas_idle.json',
                'tunnelsofprivacy/effects/heros/cyberaxe_idle.json',
                // Hero light attack effects
                'tunnelsofprivacy/effects/heros/zooko_light_attack.json',
                'tunnelsofprivacy/effects/heros/nate_light_attack.json',
                'tunnelsofprivacy/effects/heros/zancas_light_attack.json',
                'tunnelsofprivacy/effects/heros/cyberaxe_light_attack.json',
                // Hero heavy attack effects
                'tunnelsofprivacy/effects/heros/zooko_heavy_attack.json',
                'tunnelsofprivacy/effects/heros/nate_heavy_attack.json',
                'tunnelsofprivacy/effects/heros/zancas_heavy_attack.json',
                'tunnelsofprivacy/effects/heros/cyberaxe_heavy_attack.json',
                // Hero special attack effects
                'tunnelsofprivacy/effects/heros/zooko_special_attack.json',
                'tunnelsofprivacy/effects/heros/nate_special_attack.json',
                'tunnelsofprivacy/effects/heros/zancas_special_attack.json',
                'tunnelsofprivacy/effects/heros/cyberaxe_special_attack.json',
                // Mob attack effects
                'tunnelsofprivacy/effects/mobs/mob_light_attack_a.json',
                'tunnelsofprivacy/effects/mobs/mob_light_attack_b.json',
                'tunnelsofprivacy/effects/mobs/mob_light_attack_c.json',
                'tunnelsofprivacy/effects/mobs/mob_light_attack_d.json',
                'tunnelsofprivacy/effects/mobs/mob_light_attack_e.json',
                'tunnelsofprivacy/effects/mobs/mob_heavy_attack_a.json',
                'tunnelsofprivacy/effects/mobs/mob_heavy_attack_b.json',
                'tunnelsofprivacy/effects/mobs/mob_heavy_attack_c.json',
                'tunnelsofprivacy/effects/mobs/mob_heavy_attack_d.json',
                'tunnelsofprivacy/effects/mobs/mob_heavy_attack_e.json'
            ];
            
            for (const effectPath of commonEffects) {
                try {
                    await particleSystem.loadEffect(effectPath);
                } catch (e) {
                    // Effect may not exist, that's ok
                }
            }
        }
        
        // Hero idle particle emitters (stored per hero)
        const heroIdleEmitters = {};
        
        // Per-hero Y offset for idle particles (adjust position relative to hero sprite)
        const heroIdleParticleOffsets = {
            zooko: 0,
            nate: 0,
            zancas: 30, // Lower on Zancas
            cyberaxe: 0
        };
        
        // Per-hero offset for projectile attack start position (x, y offsets from hero position)
        const heroProjectileOffsets = {
            zooko: { x: 0, y: 0 },
            nate: { x: 0, y: 60 },        // Down 60px
            zancas: { x: 40, y: 60 },     // Down 60px, right 40px
            cyberaxe: { x: -40, y: 40 }   // Down 40px, left 40px
        };
        
        // Get enchantment color for a hero (returns null if no enchantment)
        function getHeroEnchantmentColor(heroName) {
            const key = heroName.toLowerCase();
            const weapon = heroWeapons[key];
            if (!weapon || !weapon.enchantment) return null;
            
            const enchant = ENCHANTMENTS.find(e => e.id === weapon.enchantment);
            return enchant ? enchant.color : null;
        }
        
        // Mob attack particle effects (randomly selected)
        const MOB_LIGHT_ATTACK_EFFECTS = [
            'tunnelsofprivacy/effects/mobs/mob_light_attack_a.json',
            'tunnelsofprivacy/effects/mobs/mob_light_attack_b.json',
            'tunnelsofprivacy/effects/mobs/mob_light_attack_c.json',
            'tunnelsofprivacy/effects/mobs/mob_light_attack_d.json',
            'tunnelsofprivacy/effects/mobs/mob_light_attack_e.json'
        ];
        
        const MOB_HEAVY_ATTACK_EFFECTS = [
            'tunnelsofprivacy/effects/mobs/mob_heavy_attack_a.json',
            'tunnelsofprivacy/effects/mobs/mob_heavy_attack_b.json',
            'tunnelsofprivacy/effects/mobs/mob_heavy_attack_c.json',
            'tunnelsofprivacy/effects/mobs/mob_heavy_attack_d.json',
            'tunnelsofprivacy/effects/mobs/mob_heavy_attack_e.json'
        ];
        
        // Small mobs (rat-sized) - these render at 40% normal size
        const SMALL_MOB_IDS = [
            'rat1', 'beetle2', 'creature1', 'creature2', 'creature3', 
            'creature4', 'creature5', 'insect1', 'mite1', 'spider1',
            'worm1', 'moth1', 'moth2'
        ];
        
        // Start looping particle effects on all heroes
        async function startHeroIdleParticles() {
            // Stop any existing emitters first
            stopHeroIdleParticles();
            
            for (const hero of battleState.heroes) {
                const heroName = hero.name.toLowerCase();
                const effectPath = `tunnelsofprivacy/effects/heros/${heroName}_idle.json`;
                const yOffset = heroIdleParticleOffsets[heroName] || 0;
                
                // Get enchantment color for this hero (if any)
                const enchantColor = getHeroEnchantmentColor(heroName);
                
                // Create a target object with offset
                const particleTarget = {
                    get x() { return hero.x; },
                    get y() { return hero.y + yOffset; }
                };
                
                try {
                    const emitter = await particleSystem.spawnLooping(effectPath, particleTarget, {
                        scale: 1.0, // Will auto-scale based on hero depth
                        colorOverride: enchantColor // Apply enchantment color
                    });
                    if (emitter) {
                        heroIdleEmitters[heroName] = emitter;
                    }
                } catch (e) {
                    console.error(`Failed to start idle particles for ${heroName}:`, e);
                }
            }
        }
        
        // Stop all hero idle particle effects
        function stopHeroIdleParticles() {
            for (const [heroName, emitter] of Object.entries(heroIdleEmitters)) {
                if (emitter) {
                    particleSystem.stopEmitter(emitter);
                }
            }
            // Clear the references
            for (const key of Object.keys(heroIdleEmitters)) {
                delete heroIdleEmitters[key];
            }
        }
        
        // Stop idle particles for a specific hero (e.g., when they die or retreat)
        function stopHeroIdleParticle(heroName) {
            const key = heroName.toLowerCase();
            if (heroIdleEmitters[key]) {
                particleSystem.stopEmitter(heroIdleEmitters[key]);
                delete heroIdleEmitters[key];
            }
        }
        // ===== END CANVAS2D PARTICLE SYSTEM =====
        
        // Asset loading tracking
        let assetsToLoad = 0;
        let assetsLoaded = 0;
        let artTotal = 0;
        let artLoaded = 0;
        let audioTotal = 0;
        let audioLoaded = 0;
        let allAssetsReady = false;
        
        // Ticker facts system
        let tickerFacts = [];
        let currentTickerFact = '';
        
        // Game state
        let isPaused = false;
        let currentScreen = 'title'; // 'title', 'dungeonMenu', 'exploration'
        
        // Load ticker facts from JSON file
        fetch('ticker_facts.json')
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                tickerFacts = data.facts;
                
                // Pick initial random fact
                if (tickerFacts.length > 0) {
                    currentTickerFact = tickerFacts[Math.floor(Math.random() * tickerFacts.length)];
                }
            })
            .catch(err => {});
        
        // ===== STORY INTRO BACKGROUND ANIMATION =====
        // intro_a.png is 8x16 atlas (128 frames) at 16fps
        let storyIntroCurrentFrame = 0;
        let storyIntroDirection = 1; // 1 = forward, -1 = backward (ping-pong)
        let storyIntroIntervalId = null;
        const INTRO_COLS = 8;
        const INTRO_ROWS = 16;
        const INTRO_TOTAL_FRAMES = 128;
        const INTRO_FPS = 16;
        
        function startStoryIntroAnimation() {
            const bgElement = document.getElementById('storyIntroBackground');
            if (!bgElement) return;
            
            // Use dungeon intro animation
            const imageFile = 'story/intro/intro_a.png';
            
            // Set intro_a atlas as background
            bgElement.style.backgroundImage = `url('${imageFile}')`;
            bgElement.style.backgroundSize = `${INTRO_COLS * 100}% ${INTRO_ROWS * 100}%`;
            bgElement.style.opacity = '1';
            
            // Start frame animation at 16fps
            const frameInterval = 1000 / INTRO_FPS; // ~62.5ms per frame
            storyIntroIntervalId = window.setInterval(() => {
                // Calculate current frame position in atlas
                const col = storyIntroCurrentFrame % INTRO_COLS;
                const row = Math.floor(storyIntroCurrentFrame / INTRO_COLS);
                
                // Set background position to show current frame
                const xPercent = (col / (INTRO_COLS - 1)) * 100;
                const yPercent = (row / (INTRO_ROWS - 1)) * 100;
                bgElement.style.backgroundPosition = `${xPercent}% ${yPercent}%`;
                
                // Advance frame with ping-pong
                storyIntroCurrentFrame += storyIntroDirection;
                
                // Reverse at boundaries (ping-pong mode)
                if (storyIntroCurrentFrame >= INTRO_TOTAL_FRAMES - 1) {
                    storyIntroCurrentFrame = INTRO_TOTAL_FRAMES - 1;
                    storyIntroDirection = -1;
                } else if (storyIntroCurrentFrame <= 0) {
                    storyIntroCurrentFrame = 0;
                    storyIntroDirection = 1;
                }
            }, frameInterval);
        }
        
        function stopStoryIntroAnimation() {
            if (storyIntroIntervalId) {
                window.clearInterval(storyIntroIntervalId);
                storyIntroIntervalId = null;
            }
        }
        // ===== END STORY INTRO BACKGROUND ANIMATION =====
        
        // ===== SPRITE SHEET ANIMATION SYSTEM =====
        // Supports 9x9 atlas (81 frames), 16fps, ping-pong/loop/once modes
        // Used for heroes, mobs, bosses in battle
        
        const ANIM_GRID_SIZE = 9; // 9x9 grid (default for heroes)
        const ANIM_TOTAL_FRAMES = 81;
        const ANIM_DEFAULT_FPS = 16;
        
        // Boss animation configurations (grid size differs from heroes)
        // Format: { cols, rows, totalFrames }
        const BOSS_ANIM_CONFIG = {
            'lvl100': { cols: 5, rows: 19, totalFrames: 95, frameSize: 768 }
        };
        
        // Hero animation configurations for non-standard sprite sheets
        // Format: { heroName: { animState: { cols, rows, totalFrames, frameSize } } }
        const HERO_ANIM_CONFIG = {
            zancas: {
                taunt: { cols: 5, rows: 19, totalFrames: 95, frameSize: 768 }
            }
        };
        
        // Boss animation state paths
        const BOSS_ANIM_PATHS = {
            'lvl100': {
                idle: 'tunnelsofprivacy/bosses/lvl100/boss_lvl100_idle.png',
                attack: 'tunnelsofprivacy/bosses/lvl100/boss_lvl100_attack.png'
            }
        };
        
        // Animation state paths for heroes
        // States can be a single path (string) or array of variants for random selection
        const HERO_ANIM_PATHS = {
            zooko: { 
                idle: [
                    'tunnelsofprivacy/heros/zooko_idle.png',
                    'tunnelsofprivacy/heros/zooko_idle_a.png',
                    'tunnelsofprivacy/heros/zooko_idle_b.png'
                ],
                light_attack: 'tunnelsofprivacy/heros/zooko_light_attack.png',
                heavy_attack: 'tunnelsofprivacy/heros/zooko_heavy_attack.png',
                special_attack: 'tunnelsofprivacy/heros/zooko_special_attack.png',
                knockout: 'tunnelsofprivacy/heros/zooko_knockout.png',
                hit: 'tunnelsofprivacy/heros/zooko_hit.png',
                defend: 'tunnelsofprivacy/heros/zooko_def.png',
                taunt: 'tunnelsofprivacy/heros/zooko_taunt.png'
            },
            nate: { 
                idle: [
                    'tunnelsofprivacy/heros/nate_idle.png',
                    'tunnelsofprivacy/heros/nate_idle_a.png',
                    'tunnelsofprivacy/heros/nate_idle_b.png',
                    'tunnelsofprivacy/heros/nate_idle_c.png'
                ],
                light_attack: 'tunnelsofprivacy/heros/nate_light_attack.png',
                heavy_attack: 'tunnelsofprivacy/heros/nate_heavy_attack.png',
                special_attack: [
                    'tunnelsofprivacy/heros/nate_special_attack.png',
                    'tunnelsofprivacy/heros/nate_special_attack_a.png'
                ],
                knockout: 'tunnelsofprivacy/heros/nate_knockout.png',
                hit: 'tunnelsofprivacy/heros/nate_hit.png',
                defend: 'tunnelsofprivacy/heros/nate_def.png',
                heal: 'tunnelsofprivacy/heros/nate_heal.png',
                taunt: 'tunnelsofprivacy/heros/nate_taunt.png',
                myturn: 'tunnelsofprivacy/heros/nate_myturn.png'
            },
            zancas: { 
                idle: [
                    'tunnelsofprivacy/heros/zancas_idle.png',
                    'tunnelsofprivacy/heros/zancas_idle_a.png',
                    'tunnelsofprivacy/heros/zancas_idle_b.png'
                ],
                light_attack: 'tunnelsofprivacy/heros/zancas_light_attack.png',
                heavy_attack: 'tunnelsofprivacy/heros/zancas_heavy_attack.png',
                special_attack: 'tunnelsofprivacy/heros/zancas_special_attack.png',
                knockout: 'tunnelsofprivacy/heros/zancas_knockout.png',
                hit: 'tunnelsofprivacy/heros/zancas_hit.png',
                defend: 'tunnelsofprivacy/heros/zancas_def.png',
                heal: 'tunnelsofprivacy/heros/zancas_heal.png',
                taunt: 'tunnelsofprivacy/heros/zancas_taunt.png'
            },
            cyberaxe: { 
                idle: [
                    'tunnelsofprivacy/heros/cyberaxe_idle.png',
                    'tunnelsofprivacy/heros/cyberaxe_idle_a.png',
                    'tunnelsofprivacy/heros/cyberaxe_idle_b.png'
                ],
                light_attack: 'tunnelsofprivacy/heros/cyberaxe_light_attack.png',
                heavy_attack: 'tunnelsofprivacy/heros/cyberaxe_heavy_attack.png',
                special_attack: 'tunnelsofprivacy/heros/cyberaxe_special_attack.png',
                knockout: 'tunnelsofprivacy/heros/cyberaxe_knockout.png',
                hit: 'tunnelsofprivacy/heros/cyberaxe_hit.png',
                defend: 'tunnelsofprivacy/heros/cyberaxe_def.png'
            }
        };
        
        // Cache for loaded sprite sheets
        const spriteSheetCache = {};
        
        // Load a sprite sheet (lazy load with caching)
        function loadSpriteSheet(path) {
            if (spriteSheetCache[path]) {
                return Promise.resolve(spriteSheetCache[path]);
            }
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    spriteSheetCache[path] = img;
                    resolve(img);
                };
                img.onerror = reject;
                img.src = path + '?v=' + Date.now();
            });
        }
        
        // Initialize animation controller for a combatant
        function initAnimation(combatant, sheetPath, playMode = 'pingpong') {
            combatant.anim = {
                sheet: null,
                sheetPath: sheetPath,
                frameSize: 0,       // Auto-calculated from sheet
                frame: 0,           // Current frame
                fps: ANIM_DEFAULT_FPS,
                lastTime: 0,        // Last frame update timestamp
                direction: 1,       // 1 = forward, -1 = reverse
                playMode: playMode, // 'pingpong', 'loop', 'once'
                state: 'idle',
                playing: true,
                onComplete: null,   // Callback when animation completes (for 'once' mode)
                // Grid config (default to hero 9x9, can be overridden for bosses)
                gridCols: ANIM_GRID_SIZE,
                gridRows: ANIM_GRID_SIZE,
                totalFrames: ANIM_TOTAL_FRAMES
            };
            
            // Check if this is a boss with custom animation config
            if (combatant.isBoss && combatant.bossLevel) {
                const bossKey = 'lvl' + combatant.bossLevel;
                const bossConfig = BOSS_ANIM_CONFIG[bossKey];
                if (bossConfig) {
                    combatant.anim.gridCols = bossConfig.cols;
                    combatant.anim.gridRows = bossConfig.rows;
                    combatant.anim.totalFrames = bossConfig.totalFrames;
                    combatant.anim.frameSize = bossConfig.frameSize; // Fixed frame size for bosses
                }
            }
            
            // Load the sprite sheet
            loadSpriteSheet(sheetPath).then(sheet => {
                combatant.anim.sheet = sheet;
                // Only auto-calculate frameSize if not already set (bosses have fixed size)
                if (!combatant.anim.frameSize) {
                    combatant.anim.frameSize = sheet.width / combatant.anim.gridCols;
                }
            }).catch(err => {
                console.error('Failed to load sprite sheet:', sheetPath, err);
            });
        }
        
        // Update animation frame based on elapsed time
        function updateAnimation(combatant, currentTime) {
            const anim = combatant.anim;
            if (!anim || !anim.sheet || !anim.playing) return;
            
            // Initialize lastTime on first call
            if (anim.lastTime === 0) {
                anim.lastTime = currentTime;
                return;
            }
            
            const frameInterval = 1000 / anim.fps;
            const elapsed = currentTime - anim.lastTime;
            
            if (elapsed >= frameInterval) {
                anim.lastTime = currentTime - (elapsed % frameInterval);
                
                // Advance frame
                anim.frame += anim.direction;
                
                // Use per-combatant totalFrames (default 81 for heroes, 95 for lvl100 boss)
                const totalFrames = anim.totalFrames || ANIM_TOTAL_FRAMES;
                
                // Handle boundaries based on play mode
                if (anim.playMode === 'pingpong') {
                    if (anim.frame >= totalFrames - 1) {
                        anim.frame = totalFrames - 1;
                        anim.direction = -1;
                    } else if (anim.frame <= 0) {
                        anim.frame = 0;
                        const wasReversing = anim.direction === -1;
                        anim.direction = 1;
                        // Cycle complete (just finished reversing) - pick new random variant
                        if (wasReversing && anim.state === 'idle') {
                            pickNextIdleVariant(combatant);
                        }
                    }
                } else if (anim.playMode === 'loop') {
                    if (anim.frame >= totalFrames) {
                        anim.frame = 0;
                    }
                } else if (anim.playMode === 'once') {
                    if (anim.frame >= totalFrames - 1) {
                        anim.frame = totalFrames - 1;
                        anim.playing = false;
                        if (anim.onComplete) anim.onComplete();
                    }
                }
            }
        }
        
        // Pick next idle variant for combatants with multiple idles
        function pickNextIdleVariant(combatant) {
            const anim = combatant.anim;
            if (!anim) return;
            
            const heroKey = combatant.name.toLowerCase();
            const paths = HERO_ANIM_PATHS[heroKey];
            if (!paths || !Array.isArray(paths.idle) || paths.idle.length <= 1) return;
            
            // Pick a different variant than current
            const otherPaths = paths.idle.filter(p => p !== anim.sheetPath);
            if (otherPaths.length === 0) return;
            
            const newPath = otherPaths[Math.floor(Math.random() * otherPaths.length)];
            anim.sheetPath = newPath;
            
            // Check if already cached (instant swap)
            if (spriteSheetCache[newPath]) {
                anim.sheet = spriteSheetCache[newPath];
                anim.frameSize = anim.sheet.width / ANIM_GRID_SIZE;
                anim.frame = 0; // Reset to start of new animation
            } else {
                // Load and swap when ready
                loadSpriteSheet(newPath).then(sheet => {
                    anim.sheet = sheet;
                    anim.frameSize = sheet.width / ANIM_GRID_SIZE;
                    anim.frame = 0; // Reset to start of new animation
                });
            }
        }
        
        // Preload all idle variants for a hero (call on battle start)
        function preloadIdleVariants(heroKey) {
            const paths = HERO_ANIM_PATHS[heroKey];
            if (paths && Array.isArray(paths.idle)) {
                paths.idle.forEach(path => loadSpriteSheet(path));
            }
        }
        
        // Preload ALL hero and boss animations at game startup (prevents hitches during combat)
        function preloadAllAnimations() {
            console.log('[Preload] Loading all hero/boss animations...');
            const promises = [];
            
            // Preload all hero animations
            for (const [heroKey, paths] of Object.entries(HERO_ANIM_PATHS)) {
                for (const [state, pathOrArray] of Object.entries(paths)) {
                    if (Array.isArray(pathOrArray)) {
                        pathOrArray.forEach(p => promises.push(loadSpriteSheet(p)));
                    } else {
                        promises.push(loadSpriteSheet(pathOrArray));
                    }
                }
            }
            
            // Preload all boss animations
            for (const [bossKey, paths] of Object.entries(BOSS_ANIM_PATHS)) {
                for (const [state, pathOrArray] of Object.entries(paths)) {
                    if (Array.isArray(pathOrArray)) {
                        pathOrArray.forEach(p => promises.push(loadSpriteSheet(p)));
                    } else {
                        promises.push(loadSpriteSheet(pathOrArray));
                    }
                }
            }
            
            Promise.all(promises).then(() => {
                console.log(`[Preload] All ${promises.length} animation sheets cached`);
            }).catch(err => {
                console.warn('[Preload] Some animations failed to load:', err);
            });
        }
        
        // Draw animated sprite from atlas
        function drawAnimatedSprite(ctx, combatant, destX, destY, destWidth, destHeight, flipX = false) {
            const anim = combatant.anim;
            if (!anim || !anim.sheet || !anim.sheet.complete) {
                // Fallback: draw static sprite if available
                if (combatant.sprite && combatant.sprite.complete && combatant.sprite.naturalHeight !== 0) {
                    ctx.save();
                    if (flipX) {
                        ctx.translate(destX + destWidth / 2, destY + destHeight / 2);
                        ctx.scale(-1, 1);
                        ctx.translate(-(destX + destWidth / 2), -(destY + destHeight / 2));
                    }
                    ctx.drawImage(combatant.sprite, destX, destY, destWidth, destHeight);
                    ctx.restore();
                }
                return;
            }
            
            // Calculate source rectangle from grid (use per-combatant gridCols)
            const gridCols = anim.gridCols || ANIM_GRID_SIZE;
            const col = anim.frame % gridCols;
            const row = Math.floor(anim.frame / gridCols);
            const srcX = col * anim.frameSize;
            const srcY = row * anim.frameSize;
            const srcSize = anim.frameSize;
            
            ctx.save();
            if (flipX) {
                ctx.translate(destX + destWidth / 2, destY + destHeight / 2);
                ctx.scale(-1, 1);
                ctx.translate(-(destX + destWidth / 2), -(destY + destHeight / 2));
            }
            ctx.drawImage(
                anim.sheet,
                srcX, srcY, srcSize, srcSize,  // Source rectangle
                destX, destY, destWidth, destHeight  // Destination rectangle
            );
            ctx.restore();
        }
        
        // Change animation state (e.g., idle -> attack -> idle)
        function setAnimationState(combatant, newState, playMode = 'pingpong', onComplete = null, broadcastToClients = true) {
            const anim = combatant.anim;
            if (!anim) return;
            
            // Get the path for this combatant's new state
            // Check if it's a boss first, then hero
            let paths = null;
            let bossKey = null;
            
            if (combatant.isBoss && combatant.bossLevel) {
                bossKey = 'lvl' + combatant.bossLevel;
                paths = BOSS_ANIM_PATHS[bossKey];
            }
            
            if (!paths) {
                const heroKey = combatant.name.toLowerCase();
                paths = HERO_ANIM_PATHS[heroKey];
            }
            
            if (!paths || !paths[newState]) {
                // No animation for this state - silently ignore for bosses without all anims
                if (!combatant.isBoss) {
                    console.warn('No animation path for:', combatant.name, newState);
                }
                return;
            }
            
            // Broadcast animation to clients (only if host and broadcastToClients is true)
            if (broadcastToClients && multiplayerState.enabled && multiplayerState.role === 'host') {
                sendWebSocketMessage({
                    type: 'animation_sync',
                    combatantName: combatant.name,
                    animState: newState,
                    playMode: playMode
                });
            }
            
            // Handle array of variants (random selection)
            let newPath = paths[newState];
            if (Array.isArray(newPath)) {
                newPath = newPath[Math.floor(Math.random() * newPath.length)];
            }
            
            // If same path and already playing, don't restart (but allow different variant)
            if (anim.sheetPath === newPath && anim.playing) {
                return;
            }
            
            anim.state = newState;
            anim.sheetPath = newPath;
            anim.frame = 0;
            anim.direction = 1;
            anim.playMode = playMode;
            anim.playing = true;
            anim.onComplete = onComplete;
            anim.lastTime = 0;
            
            // Check for custom hero animation config (non-standard grid sizes)
            const heroKey = combatant.name.toLowerCase();
            const heroConfig = HERO_ANIM_CONFIG[heroKey]?.[newState];
            if (heroConfig) {
                anim.gridCols = heroConfig.cols;
                anim.gridRows = heroConfig.rows;
                anim.totalFrames = heroConfig.totalFrames;
                anim.frameSize = heroConfig.frameSize;
            } else if (!combatant.isBoss) {
                // Reset to default hero grid for standard animations
                anim.gridCols = ANIM_GRID_SIZE;
                anim.gridRows = ANIM_GRID_SIZE;
                anim.totalFrames = ANIM_TOTAL_FRAMES;
                anim.frameSize = 0; // Will be recalculated from sheet
            }
            
            // Load new sprite sheet
            loadSpriteSheet(newPath).then(sheet => {
                anim.sheet = sheet;
                // Use per-combatant grid config if available
                if (!anim.frameSize || anim.gridCols !== ANIM_GRID_SIZE) {
                    anim.frameSize = sheet.width / anim.gridCols;
                } else {
                    anim.frameSize = sheet.width / ANIM_GRID_SIZE;
                }
            });
        }
        // ===== END SPRITE SHEET ANIMATION SYSTEM =====
        
        const themeTracks = [
            { file: 'music/main_theme.webm', name: 'Tunnels of Privacy Theme' },
            { file: 'music/theme_a.webm', name: 'Electric Coin Company' },
            { file: 'music/theme_b.webm', name: 'Zcash Foundation' },
            { file: 'music/theme_c_boss.webm', name: 'Proof of Work Battle' },
            { file: 'music/theme_d.webm', name: 'ZecWallet Lite' },
            { file: 'music/theme_e.webm', name: 'Private by Default' },
            { file: 'music/theme_f.webm', name: 'Halo Arc Dreams' },
            { file: 'music/theme_g.webm', name: 'Mining the Future' },
            { file: 'music/theme_h.webm', name: 'zkSNARK Symphony' },
            { file: 'music/theme_i.webm', name: 'Trusted Setup Ceremony' },
            { file: 'music/theme_j.webm', name: 'Shielded Sunset' }
        ];
        
        // Zone music tracks - mapped to dungeon zones from level_data.json
        // Descent Arc (Levels 1-100)
        const zoneMusicTracks = [
            { file: 'music/level_1.webm', minLevel: 1, maxLevel: 5, name: 'Entry Crypts' },
            { file: 'music/level_2.webm', minLevel: 6, maxLevel: 15, name: 'Forgotten Mines' },
            { file: 'music/level_3.webm', minLevel: 16, maxLevel: 25, name: 'Fungal Gardens' },
            { file: 'music/level_4.webm', minLevel: 26, maxLevel: 35, name: 'Underground River' },
            { file: 'music/level_5.webm', minLevel: 36, maxLevel: 45, name: 'Crystal Caverns' },
            { file: 'music/level_6.webm', minLevel: 46, maxLevel: 55, name: 'Bone Pits' },
            { file: 'music/level_7.webm', minLevel: 56, maxLevel: 65, name: 'Infernal Depths' },
            { file: 'music/level_8.webm', minLevel: 66, maxLevel: 75, name: 'Shadow Realm' },
            { file: 'music/level_9.webm', minLevel: 76, maxLevel: 90, name: 'Abyssal Trenches' },
            { file: 'music/level_10.webm', minLevel: 91, maxLevel: 100, name: 'Core of Darkness' },
            // Ascent Arc (Levels 101-1000)
            { file: 'music/up_1.webm', minLevel: 101, maxLevel: 200, name: 'Sanctuary Ruins' },
            { file: 'music/up_2.webm', minLevel: 201, maxLevel: 400, name: 'Ember Wastes' },
            { file: 'music/up_3.webm', minLevel: 401, maxLevel: 700, name: 'Celestial Spire' },
            { file: 'music/up_4.webm', minLevel: 701, maxLevel: 999, name: 'Void Threshold' },
            { file: 'music/up_5.webm', minLevel: 1000, maxLevel: 999999, name: 'Beyond the Veil' }
        ];
        
        // Get appropriate zone music track for current dungeon level
        function getMusicForZone(level) {
            for (let i = 0; i < zoneMusicTracks.length; i++) {
                const track = zoneMusicTracks[i];
                if (level >= track.minLevel && level <= track.maxLevel) {
                    return track;
                }
            }
            return zoneMusicTracks[0]; // Default to first track
        }
        
        function loadMusic(trackData) {
            if (!musicEnabled) return;
            
            // Check if zone or theme music is disabled - skip to alternate type
            const isTheme = trackData.minLevel === undefined;
            if (isTheme && !themeMusicEnabled) {
                // Theme disabled, play zone track instead
                if (zoneMusicEnabled) {
                    const currentLevel = parseInt(document.getElementById('dungeonLevel')?.textContent) || 1;
                    const zoneTrack = getMusicForZone(currentLevel);
                    loadMusic(zoneTrack);
                }
                return;
            }
            if (!isTheme && !zoneMusicEnabled) {
                // Zone disabled, play theme instead
                if (themeMusicEnabled) {
                    const randomTheme = themeTracks[Math.floor(Math.random() * themeTracks.length)];
                    loadMusic(randomTheme);
                }
                return;
            }
            
            // Check if we're already playing this track
            if (currentMusic && currentMusic.src.endsWith(trackData.file)) {
                return; // Don't restart the same track
            }
            
            // Update music ticker with track name
            const tickerText1 = document.getElementById('musicTickerText1');
            const tickerText2 = document.getElementById('musicTickerText2');
            if (tickerText1 && tickerText2 && trackData.name) {
                // Pick a new random fact each time track changes
                if (tickerFacts.length > 0) {
                    currentTickerFact = tickerFacts[Math.floor(Math.random() * tickerFacts.length)];
                }
                
                // Check if this is a zone track or theme track
                let musicInfo = '';
                if (trackData.minLevel !== undefined) {
                    // Zone track - show level range
                    const levelRange = trackData.maxLevel === 999999 ? `${trackData.minLevel}+` : `${trackData.minLevel}-${trackData.maxLevel}`;
                    musicInfo = `â™« Zone Track: ${trackData.name} (Levels ${levelRange}) â™«`;
                } else {
                    // Theme track
                    musicInfo = `â™« Theme Song: ${trackData.name} â™«`;
                }
                
                // Combine music info with fun fact
                const finalText = currentTickerFact ? `${musicInfo}  â€¢  ${currentTickerFact}` : musicInfo;
                tickerText1.textContent = finalText;
                tickerText2.textContent = finalText;
            }
            
            // Use musicVolume divided by 500 (1-150 scale), clamped to max 1.0
            const volumeScale = Math.min(1.0, musicVolume / 500);
            
            // Create new audio element
            const newMusic = new Audio(trackData.file);
            newMusic.loop = false;
            newMusic.volume = 0; // Start silent
            
            // Add ended listener BEFORE play to avoid race condition
            newMusic.addEventListener('ended', () => {
                // Don't auto-play next track if user manually paused
                if (userPausedMusic || !musicEnabled) return;
                // Only trigger if this is still the current track (not replaced by another)
                if (currentMusic !== newMusic) return;
                
                mainThemePlayed = true;
                const shouldPlayTheme = Math.random() < 0.5; // 50% chance
                
                if (shouldPlayTheme && themeMusicEnabled) {
                    // Pick random theme
                    const randomTheme = themeTracks[Math.floor(Math.random() * themeTracks.length)];
                    loadMusic(randomTheme);
                } else if (zoneMusicEnabled) {
                    // Play zone track
                    const currentLevel = parseInt(document.getElementById('dungeonLevel')?.textContent) || 1;
                    const zoneTrack = getMusicForZone(currentLevel);
                    loadMusic(zoneTrack);
                } else if (themeMusicEnabled) {
                    // Fall back to theme if zone disabled
                    const randomTheme = themeTracks[Math.floor(Math.random() * themeTracks.length)];
                    loadMusic(randomTheme);
                }
            });
            
            // Set currentMusic BEFORE starting playback so ended handler has correct reference
            const oldMusic = currentMusic;
            currentMusic = newMusic;
            
            // Fade in new track
            newMusic.play().then(() => {
                fadeMusic(newMusic, 0, volumeScale, 1000);
                musicStarted = true;
                updateMusicButton();
            }).catch(err => {
                console.log('Music autoplay blocked:', err);
            });
            
            // Crossfade: fade out old track while new one fades in
            if (oldMusic) {
                fadeMusic(oldMusic, oldMusic.volume, 0, 1000, () => {
                    oldMusic.pause();
                    oldMusic.removeAttribute('src'); // More thorough cleanup
                    oldMusic.load(); // Force browser to release buffered data
                });
            }
        }
        
        function fadeMusic(audioElement, startVol, endVol, duration, callback) {
            const steps = 20;
            const stepTime = duration / steps;
            const volStep = (endVol - startVol) / steps;
            let currentStep = 0;
            
            const fadeInterval = setInterval(() => {
                currentStep++;
                const newVol = startVol + (volStep * currentStep);
                audioElement.volume = Math.max(0, Math.min(1, newVol));
                
                if (currentStep >= steps) {
                    clearInterval(fadeInterval);
                    audioElement.volume = Math.max(0, Math.min(1.0, endVol));
                    if (callback) callback();
                }
            }, stepTime);
        }
        
        // Music Control Functions
        function musicPlayPause() {
            const icon = document.getElementById('playPauseIcon');
            
            if (!currentMusic) {
                // No music loaded yet, start music system
                musicEnabled = true;
                userPausedMusic = false;
                startMusicSystem();
                if (icon) icon.src = 'tunnelsofprivacy/icons/music_pause.png';
                return;
            }
            
            if (currentMusic.paused) {
                currentMusic.play().catch(err => console.log('Play error:', err));
                musicEnabled = true;
                userPausedMusic = false;
                if (icon) icon.src = 'tunnelsofprivacy/icons/music_pause.png';
            } else {
                currentMusic.pause();
                userPausedMusic = true;
                if (icon) icon.src = 'tunnelsofprivacy/icons/music_play.png';
            }
        }
        
        function musicPrevious() {
            if (currentMusic) {
                currentMusic.pause();
            }
            
            musicEnabled = true;
            userPausedMusic = false;
            mainThemePlayed = true;
            
            // If zone music enabled, play zone track; otherwise theme
            if (zoneMusicEnabled) {
                const currentLevel = parseInt(document.getElementById('dungeonLevel')?.textContent) || 1;
                const zoneTrack = getMusicForZone(currentLevel);
                loadMusic(zoneTrack);
            } else if (themeMusicEnabled) {
                const randomIndex = Math.floor(Math.random() * (themeTracks.length - 1)) + 1;
                const randomTrack = themeTracks[randomIndex];
                loadMusic(randomTrack);
            }
        }
        
        function musicNext() {
            if (currentMusic) {
                currentMusic.pause();
            }
            
            musicEnabled = true;
            userPausedMusic = false;
            mainThemePlayed = true;
            
            // Alternate between zone and theme tracks
            const isCurrentlyZone = currentMusic && zoneMusicTracks.some(t => currentMusic.src.endsWith(t.file));
            
            if (isCurrentlyZone && themeMusicEnabled) {
                // Currently zone, play random theme
                const randomIndex = Math.floor(Math.random() * themeTracks.length);
                loadMusic(themeTracks[randomIndex]);
            } else if (zoneMusicEnabled) {
                // Play zone track for current level
                const currentLevel = parseInt(document.getElementById('dungeonLevel')?.textContent) || 1;
                const zoneTrack = getMusicForZone(currentLevel);
                loadMusic(zoneTrack);
            } else if (themeMusicEnabled) {
                // Fall back to theme
                const randomIndex = Math.floor(Math.random() * themeTracks.length);
                loadMusic(themeTracks[randomIndex]);
            }
        }
        
        function updateMusicButton() {
            const icon = document.getElementById('playPauseIcon');
            if (icon) {
                if (currentMusic && !currentMusic.paused) {
                    icon.src = 'tunnelsofprivacy/icons/music_pause.png';
                } else {
                    icon.src = 'tunnelsofprivacy/icons/music_play.png';
                }
            }
        }
        
        // SEPARATE animation loop for music system - monitors zone changes
        function animateMusicSystem() {
            if (!musicEnabled) {
                musicAnimationFrameId = null;
                return;
            }
            
            musicAnimationFrameId = requestAnimationFrame(animateMusicSystem);
            
            // Get current dungeon level
            const currentLevel = parseInt(document.getElementById('dungeonLevel')?.textContent) || 1;
            
            // Check if zone changed and we need a different track
            if (currentLevel !== currentMusicZone && zoneMusicEnabled) {
                const oldTrack = getMusicForZone(currentMusicZone);
                const newTrack = getMusicForZone(currentLevel);
                
                // Only switch if track file is different (zone changed)
                if (oldTrack.file !== newTrack.file) {
                    console.log(`[Music] Zone changed: Level ${currentMusicZone} -> ${currentLevel}, switching to "${newTrack.name}"`);
                    loadMusic(newTrack);
                }
                
                currentMusicZone = currentLevel;
            }
            
            // Update volume dynamically based on musicVolume (1-150 range)
            if (currentMusic) {
                const volumeScale = Math.min(1.0, musicVolume / 500);
                currentMusic.volume = volumeScale;
            }
        }
        
        // Start the music system with proper initialization
        function startMusicSystem() {
            if (musicEnabled && !musicAnimationFrameId) {
                const currentLevel = parseInt(document.getElementById('dungeonLevel')?.textContent) || 1;
                currentMusicZone = currentLevel;
                
                // Start with a random theme song for variety, then zone music takes over
                if (themeMusicEnabled && !mainThemePlayed) {
                    // First time: play main theme
                    loadMusic(themeTracks[0]);
                    mainThemePlayed = true;
                } else if (themeMusicEnabled) {
                    // After first time: random theme
                    const randomTheme = themeTracks[Math.floor(Math.random() * themeTracks.length)];
                    loadMusic(randomTheme);
                } else if (zoneMusicEnabled) {
                    // Themes disabled: play zone track
                    const zoneTrack = getMusicForZone(currentLevel);
                    loadMusic(zoneTrack);
                }
                
                // Start the monitoring loop
                animateMusicSystem();
            }
        }
        
        function updateVolume() {
            const slider = document.getElementById('volumeSlider');
            if (!slider) return;
            
            musicVolume = parseInt(slider.value);
            
            // Update settings object
            settings.musicVolume = musicVolume;
            
            // Update volume display
            const volumeDisplay = document.getElementById('volumeSliderValue');
            if (volumeDisplay) {
                volumeDisplay.textContent = musicVolume;
            }
            
            // Update settings panel slider if open
            const settingsSlider = document.getElementById('musicVolume');
            if (settingsSlider) {
                settingsSlider.value = musicVolume;
            }
            const settingsVolumeDisplay = document.getElementById('musicVolumeValue');
            if (settingsVolumeDisplay) {
                settingsVolumeDisplay.textContent = musicVolume;
            }
            
            if (currentMusic) {
                const actualVol = Math.min(1.0, musicVolume / 500);
                currentMusic.volume = actualVol;
            }
            
            // Save to localStorage
            saveSettings();
        }
        
        // Settings System
        let settings = {
            musicEnabled: true,
            musicVolume: 40,
            sfxVolume: 50,            // SFX volume (0-100, default 50%)
            bgSoundVolume: 25,        // Background video sound volume (0-100, default 25 -> 5%)
            voiceVolume: 90,          // TTS and narrator volume (0-100, default 90 -> 36%)
            themeMusicEnabled: true,  // Theme songs toggle
            zoneMusicEnabled: true,   // Zone music toggle
            showHitboxes: false,
            playerName: '',
            llmFreeWill: true,       // NPCs chat autonomously
            llmUsePaid: false,       // Use paid LLM models
            rpMode: false,           // RP emotes/dramatic speech vs normal 2025 talk
            diagMode: false,         // Diagnostic mode - enemies have 5 HP
            difficulty: 'normal'     // Game difficulty: 'casual', 'normal', 'expert'
        };
        
        // ============ PARTY INVENTORY SYSTEM ============
        // Hero colors for inventory slots
        const HERO_COLORS = {
            zooko: '#F2C94C',
            nate: '#E74C3C',
            zancas: '#27AE60',
            cyberaxe: '#2E86DE'
        };
        
        // Hero quadrant layout for 6x6 grid (36 slots)
        // Each hero owns a 3x3 corner quadrant
        // Grid layout with equipment slots on sides:
        //
        // Equipment slots use negative IDs (left side) and 36+ IDs (right side)
        // [-1] 0  1  2 |  3  4  5 [36]
        // [-2] 6  7  8 |  9 10 11 [37]
        // [-3]12 13 14 | 15 16 17 [38]
        // --------+--------
        // [-4]18 19 20 | 21 22 23 [39]
        // [-5]24 25 26 | 27 28 29 [40]
        // [-6]30 31 32 | 33 34 35 [41]
        //
        // Zooko (top-left):     0,1,2,6,7,8,12,13,14 - potion slot: 14, equipment: -1,-2,-3
        // Nate (top-right):     3,4,5,9,10,11,15,16,17 - potion slot: 15, equipment: 36,37,38
        // Zancas (bottom-left): 18,19,20,24,25,26,30,31,32 - potion slot: 20, equipment: -4,-5,-6
        // CyberAxe (bottom-right): 21,22,23,27,28,29,33,34,35 - potion slot: 21, equipment: 39,40,41
        
        // Hero quadrant definitions
        const HERO_QUADRANTS = {
            zooko: [0, 1, 2, 6, 7, 8, 12, 13, 14],      // Top-left 3x3
            nate: [3, 4, 5, 9, 10, 11, 15, 16, 17],     // Top-right 3x3
            zancas: [18, 19, 20, 24, 25, 26, 30, 31, 32], // Bottom-left 3x3
            cyberaxe: [21, 22, 23, 27, 28, 29, 33, 34, 35] // Bottom-right 3x3
        };
        
        // Hero equipment slots (3 per hero - weapon, armor, accessory)
        const HERO_EQUIPMENT_SLOTS = {
            zooko: [-1, -2, -3],      // Left side, rows 0-2
            zancas: [-4, -5, -6],     // Left side, rows 3-5
            nate: [36, 37, 38],       // Right side, rows 0-2
            cyberaxe: [39, 40, 41]    // Right side, rows 3-5
        };
        
        // Equipment slot types (by position in array)
        const EQUIPMENT_SLOT_TYPES = ['weapon', 'armor', 'accessory'];
        
        // Get hero owner for equipment slot
        function getEquipmentSlotOwner(slotId) {
            for (const [hero, slots] of Object.entries(HERO_EQUIPMENT_SLOTS)) {
                if (slots.includes(slotId)) return hero;
            }
            return null;
        }
        
        // Get equipment slot type
        function getEquipmentSlotType(slotId) {
            for (const [hero, slots] of Object.entries(HERO_EQUIPMENT_SLOTS)) {
                const idx = slots.indexOf(slotId);
                if (idx !== -1) return EQUIPMENT_SLOT_TYPES[idx];
            }
            return null;
        }
        
        // Hero equipment state (separate from inventory)
        let heroEquipment = {
            zooko: { weapon: null, armor: null, accessory: null },
            nate: { weapon: null, armor: null, accessory: null },
            zancas: { weapon: null, armor: null, accessory: null },
            cyberaxe: { weapon: null, armor: null, accessory: null }
        };
        
        // Hero potion slots (inner corner of each quadrant toward center 2x2)
        const HERO_POTION_SLOTS = {
            14: 'zooko',    // Zooko's inner corner (row 2, col 2)
            15: 'nate',     // Nate's inner corner (row 2, col 3)
            20: 'zancas',   // Zancas's inner corner (row 3, col 2)
            21: 'cyberaxe'  // CyberAxe's inner corner (row 3, col 3)
        };
        
        // Unlock order: center 2x2 per hero first, then expand 1 per hero at a time
        // Phase 1 (12 slots): Center 2x2 of each hero - 14,13,8 (Zooko), 15,16,9 (Nate), 20,19,26 (Zancas), 21,22,27 (CyberAxe)
        // Then 1 per hero rotating until all unlocked
        const UNLOCK_ORDER = [
            // Phase 1: Center 2x2 of each quadrant (12 slots)
            14, 15, 20, 21,  // Inner corners
            13, 16, 19, 22,  // Adjacent horizontal
            8, 9, 26, 27,    // Adjacent vertical
            // Remaining slots: 1 per hero rotating
            7, 10, 25, 28,   // Next ring inward
            12, 17, 18, 23,  // Edge middle
            2, 5, 32, 35,    // Edge corners
            1, 4, 31, 34,    // Outer middle
            6, 11, 24, 29,   // Outer sides
            0, 3, 30, 33     // Far corners
        ];
        
        // Party inventory state
        let partyInventory = {
            items: [], // Array of item objects indexed by grid position, null for empty
            maxSlots: 12, // Start with center 2x2 per hero (3 each = 12)
            partyLevel: 1
        };
        
        // Calculate max inventory slots based on party level
        function calculateMaxSlots(partyLevel) {
            // Base: 12 slots (center 2x2 per hero) at level 1-9
            // Every 10 levels adds 4 slots (1 per hero): 10->16, 20->20, ..., 60->36 max
            const bonusSlots = Math.floor(partyLevel / 10) * 4;
            return Math.min(36, 12 + bonusSlots); // Cap at 36 (6x6)
        }
        
        // Check if a grid position is unlocked
        function isSlotUnlocked(gridPos, maxSlots) {
            const unlockIndex = UNLOCK_ORDER.indexOf(gridPos);
            return unlockIndex !== -1 && unlockIndex < maxSlots;
        }
        
        // Get hero owner for a grid position (based on quadrant)
        function getSlotHeroOwner(gridPos) {
            for (const [hero, slots] of Object.entries(HERO_QUADRANTS)) {
                if (slots.includes(gridPos)) return hero;
            }
            return null;
        }
        
        // Check if slot is a hero potion slot
        function isHeroPotionSlot(gridPos) {
            return HERO_POTION_SLOTS.hasOwnProperty(gridPos);
        }
        
        // Initialize inventory with hero health potions
        function initializeInventory(partyLevel = 1) {
            partyInventory.partyLevel = partyLevel;
            partyInventory.maxSlots = calculateMaxSlots(partyLevel);
            partyInventory.items = new Array(36).fill(null); // Always 36 slots, some locked
            
            // Fill hero potion slots (1 per hero at inner corners)
            for (const [gridPos, heroOwner] of Object.entries(HERO_POTION_SLOTS)) {
                partyInventory.items[parseInt(gridPos)] = {
                    id: 'health_potion',
                    name: 'Health Potion',
                    icon: 'tunnelsofprivacy/items/healing_potions_a_cropped.png',
                    type: 'consumable',
                    heroSlot: true,
                    owner: heroOwner
                };
            }
            
            // Restore party meals from save file
            const sharedSave = loadSharedSave();
            if (sharedSave?.dungeonState?.partyMeals) {
                sharedSave.dungeonState.partyMeals.forEach(meal => {
                    if (meal.inventorySlot !== undefined && meal.inventorySlot >= 0 && meal.inventorySlot < 36) {
                        partyInventory.items[meal.inventorySlot] = {
                            id: meal.id,
                            name: meal.name,
                            icon: meal.icon,
                            type: 'party_meal',
                            value: meal.value,
                            description: meal.description
                        };
                    }
                });
                console.log(`[Inventory] Restored ${sharedSave.dungeonState.partyMeals.length} party meals from save`);
            }
            
            console.log(`[Inventory] Initialized with ${partyInventory.maxSlots} slots at party level ${partyLevel}`);
        }
        
        // Refresh hero potion slots (called at start of each room)
        function refreshHeroPotions() {
            // Fill hero potion slots (1 per hero at inner corners)
            for (const [gridPos, heroOwner] of Object.entries(HERO_POTION_SLOTS)) {
                partyInventory.items[parseInt(gridPos)] = {
                    id: 'health_potion',
                    name: 'Health Potion',
                    icon: 'tunnelsofprivacy/items/healing_potions_a_cropped.png',
                    type: 'consumable',
                    heroSlot: true,
                    owner: heroOwner
                };
            }
            console.log('[Inventory] Hero potions refreshed');
            
            // Sync to multiplayer clients
            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                sendInventoryUpdate();
            }
        }
        
        // Send inventory update to clients
        function sendInventoryUpdate() {
            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                const sharedSave = loadSharedSave();
                sendWebSocketMessage({
                    type: 'inventory_update',
                    inventory: {
                        items: partyInventory.items,
                        maxSlots: partyInventory.maxSlots,
                        partyLevel: partyInventory.partyLevel
                    },
                    equipment: heroEquipment,
                    partyMeals: sharedSave?.dungeonState?.partyMeals || [],
                    gold: sharedSave?.dungeonState?.gold || 0
                });
            }
        }
        
        // Handle inventory update from host (client)
        function handleInventoryUpdate(data) {
            partyInventory.items = data.inventory.items;
            partyInventory.maxSlots = data.inventory.maxSlots;
            partyInventory.partyLevel = data.inventory.partyLevel;
            
            // Also sync equipment if included
            if (data.equipment) {
                heroEquipment = data.equipment;
            }
            
            // Sync party meals cache
            if (data.partyMeals !== undefined) {
                multiplayerState.partyMealsCache = data.partyMeals;
            }
            
            // Sync gold cache
            if (data.gold !== undefined) {
                multiplayerState.goldCache = data.gold;
                updateGoldDisplay();
            }
            
            console.log('[Inventory] Received update from host');
            
            // Update UI if inventory panel is open
            if (document.getElementById('inventoryPanel')?.style.display === 'block') {
                renderInventoryGrid();
            }
            
            // Update camp panel meals list if open
            if (document.getElementById('campPanel')?.style.display === 'block') {
                populatePartyMealsList();
            }
            
            // Update store display if in store
            if (currentScreen === 'nonCombatRoom' && nonCombatRoomState.roomType === 'store') {
                populateStoreContent();
            }
        }
        
        // Send equipment-only update to clients
        function sendEquipmentUpdate() {
            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                sendWebSocketMessage({
                    type: 'equipment_update',
                    equipment: heroEquipment
                });
            }
        }
        
        // Handle equipment update from host (client)
        function handleEquipmentUpdate(data) {
            heroEquipment = data.equipment;
            console.log('[Equipment] Received update from host');
            
            // Update UI if inventory panel is open
            if (document.getElementById('inventoryPanel')?.style.display === 'block') {
                renderInventoryGrid();
            }
        }
        
        // Open inventory panel
        function openInventory() {
            document.getElementById('overlay').style.display = 'block';
            document.getElementById('inventoryPanel').style.display = 'block';
            renderInventoryGrid();
            
            // Client requests inventory sync from host
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                sendWebSocketMessage({ type: 'request_resync' });
            }
        }
        
        // Close inventory panel
        function closeInventory() {
            document.getElementById('inventoryPanel').style.display = 'none';
            document.getElementById('overlay').style.display = 'none';
        }
        
        // Render inventory grid
        function renderInventoryGrid() {
            const grid = document.getElementById('inventoryGrid');
            if (!grid) return;
            
            const currentLevel = partyInventory.partyLevel;
            const maxSlots = partyInventory.maxSlots;
            
            // Equipment slot icons
            const SLOT_ICONS = { weapon: 'âš”ï¸', armor: 'ðŸ›¡ï¸', accessory: 'ðŸ’' };
            
            let html = '';
            
            // Render row by row (6 rows)
            for (let row = 0; row < 6; row++) {
                // LEFT EQUIPMENT SLOT (Zooko rows 0-2, Zancas rows 3-5)
                const leftEquipSlotId = -(row + 1); // -1 to -6
                const leftHero = row < 3 ? 'zooko' : 'zancas';
                const leftSlotType = EQUIPMENT_SLOT_TYPES[row % 3];
                const leftHeroColor = HERO_COLORS[leftHero];
                
                let leftContent, leftTitle;
                if (leftSlotType === 'weapon') {
                    // Show hero's signature weapon
                    const weaponStats = getWeaponStats(leftHero);
                    const enchantGlow = weaponStats.enchantment ? `filter: drop-shadow(0 0 6px ${weaponStats.enchantment.color}) drop-shadow(0 0 12px ${weaponStats.enchantment.color});` : '';
                    leftContent = `<img src="${weaponStats.icon}" alt="${weaponStats.fullName}" style="width: 80%; height: 80%; object-fit: contain; ${enchantGlow}">`;
                    leftTitle = `${weaponStats.fullName} - DMG: ${weaponStats.damage} | DEF: ${weaponStats.defense} | CRIT: ${weaponStats.crit}%`;
                } else {
                    const leftEquipped = heroEquipment[leftHero][leftSlotType];
                    leftContent = leftEquipped 
                        ? `<img src="${leftEquipped.icon}" alt="${leftEquipped.name}" title="${leftEquipped.name}" style="width: 80%; height: 80%; object-fit: contain;">`
                        : `<span class="slotIcon">${SLOT_ICONS[leftSlotType]}</span>`;
                    leftTitle = `${leftHero} - ${leftSlotType}`;
                }
                
                html += `<div class="equipmentCell" style="border-color: ${leftHeroColor}80; box-shadow: inset 0 0 12px ${leftHeroColor}30;" data-equip="${leftEquipSlotId}" data-hero="${leftHero}" data-slottype="${leftSlotType}" title="${leftTitle}">${leftContent}</div>`;
                
                // INVENTORY CELLS (6 per row)
                for (let col = 0; col < 6; col++) {
                    const gridPos = row * 6 + col;
                    const item = partyInventory.items[gridPos];
                    const isUnlocked = isSlotUnlocked(gridPos, maxSlots);
                    const heroOwner = getSlotHeroOwner(gridPos);
                    const heroColor = heroOwner ? HERO_COLORS[heroOwner] : null;
                    const isPotionSlot = isHeroPotionSlot(gridPos);
                    
                    // Determine cell styling - ALL cells in quadrant get hero color tint
                    let cellStyle = '';
                    let cellClass = 'inventoryCell';
                    
                    if (!isUnlocked) {
                        cellClass += ' locked';
                        // Still show quadrant color but dimmed for locked cells
                        if (heroColor) {
                            cellStyle = `background: ${heroColor}10; border-color: ${heroColor}30;`;
                        }
                    } else {
                        // Unlocked cells show full quadrant color
                        if (heroColor) {
                            // Potion slots get stronger highlight
                            if (isPotionSlot) {
                                cellStyle = `background: ${heroColor}30; border-color: ${heroColor}; box-shadow: inset 0 0 15px ${heroColor}50;`;
                            } else {
                                cellStyle = `background: ${heroColor}15; border-color: ${heroColor}80; box-shadow: inset 0 0 8px ${heroColor}25;`;
                            }
                        }
                    }
                    
                    // Cell content
                    let content = '';
                    if (item) {
                        content = `<img src="${item.icon}" alt="${item.name}" title="${item.name}" style="width: 80%; height: 80%; object-fit: contain;">`;
                    }
                    
                    html += `<div class="${cellClass}" style="${cellStyle}" data-slot="${gridPos}">${content}</div>`;
                }
                
                // RIGHT EQUIPMENT SLOT (Nate rows 0-2, CyberAxe rows 3-5)
                const rightEquipSlotId = 36 + row; // 36 to 41
                const rightHero = row < 3 ? 'nate' : 'cyberaxe';
                const rightSlotType = EQUIPMENT_SLOT_TYPES[row % 3];
                const rightHeroColor = HERO_COLORS[rightHero];
                
                let rightContent, rightTitle;
                if (rightSlotType === 'weapon') {
                    // Show hero's signature weapon
                    const weaponStats = getWeaponStats(rightHero);
                    const enchantGlow = weaponStats.enchantment ? `filter: drop-shadow(0 0 6px ${weaponStats.enchantment.color}) drop-shadow(0 0 12px ${weaponStats.enchantment.color});` : '';
                    rightContent = `<img src="${weaponStats.icon}" alt="${weaponStats.fullName}" style="width: 80%; height: 80%; object-fit: contain; ${enchantGlow}">`;
                    rightTitle = `${weaponStats.fullName} - DMG: ${weaponStats.damage} | DEF: ${weaponStats.defense} | CRIT: ${weaponStats.crit}%`;
                } else {
                    const rightEquipped = heroEquipment[rightHero][rightSlotType];
                    rightContent = rightEquipped 
                        ? `<img src="${rightEquipped.icon}" alt="${rightEquipped.name}" title="${rightEquipped.name}" style="width: 80%; height: 80%; object-fit: contain;">`
                        : `<span class="slotIcon">${SLOT_ICONS[rightSlotType]}</span>`;
                    rightTitle = `${rightHero} - ${rightSlotType}`;
                }
                
                html += `<div class="equipmentCell" style="border-color: ${rightHeroColor}80; box-shadow: inset 0 0 12px ${rightHeroColor}30;" data-equip="${rightEquipSlotId}" data-hero="${rightHero}" data-slottype="${rightSlotType}" title="${rightTitle}">${rightContent}</div>`;
            }
            
            grid.innerHTML = html;
            
            // Add weapon tooltip event listeners
            setupWeaponTooltips(grid);
            
            // Add food tooltip event listeners for party meals
            setupFoodTooltips(grid);
            
            // Add potion tooltip event listeners for consumables
            setupPotionTooltips(grid);
            
            // Update level progress display
            const progressEl = document.getElementById('inventoryLevelProgress');
            if (progressEl) {
                const nextUnlockLevel = Math.ceil((currentLevel + 1) / 10) * 10;
                const currentUnlocked = maxSlots;
                progressEl.innerHTML = `
                    <span style="color: #BFD1E0;">Party Level: <span style="color: #F2C94C; font-weight: bold;">${currentLevel}</span></span>
                    <span style="color: #5A7A8F; font-size: 11px;">Slots: ${currentUnlocked}/36 â€¢ ${currentUnlocked >= 36 ? 'MAX' : `+4 at Lv${nextUnlockLevel}`}</span>
                `;
            }
        }
        
        // Render inventory in store screen (same grid, different container)
        function renderStoreInventoryGrid() {
            const grid = document.getElementById('storeInventoryGrid');
            if (!grid) return;
            
            const currentLevel = partyInventory.partyLevel;
            const maxSlots = partyInventory.maxSlots;
            
            // Equipment slot icons
            const SLOT_ICONS = { weapon: 'âš”ï¸', armor: 'ðŸ›¡ï¸', accessory: 'ðŸ’' };
            
            let html = '';
            
            // Render row by row (6 rows)
            for (let row = 0; row < 6; row++) {
                // LEFT EQUIPMENT SLOT
                const leftEquipSlotId = -(row + 1);
                const leftHero = row < 3 ? 'zooko' : 'zancas';
                const leftSlotType = EQUIPMENT_SLOT_TYPES[row % 3];
                const leftHeroColor = HERO_COLORS[leftHero];
                
                let leftContent, leftTitle;
                if (leftSlotType === 'weapon') {
                    // Show hero's signature weapon
                    const weaponStats = getWeaponStats(leftHero);
                    const enchantGlow = weaponStats.enchantment ? `filter: drop-shadow(0 0 6px ${weaponStats.enchantment.color}) drop-shadow(0 0 12px ${weaponStats.enchantment.color});` : '';
                    leftContent = `<img src="${weaponStats.icon}" alt="${weaponStats.fullName}" style="width: 80%; height: 80%; object-fit: contain; ${enchantGlow}">`;
                    leftTitle = `${weaponStats.fullName} - DMG: ${weaponStats.damage} | DEF: ${weaponStats.defense} | CRIT: ${weaponStats.crit}%`;
                } else {
                    const leftEquipped = heroEquipment[leftHero][leftSlotType];
                    leftContent = leftEquipped 
                        ? `<img src="${leftEquipped.icon}" alt="${leftEquipped.name}" title="${leftEquipped.name}" style="width: 80%; height: 80%; object-fit: contain;">`
                        : `<span style="font-size: 18px; opacity: 0.4;">${SLOT_ICONS[leftSlotType]}</span>`;
                    leftTitle = `${leftHero} - ${leftSlotType}`;
                }
                
                html += `<div class="equipmentCell" style="width: 54px; height: 54px; border-color: ${leftHeroColor}80; box-shadow: inset 0 0 12px ${leftHeroColor}30; display: flex; align-items: center; justify-content: center; background: linear-gradient(145deg, rgba(60, 60, 80, 0.4), rgba(40, 40, 60, 0.3)); border: 2px dashed rgba(150, 150, 180, 0.5); border-radius: 10px; cursor: pointer;" data-equip="${leftEquipSlotId}" data-hero="${leftHero}" data-slottype="${leftSlotType}" title="${leftTitle}">${leftContent}</div>`;
                
                // INVENTORY CELLS (6 per row)
                for (let col = 0; col < 6; col++) {
                    const gridPos = row * 6 + col;
                    const item = partyInventory.items[gridPos];
                    const isUnlocked = isSlotUnlocked(gridPos, maxSlots);
                    const heroOwner = getSlotHeroOwner(gridPos);
                    const heroColor = heroOwner ? HERO_COLORS[heroOwner] : null;
                    const isPotionSlot = isHeroPotionSlot(gridPos);
                    
                    let cellStyle = 'width: 54px; height: 54px; display: flex; align-items: center; justify-content: center; border-radius: 8px; ';
                    
                    if (!isUnlocked) {
                        cellStyle += `background: rgba(40, 40, 50, 0.4); border: 2px solid rgba(80, 80, 100, 0.3); opacity: 0.5;`;
                    } else if (heroColor) {
                        if (isPotionSlot) {
                            cellStyle += `background: ${heroColor}30; border: 2px solid ${heroColor}; box-shadow: inset 0 0 15px ${heroColor}50;`;
                        } else {
                            cellStyle += `background: ${heroColor}15; border: 2px solid ${heroColor}80; box-shadow: inset 0 0 8px ${heroColor}25;`;
                        }
                    } else {
                        cellStyle += `background: linear-gradient(135deg, rgba(45, 156, 219, 0.15), rgba(20, 80, 120, 0.2)); border: 2px solid rgba(45, 156, 219, 0.5);`;
                    }
                    
                    let content = '';
                    if (item) {
                        content = `<img src="${item.icon}" alt="${item.name}" title="${item.name}" style="width: 80%; height: 80%; object-fit: contain;">`;
                    } else if (!isUnlocked) {
                        content = `<span style="font-size: 14px; opacity: 0.4;">ðŸ”’</span>`;
                    }
                    
                    html += `<div style="${cellStyle}" data-slot="${gridPos}">${content}</div>`;
                }
                
                // RIGHT EQUIPMENT SLOT
                const rightEquipSlotId = 36 + row;
                const rightHero = row < 3 ? 'nate' : 'cyberaxe';
                const rightSlotType = EQUIPMENT_SLOT_TYPES[row % 3];
                const rightHeroColor = HERO_COLORS[rightHero];
                
                let rightContent, rightTitle;
                if (rightSlotType === 'weapon') {
                    // Show hero's signature weapon
                    const weaponStats = getWeaponStats(rightHero);
                    const enchantGlow = weaponStats.enchantment ? `filter: drop-shadow(0 0 6px ${weaponStats.enchantment.color}) drop-shadow(0 0 12px ${weaponStats.enchantment.color});` : '';
                    rightContent = `<img src="${weaponStats.icon}" alt="${weaponStats.fullName}" style="width: 80%; height: 80%; object-fit: contain; ${enchantGlow}">`;
                    rightTitle = `${weaponStats.fullName} - DMG: ${weaponStats.damage} | DEF: ${weaponStats.defense} | CRIT: ${weaponStats.crit}%`;
                } else {
                    const rightEquipped = heroEquipment[rightHero][rightSlotType];
                    rightContent = rightEquipped 
                        ? `<img src="${rightEquipped.icon}" alt="${rightEquipped.name}" title="${rightEquipped.name}" style="width: 80%; height: 80%; object-fit: contain;">`
                        : `<span style="font-size: 18px; opacity: 0.4;">${SLOT_ICONS[rightSlotType]}</span>`;
                    rightTitle = `${rightHero} - ${rightSlotType}`;
                }
                
                html += `<div class="equipmentCell" style="width: 54px; height: 54px; border-color: ${rightHeroColor}80; box-shadow: inset 0 0 12px ${rightHeroColor}30; display: flex; align-items: center; justify-content: center; background: linear-gradient(145deg, rgba(60, 60, 80, 0.4), rgba(40, 40, 60, 0.3)); border: 2px dashed rgba(150, 150, 180, 0.5); border-radius: 10px; cursor: pointer;" data-equip="${rightEquipSlotId}" data-hero="${rightHero}" data-slottype="${rightSlotType}" title="${rightTitle}">${rightContent}</div>`;
            }
            
            grid.innerHTML = html;
            
            // Add weapon tooltip event listeners
            setupWeaponTooltips(grid);
            
            // Add food tooltip event listeners for party meals
            setupFoodTooltips(grid);
            
            // Add potion tooltip event listeners for consumables
            setupPotionTooltips(grid);
        }
        
        // Setup weapon tooltip hover events for equipment slots
        function setupWeaponTooltips(container) {
            const tooltip = document.getElementById('weaponTooltip');
            if (!tooltip) return;
            
            container.querySelectorAll('.equipmentCell[data-slottype="weapon"]').forEach(cell => {
                cell.addEventListener('mouseenter', (e) => {
                    e.stopPropagation();
                    const heroName = cell.dataset.hero;
                    if (!heroName) return;
                    
                    // Hide info tooltip if showing
                    hideTooltip();
                    
                    tooltip.innerHTML = getWeaponTooltipHTML(heroName);
                    tooltip.style.opacity = '1';
                    
                    // Position tooltip
                    const rect = cell.getBoundingClientRect();
                    const tooltipWidth = 240;
                    
                    // Position to the right of the cell, or left if near right edge
                    let left = rect.right + 10;
                    if (left + tooltipWidth > window.innerWidth) {
                        left = rect.left - tooltipWidth - 10;
                    }
                    
                    tooltip.style.left = left + 'px';
                    tooltip.style.top = (rect.top - 20) + 'px';
                });
                
                cell.addEventListener('mouseleave', () => {
                    tooltip.style.opacity = '0';
                });
            });
        }
        
        // ============ EQUIPMENT SHOP SYSTEM ============
        
        // Equipment upgrade tiers (every 10 levels)
        const EQUIPMENT_UPGRADES = [
            { level: 10, name: 'Iron', statBonus: { str: 1, dex: 1 }, cost: 500 },
            { level: 20, name: 'Steel', statBonus: { str: 2, dex: 2 }, cost: 1500 },
            { level: 30, name: 'Mithril', statBonus: { str: 3, dex: 3, con: 1 }, cost: 3500 },
            { level: 40, name: 'Adamant', statBonus: { str: 4, dex: 4, con: 2 }, cost: 7000 },
            { level: 50, name: 'Dragon', statBonus: { str: 5, dex: 5, con: 3, int: 1 }, cost: 12000 },
            { level: 60, name: 'Zcash', statBonus: { str: 6, dex: 6, con: 4, int: 2, wis: 1 }, cost: 20000 },
            { level: 70, name: 'Shielded', statBonus: { str: 7, dex: 7, con: 5, int: 3, wis: 2 }, cost: 35000 },
            { level: 80, name: 'Sapling', statBonus: { str: 8, dex: 8, con: 6, int: 4, wis: 3, cha: 1 }, cost: 55000 },
            { level: 90, name: 'Orchard', statBonus: { str: 9, dex: 9, con: 7, int: 5, wis: 4, cha: 2 }, cost: 80000 },
            { level: 100, name: 'Legendary', statBonus: { str: 10, dex: 10, con: 8, int: 6, wis: 5, cha: 3 }, cost: 150000 }
        ];
        
        // Visual enchantments with effects
        const ENCHANTMENTS = [
            { id: 'fire_red', name: 'Red Fire', color: '#FF4500', effect: 'fire', cost: 300 },
            { id: 'fire_purple', name: 'Purple Fire', color: '#9B59B6', effect: 'fire', cost: 500 },
            { id: 'fire_blue', name: 'Blue Fire', color: '#3498DB', effect: 'fire', cost: 500 },
            { id: 'fire_green', name: 'Green Fire', color: '#27AE60', effect: 'fire', cost: 500 },
            { id: 'lightning_yellow', name: 'Lightning', color: '#F1C40F', effect: 'lightning', cost: 400 },
            { id: 'lightning_blue', name: 'Arc Lightning', color: '#00BFFF', effect: 'lightning', cost: 600 },
            { id: 'ice_blue', name: 'Frost', color: '#87CEEB', effect: 'ice', cost: 400 },
            { id: 'ice_white', name: 'Blizzard', color: '#FFFFFF', effect: 'ice', cost: 600 },
            { id: 'wind_green', name: 'Gale', color: '#98FB98', effect: 'wind', cost: 350 },
            { id: 'wind_silver', name: 'Tempest', color: '#C0C0C0', effect: 'wind', cost: 550 },
            { id: 'shadow_purple', name: 'Shadow', color: '#4B0082', effect: 'shadow', cost: 450 },
            { id: 'holy_gold', name: 'Divine', color: '#FFD700', effect: 'holy', cost: 700 },
            { id: 'zcash_orange', name: 'Zcash Glow', color: '#F4B728', effect: 'zcash', cost: 1000 }
        ];
        
        // Hero signature weapons (static, cannot be changed - only upgraded/enchanted)
        const HERO_WEAPONS = {
            zooko: {
                name: "Zooko's Triangle Staff",
                icon: 'tunnelsofprivacy/items/zooko_staff.png',
                description: "A mystical staff channeling the power of cryptographic triangles.",
                baseDamage: 8,
                baseDefense: 2,
                baseCrit: 5
            },
            nate: {
                name: "Zashi Wallet",
                icon: 'tunnelsofprivacy/items/nate_zcash_zashi_walletpng.png',
                description: "A powerful mobile device running Zashi - the shielded Zcash wallet.",
                baseDamage: 6,
                baseDefense: 4,
                baseCrit: 8
            },
            zancas: {
                name: "Zingo Orb",
                icon: 'tunnelsofprivacy/items/zancas_zingo_orb.png',
                description: "An orb device powered by Zingo wallet technology.",
                baseDamage: 7,
                baseDefense: 3,
                baseCrit: 7
            },
            cyberaxe: {
                name: "Axe of Creation",
                icon: 'tunnelsofprivacy/items/cyberaxe_axe.png',
                description: "The legendary CyberAxe - forged in the fires of innovation.",
                baseDamage: 10,
                baseDefense: 1,
                baseCrit: 4
            }
        };
        
        // Get weapon stats including upgrades and enchantment
        function getWeaponStats(heroName) {
            const baseWeapon = HERO_WEAPONS[heroName];
            const weaponState = heroWeapons[heroName];
            if (!baseWeapon) return null;
            
            // Calculate upgrade bonuses
            let upgradeDamage = 0;
            let upgradeDefense = 0;
            let upgradeCrit = 0;
            let upgradeName = '';
            
            if (weaponState.upgradeLevel > 0) {
                const upgradeIndex = weaponState.upgradeLevel - 1;
                if (upgradeIndex < EQUIPMENT_UPGRADES.length) {
                    const upgrade = EQUIPMENT_UPGRADES[upgradeIndex];
                    upgradeName = upgrade.name;
                    // Each upgrade tier adds +2 damage, +1 defense, +5% crit
                    upgradeDamage = weaponState.upgradeLevel * 2;
                    upgradeDefense = weaponState.upgradeLevel;
                    upgradeCrit = weaponState.upgradeLevel * 5;
                }
            }
            
            // Get enchantment info
            let enchantment = null;
            if (weaponState.enchantment) {
                enchantment = ENCHANTMENTS.find(e => e.id === weaponState.enchantment);
            }
            
            return {
                name: baseWeapon.name,
                fullName: upgradeName ? `${upgradeName} ${baseWeapon.name}` : baseWeapon.name,
                icon: baseWeapon.icon,
                description: baseWeapon.description,
                damage: baseWeapon.baseDamage + upgradeDamage,
                defense: baseWeapon.baseDefense + upgradeDefense,
                crit: baseWeapon.baseCrit + upgradeCrit,
                baseDamage: baseWeapon.baseDamage,
                baseDefense: baseWeapon.baseDefense,
                baseCrit: baseWeapon.baseCrit,
                upgradeDamage,
                upgradeDefense,
                upgradeCrit,
                upgradeTier: upgradeName,
                upgradeLevel: weaponState.upgradeLevel,
                enchantment: enchantment
            };
        }
        
        // Generate weapon tooltip HTML
        function getWeaponTooltipHTML(heroName) {
            const stats = getWeaponStats(heroName);
            if (!stats) return '';
            
            const heroColor = HERO_COLORS[heroName];
            const heroDisplayName = heroName.charAt(0).toUpperCase() + heroName.slice(1);
            
            let enchantHTML = '';
            if (stats.enchantment) {
                enchantHTML = `
                    <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1);">
                        <span style="color: ${stats.enchantment.color}; text-shadow: 0 0 8px ${stats.enchantment.color};">
                            âœ¨ ${stats.enchantment.name}
                        </span>
                    </div>
                `;
            }
            
            let upgradeHTML = '';
            if (stats.upgradeTier) {
                upgradeHTML = `<span style="color: #F4B728; font-size: 11px;"> [${stats.upgradeTier}]</span>`;
            }
            
            return `
                <div style="background: linear-gradient(145deg, rgba(30,35,50,0.98), rgba(20,25,35,0.98)); border: 2px solid ${heroColor}; border-radius: 12px; padding: 12px; min-width: 220px; box-shadow: 0 8px 32px rgba(0,0,0,0.6), 0 0 20px ${heroColor}40;">
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                        <img src="${stats.icon}" alt="${stats.fullName}" style="width: 36px; height: 36px; object-fit: contain;${stats.enchantment ? ` filter: drop-shadow(0 0 6px ${stats.enchantment.color}) drop-shadow(0 0 12px ${stats.enchantment.color});` : ''}">
                        <div>
                            <div style="color: ${heroColor}; font-weight: bold; font-size: 14px;">${stats.fullName}${upgradeHTML}</div>
                            <div style="color: #888; font-size: 11px;">${heroDisplayName}'s Weapon</div>
                        </div>
                    </div>
                    <div style="color: #AAA; font-size: 11px; font-style: italic; margin-bottom: 10px;">${stats.description}</div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; text-align: center;">
                        <div style="background: rgba(231,76,60,0.2); padding: 6px; border-radius: 6px;">
                            <div style="color: #E74C3C; font-size: 11px;">âš”ï¸ DMG</div>
                            <div style="color: #FFF; font-weight: bold;">${stats.damage}</div>
                            ${stats.upgradeDamage > 0 ? `<div style="color: #2ECC71; font-size: 10px;">+${stats.upgradeDamage}</div>` : ''}
                        </div>
                        <div style="background: rgba(52,152,219,0.2); padding: 6px; border-radius: 6px;">
                            <div style="color: #3498DB; font-size: 11px;">ðŸ›¡ï¸ DEF</div>
                            <div style="color: #FFF; font-weight: bold;">${stats.defense}</div>
                            ${stats.upgradeDefense > 0 ? `<div style="color: #2ECC71; font-size: 10px;">+${stats.upgradeDefense}</div>` : ''}
                        </div>
                        <div style="background: rgba(241,196,15,0.2); padding: 6px; border-radius: 6px;">
                            <div style="color: #F1C40F; font-size: 11px;">ðŸ’¥ CRIT</div>
                            <div style="color: #FFF; font-weight: bold;">${stats.crit}%</div>
                            ${stats.upgradeCrit > 0 ? `<div style="color: #2ECC71; font-size: 10px;">+${stats.upgradeCrit}%</div>` : ''}
                        </div>
                    </div>
                    ${enchantHTML}
                </div>
            `;
        }
        
        // Currently selected hero in equipment shop
        let selectedEquipHero = null;
        
        // Hero weapon data (stored per hero)
        let heroWeapons = {
            zooko: { upgradeLevel: 0, enchantment: null },
            nate: { upgradeLevel: 0, enchantment: null },
            zancas: { upgradeLevel: 0, enchantment: null },
            cyberaxe: { upgradeLevel: 0, enchantment: null }
        };
        
        // Select a hero in the equipment shop
        function selectEquipHero(heroName) {
            selectedEquipHero = heroName;
            
            // Update button styles
            document.querySelectorAll('.equipHeroBtn').forEach(btn => {
                const isSelected = btn.dataset.hero === heroName;
                btn.style.opacity = isSelected ? '1' : '0.6';
                btn.style.transform = isSelected ? 'scale(1.05)' : 'scale(1)';
            });
            
            // Update display
            updateEquipmentShopDisplay();
        }
        
        // Update equipment shop display for selected hero
        function updateEquipmentShopDisplay() {
            if (!selectedEquipHero) return;
            
            const heroColor = HERO_COLORS[selectedEquipHero];
            const heroName = selectedEquipHero.charAt(0).toUpperCase() + selectedEquipHero.slice(1);
            const weapon = heroWeapons[selectedEquipHero];
            
            // Update hero name
            document.getElementById('equipHeroName').textContent = heroName;
            document.getElementById('equipHeroName').style.color = heroColor;
            
            // Get current upgrade info
            const currentUpgrade = EQUIPMENT_UPGRADES.find(u => u.level === weapon.upgradeLevel * 10) || { name: 'Basic', level: 0 };
            document.getElementById('equipWeaponLevel').textContent = currentUpgrade.name + (weapon.upgradeLevel > 0 ? ` (Lv ${weapon.upgradeLevel * 10})` : '');
            
            // Get enchantment info
            const enchant = weapon.enchantment ? ENCHANTMENTS.find(e => e.id === weapon.enchantment) : null;
            document.getElementById('equipEnchantName').textContent = enchant ? enchant.name : 'None';
            if (enchant) {
                document.getElementById('equipEnchantName').style.color = enchant.color;
            } else {
                document.getElementById('equipEnchantName').style.color = '#888';
            }
            
            // Populate upgrade options
            populateUpgradeOptions();
            
            // Populate enchantment options
            populateEnchantOptions();
        }
        
        // Populate available upgrades
        function populateUpgradeOptions() {
            const container = document.getElementById('upgradeOptions');
            if (!container || !selectedEquipHero) return;
            
            const weapon = heroWeapons[selectedEquipHero];
            const currentLevel = weapon.upgradeLevel * 10;
            const partyLevel = partyInventory.partyLevel || 1;
            
            // Get gold from save
            const sharedSave = loadSharedSave();
            const gold = sharedSave?.dungeonState?.gold || 0;
            
            let html = '';
            
            EQUIPMENT_UPGRADES.forEach(upgrade => {
                const isOwned = currentLevel >= upgrade.level;
                const canAfford = gold >= upgrade.cost;
                const meetsLevel = partyLevel >= upgrade.level;
                const isNextUpgrade = currentLevel + 10 === upgrade.level;
                
                if (isOwned) {
                    html += `<div style="background: rgba(39, 174, 96, 0.2); border: 1px solid #27AE60; border-radius: 6px; padding: 6px 10px; opacity: 0.6;">
                        <span style="color: #27AE60; font-size: 11px;">âœ“ ${upgrade.name} (Owned)</span>
                    </div>`;
                } else if (isNextUpgrade) {
                    const canBuy = canAfford && meetsLevel;
                    html += `<div style="background: rgba(155, 89, 182, 0.2); border: 1px solid ${canBuy ? '#9B59B6' : '#666'}; border-radius: 6px; padding: 6px 10px; cursor: ${canBuy ? 'pointer' : 'not-allowed'}; opacity: ${canBuy ? '1' : '0.5'};" onclick="${canBuy ? `buyUpgrade(${upgrade.level})` : ''}">
                        <div style="color: #9B59B6; font-size: 11px; font-weight: bold;">${upgrade.name} Weapon</div>
                        <div style="color: #F1C40F; font-size: 10px;">ðŸ’° ${upgrade.cost} gold</div>
                        ${!meetsLevel ? `<div style="color: #E74C3C; font-size: 9px;">Requires Party Lv ${upgrade.level}</div>` : ''}
                    </div>`;
                }
            });
            
            if (!html) {
                html = '<div style="color: #888; font-size: 11px; text-align: center; padding: 10px;">Max upgrades reached!</div>';
            }
            
            container.innerHTML = html;
        }
        
        // Populate available enchantments
        function populateEnchantOptions() {
            const container = document.getElementById('enchantOptions');
            if (!container || !selectedEquipHero) return;
            
            const weapon = heroWeapons[selectedEquipHero];
            
            // Get gold from save
            const sharedSave = loadSharedSave();
            const gold = sharedSave?.dungeonState?.gold || 0;
            
            let html = '';
            
            ENCHANTMENTS.forEach(enchant => {
                const isActive = weapon.enchantment === enchant.id;
                const canAfford = gold >= enchant.cost;
                
                html += `<div style="background: ${isActive ? `${enchant.color}30` : 'rgba(0,0,0,0.3)'}; border: 2px solid ${isActive ? enchant.color : (canAfford ? '#666' : '#444')}; border-radius: 6px; padding: 6px; text-align: center; cursor: ${canAfford && !isActive ? 'pointer' : 'default'}; opacity: ${canAfford || isActive ? '1' : '0.5'};" onclick="${canAfford && !isActive ? `buyEnchant('${enchant.id}')` : ''}">
                    <div style="color: ${enchant.color}; font-size: 10px; font-weight: bold;">${enchant.name}</div>
                    <div style="font-size: 9px; color: ${isActive ? '#27AE60' : '#F1C40F'};">${isActive ? 'âœ“ Active' : `ðŸ’° ${enchant.cost}`}</div>
                </div>`;
            });
            
            container.innerHTML = html;
        }
        
        // Buy an upgrade
        function buyUpgrade(upgradeLevel) {
            if (!selectedEquipHero) return;
            
            const upgrade = EQUIPMENT_UPGRADES.find(u => u.level === upgradeLevel);
            if (!upgrade) return;
            
            const sharedSave = loadSharedSave();
            const gold = sharedSave?.dungeonState?.gold || 0;
            
            if (gold < upgrade.cost) {
                showNotification('Not enough gold!', 'error');
                return;
            }
            
            // Deduct gold
            sharedSave.dungeonState.gold = gold - upgrade.cost;
            
            // Apply upgrade
            heroWeapons[selectedEquipHero].upgradeLevel = upgradeLevel / 10;
            
            // Save
            saveSharedSave(sharedSave);
            saveHeroWeapons();
            
            // Update display
            updateEquipmentShopDisplay();
            updateGoldDisplay();
            
            showNotification(`${selectedEquipHero.charAt(0).toUpperCase() + selectedEquipHero.slice(1)} weapon upgraded to ${upgrade.name}!`, 'success');
            
            // Sync to multiplayer
            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                sendEquipmentUpdate();
            }
        }
        
        // Buy an enchantment
        function buyEnchant(enchantId) {
            if (!selectedEquipHero) return;
            
            const enchant = ENCHANTMENTS.find(e => e.id === enchantId);
            if (!enchant) return;
            
            const sharedSave = loadSharedSave();
            const gold = sharedSave?.dungeonState?.gold || 0;
            
            if (gold < enchant.cost) {
                showNotification('Not enough gold!', 'error');
                return;
            }
            
            // Deduct gold
            sharedSave.dungeonState.gold = gold - enchant.cost;
            
            // Apply enchantment
            heroWeapons[selectedEquipHero].enchantment = enchantId;
            
            // Save
            saveSharedSave(sharedSave);
            saveHeroWeapons();
            
            // Update display
            updateEquipmentShopDisplay();
            updateGoldDisplay();
            
            showNotification(`${enchant.name} enchantment applied!`, 'success');
            
            // Restart hero idle particles to apply new enchantment color
            if (battleState.heroes && battleState.heroes.length > 0) {
                startHeroIdleParticles();
            }
            
            // Sync to multiplayer
            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                sendEquipmentUpdate();
            }
        }
        
        // Save hero weapons to localStorage
        function saveHeroWeapons() {
            const sharedSave = loadSharedSave();
            if (sharedSave) {
                sharedSave.heroWeapons = heroWeapons;
                saveSharedSave(sharedSave);
            }
        }
        
        // Load hero weapons from localStorage
        function loadHeroWeapons() {
            const sharedSave = loadSharedSave();
            if (sharedSave?.heroWeapons) {
                heroWeapons = sharedSave.heroWeapons;
            }
        }

        function showSettings() {
            document.getElementById('overlay').style.display = 'block';
            document.getElementById('settingsPanel').style.display = 'block';
            
            // Load current settings into UI
            document.getElementById('musicEnabled').checked = settings.musicEnabled;
            document.getElementById('musicVolume').value = settings.musicVolume;
            document.getElementById('musicVolumeValue').textContent = settings.musicVolume;
            document.getElementById('bgSoundVolume').value = settings.bgSoundVolume;
            document.getElementById('bgSoundVolumeValue').textContent = settings.bgSoundVolume;
            document.getElementById('voiceVolume').value = settings.voiceVolume;
            document.getElementById('voiceVolumeValue').textContent = settings.voiceVolume;
            document.getElementById('sfxVolume').value = settings.sfxVolume !== undefined ? settings.sfxVolume : 50;
            document.getElementById('sfxVolumeValue').textContent = settings.sfxVolume !== undefined ? settings.sfxVolume : 50;
            document.getElementById('themeMusicEnabled').checked = settings.themeMusicEnabled !== false;
            document.getElementById('zoneMusicEnabled').checked = settings.zoneMusicEnabled !== false;
            document.getElementById('showHitboxes').checked = settings.showHitboxes;
            document.getElementById('llmFreeWill').checked = settings.llmFreeWill;
            document.getElementById('llmUsePaid').checked = settings.llmUsePaid;
            document.getElementById('rpMode').checked = settings.rpMode !== false; // Default true
            document.getElementById('diagMode').checked = settings.diagMode === true;
        }
        
        // Apply background sound volume to all active video backgrounds
        function applyBgSoundVolume() {
            const vol = (settings.bgSoundVolume ?? 25) / 500;
            console.log('[applyBgSoundVolume] Setting volume to:', vol, 'from bgSoundVolume:', settings.bgSoundVolume);
            
            // Camp video
            const campVideo = document.getElementById('campVideo');
            if (campVideo) {
                campVideo.volume = vol;
                console.log('[applyBgSoundVolume] Camp video volume set');
            }
            
            // Store/trader video
            const storeVideo = document.getElementById('storeBackgroundVideo');
            if (storeVideo) {
                storeVideo.volume = vol;
                console.log('[applyBgSoundVolume] Store video volume set');
            }
            
            // Battle background video (if not muted)
            const battleVideo = document.getElementById('battleBackgroundVideo');
            if (battleVideo && !battleVideo.muted) {
                battleVideo.volume = vol;
                console.log('[applyBgSoundVolume] Battle video volume set');
            }
        }
        
        // Story voice audio players (for title screen)
        let storyVoiceAudio = null;
        let kingVoiceAudio = null;
        
        // Toggle Story Voice playback
        function toggleStoryVoice() {
            const btn = document.getElementById('storyVoiceBtn');
            const icon = document.getElementById('storyVoiceIcon');
            
            // Stop king voice if playing
            if (kingVoiceAudio && !kingVoiceAudio.paused) {
                kingVoiceAudio.pause();
                kingVoiceAudio.currentTime = 0;
                document.getElementById('kingVoiceIcon').textContent = 'ðŸ‘‘';
                document.getElementById('kingVoiceBtn').style.borderColor = '#F2C94C';
            }
            
            if (storyVoiceAudio && !storyVoiceAudio.paused) {
                // Stop playing
                storyVoiceAudio.pause();
                storyVoiceAudio.currentTime = 0;
                icon.textContent = 'ðŸ“–';
                btn.style.borderColor = '#8B45FF';
            } else {
                // Start playing
                if (!storyVoiceAudio) {
                    storyVoiceAudio = new Audio('tunnelsofprivacy/voiced/intro_voiced.mp3');
                    storyVoiceAudio.addEventListener('ended', () => {
                        icon.textContent = 'ðŸ“–';
                        btn.style.borderColor = '#8B45FF';
                    });
                }
                storyVoiceAudio.volume = Math.min((settings.voiceVolume || 90) / 100, 1.0);
                storyVoiceAudio.currentTime = 0;
                storyVoiceAudio.play().catch(e => console.log('[StoryVoice] Playback failed:', e));
                icon.textContent = 'â¹ï¸';
                btn.style.borderColor = '#27AE60';
            }
        }
        
        // Toggle King Voice playback
        function toggleKingVoice() {
            const btn = document.getElementById('kingVoiceBtn');
            const icon = document.getElementById('kingVoiceIcon');
            
            // Stop story voice if playing
            if (storyVoiceAudio && !storyVoiceAudio.paused) {
                storyVoiceAudio.pause();
                storyVoiceAudio.currentTime = 0;
                document.getElementById('storyVoiceIcon').textContent = 'ðŸ“–';
                document.getElementById('storyVoiceBtn').style.borderColor = '#8B45FF';
            }
            
            if (kingVoiceAudio && !kingVoiceAudio.paused) {
                // Stop playing
                kingVoiceAudio.pause();
                kingVoiceAudio.currentTime = 0;
                icon.textContent = 'ðŸ‘‘';
                btn.style.borderColor = '#F2C94C';
            } else {
                // Start playing
                if (!kingVoiceAudio) {
                    kingVoiceAudio = new Audio('tunnelsofprivacy/voiced/intro_king_voiced.mp3');
                    kingVoiceAudio.addEventListener('ended', () => {
                        icon.textContent = 'ðŸ‘‘';
                        btn.style.borderColor = '#F2C94C';
                    });
                }
                kingVoiceAudio.volume = Math.min((settings.voiceVolume || 90) / 100, 1.0);
                kingVoiceAudio.currentTime = 0;
                kingVoiceAudio.play().catch(e => console.log('[KingVoice] Playback failed:', e));
                icon.textContent = 'â¹ï¸';
                btn.style.borderColor = '#27AE60';
            }
        }
        
        function showAbout() {
            document.getElementById('overlay').style.display = 'block';
            document.getElementById('aboutPanel').style.display = 'block';
        }
        
        function updateSettings() {
            // Read values from UI
            settings.musicEnabled = document.getElementById('musicEnabled').checked;
            settings.musicVolume = parseInt(document.getElementById('musicVolume').value);
            settings.bgSoundVolume = parseInt(document.getElementById('bgSoundVolume').value);
            settings.voiceVolume = parseInt(document.getElementById('voiceVolume').value);
            settings.sfxVolume = parseInt(document.getElementById('sfxVolume').value);
            settings.showHitboxes = document.getElementById('showHitboxes').checked;
            settings.llmFreeWill = document.getElementById('llmFreeWill').checked;
            settings.llmUsePaid = document.getElementById('llmUsePaid').checked;
            settings.rpMode = document.getElementById('rpMode').checked;
            settings.diagMode = document.getElementById('diagMode').checked;
            
            // Update display
            document.getElementById('musicVolumeValue').textContent = settings.musicVolume;
            document.getElementById('bgSoundVolumeValue').textContent = settings.bgSoundVolume;
            document.getElementById('voiceVolumeValue').textContent = settings.voiceVolume;
            document.getElementById('sfxVolumeValue').textContent = settings.sfxVolume;
            sfxVolume = settings.sfxVolume;
            
            // Apply background sound volume to active videos
            applyBgSoundVolume();
            
            // Read theme/zone music toggles
            const themeCheckbox = document.getElementById('themeMusicEnabled');
            const zoneCheckbox = document.getElementById('zoneMusicEnabled');
            if (themeCheckbox) settings.themeMusicEnabled = themeCheckbox.checked;
            if (zoneCheckbox) settings.zoneMusicEnabled = zoneCheckbox.checked;
            
            // Prevent both being disabled - at least one must be on
            if (!settings.themeMusicEnabled && !settings.zoneMusicEnabled) {
                // Re-enable the one that was just disabled
                if (!themeCheckbox.checked) {
                    settings.zoneMusicEnabled = true;
                    if (zoneCheckbox) zoneCheckbox.checked = true;
                } else {
                    settings.themeMusicEnabled = true;
                    if (themeCheckbox) themeCheckbox.checked = true;
                }
            }
            
            // Apply to game state
            musicEnabled = settings.musicEnabled;
            musicVolume = settings.musicVolume;
            themeMusicEnabled = settings.themeMusicEnabled;
            zoneMusicEnabled = settings.zoneMusicEnabled;
            
            // Re-render battle if active to show/hide hitboxes
            if (battleState.active) {
                renderBattle();
            }
            
            // Handle music volume change (don't change play/pause state)
            if (currentMusic && musicEnabled) {
                const actualVol = Math.min(1.0, musicVolume / 500);
                currentMusic.volume = actualVol;
            }
            
            // Only pause music if explicitly disabled via checkbox
            if (currentMusic && !musicEnabled) {
                currentMusic.pause();
            }
            
            // Update volume slider in main controls
            const mainSlider = document.getElementById('volumeSlider');
            if (mainSlider) {
                mainSlider.value = musicVolume;
            }
            
            // Update play/pause button
            updateMusicButton();
            
            // Save to localStorage
            saveSettings();
        }
        
        function closeAllPanels() {
            document.getElementById('overlay').style.display = 'none';
            document.getElementById('settingsPanel').style.display = 'none';
            document.getElementById('aboutPanel').style.display = 'none';
            document.getElementById('inventoryPanel').style.display = 'none';
            const loadSavePanel = document.getElementById('loadSavePanel');
            if (loadSavePanel) {
                loadSavePanel.style.display = 'none';
            }
        }
        
        function showLoadSave() {
            document.getElementById('overlay').style.display = 'block';
            const loadSavePanel = document.getElementById('loadSavePanel');
            if (loadSavePanel) {
                loadSavePanel.style.display = 'block';
            }
        }
        
        function loadSaveFile() {
            const fileInput = document.getElementById('saveFileInput');
            const file = fileInput.files[0];
            
            if (!file) {
                alert('Please select a save file first!');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const saveData = JSON.parse(e.target.result);
                    
                    // Validate save data structure
                    if (!saveData || !saveData.heroes) {
                        alert('Invalid save file format! Missing hero data.');
                        return;
                    }
                    
                    // Save to localStorage
                    if (saveSharedSave(saveData)) {
                        alert('Save file loaded successfully!');
                        
                        // Refresh hero displays
                        if (saveData.heroes.zooko) updateHeroDisplay('zooko', saveData.heroes.zooko);
                        if (saveData.heroes.nate) updateHeroDisplay('nate', saveData.heroes.nate);
                        if (saveData.heroes.zancas) updateHeroDisplay('zancas', saveData.heroes.zancas);
                        if (saveData.heroes.cyberaxe) updateHeroDisplay('cyberaxe', saveData.heroes.cyberaxe);
                        
                        // Update gold display
                        updateGoldDisplay();
                        
                        // Update dungeon level if arcade state exists
                        if (saveData.arcadeState && saveData.arcadeState.level) {
                            document.getElementById('dungeonLevel').textContent = saveData.arcadeState.level;
                        }
                        
                        // Update title screen buttons
                        updateTitleScreenButtons();
                        
                        // Close panel
                        closeAllPanels();
                        
                        // Clear file input
                        fileInput.value = '';
                    } else {
                        alert('Failed to save the loaded data to localStorage.');
                    }
                } catch (error) {
                    alert('Error reading save file: ' + error.message);
                    console.error('Save file load error:', error);
                }
            };
            
            reader.onerror = function() {
                alert('Error reading file!');
            };
            
            reader.readAsText(file);
        }
        
        function saveSettings() {
            try {
                localStorage.setItem(STORAGE_KEYS.SETTINGS, JSON.stringify(settings));
            } catch (e) {
                console.error('Failed to save settings:', e);
            }
        }
        
        function loadSettings() {
            try {
                const saved = localStorage.getItem(STORAGE_KEYS.SETTINGS);
                if (saved) {
                    const loaded = JSON.parse(saved);
                    settings = { ...settings, ...loaded };
                    
                    // Apply to game state
                    musicEnabled = settings.musicEnabled;
                    musicVolume = settings.musicVolume;
                    sfxVolume = settings.sfxVolume !== undefined ? settings.sfxVolume : 50;
                    themeMusicEnabled = settings.themeMusicEnabled !== false;
                    zoneMusicEnabled = settings.zoneMusicEnabled !== false;
                    
                    // Update main volume slider and display
                    const mainSlider = document.getElementById('volumeSlider');
                    if (mainSlider) {
                        mainSlider.value = musicVolume;
                    }
                    const volumeDisplay = document.getElementById('volumeSliderValue');
                    if (volumeDisplay) {
                        volumeDisplay.textContent = musicVolume;
                    }
                    
                    // Populate player name input field
                    const playerNameInput = document.getElementById('multiplayerPlayerName');
                    if (playerNameInput) {
                        if (settings.playerName) {
                            playerNameInput.value = settings.playerName;
                            multiplayerState.playerName = settings.playerName;
                        } else {
                            // Use random name as default
                            playerNameInput.value = multiplayerState.playerName;
                        }
                    }
                }
            } catch (e) {
                console.error('Failed to load settings:', e);
            }
            
            // Ensure player name input has a value even if settings load failed
            const playerNameInput = document.getElementById('multiplayerPlayerName');
            if (playerNameInput && !playerNameInput.value) {
                playerNameInput.value = multiplayerState.playerName;
            }
        }
        
        // Load shared save and populate hero stats
        function loadSharedSave() {
            try {
                const saved = localStorage.getItem(STORAGE_KEYS.SHARED_SAVE);
                if (!saved) return null;
                
                const sharedSave = JSON.parse(saved);
                return migrateSharedSave(sharedSave);
            } catch (e) {
                console.error('Failed to load shared save:', e);
                return null;
            }
        }
        
        // Save shared save to localStorage
        function saveSharedSave(sharedSave) {
            try {
                const jsonString = JSON.stringify(sharedSave);
                localStorage.setItem(STORAGE_KEYS.SHARED_SAVE, jsonString);
                console.log('Shared save written. Size:', jsonString.length, 'bytes');
                return true;
            } catch (e) {
                console.error('Failed to save shared save:', e);
                return false;
            }
        }
        
        // Migrate shared save between versions
        function migrateSharedSave(sharedSave) {
            // Currently at version 1, no migrations needed yet
            return sharedSave;
        }
        
        // Creates default shared save with initial hero stats
        function createDefaultSharedSave() {
            // Get rolled stats if any were set during hero selection
            const rolledStats = multiplayerState.rolledHeroStats || {};
            
            // Helper to merge rolled stats with defaults
            function getHeroStats(heroKey, defaultStats) {
                if (rolledStats[heroKey]) {
                    return {
                        name: defaultStats.name,
                        str: rolledStats[heroKey].str,
                        dex: rolledStats[heroKey].dex,
                        con: rolledStats[heroKey].con,
                        int: rolledStats[heroKey].int,
                        wis: rolledStats[heroKey].wis,
                        cha: rolledStats[heroKey].cha,
                        hp: rolledStats[heroKey].hp,
                        maxHp: rolledStats[heroKey].maxHp,
                        ac: rolledStats[heroKey].ac,
                        xp: 0,
                        level: 1
                    };
                }
                return defaultStats;
            }
            
            return {
                saveVersion: 1,
                lastPlayed: Date.now(),
                arcadeState: null,
                dungeonState: {
                    currentLevel: 1,
                    inventory: [],
                    gold: 42,
                    questProgress: {
                        hasScepter: false,
                        hasReturned: false,
                        bossesDefeated: []
                    }
                },
                heroes: {
                    zooko: getHeroStats('zooko', {
                        name: 'Zooko',
                        str: 8, dex: 11, con: 10, int: 15, wis: 13, cha: 9,
                        hp: 22, maxHp: 25, ac: 12, xp: 0, level: 1
                    }),
                    nate: getHeroStats('nate', {
                        name: 'Nate',
                        str: 14, dex: 12, con: 13, int: 10, wis: 9, cha: 11,
                        hp: 28, maxHp: 30, ac: 14, xp: 0, level: 1
                    }),
                    zancas: getHeroStats('zancas', {
                        name: 'Zancas',
                        str: 10, dex: 15, con: 11, int: 12, wis: 14, cha: 8,
                        hp: 24, maxHp: 26, ac: 13, xp: 0, level: 1
                    }),
                    cyberaxe: getHeroStats('cyberaxe', {
                        name: 'CyberAxe',
                        str: 16, dex: 10, con: 14, int: 8, wis: 11, cha: 10,
                        hp: 32, maxHp: 35, ac: 15, xp: 0, level: 1
                    })
                }
            };
        }
        
        // Custom dialog system (replaces browser confirm/alert)
        function showConfirmDialog(title, message, onConfirm, onCancel) {
            const dialog = document.getElementById('confirmDialog');
            const overlay = document.getElementById('overlay');
            const titleEl = document.getElementById('confirmDialogTitle');
            const messageEl = document.getElementById('confirmDialogMessage');
            const yesBtn = document.getElementById('confirmDialogYes');
            const noBtn = document.getElementById('confirmDialogNo');
            
            titleEl.textContent = title;
            messageEl.textContent = message;
            
            // Clear previous handlers
            yesBtn.onclick = null;
            noBtn.onclick = null;
            
            yesBtn.onclick = () => {
                dialog.style.display = 'none';
                overlay.style.zIndex = '150'; // Reset overlay z-index
                if (onConfirm) onConfirm();
            };
            
            noBtn.onclick = () => {
                dialog.style.display = 'none';
                overlay.style.zIndex = '150'; // Reset overlay z-index
                if (onCancel) onCancel();
            };
            
            overlay.style.zIndex = '1150'; // Above settings (1100) but below dialogs (1200)
            overlay.style.display = 'block';
            dialog.style.display = 'block';
        }
        
        function showInfoDialog(title, message, icon, onOk) {
            const dialog = document.getElementById('infoDialog');
            const overlay = document.getElementById('overlay');
            const titleEl = document.getElementById('infoDialogTitle');
            const messageEl = document.getElementById('infoDialogMessage');
            const iconEl = document.getElementById('infoDialogIcon');
            const okBtn = document.getElementById('infoDialogOk');
            
            titleEl.textContent = title;
            messageEl.textContent = message;
            iconEl.textContent = icon || 'âœ…';
            
            // Set border color based on icon
            if (icon === 'âŒ' || icon === 'âš ï¸') {
                dialog.style.borderColor = '#EB5757';
                titleEl.style.color = '#EB5757';
            } else {
                dialog.style.borderColor = '#27AE60';
                titleEl.style.color = '#27AE60';
            }
            
            okBtn.onclick = () => {
                dialog.style.display = 'none';
                overlay.style.zIndex = '150'; // Reset overlay z-index
                if (onOk) onOk();
            };
            
            overlay.style.zIndex = '1150'; // Above settings (1100) but below dialogs (1200)
            overlay.style.display = 'block';
            dialog.style.display = 'block';
        }
        
        // Clear cache - deletes all localStorage data and forces hard reload
        function clearCache() {
            showConfirmDialog(
                'CLEAR ALL DATA',
                'This will delete ALL saved data including your hero progress, settings, and game state. This cannot be undone. Are you sure?',
                () => {
                    // User confirmed - clear everything
                    try {
                        localStorage.removeItem(STORAGE_KEYS.SETTINGS);
                        localStorage.removeItem(STORAGE_KEYS.SHARED_SAVE);
                        
                        // Clear browser cache for images and assets
                        if ('caches' in window) {
                            caches.keys().then(function(names) {
                                for (let name of names) caches.delete(name);
                            });
                        }
                        
                        showInfoDialog(
                            'CACHE CLEARED',
                            'All data has been deleted. The page will now reload with fresh assets.',
                            'âœ…',
                            () => {
                                // Force hard reload (bypass cache)
                                location.reload(true);
                            }
                        );
                    } catch (e) {
                        console.error('Clear cache error:', e);
                        showInfoDialog('ERROR', 'Error clearing cache: ' + e.message, 'âŒ');
                    }
                },
                null // Cancel does nothing
            );
        }
        
        // Update title screen button states based on save existence
        function updateTitleScreenButtons() {
            const sharedSave = loadSharedSave();
            const continueBtn = document.getElementById('continueBtn');
            
            if (sharedSave && (sharedSave.arcadeState || sharedSave.dungeonState)) {
                // Has save - enable CONTINUE
                continueBtn.disabled = false;
                continueBtn.classList.remove('comingSoon');
            } else {
                // No save - disable CONTINUE
                continueBtn.disabled = true;
                continueBtn.classList.add('comingSoon');
            }
        }
        
        // Continue game - load from save
        // Single-player: Continue game from save
        function continueGameSinglePlayer() {
            const sharedSave = loadSharedSave();
            if (!sharedSave) {
                alert('No save game found! Start a new adventure first.');
                return;
            }
            
            // Hide hero selection modal if open (for single player flow)
            document.getElementById('heroSelectionModal').style.display = 'none';
            document.getElementById('musicControls').classList.remove('heroSelectionActive');
            document.getElementById('musicTicker').classList.remove('battleActive');
            
            // Restore hidden elements (in case coming from single player hero selection)
            const codeDisplay = document.getElementById('heroSelectionCode');
            if (codeDisplay) codeDisplay.parentElement.style.display = '';
            const playerNameInput = document.getElementById('playerNameInput');
            if (playerNameInput) playerNameInput.parentElement.style.display = '';
            const backBtn = document.getElementById('heroSelectionBackBtn');
            if (backBtn) backBtn.style.display = '';
            
            // Center music controls for dungeon menu
            document.getElementById('musicControls').classList.add('dungeonMenuActive');
            document.getElementById('musicTicker').classList.add('dungeonMenuActive');
            
            // Show dungeon menu with existing save (no warning needed)
            document.getElementById('titleScreen').style.display = 'none';
            document.getElementById('dungeonMenuScreen').style.display = 'block';
            currentScreen = 'dungeonMenu';
            
            // Update dungeon menu with save data
            updateDungeonMenuHeroes();
            updateGoldDisplay();
            updateDifficultyButtons();
            
            // Apply client UI restrictions
            applyClientUIRestrictions();
            
            // Get current level from save
            const currentLevel = sharedSave?.dungeonState?.currentLevel || sharedSave?.arcadeState?.level || 1;
            
            // Update level display
            const dungeonMenuLevel = document.getElementById('dungeonMenuLevel');
            if (dungeonMenuLevel) {
                dungeonMenuLevel.textContent = currentLevel;
            }
            
            // Initialize level layout for current level (generates rooms, updates UI)
            initializeLevelLayout(currentLevel);
            
            // Pre-generate next encounter while player is in dungeon menu
            preGenerateNextEncounter();
        }
        
        // Router: Determine which continue function to call
        function continueGame() {
            if (multiplayerState.enabled) {
                continueGameMultiplayer();
            } else {
                continueGameSinglePlayer();
            }
        }
        
        // ===== BATTLE SYSTEM =====
        
        // Battle state
        let battleState = {
            active: false,
            won: false,
            hadBoss: false, // Track if this battle had a boss (for level progress)
            currentTurn: 0,
            turnOrder: [],
            heroes: [],
            allHeroes: [], // All heroes including dead/retreated ones (for saving stats)
            enemies: [],
            platforms: [],
            canvas: null,
            ctx: null,
            backgroundImage: null,
            backgroundPath: '',
            backgroundVideo: null,
            backgroundVideoPath: '',
            useVideoBackground: false,
            detectedPlatforms: [],
            targetingMode: false,
            pendingAction: null,
            swapTargetingMode: false,
            swapInitiator: null
        };
        
        // Room video backgrounds (valid room numbers only, excluding removed backgrounds)
        const validRoomNumbers = [
            1, 2, 3, 4, 5, 6, 7, 10, 12, 14, 15, 16, 17, 18, 19, 20,
            21, 22, 23, 24, 27, 28, 29, 31, 32, 34, 35, 36, 37, 38, 39, 40,
            41, 42, 44, 45, 47, 48, 49, 50, 51, 55, 56, 57, 58, 59, 60,
            61, 62, 64, 65, 68
        ];
        const roomVideos = validRoomNumbers.map(i => `tunnelsofprivacy/levels/rooms/rooms (${i}).mp4`);
        
        // Get random room video
        function getRandomRoomVideo() {
            return roomVideos[Math.floor(Math.random() * roomVideos.length)];
        }
        
        // Exploration background images (11 images)
        const exploreBackgrounds = [];
        for (let i = 1; i <= 11; i++) {
            exploreBackgrounds.push(`tunnelsofprivacy/events/explore/explore (${i}).png`);
        }
        
        // Get random exploration background
        function getRandomExploreBackground() {
            return exploreBackgrounds[Math.floor(Math.random() * exploreBackgrounds.length)];
        }
        
        // NPC Encounter background images (10 images)
        const encounterBackgrounds = [];
        for (let i = 1; i <= 10; i++) {
            encounterBackgrounds.push(`tunnelsofprivacy/events/encoutners/encoutners (${i}).png`);
        }
        
        // Get random encounter background
        function getRandomEncounterBackground() {
            return encounterBackgrounds[Math.floor(Math.random() * encounterBackgrounds.length)];
        }
        
        // Trader/Store video backgrounds (12 videos)
        const traderVideos = [
            'tunnelsofprivacy/levels/traders/traders_armory_lane_var1.mp4',
            'tunnelsofprivacy/levels/traders/traders_currency_exchange_var1.mp4',
            'tunnelsofprivacy/levels/traders/traders_dragon_vault_market_var1.mp4',
            'tunnelsofprivacy/levels/traders/traders_elevator_hub_var1.mp4',
            'tunnelsofprivacy/levels/traders/traders_food_bazaar_var1.mp4',
            'tunnelsofprivacy/levels/traders/traders_fungus_village_var1.mp4',
            'tunnelsofprivacy/levels/traders/traders_inner_market_var1.mp4',
            'tunnelsofprivacy/levels/traders/traders_loan_shark_row_var1.mp4',
            'tunnelsofprivacy/levels/traders/traders_merc_gear_ground_var1.mp4',
            'tunnelsofprivacy/levels/traders/traders_shady_dealer_alley_var1.mp4',
            'tunnelsofprivacy/levels/traders/traders_under_bridge_var1.mp4',
            'tunnelsofprivacy/levels/traders/traders_zec_crystal_plaza_var1.mp4'
        ];
        
        // Get random trader video
        function getRandomTraderVideo() {
            return traderVideos[Math.floor(Math.random() * traderVideos.length)];
        }
        
        // Stop and hide store background video
        function stopStoreVideo() {
            const videoEl = document.getElementById('storeBackgroundVideo');
            if (videoEl) {
                videoEl.pause();
                videoEl.style.display = 'none';
            }
        }
        
        // Stop and hide battle background video
        function stopBattleVideo() {
            const videoEl = document.getElementById('battleBackgroundVideo');
            if (videoEl) {
                videoEl.pause();
                videoEl.style.display = 'none';
            }
            battleState.useVideoBackground = false;
        }
        
        // Calculate number of mobs to spawn based on dungeon level
        // Scales from 2 mobs at level 1 up to max 9 mobs at higher levels
        function getMobCountForLevel(level) {
            // Level 1: 2 mobs (intro)
            // Level 2-4: 2 mobs
            // Level 5-9: 3 mobs
            // Level 10-14: 4 mobs
            // Level 15-19: 5 mobs
            // Level 20-29: 6 mobs
            // Level 30-39: 7 mobs
            // Level 40-49: 8 mobs
            // Level 50+: 9 mobs (max)
            if (level < 5) return 2;
            if (level < 10) return 3;
            if (level < 15) return 4;
            if (level < 20) return 5;
            if (level < 30) return 6;
            if (level < 40) return 7;
            if (level < 50) return 8;
            return 9; // Max mobs
        }
        
        // Scale mob stats for early levels (1-9) to make them easier
        // Mobs in JSON are balanced for level 10+, so we reduce stats for early game
        function getEarlyLevelScaling(level) {
            // Level 1-2: 50% stats (learning phase)
            // Level 3-4: 60% stats
            // Level 5-6: 70% stats
            // Level 7-8: 80% stats
            // Level 9: 90% stats
            // Level 10+: 100% stats (full power)
            if (level <= 2) return 0.50;
            if (level <= 4) return 0.60;
            if (level <= 6) return 0.70;
            if (level <= 8) return 0.80;
            if (level <= 9) return 0.90;
            return 1.0; // Full stats at level 10+
        }
        
        // Apply early-level scaling to mob stats
        function applyEarlyLevelScaling(mobEnemy, roomLevel) {
            const scale = getEarlyLevelScaling(roomLevel);
            if (scale < 1.0) {
                mobEnemy.hp = Math.max(1, Math.floor(mobEnemy.hp * scale));
                mobEnemy.maxHp = Math.max(1, Math.floor(mobEnemy.maxHp * scale));
                mobEnemy.attackDamage = Math.max(1, Math.floor(mobEnemy.attackDamage * scale));
                // AC reduction is smaller (only reduce by half the scaling difference)
                const acReduction = Math.floor((1 - scale) * mobEnemy.ac * 0.5);
                mobEnemy.ac = Math.max(8, mobEnemy.ac - acReduction);
            }
        }
        
        // Get boss data file based on difficulty setting
        function getBossDifficultyFile() {
            const difficultyMap = {
                'casual': 'tunnelsofprivacy/bosses/bosses_data_easy.json',
                'normal': 'tunnelsofprivacy/bosses/bosses_data_normal.json',
                'expert': 'tunnelsofprivacy/bosses/bosses_data_hard.json'
            };
            return difficultyMap[settings.difficulty] || difficultyMap['normal'];
        }
        
        // ===== CAMP SYSTEM =====
        
        // Camp state
        let campState = {
            active: false,
            selectedHours: 8,
            hoursRemaining: 0,
            healPerHour: 2,
            startTime: null,
            intervalId: null,
            videoPlaying: false
        };
        
        // Camp video files organized by level ranges
        const campVideos = {
            // Early levels (1-20) - general camp videos
            early: [
                'tunnelsofprivacy/levels/camps/camp_lvl1_var1.mp4',
                'tunnelsofprivacy/levels/camps/camp_lvl1_var2.mp4',
                'tunnelsofprivacy/levels/camps/camp_lvl1_var3.mp4',
                'tunnelsofprivacy/levels/camps/camp_lvl1_var4.mp4'
            ],
            // Mid levels (21-60) - counterfeit vaults area
            mid: [
                'tunnelsofprivacy/levels/camps/camp_lvl5x-6x_counterfeit_vaults_var1.mp4',
                'tunnelsofprivacy/levels/camps/camp_lvl5x-6x_counterfeit_vaults_var2.mp4'
            ],
            // Deep levels (61-90) - descent to core
            deep: [
                'tunnelsofprivacy/levels/camps/camp_lvl9x_descent_to_core_var1.mp4',
                'tunnelsofprivacy/levels/camps/camp_lvl9x_descent_to_core_var2.mp4'
            ],
            // Zone-specific camps
            forkedMaze: ['tunnelsofprivacy/levels/camps/camp_forked_maze_var1.mp4'],
            fungibilityLabyrinth: ['tunnelsofprivacy/levels/camps/camp_fungibility_labyrinth_var1.mp4'],
            haloSpiral: ['tunnelsofprivacy/levels/camps/camp_halo_spiral_var1.mp4'],
            identityDepths: [
                'tunnelsofprivacy/levels/camps/camp_identity_depths_var1.mp4',
                'tunnelsofprivacy/levels/camps/camp_identity_depths_var2.mp4'
            ],
            orchardSanctum: ['tunnelsofprivacy/levels/camps/camp_orchard_sanctum_var1.mp4'],
            // Generic camps
            generic: [
                'tunnelsofprivacy/levels/camps/camps_bitgold_bazaar_var1.mp4',
                'tunnelsofprivacy/levels/camps/camps_collapsed_gallery_var1.mp4',
                'tunnelsofprivacy/levels/camps/camps_crossroads_village_var1.mp4',
                'tunnelsofprivacy/levels/camps/camps_refugee_village_var1.mp4',
                'tunnelsofprivacy/levels/camps/camps_river_tavern_var1.mp4',
                'tunnelsofprivacy/levels/camps/camps_tunnel_inn_var1.mp4'
            ]
        };
        
        // Get appropriate camp video based on current dungeon level
        function getCampVideoForLevel(level) {
            let videoPool = [];
            
            if (level <= 20) {
                videoPool = [...campVideos.early, ...campVideos.generic];
            } else if (level <= 60) {
                videoPool = [...campVideos.mid, ...campVideos.generic];
            } else if (level <= 90) {
                videoPool = [...campVideos.deep, ...campVideos.generic];
            } else {
                // High levels - use zone-specific or generic
                videoPool = [
                    ...campVideos.identityDepths,
                    ...campVideos.orchardSanctum,
                    ...campVideos.haloSpiral,
                    ...campVideos.generic
                ];
            }
            
            // Random selection
            return videoPool[Math.floor(Math.random() * videoPool.length)];
        }
        
        // Open the camp panel
        function openCampPanel() {
            // Host-only check in multiplayer
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                showNotification('Only the party leader can set up camp', 'warning');
                return;
            }
            
            // Close other panels
            const dungeonMastersPanel = document.getElementById('dungeonMastersPanel');
            if (dungeonMastersPanel) dungeonMastersPanel.style.display = 'none';
            
            // Sync battleState.heroes with saved data (in case exploration damaged them)
            const sharedSave = loadSharedSave();
            if (sharedSave && sharedSave.heroes) {
                battleState.heroes.forEach(hero => {
                    const heroKey = hero.name.toLowerCase();
                    if (sharedSave.heroes[heroKey]) {
                        hero.hp = sharedSave.heroes[heroKey].hp;
                        hero.maxHp = sharedSave.heroes[heroKey].maxHp;
                    }
                });
            }
            
            // Show camp panel
            const campPanel = document.getElementById('campPanel');
            if (campPanel) {
                campPanel.style.display = 'block';
                
                // Update heal preview based on selected hours
                updateCampHealPreview();
                
                // Populate party meals list
                populatePartyMealsList();
                
                // Highlight camp button
                const campBtn = document.getElementById('campBtn');
                if (campBtn) {
                    campBtn.style.background = 'linear-gradient(135deg, rgba(39, 174, 96, 0.7), rgba(39, 174, 96, 0.5))';
                    campBtn.style.borderColor = '#27AE60';
                }
            }
        }
        
        // Close the camp panel
        function closeCampPanel() {
            const campPanel = document.getElementById('campPanel');
            if (campPanel) {
                campPanel.style.display = 'none';
                
                // Reset camp button style
                const campBtn = document.getElementById('campBtn');
                if (campBtn) {
                    campBtn.style.background = '';
                    campBtn.style.borderColor = '';
                }
            }
        }
        
        // Set camp duration
        function setCampDuration(hours) {
            campState.selectedHours = hours;
            
            // Update button states
            const buttons = document.querySelectorAll('.campDurationBtn');
            buttons.forEach(btn => {
                const btnHours = parseInt(btn.dataset.hours);
                if (btnHours === hours) {
                    btn.style.background = 'rgba(39, 174, 96, 0.6)';
                    btn.style.color = 'white';
                    btn.classList.add('active');
                } else {
                    btn.style.background = 'rgba(39, 174, 96, 0.3)';
                    btn.style.color = '#27AE60';
                    btn.classList.remove('active');
                }
            });
            
            // Update heal preview
            updateCampHealPreview();
        }
        
        // Update the heal preview in camp panel
        function updateCampHealPreview() {
            const hours = campState.selectedHours;
            const healAmount = hours * campState.healPerHour;
            
            // Update each hero's heal preview
            const heroes = ['Zooko', 'Nate', 'Zancas', 'CyberAxe'];
            heroes.forEach(hero => {
                const el = document.getElementById(`campHeal${hero}`);
                if (el) {
                    // Calculate actual heal (can't exceed max HP)
                    const heroData = battleState.heroes.find(h => h.name === hero) || 
                                     { hp: 100, maxHp: 100 };
                    const actualHeal = Math.min(healAmount, heroData.maxHp - heroData.hp);
                    el.textContent = actualHeal > 0 ? `+${actualHeal} HP` : 'FULL';
                    el.style.color = actualHeal > 0 ? '#E74C3C' : '#27AE60';
                }
            });
        }
        
        // Populate the party meals list in camp panel
        function populatePartyMealsList() {
            const listEl = document.getElementById('partyMealsList');
            if (!listEl) return;
            
            // Clients use cached meals from host
            let meals;
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                meals = multiplayerState.partyMealsCache || [];
            } else {
                const sharedSave = loadSharedSave();
                meals = sharedSave?.dungeonState?.partyMeals || [];
            }
            
            if (meals.length === 0) {
                listEl.innerHTML = '<div style="color: #89A0B4; font-size: 11px; text-align: center;">No meals in inventory</div>';
                return;
            }
            
            // Group meals by type for cleaner display
            const mealCounts = {};
            meals.forEach((meal, index) => {
                if (!mealCounts[meal.id]) {
                    mealCounts[meal.id] = { ...meal, count: 0, indices: [] };
                }
                mealCounts[meal.id].count++;
                mealCounts[meal.id].indices.push(index);
            });
            
            let html = '';
            Object.values(mealCounts).forEach(meal => {
                // Store meal data as JSON for tooltip (escape quotes)
                const mealDataAttr = JSON.stringify({ name: meal.name, id: meal.id, value: meal.value, type: 'party_meal' }).replace(/"/g, '&quot;');
                html += `
                    <div class="meal-item" data-meal='${mealDataAttr}' style="display: flex; align-items: center; justify-content: space-between; padding: 6px 8px; background: rgba(255, 159, 67, 0.15); border: 1px solid rgba(255, 159, 67, 0.3); border-radius: 6px; margin-bottom: 4px; cursor: pointer;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <span style="font-size: 16px;">ðŸ–</span>
                            <div>
                                <div style="color: #FF9F43; font-size: 12px; font-weight: bold;">${meal.name} x${meal.count}</div>
                                <div style="color: #89A0B4; font-size: 10px;">+${meal.value} HP each hero</div>
                            </div>
                        </div>
                        <button onclick="usePartyMeal(${meal.indices[0]})" style="padding: 4px 10px; background: linear-gradient(135deg, #FF9F43, #F39C12); border: none; border-radius: 4px; color: white; font-size: 11px; font-weight: bold; cursor: pointer;">
                            EAT
                        </button>
                    </div>
                `;
            });
            
            html += `<div style="text-align: center; margin-top: 6px; font-size: 10px; color: #89A0B4;">${meals.length}/10 meal slots used</div>`;
            listEl.innerHTML = html;
            
            // Add hover events for food tooltips
            listEl.querySelectorAll('.meal-item').forEach(el => {
                el.addEventListener('mouseenter', (e) => {
                    const mealData = JSON.parse(el.dataset.meal);
                    showFoodTooltip(e, mealData);
                });
                el.addEventListener('mousemove', (e) => updateFoodTooltipPosition(e));
                el.addEventListener('mouseleave', () => hideFoodTooltip());
            });
        }
        
        // Use a party meal to heal all heroes
        function usePartyMeal(mealIndex) {
            // Hide any open food tooltip immediately
            hideFoodTooltip();
            
            // Host-only check
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                showNotification('Only the party leader can use meals', 'warning');
                return;
            }
            
            const sharedSave = loadSharedSave();
            if (!sharedSave?.dungeonState?.partyMeals || !sharedSave.dungeonState.partyMeals[mealIndex]) {
                showNotification('Meal not found!', 'error');
                return;
            }
            
            const meal = sharedSave.dungeonState.partyMeals[mealIndex];
            const healAmount = meal.value;
            
            // Heal all heroes
            let healedAny = false;
            ['zooko', 'nate', 'zancas', 'cyberaxe'].forEach(heroKey => {
                const hero = sharedSave.heroes[heroKey];
                if (hero && hero.hp < hero.maxHp) {
                    const oldHp = hero.hp;
                    hero.hp = Math.min(hero.hp + healAmount, hero.maxHp);
                    if (hero.hp > oldHp) healedAny = true;
                }
            });
            
            // Also update battleState heroes for immediate UI update
            battleState.heroes.forEach(hero => {
                const heroKey = hero.name.toLowerCase();
                if (sharedSave.heroes[heroKey]) {
                    hero.hp = sharedSave.heroes[heroKey].hp;
                    hero.maxHp = sharedSave.heroes[heroKey].maxHp;
                }
            });
            
            // Clear the inventory slot if this meal had one assigned
            if (meal.inventorySlot !== undefined && partyInventory.items[meal.inventorySlot]) {
                partyInventory.items[meal.inventorySlot] = null;
            }
            
            // Remove the used meal from partyMeals array
            sharedSave.dungeonState.partyMeals.splice(mealIndex, 1);
            
            // Save and update UI
            saveSharedSave(sharedSave);
            updateDungeonMenuHeroes();
            updateCampHealPreview();
            populatePartyMealsList();
            
            // Sync inventory to clients
            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                sendInventoryUpdate();
            }
            
            // Show notification
            if (healedAny) {
                showNotification(`The party enjoyed ${meal.name}! +${healAmount} HP each`, 'success');
            } else {
                showNotification(`The party enjoyed ${meal.name} (already at full health)`, 'success');
            }
            
            // Broadcast to clients in multiplayer
            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                sendWebSocketMessage({
                    type: 'party_meal_used',
                    mealName: meal.name,
                    healAmount: healAmount
                });
            }
            
            console.log(`[Camp] Used party meal: ${meal.name} (+${healAmount} HP each)`);
        }
        
        // Start camping
        function startCamping() {
            // Host-only check
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                showNotification('Only the party leader can start camping', 'warning');
                return;
            }
            
            // Set camp state
            campState.active = true;
            campState.hoursRemaining = campState.selectedHours;
            campState.startTime = Date.now();
            
            // Hide dungeon menu
            document.getElementById('dungeonMenuScreen').style.display = 'none';
            closeCampPanel();
            
            // Show camping screen
            const campingScreen = document.getElementById('campingScreen');
            if (campingScreen) {
                campingScreen.style.display = 'block';
            }
            
            // Load and play camp video
            const currentLevel = parseInt(document.getElementById('dungeonMenuLevel')?.textContent) || 1;
            const videoSrc = getCampVideoForLevel(currentLevel);
            const videoEl = document.getElementById('campVideo');
            if (videoEl) {
                videoEl.querySelector('source').src = videoSrc;
                videoEl.load();
                videoEl.volume = (settings.bgSoundVolume ?? 25) / 500; // Use settings
                videoEl.play().catch(e => console.log('[Camp] Video autoplay blocked:', e));
                campState.videoPlaying = true;
            }
            
            // Update UI
            document.getElementById('campTimeRemaining').textContent = campState.hoursRemaining;
            document.getElementById('campProgressBar').style.width = '0%';
            document.getElementById('campHealedSoFar').textContent = '0';
            document.getElementById('campEventLog').innerHTML = '<div style="color: #89A0B4; font-size: 12px; text-align: center;">The campfire crackles softly...</div>';
            
            // Start camping timer (1 second = 1 hour in-game for faster gameplay)
            const totalDuration = campState.selectedHours * 1000; // 1 second per hour
            let elapsed = 0;
            let healedSoFar = 0;
            
            campState.intervalId = setInterval(() => {
                elapsed += 100;
                const progress = (elapsed / totalDuration) * 100;
                const hoursElapsed = Math.floor(elapsed / 1000);
                const hoursRemaining = campState.selectedHours - hoursElapsed;
                
                // Update UI
                document.getElementById('campProgressBar').style.width = `${progress}%`;
                document.getElementById('campTimeRemaining').textContent = Math.max(0, hoursRemaining);
                
                // Broadcast progress to clients every 500ms
                if (multiplayerState.enabled && multiplayerState.role === 'host' && elapsed % 500 === 0) {
                    sendWebSocketMessage({
                        type: 'camp_progress',
                        progress: progress,
                        hoursRemaining: Math.max(0, hoursRemaining),
                        healedSoFar: healedSoFar
                    });
                }
                
                // Heal every "hour" (every 1000ms)
                if (hoursElapsed > healedSoFar / campState.healPerHour) {
                    healedSoFar += campState.healPerHour;
                    document.getElementById('campHealedSoFar').textContent = healedSoFar;
                    
                    // Play eating sound
                    playSfx('campEat');
                    
                    // Actually heal heroes
                    applyHealToHeroes(campState.healPerHour);
                    
                    // Random camp events (longer rest = more events)
                    if (Math.random() < 0.15 * campState.selectedHours / 8) {
                        triggerCampEvent();
                    }
                }
                
                // Check if camping is complete
                if (elapsed >= totalDuration) {
                    completeCamping();
                }
            }, 100);
            
            // Log start
            addCampEvent('You set up camp and rest by the fire...');
            
            // Broadcast to clients in multiplayer
            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                sendWebSocketMessage({
                    type: 'camp_started',
                    hours: campState.selectedHours,
                    videoSrc: videoSrc,
                    initialEvent: 'You set up camp and rest by the fire...'
                });
            }
            
            console.log('[Camp] Started camping for', campState.selectedHours, 'hours');
        }
        
        // Apply healing to all heroes - directly updates save file
        function applyHealToHeroes(amount) {
            const sharedSave = loadSharedSave();
            if (!sharedSave || !sharedSave.heroes) return;
            
            // Heal each hero directly in the save (ALL heroes, including knocked out at 0 HP)
            ['zooko', 'nate', 'zancas', 'cyberaxe'].forEach(heroKey => {
                const hero = sharedSave.heroes[heroKey];
                if (hero) {
                    hero.hp = Math.min(hero.hp + amount, hero.maxHp);
                }
            });
            
            saveSharedSave(sharedSave);
            updateDungeonMenuHeroes();
        }
        
        // Add event to camp log
        function addCampEvent(message) {
            const log = document.getElementById('campEventLog');
            if (log) {
                const entry = document.createElement('div');
                entry.style.cssText = 'color: #F2C94C; font-size: 12px; padding: 4px 0; border-bottom: 1px solid rgba(255,255,255,0.1);';
                entry.textContent = `ðŸŒ™ ${message}`;
                log.appendChild(entry);
                log.scrollTop = log.scrollHeight;
            }
        }
        
        // Trigger a random camp event
        function triggerCampEvent() {
            const goodEvents = [
                { text: 'A friendly traveler shares supplies with your party!', effect: 'heal', value: 5 },
                { text: 'The stars align, granting mystical energy!', effect: 'heal', value: 3 },
                { text: 'You find a hidden cache of gold nearby!', effect: 'gold', value: 10 },
                { text: 'A wandering merchant offers a fair trade.', effect: 'gold', value: 5 },
                { text: 'The peaceful rest rejuvenates your spirit.', effect: 'heal', value: 2 }
            ];
            
            const badEvents = [
                { text: 'Bandits steal some of your gold in the night!', effect: 'gold', value: -5 },
                { text: 'A strange noise disturbs your rest...', effect: 'none' },
                { text: 'Wild animals rummage through your supplies.', effect: 'gold', value: -3 },
                { text: 'The cold night air makes sleeping difficult.', effect: 'none' }
            ];
            
            // 70% good, 30% bad events
            const events = Math.random() < 0.7 ? goodEvents : badEvents;
            const event = events[Math.floor(Math.random() * events.length)];
            
            addCampEvent(event.text);
            
            // Broadcast event to clients
            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                sendWebSocketMessage({
                    type: 'camp_event',
                    text: event.text
                });
            }
            
            // Apply event effect
            if (event.effect === 'heal' && event.value > 0) {
                applyHealToHeroes(event.value);
            } else if (event.effect === 'gold') {
                // Update gold in sharedSave (host only)
                if (!multiplayerState.enabled || multiplayerState.role === 'host') {
                    const sharedSave = loadSharedSave();
                    if (sharedSave) {
                        if (!sharedSave.dungeonState) sharedSave.dungeonState = {};
                        sharedSave.dungeonState.gold = Math.max(0, (sharedSave.dungeonState.gold || 0) + event.value);
                        saveSharedSave(sharedSave);
                    }
                }
                updateGoldDisplay();
            }
        }
        
        // Cancel camping early
        function cancelCamping() {
            if (!campState.active) return;
            
            addCampEvent('You break camp early and prepare to move on.');
            
            // Clear interval
            if (campState.intervalId) {
                clearInterval(campState.intervalId);
                campState.intervalId = null;
            }
            
            // Stop video
            const videoEl = document.getElementById('campVideo');
            if (videoEl) {
                videoEl.pause();
                campState.videoPlaying = false;
            }
            
            campState.active = false;
            
            // Save hero states (host only in multiplayer)
            if (!multiplayerState.enabled || multiplayerState.role === 'host') {
                const sharedSave = loadSharedSave();
                if (sharedSave && sharedSave.heroes) {
                    battleState.heroes.forEach(hero => {
                        const heroKey = hero.name.toLowerCase();
                        if (sharedSave.heroes[heroKey]) {
                            sharedSave.heroes[heroKey].hp = hero.hp;
                            sharedSave.heroes[heroKey].maxHp = hero.maxHp;
                        }
                    });
                    sharedSave.lastPlayed = Date.now();
                    saveSharedSave(sharedSave);
                }
                
                // Broadcast camp cancelled to clients
                if (multiplayerState.enabled && multiplayerState.role === 'host') {
                    sendWebSocketMessage({
                        type: 'camp_completed',
                        hoursRested: 0,
                        healedAmount: campState.totalHealed || 0,
                        cancelled: true,
                        heroes: sharedSave ? [
                            { name: 'Zooko', hp: sharedSave.heroes.zooko?.hp, maxHp: sharedSave.heroes.zooko?.maxHp },
                            { name: 'Nate', hp: sharedSave.heroes.nate?.hp, maxHp: sharedSave.heroes.nate?.maxHp },
                            { name: 'Zancas', hp: sharedSave.heroes.zancas?.hp, maxHp: sharedSave.heroes.zancas?.maxHp },
                            { name: 'CyberAxe', hp: sharedSave.heroes.cyberaxe?.hp, maxHp: sharedSave.heroes.cyberaxe?.maxHp }
                        ] : []
                    });
                }
            }
            
            // Return to dungeon menu
            document.getElementById('campingScreen').style.display = 'none';
            document.getElementById('dungeonMenuScreen').style.display = 'block';
            
            showNotification('Camp broken early', 'info');
        }
        
        // Complete camping
        function completeCamping() {
            // Clear interval
            if (campState.intervalId) {
                clearInterval(campState.intervalId);
                campState.intervalId = null;
            }
            
            // Final heal summary
            const totalHealed = campState.selectedHours * campState.healPerHour;
            addCampEvent(`Well rested! Total healing: ${totalHealed} HP per hero.`);
            
            // Stop video
            const videoEl = document.getElementById('campVideo');
            if (videoEl) {
                videoEl.pause();
                campState.videoPlaying = false;
            }
            
            campState.active = false;
            
            // Brief delay before returning to menu
            setTimeout(() => {
                document.getElementById('campingScreen').style.display = 'none';
                document.getElementById('dungeonMenuScreen').style.display = 'block';
                updateDungeonMenuHeroes();
                
                showNotification(`Party rested for ${campState.selectedHours} hours! +${totalHealed} HP healed.`, 'success');
                
                // Broadcast completion in multiplayer
                if (multiplayerState.enabled && multiplayerState.role === 'host') {
                    const sharedSave = loadSharedSave();
                    sendWebSocketMessage({
                        type: 'camp_completed',
                        hoursRested: campState.selectedHours,
                        healedAmount: totalHealed,
                        heroes: sharedSave ? [
                            { name: 'Zooko', hp: sharedSave.heroes.zooko?.hp, maxHp: sharedSave.heroes.zooko?.maxHp },
                            { name: 'Nate', hp: sharedSave.heroes.nate?.hp, maxHp: sharedSave.heroes.nate?.maxHp },
                            { name: 'Zancas', hp: sharedSave.heroes.zancas?.hp, maxHp: sharedSave.heroes.zancas?.maxHp },
                            { name: 'CyberAxe', hp: sharedSave.heroes.cyberaxe?.hp, maxHp: sharedSave.heroes.cyberaxe?.maxHp }
                        ] : []
                    });
                }
            }, 1500);
            
            console.log('[Camp] Camping complete');
        }
        
        // Toggle Dungeon Masters panel visibility
        function toggleDungeonMasters() {
            // Close camp panel if open
            closeCampPanel();
            
            const panel = document.getElementById('dungeonMastersPanel');
            const btn = document.getElementById('dungeonMastersBtn');
            if (panel) {
                const isVisible = panel.style.display !== 'none';
                panel.style.display = isVisible ? 'none' : 'block';
                
                // Update gold input with current value when opening
                if (!isVisible) {
                    const goldInput = document.getElementById('setGoldInput');
                    if (goldInput) {
                        const sharedSave = JSON.parse(localStorage.getItem('top_shared_save') || '{}');
                        goldInput.value = sharedSave.dungeonState?.gold || 0;
                    }
                }
                
                // Update button style to show active state
                if (btn) {
                    if (isVisible) {
                        btn.style.background = 'linear-gradient(135deg, rgba(139, 69, 255, 0.4), rgba(75, 0, 130, 0.4))';
                        btn.style.borderColor = '';
                    } else {
                        btn.style.background = 'linear-gradient(135deg, rgba(139, 69, 255, 0.7), rgba(75, 0, 130, 0.7))';
                        btn.style.borderColor = '#F2C94C';
                    }
                }
            }
        }
        
        // Set game difficulty and regenerate encounter
        function setDifficulty(difficulty) {
            // In multiplayer, only host can change difficulty
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                showNotification('Only the party leader can change difficulty', 'warning');
                return;
            }
            
            // Don't do anything if same difficulty
            if (settings.difficulty === difficulty) {
                return;
            }
            
            settings.difficulty = difficulty;
            saveSettings();
            
            // Update button highlights
            updateDifficultyButtons();
            
            // Reset and regenerate the queued encounter
            preGeneratedEncounter = {
                ready: false,
                generating: false,
                boss: null,
                mobs: [],
                captive: null,
                background: null,
                roomLevel: preGeneratedEncounter.roomLevel || 1
            };
            updateExploreLoadingBar(0);
            
            // Start regenerating
            preGenerateNextEncounter();
            
            const difficultyNames = { 'casual': 'Casual', 'normal': 'Normal', 'expert': 'Expert' };
            showNotification(`Difficulty set to ${difficultyNames[difficulty]}`, 'info');
            console.log('[Difficulty] Changed to:', difficulty);
            
            // In multiplayer, broadcast difficulty change to clients
            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                sendWebSocketMessage({
                    type: 'difficulty_change',
                    difficulty: difficulty
                });
            }
        }
        
        // Update difficulty button visual states
        function updateDifficultyButtons() {
            const buttons = {
                'casual': document.getElementById('diffCasualBtn'),
                'normal': document.getElementById('diffNormalBtn'),
                'expert': document.getElementById('diffExpertBtn')
            };
            
            // Reset all buttons
            Object.values(buttons).forEach(btn => {
                if (btn) {
                    btn.style.background = '';
                    btn.style.borderColor = '';
                    btn.style.boxShadow = '';
                }
            });
            
            // Highlight selected difficulty
            const selectedBtn = buttons[settings.difficulty];
            if (selectedBtn) {
                const colors = {
                    'casual': { bg: 'rgba(39, 174, 96, 0.4)', border: '#27AE60', shadow: '0 0 15px rgba(39, 174, 96, 0.5)' },
                    'normal': { bg: 'rgba(242, 201, 76, 0.4)', border: '#F2C94C', shadow: '0 0 15px rgba(242, 201, 76, 0.5)' },
                    'expert': { bg: 'rgba(235, 87, 87, 0.4)', border: '#EB5757', shadow: '0 0 15px rgba(235, 87, 87, 0.5)' }
                };
                const c = colors[settings.difficulty];
                selectedBtn.style.background = `linear-gradient(135deg, ${c.bg}, ${c.bg})`;
                selectedBtn.style.borderColor = c.border;
                selectedBtn.style.boxShadow = c.shadow;
            }
        }
        
        // Set party level - scales all hero stats to target level
        function setPartyLevel() {
            // In multiplayer, only host can change party level
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                showNotification('Only the party leader can change party level', 'warning');
                return;
            }
            
            const input = document.getElementById('partyLevelInput');
            const targetLevel = parseInt(input?.value) || 1;
            
            if (targetLevel < 1 || targetLevel > 100) {
                showNotification('Party level must be between 1 and 100', 'error');
                return;
            }
            
            const sharedSave = loadSharedSave();
            if (!sharedSave || !sharedSave.heroes) {
                showNotification('No save data found', 'error');
                return;
            }
            
            // Base stats for each hero at level 1
            const baseStats = {
                zooko: { str: 14, dex: 12, con: 14, int: 10, wis: 12, cha: 16, baseHp: 30 },
                nate: { str: 16, dex: 14, con: 12, int: 10, wis: 10, cha: 12, baseHp: 28 },
                zancas: { str: 10, dex: 16, con: 10, int: 16, wis: 14, cha: 10, baseHp: 24 },
                cyberaxe: { str: 18, dex: 10, con: 16, int: 8, wis: 10, cha: 10, baseHp: 32 }
            };
            
            // Scale each hero
            ['zooko', 'nate', 'zancas', 'cyberaxe'].forEach(heroKey => {
                if (!sharedSave.heroes[heroKey]) return;
                
                const base = baseStats[heroKey];
                const hero = sharedSave.heroes[heroKey];
                const levelsGained = targetLevel - 1;
                
                // Stats increase: +1 to primary stats every 4 levels, +1 to secondary every 5 levels
                // Primary stats get more bonus
                const primaryBonus = Math.floor(levelsGained / 4);
                const secondaryBonus = Math.floor(levelsGained / 5);
                
                // Determine primary stats per hero
                if (heroKey === 'zooko') {
                    hero.cha = base.cha + primaryBonus;
                    hero.con = base.con + primaryBonus;
                    hero.str = base.str + secondaryBonus;
                    hero.dex = base.dex + secondaryBonus;
                    hero.wis = base.wis + secondaryBonus;
                    hero.int = base.int + secondaryBonus;
                } else if (heroKey === 'nate') {
                    hero.str = base.str + primaryBonus;
                    hero.dex = base.dex + primaryBonus;
                    hero.con = base.con + secondaryBonus;
                    hero.int = base.int + secondaryBonus;
                    hero.wis = base.wis + secondaryBonus;
                    hero.cha = base.cha + secondaryBonus;
                } else if (heroKey === 'zancas') {
                    hero.int = base.int + primaryBonus;
                    hero.dex = base.dex + primaryBonus;
                    hero.wis = base.wis + secondaryBonus;
                    hero.str = base.str + secondaryBonus;
                    hero.con = base.con + secondaryBonus;
                    hero.cha = base.cha + secondaryBonus;
                } else if (heroKey === 'cyberaxe') {
                    hero.str = base.str + primaryBonus;
                    hero.con = base.con + primaryBonus;
                    hero.dex = base.dex + secondaryBonus;
                    hero.int = base.int + secondaryBonus;
                    hero.wis = base.wis + secondaryBonus;
                    hero.cha = base.cha + secondaryBonus;
                }
                
                // HP scales with level and CON
                const conMod = Math.floor((hero.con - 10) / 2);
                hero.maxHp = base.baseHp + (levelsGained * (5 + conMod));
                hero.hp = hero.maxHp; // Full heal on level set
                
                // Set level and XP
                hero.level = targetLevel;
                hero.xp = getXpForLevel(targetLevel);
                
                // AC scales slightly with level
                hero.ac = 10 + Math.floor((hero.dex - 10) / 2) + Math.floor(targetLevel / 10);
            });
            
            // Save and update UI
            saveSharedSave(sharedSave);
            updateDungeonMenuHeroes();
            
            showNotification(`Party level set to ${targetLevel}!`, 'success');
            console.log('[PartyLevel] All heroes set to level', targetLevel);
            
            // Broadcast to clients in multiplayer
            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                sendWebSocketMessage({
                    type: 'party_level_update',
                    targetLevel: targetLevel,
                    heroes: {
                        zooko: sharedSave.heroes.zooko,
                        nate: sharedSave.heroes.nate,
                        zancas: sharedSave.heroes.zancas,
                        cyberaxe: sharedSave.heroes.cyberaxe
                    }
                });
            }
            
            // Update inventory slots based on new party level
            partyInventory.partyLevel = targetLevel;
            partyInventory.maxSlots = calculateMaxSlots(targetLevel);
            
            // Sync inventory to clients
            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                sendInventoryUpdate();
            }
        }
        
        // Set party gold
        function setPartyGold() {
            // In multiplayer, only host can change gold
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                showNotification('Only the party leader can change gold', 'warning');
                return;
            }
            
            const input = document.getElementById('setGoldInput');
            const newGold = parseInt(input?.value) || 0;
            
            if (newGold < 0) {
                showNotification('Gold cannot be negative', 'error');
                return;
            }
            
            // Update party gold
            partyGold = newGold;
            
            // Save to shared save
            const sharedSave = loadSharedSave();
            if (sharedSave) {
                sharedSave.dungeonState = sharedSave.dungeonState || {};
                sharedSave.dungeonState.gold = newGold;
                saveSharedSave(sharedSave);
            }
            
            // Update UI
            updateGoldDisplay();
            
            showNotification(`Party gold set to ${newGold}!`, 'success');
            console.log('[PartyGold] Gold set to', newGold);
            
            // Broadcast to clients in multiplayer
            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                sendWebSocketMessage({
                    type: 'gold_update',
                    gold: newGold
                });
            }
        }
        
        // Get XP required for a given level
        function getXpForLevel(level) {
            // Simple XP curve: 100 * level^2
            return 100 * level * level;
        }
        
        // ===== DUNGEON MENU STORY BACKGROUND ANIMATION =====
        // Sprite atlas format: 8 cols x 16 rows = 128 frames at 16fps
        const STORY_COLS = 8;
        const STORY_ROWS = 16;
        const STORY_TOTAL_FRAMES = 128;
        const STORY_FPS = 16;
        
        let storyBackgroundFrame = 0;
        let storyBackgroundDirection = 1; // 1 = forward, -1 = backward (ping-pong)
        let storyBackgroundIntervalId = null;
        let currentStoryAnimation = null;
        
        // Story animations based on dungeon level
        const dungeonStoryLoops = [
            { file: 'story/intro/intro_a.png', minLevel: 1, maxLevel: 2, pingpong: true },
            { file: 'story/intro/intro_b.png', minLevel: 3, maxLevel: 4, pingpong: true },
            { file: 'story/intro/intro_c.png', minLevel: 5, maxLevel: 5, pingpong: true },
            { file: 'story/intro/intro_d.png', minLevel: 6, maxLevel: 7, pingpong: true },
            { file: 'story/intro/intro_e.png', minLevel: 8, maxLevel: 9, pingpong: true },
            { file: 'story/lvl1/story_lvl_1.png', minLevel: 10, maxLevel: 12, pingpong: true },
            { file: 'story/lvl1/story_lvl_1_loop.png', minLevel: 13, maxLevel: 19, pingpong: false },
            { file: 'story/lvl2/story_lvl_2.png', minLevel: 20, maxLevel: 22, pingpong: true },
            { file: 'story/lvl2/story_lvl_2_idle.png', minLevel: 23, maxLevel: 29, pingpong: false },
            { file: 'story/lvl3/story_lvl_3.png', minLevel: 30, maxLevel: 32, pingpong: true },
            { file: 'story/lvl3/story_lvl_3_idle.png', minLevel: 33, maxLevel: 39, pingpong: false },
            { file: 'story/lvl4/story_lvl_4.png', minLevel: 40, maxLevel: 42, pingpong: true },
            { file: 'story/lvl4/story_lvl_4_idle.png', minLevel: 43, maxLevel: 49, pingpong: false },
            { file: 'story/lvl5/story_lvl_5.png', minLevel: 50, maxLevel: 52, pingpong: true },
            { file: 'story/lvl5/story_lvl_5_idle.png', minLevel: 53, maxLevel: 59, pingpong: false },
            { file: 'story/lvl6/story_lvl_6.png', minLevel: 60, maxLevel: 62, pingpong: true },
            { file: 'story/lvl6/story_lvl_6_idle.png', minLevel: 63, maxLevel: 69, pingpong: false },
            { file: 'story/lvl7/story_lvl_7.png', minLevel: 70, maxLevel: 72, pingpong: true },
            { file: 'story/lvl7/story_lvl_7_idle.png', minLevel: 73, maxLevel: 79, pingpong: false },
            { file: 'story/lvl8/story_lvl_8.png', minLevel: 80, maxLevel: 82, pingpong: true },
            { file: 'story/lvl8/story_lvl_8_idle.png', minLevel: 83, maxLevel: 89, pingpong: false },
            { file: 'story/lvl9/story_lvl_9.png', minLevel: 90, maxLevel: 92, pingpong: true },
            { file: 'story/lvl9/story_lvl_9_idle.png', minLevel: 93, maxLevel: 99, pingpong: false },
            { file: 'story/lvl10/story_lvl_10.png', minLevel: 100, maxLevel: 102, pingpong: true },
            { file: 'story/lvl10/story_lvl_10_idle.png', minLevel: 103, maxLevel: 199, pingpong: false },
            { file: 'story/up_1/story_up_1.png', minLevel: 200, maxLevel: 210, pingpong: true },
            { file: 'story/up_1/story_up_1_idle.png', minLevel: 211, maxLevel: 399, pingpong: false },
            { file: 'story/up_2/story_up_2.png', minLevel: 400, maxLevel: 410, pingpong: true },
            { file: 'story/up_2/story_up_2_idle.png', minLevel: 411, maxLevel: 599, pingpong: false },
            { file: 'story/up_3/story_up_3.png', minLevel: 600, maxLevel: 610, pingpong: true },
            { file: 'story/up_3/story_up_3_idle.png', minLevel: 611, maxLevel: 799, pingpong: false },
            { file: 'story/up_4/story_up_4.png', minLevel: 800, maxLevel: 810, pingpong: true },
            { file: 'story/up_4/story_up_4_idle.png', minLevel: 811, maxLevel: 999, pingpong: false },
            { file: 'story/up_5/story_up_5.png', minLevel: 1000, maxLevel: 1005, pingpong: true },
            { file: 'story/up_5/story_up_5_idle.png', minLevel: 1006, maxLevel: 9999, pingpong: false },
            { file: 'story/end/end.png', minLevel: 10000, maxLevel: 999999, pingpong: true }
        ];
        
        // Get story animation for current level
        function getDungeonStoryAnimation(level) {
            for (const loop of dungeonStoryLoops) {
                if (level >= loop.minLevel && level <= loop.maxLevel) {
                    return loop;
                }
            }
            // Default to first animation
            return dungeonStoryLoops[0];
        }
        
        // Start dungeon menu background animation
        function startDungeonMenuAnimation() {
            const bgElement = document.getElementById('dungeonMenuBackground');
            if (!bgElement) return;
            
            // Get current dungeon level
            const dungeonLevelEl = document.getElementById('dungeonMenuLevel');
            const currentLevel = parseInt(dungeonLevelEl?.textContent) || 1;
            
            // Get appropriate animation for this level
            const animData = getDungeonStoryAnimation(currentLevel);
            
            // Only reload if animation changed
            if (currentStoryAnimation !== animData.file) {
                currentStoryAnimation = animData.file;
                storyBackgroundFrame = 0;
                storyBackgroundDirection = 1;
                
                // Set sprite atlas as background
                bgElement.style.backgroundImage = `url('${animData.file}')`;
                bgElement.style.backgroundSize = `${STORY_COLS * 100}% ${STORY_ROWS * 100}%`;
                bgElement.style.opacity = '0.25';
                
                console.log('[StoryBG] Loaded animation:', animData.file, 'for level', currentLevel);
            }
            
            // Stop existing animation if running
            if (storyBackgroundIntervalId) {
                clearInterval(storyBackgroundIntervalId);
            }
            
            // Start frame animation at 16fps
            const frameInterval = 1000 / STORY_FPS;
            const isPingPong = animData.pingpong;
            
            storyBackgroundIntervalId = setInterval(() => {
                // Calculate current frame position in atlas
                const col = storyBackgroundFrame % STORY_COLS;
                const row = Math.floor(storyBackgroundFrame / STORY_COLS);
                
                // Set background position to show current frame
                const xPercent = (col / (STORY_COLS - 1)) * 100;
                const yPercent = (row / (STORY_ROWS - 1)) * 100;
                bgElement.style.backgroundPosition = `${xPercent}% ${yPercent}%`;
                
                // Advance frame
                if (isPingPong) {
                    // Ping-pong mode: forward then backward
                    storyBackgroundFrame += storyBackgroundDirection;
                    
                    if (storyBackgroundFrame >= STORY_TOTAL_FRAMES - 1) {
                        storyBackgroundFrame = STORY_TOTAL_FRAMES - 1;
                        storyBackgroundDirection = -1;
                    } else if (storyBackgroundFrame <= 0) {
                        storyBackgroundFrame = 0;
                        storyBackgroundDirection = 1;
                    }
                } else {
                    // Loop mode: restart at beginning
                    storyBackgroundFrame++;
                    if (storyBackgroundFrame >= STORY_TOTAL_FRAMES) {
                        storyBackgroundFrame = 0;
                    }
                }
            }, frameInterval);
        }
        
        // Stop dungeon menu background animation
        function stopDungeonMenuAnimation() {
            if (storyBackgroundIntervalId) {
                clearInterval(storyBackgroundIntervalId);
                storyBackgroundIntervalId = null;
            }
        }
        
        // Update story background when level changes
        function updateDungeonMenuBackground() {
            // Only update if dungeon menu is visible
            if (currentScreen === 'dungeonMenu') {
                startDungeonMenuAnimation();
            }
        }
        // ===== END DUNGEON MENU STORY BACKGROUND ANIMATION =====
        
        // Pre-generated encounter data (prepared while in dungeon menu)
        let preGeneratedEncounter = {
            ready: false,
            generating: false,
            boss: null,
            mobs: [],
            captive: null,
            background: null,
            roomLevel: 2,
            roomType: 'combat',   // Room type from level layout
            currentRoomId: null,  // Track which room from layout we're in
            storeData: null,      // Store room merchant/items
            secretData: null,     // Secret room rewards
            npcData: null,        // NPC room data
            explorationData: null // Exploration event data
        };
        
        // Pre-generate the next encounter while player is in dungeon menu
        async function preGenerateNextEncounter() {
            // Don't regenerate if already ready or currently generating
            if (preGeneratedEncounter.ready || preGeneratedEncounter.generating) {
                return;
            }
            
            // Only host generates encounters
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                return;
            }
            
            preGeneratedEncounter.generating = true;
            
            // Reset loading bar
            updateExploreLoadingBar(0);
            
            try {
                const roomLevel = preGeneratedEncounter.roomLevel;
                
                // Get room type from level layout (or default to combat)
                const roomType = getNextRoomType();
                preGeneratedEncounter.roomType = roomType;
                console.log(`[PreGen] Generating ${roomType} room for level ${roomLevel}`);
                
                // Load enemy data based on difficulty setting (needed for combat/boss rooms)
                let bossesData = [];
                let mobsData = [];
                if (roomType === 'combat' || roomType === 'boss' || roomType === 'mini_boss') {
                    try {
                        const difficultyFile = getBossDifficultyFile();
                        const bossResponse = await fetch(difficultyFile);
                        bossesData = await bossResponse.json();
                        const mobResponse = await fetch('tunnelsofprivacy/mobs/mobs_data.json');
                        const mobObj = await mobResponse.json();
                        mobsData = mobObj.mobs || [];
                    } catch(e) {
                        console.error('[PreGen] Failed to load enemy data:', e);
                        preGeneratedEncounter.generating = false;
                        updateExploreLoadingBar(0);
                        return;
                    }
                }
                updateExploreLoadingBar(10);  // Data loaded
                
                // Generate content based on room type
                switch (roomType) {
                    case 'boss':
                        // Boss room - always has the level boss
                        await generateBossRoomContent(bossesData, roomLevel);
                        break;
                    
                    case 'mini_boss':
                        // Mini-boss room - tougher than normal, but not the main boss
                        await generateMiniBossRoomContent(bossesData, mobsData, roomLevel);
                        break;
                    
                    case 'store':
                        // Store room - merchant with items to buy
                        await generateStoreRoomContent(roomLevel);
                        break;
                    
                    case 'secret':
                        // Secret room - special treasure/event
                        await generateSecretRoomContent(roomLevel);
                        break;
                    
                    case 'npc':
                        // NPC room - friendly character interaction
                        await generateNPCRoomContent(roomLevel);
                        break;
                    
                    case 'exploration':
                        // Exploration event - puzzle/trap/discovery
                        await generateExplorationRoomContent(roomLevel);
                        break;
                    
                    case 'combat':
                    default:
                        // Standard combat room
                        await generateCombatRoomContent(bossesData, mobsData, roomLevel);
                        break;
                }
                
                // Pre-select background (all room types get a background)
                const backgroundOptions = [
                    'backgrounds_lvl1 (8).png',
                    'backgrounds_lvl1 (10).png',
                    'backgrounds_lvl1 (12).png',
                    'backgrounds_lvl1 (14).png',
                    'backgrounds_lvl1 (15).png',
                    'backgrounds_lvl1 (16).png'
                ];
                preGeneratedEncounter.background = backgroundOptions[Math.floor(Math.random() * backgroundOptions.length)];
                
                preGeneratedEncounter.ready = true;
                preGeneratedEncounter.generating = false;
                updateExploreLoadingBar(100);  // Complete!
                
                // Update the Next Room Preview UI
                updateNextRoomPreview();
                updateLevelLayoutDisplay();
                updateDungeonMastersStatus();
                
            } catch (error) {
                console.error('[PreGen] Error during pre-generation:', error);
                preGeneratedEncounter.generating = false;
                updateExploreLoadingBar(0);
            }
        }
        
        // ===== ROOM TYPE GENERATION FUNCTIONS =====
        
        // Generate standard combat room content
        async function generateCombatRoomContent(bossesData, mobsData, roomLevel) {
            // Standard combat has no boss, just mobs
            preGeneratedEncounter.boss = null;
            preGeneratedEncounter.mobs = [];
            
            const hostileMobs = mobsData.filter(m => m.behavior?.hostile && (m.minLevel === undefined || m.minLevel <= roomLevel));
            const mobCount = getMobCountForLevel(roomLevel);
            const mobProgressPerMob = 60 / mobCount; // Distribute 60% progress across all mobs
            
            for (let i = 0; i < mobCount && i < hostileMobs.length; i++) {
                const mob = hostileMobs[Math.floor(Math.random() * hostileMobs.length)];
                const generatedMob = await generateEncounter('mob', mob, roomLevel);
                preGeneratedEncounter.mobs.push({
                    baseData: mob,
                    generated: generatedMob
                });
                updateExploreLoadingBar(10 + Math.round((i + 1) * mobProgressPerMob));
                await new Promise(r => setTimeout(r, 300));
            }
            
            // Generate captive (50% chance)
            preGeneratedEncounter.captive = null;
            if (Math.random() > 0.5) {
                const captiveData = await generateEncounter('captive', {}, roomLevel);
                const captiveSpriteNum = Math.floor(Math.random() * 12) + 1;
                preGeneratedEncounter.captive = {
                    generated: captiveData,
                    spriteNum: captiveSpriteNum
                };
            }
            updateExploreLoadingBar(90);
        }
        
        // Generate boss room content (level boss)
        async function generateBossRoomContent(bossesData, roomLevel) {
            preGeneratedEncounter.mobs = [];
            preGeneratedEncounter.captive = null;
            
            let boss = bossesData.find(b => b.mainLevel === roomLevel);
            
            // Fallback for levels without exact boss match
            if (!boss) {
                if (roomLevel > 100) {
                    boss = bossesData[Math.floor(Math.random() * bossesData.length)];
                } else {
                    console.warn(`[PreGen] No boss found for level ${roomLevel}, finding nearest...`);
                    const sortedBosses = [...bossesData].sort((a, b) => 
                        Math.abs(a.mainLevel - roomLevel) - Math.abs(b.mainLevel - roomLevel)
                    );
                    boss = sortedBosses[0];
                }
            }
            
            if (boss) {
                const generatedBoss = await generateEncounter('boss', boss, roomLevel);
                preGeneratedEncounter.boss = {
                    baseData: boss,
                    generated: generatedBoss
                };
            }
            updateExploreLoadingBar(90);
        }
        
        // Generate mini-boss room content
        async function generateMiniBossRoomContent(bossesData, mobsData, roomLevel) {
            // Mini-boss: pick a boss from lower levels or a tougher mob
            preGeneratedEncounter.mobs = [];
            preGeneratedEncounter.captive = null;
            
            // Try to find a boss from earlier levels
            const lowerLevelBosses = bossesData.filter(b => b.mainLevel < roomLevel && b.mainLevel >= Math.max(1, roomLevel - 10));
            
            let miniBoss = null;
            if (lowerLevelBosses.length > 0) {
                miniBoss = lowerLevelBosses[Math.floor(Math.random() * lowerLevelBosses.length)];
            } else if (bossesData.length > 0) {
                // Use any random boss
                miniBoss = bossesData[Math.floor(Math.random() * bossesData.length)];
            }
            
            if (miniBoss) {
                const generatedBoss = await generateEncounter('boss', miniBoss, roomLevel);
                preGeneratedEncounter.boss = {
                    baseData: miniBoss,
                    generated: generatedBoss,
                    isMiniBoss: true
                };
            }
            updateExploreLoadingBar(90);
        }
        
        // Generate store room content
        async function generateStoreRoomContent(roomLevel) {
            preGeneratedEncounter.boss = null;
            preGeneratedEncounter.mobs = [];
            preGeneratedEncounter.captive = null;
            
            // Store data - items available for purchase
            preGeneratedEncounter.storeData = {
                merchantName: getRandomMerchantName(),
                items: generateStoreItems(roomLevel),
                greeting: getRandomMerchantGreeting()
            };
            
            console.log('[PreGen] Generated store with', preGeneratedEncounter.storeData.items.length, 'items');
            updateExploreLoadingBar(90);
        }
        
        // Generate secret room content
        async function generateSecretRoomContent(roomLevel) {
            preGeneratedEncounter.boss = null;
            preGeneratedEncounter.mobs = [];
            preGeneratedEncounter.captive = null;
            
            // Secret room rewards
            const secretTypes = ['treasure', 'artifact', 'shrine', 'knowledge'];
            const secretType = secretTypes[Math.floor(Math.random() * secretTypes.length)];
            
            preGeneratedEncounter.secretData = {
                type: secretType,
                reward: generateSecretReward(secretType, roomLevel),
                description: getSecretDescription(secretType)
            };
            
            console.log('[PreGen] Generated secret room:', secretType);
            updateExploreLoadingBar(90);
        }
        
        // Generate NPC room content
        async function generateNPCRoomContent(roomLevel) {
            preGeneratedEncounter.boss = null;
            preGeneratedEncounter.mobs = [];
            preGeneratedEncounter.captive = null;
            
            // NPC encounter - friendly character
            const npcTypes = ['adventurer', 'scholar', 'healer', 'guide', 'refugee', 'wounded', 'lost'];
            const npcType = npcTypes[Math.floor(Math.random() * npcTypes.length)];
            
            // Calculate costs/rewards based on room level
            const baseHelpCost = 25 + (roomLevel * 10); // Gold cost to help
            const baseXpReward = 50 + (roomLevel * 25); // XP for helping
            const baseRobReward = 40 + (roomLevel * 15); // Gold from robbing
            const baseZcashXp = 50 + (roomLevel * 25); // XP for telling about Zcash
            
            preGeneratedEncounter.npcData = {
                type: npcType,
                name: getRandomNPCName(npcType),
                dialogue: getNPCDialogue(npcType, roomLevel),
                helpCost: baseHelpCost,
                helpXpReward: baseXpReward,
                robGoldReward: baseRobReward,
                zcashXpReward: baseZcashXp,
                choiceMade: false
            };
            
            console.log('[PreGen] Generated NPC room:', npcType, 'Help cost:', baseHelpCost, 'XP:', baseXpReward, 'Rob:', baseRobReward);
            updateExploreLoadingBar(90);
        }
        
        // Generate exploration event room content
        async function generateExplorationRoomContent(roomLevel) {
            preGeneratedEncounter.boss = null;
            preGeneratedEncounter.mobs = [];
            preGeneratedEncounter.captive = null;
            
            // Exploration events
            const eventTypes = ['puzzle', 'trap', 'discovery', 'environmental'];
            const eventType = eventTypes[Math.floor(Math.random() * eventTypes.length)];
            
            // Calculate values based on room level
            const difficulty = roomLevel;
            const baseSuccessChance = Math.max(40, 90 - (roomLevel * 3)); // 90% at level 1, down to 40% min
            const oneHeroXp = 50 + (roomLevel * 30); // XP for single hero success
            const partyXp = 100 + (roomLevel * 50); // XP for party success (split)
            const oneHeroFailDamage = 15 + (roomLevel * 5); // Damage on single hero fail
            const partyFailDamage = 10 + (roomLevel * 3); // Damage to each hero on party fail
            
            preGeneratedEncounter.explorationData = {
                type: eventType,
                challenge: generateExplorationChallenge(eventType, roomLevel),
                difficulty: difficulty,
                successChance: baseSuccessChance,
                oneHeroXp: oneHeroXp,
                partyXp: partyXp,
                oneHeroFailDamage: oneHeroFailDamage,
                partyFailDamage: partyFailDamage,
                choiceMade: false
            };
            
            console.log('[PreGen] Generated exploration event:', eventType, 'Difficulty:', difficulty, 'Success:', baseSuccessChance + '%');
            updateExploreLoadingBar(90);
        }
        
        // ===== STORE HELPERS =====
        function getRandomMerchantName() {
            const names = ['Zashop the Vendor', 'Cryptkeeper\'s Cache', 'The Shield Merchant', 'Thornwick\'s Treasures', 'Dusty Dale\'s Goods'];
            return names[Math.floor(Math.random() * names.length)];
        }
        
        function getRandomMerchantGreeting() {
            const greetings = [
                'Welcome, brave adventurer! Take a look at my wares.',
                'Ah, customers! Please, browse to your heart\'s content.',
                'Looking for something special? I might have just the thing.',
                'My prices are fair, my goods are... mostly legitimate.',
                'Heroes! Perfect timing. I have new stock from the upper levels.'
            ];
            return greetings[Math.floor(Math.random() * greetings.length)];
        }
        
        function generateStoreItems(roomLevel) {
            // APPROVED ITEMS LIST - Only items we have implemented
            const APPROVED_ITEMS = [
                { 
                    id: 'health_potion',
                    name: 'Health Potion', 
                    type: 'consumable', 
                    effect: 'heal', 
                    value: 25, 
                    basePrice: 50,
                    icon: 'tunnelsofprivacy/items/healing_potions_a_cropped.png',
                    description: 'Restores 25 HP to one hero'
                },
                // Party Meal Foods - Heal entire party, usable only at camp
                { 
                    id: 'meal_craps',
                    name: 'Craps', 
                    type: 'party_meal', 
                    effect: 'party_heal', 
                    value: 10, 
                    basePrice: 10,
                    icon: 'tunnelsofprivacy/items/meal_1.png',
                    description: 'Simple scraps. Heals party for 10 HP each at camp.'
                },
                { 
                    id: 'meal_veggies',
                    name: 'Fresh Veggies', 
                    type: 'party_meal', 
                    effect: 'party_heal', 
                    value: 50, 
                    basePrice: 50,
                    icon: 'tunnelsofprivacy/items/meal_2.png',
                    description: 'Crisp vegetables. Heals party for 50 HP each at camp.'
                },
                { 
                    id: 'meal_bread',
                    name: 'Hearty Bread', 
                    type: 'party_meal', 
                    effect: 'party_heal', 
                    value: 100, 
                    basePrice: 100,
                    icon: 'tunnelsofprivacy/items/meal_3.png',
                    description: 'Warm loaf of bread. Heals party for 100 HP each at camp.'
                },
                { 
                    id: 'meal_fish',
                    name: 'Grilled Fish', 
                    type: 'party_meal', 
                    effect: 'party_heal', 
                    value: 200, 
                    basePrice: 200,
                    icon: 'tunnelsofprivacy/items/meal_4.png',
                    description: 'Freshly caught fish. Heals party for 200 HP each at camp.'
                },
                { 
                    id: 'meal_chicken',
                    name: 'Roast Chicken', 
                    type: 'party_meal', 
                    effect: 'party_heal', 
                    value: 350, 
                    basePrice: 350,
                    icon: 'tunnelsofprivacy/items/meal_5.png',
                    description: 'Juicy roasted chicken. Heals party for 350 HP each at camp.'
                },
                { 
                    id: 'meal_steak',
                    name: 'Steak & Potatoes', 
                    type: 'party_meal', 
                    effect: 'party_heal', 
                    value: 500, 
                    basePrice: 500,
                    icon: 'tunnelsofprivacy/items/meal_6.png',
                    description: 'Hearty steak dinner. Heals party for 500 HP each at camp.'
                },
                { 
                    id: 'meal_feast',
                    name: 'Feast Platter', 
                    type: 'party_meal', 
                    effect: 'party_heal', 
                    value: 1000, 
                    basePrice: 1000,
                    icon: 'tunnelsofprivacy/items/meal_7.png',
                    description: 'Bountiful platter. Heals party for 1000 HP each at camp.'
                },
                { 
                    id: 'meal_banquet',
                    name: 'Royal Banquet', 
                    type: 'party_meal', 
                    effect: 'party_heal', 
                    value: 2500, 
                    basePrice: 2500,
                    icon: 'tunnelsofprivacy/items/meal_8.png',
                    description: 'Fit for royalty. Heals party for 2500 HP each at camp.'
                },
                { 
                    id: 'meal_dragon',
                    name: 'Dragon Steak', 
                    type: 'party_meal', 
                    effect: 'party_heal', 
                    value: 5000, 
                    basePrice: 5000,
                    icon: 'tunnelsofprivacy/items/meal_9.png',
                    description: 'Legendary dragon meat. Heals party for 5000 HP each at camp.'
                },
                { 
                    id: 'meal_divine',
                    name: 'Divine Feast', 
                    type: 'party_meal', 
                    effect: 'party_heal', 
                    value: 10000, 
                    basePrice: 10000,
                    icon: 'tunnelsofprivacy/items/meal_10.png',
                    description: 'Food of the gods. Heals party for 10000 HP each at camp.'
                }
            ];
            
            const items = [];
            
            // Always add health potions (random quantity 2-5, with price scaling)
            items.push({
                ...APPROVED_ITEMS[0], // Health Potion
                price: Math.floor(APPROVED_ITEMS[0].basePrice * (1 + roomLevel * 0.05)),
                quantity: 99 // Unlimited
            });
            
            // Always add ALL party meals (1-10) with unlimited stock
            for (let i = 1; i <= 10; i++) {
                const mealItem = APPROVED_ITEMS[i];
                if (mealItem && mealItem.type === 'party_meal') {
                    items.push({
                        ...mealItem,
                        price: mealItem.basePrice, // No price scaling for meals
                        quantity: 99 // Unlimited - casual game
                    });
                }
            }
            
            return items;
        }
        
        // ===== SECRET ROOM HELPERS =====
        function generateSecretReward(secretType, roomLevel) {
            const baseXP = 50 * roomLevel;
            const baseGold = 100 * roomLevel;
            
            switch (secretType) {
                case 'treasure':
                    return { gold: baseGold * 2, xp: baseXP };
                case 'artifact':
                    return { item: 'Mysterious Artifact', xp: baseXP * 2 };
                case 'shrine':
                    return { blessing: 'temporary_buff', xp: baseXP, duration: 3 };
                case 'knowledge':
                    return { xp: baseXP * 3, lore: 'Ancient Zcash Knowledge' };
                default:
                    return { xp: baseXP };
            }
        }
        
        function getSecretDescription(secretType) {
            const descriptions = {
                'treasure': 'You discover a hidden cache of valuables!',
                'artifact': 'A strange artifact glows with mysterious energy...',
                'shrine': 'An ancient shrine radiates peaceful power.',
                'knowledge': 'Cryptic writings cover the walls of this hidden chamber.'
            };
            return descriptions[secretType] || 'You found something interesting...';
        }
        
        // ===== NPC HELPERS =====
        function getRandomNPCName(npcType) {
            const names = {
                'adventurer': ['Marcus the Bold', 'Elena Swift', 'Gruff Ironfoot', 'Lily Shadowstep'],
                'scholar': ['Professor Zook', 'Sage Whisperwind', 'Archivist Dusty', 'Lorekeeper Nyx'],
                'healer': ['Sister Mercy', 'Brother Calm', 'Herbalist Fern', 'Medic Kane'],
                'guide': ['Old Map Murphy', 'Scout Keen-Eye', 'Pathfinder Rosa', 'Tunnel Tom'],
                'refugee': ['Fleeing Farmer', 'Scared Merchant', 'Lost Child', 'Escaped Prisoner'],
                'wounded': ['Injured Scout', 'Limping Soldier', 'Hurt Miner', 'Bleeding Traveler'],
                'lost': ['Confused Wanderer', 'Disoriented Explorer', 'Stranded Pilgrim', 'Bewildered Novice']
            };
            const typeNames = names[npcType] || names['adventurer'];
            return typeNames[Math.floor(Math.random() * typeNames.length)];
        }
        
        function getNPCDialogue(npcType, roomLevel) {
            const dialogues = {
                'adventurer': `I've been exploring these tunnels for days. Level ${roomLevel} is treacherous - stay alert!`,
                'scholar': `Fascinating! The cryptographic inscriptions here suggest ancient Zcash knowledge...`,
                'healer': `You look weary, travelers. Let me tend to your wounds.`,
                'guide': `I know these passages well. The boss room is nearby - I can feel it.`,
                'refugee': `Please, you must help me! The monsters drove me from my home. I have nothing left...`,
                'wounded': `*cough* I barely escaped with my life. Could you spare some gold for medicine?`,
                'lost': `Thank the stars, other people! I've been wandering these tunnels for what feels like forever...`
            };
            return dialogues[npcType] || 'Hello there, traveler.';
        }
        
        // ===== EXPLORATION HELPERS =====
        function generateExplorationChallenge(eventType, roomLevel) {
            const challenges = {
                'puzzle': { type: 'riddle', difficulty: roomLevel, description: 'Solve the ancient puzzle' },
                'trap': { type: 'avoid', difficulty: roomLevel, description: 'Navigate the trapped corridor' },
                'discovery': { type: 'search', difficulty: roomLevel, description: 'Investigate the strange markings' },
                'environmental': { type: 'survive', difficulty: roomLevel, description: 'Deal with hazardous conditions' }
            };
            return challenges[eventType] || challenges['discovery'];
        }
        
        function generateExplorationReward(eventType, roomLevel) {
            const baseXP = 30 * roomLevel;
            return {
                xp: baseXP,
                bonus: eventType === 'puzzle' ? 'intelligence_boost' : eventType === 'trap' ? 'dexterity_boost' : null
            };
        }
        
        // ===== END ROOM TYPE GENERATION FUNCTIONS =====
        
        // ===== NON-COMBAT ROOM SYSTEM =====
        
        // State for non-combat rooms
        let nonCombatRoomState = {
            active: false,
            roomType: null,
            data: null
        };
        
        // Enter a non-combat room (store, NPC, secret, exploration)
        function enterNonCombatRoom(roomType) {
            console.log('[NonCombat] Entering room type:', roomType);
            
            // Client requests inventory sync when entering store
            if (roomType === 'store' && multiplayerState.enabled && multiplayerState.role === 'client') {
                sendWebSocketMessage({ type: 'request_resync' });
            }
            
            nonCombatRoomState.active = true;
            nonCombatRoomState.roomType = roomType;
            nonCombatRoomState.data = preGeneratedEncounter;
            
            // Stop dungeon menu animation
            stopDungeonMenuAnimation();
            
            // Hide dungeon menu, show non-combat room
            currentScreen = 'nonCombatRoom';
            document.getElementById('dungeonMenuScreen').style.display = 'none';
            document.getElementById('nonCombatRoomScreen').style.display = 'block';
            
            // Move music controls
            document.getElementById('musicControls').classList.add('battleActive');
            document.getElementById('musicTicker').classList.add('battleActive');
            
            // Stop any previous store video
            stopStoreVideo();
            
            // Set background - use video for stores, static image for others
            if (roomType === 'store') {
                // Use video background for store
                const selectedVideo = preGeneratedEncounter.storeVideo || getRandomTraderVideo();
                preGeneratedEncounter.storeVideo = selectedVideo; // Save for multiplayer sync
                
                const videoEl = document.getElementById('storeBackgroundVideo');
                if (videoEl) {
                    videoEl.querySelector('source').src = selectedVideo;
                    videoEl.load();
                    videoEl.volume = (settings.bgSoundVolume ?? 25) / 500; // Use settings
                    videoEl.style.display = 'block';
                    videoEl.play().catch(e => console.log('[Store] Video autoplay blocked:', e));
                }
                // Hide static background
                document.getElementById('nonCombatBackground').style.display = 'none';
            } else {
                // Use static background for other room types
                document.getElementById('storeBackgroundVideo').style.display = 'none';
                document.getElementById('nonCombatBackground').style.display = 'block';
                
                // Select appropriate background based on room type
                let backgroundUrl;
                if (roomType === 'exploration') {
                    // Use explore backgrounds for exploration rooms
                    backgroundUrl = preGeneratedEncounter.exploreBackground || getRandomExploreBackground();
                    preGeneratedEncounter.exploreBackground = backgroundUrl; // Save for multiplayer sync
                } else if (roomType === 'npc') {
                    // Use encounter backgrounds for NPC rooms
                    backgroundUrl = preGeneratedEncounter.encounterBackground || getRandomEncounterBackground();
                    preGeneratedEncounter.encounterBackground = backgroundUrl; // Save for multiplayer sync
                } else {
                    // Secret rooms use general dungeon backgrounds
                    backgroundUrl = preGeneratedEncounter.background 
                        ? `tunnelsofprivacy/backgrounds/${preGeneratedEncounter.background}`
                        : getRandomExploreBackground(); // Fallback to explore
                    if (!preGeneratedEncounter.background) {
                        preGeneratedEncounter.exploreBackground = backgroundUrl;
                    }
                }
                
                document.getElementById('nonCombatBackground').style.backgroundImage = `url('${backgroundUrl}')`;
            }
            
            // Configure room display based on type
            const roomConfigs = {
                'store': { icon: '<span class="icon icon-xxl icon-store"></span>', title: 'MERCHANT\'S SHOP', subtitle: 'Browse the wares...', color: '#27AE60' },
                'npc': { icon: 'ðŸ‘¤', title: 'FRIENDLY ENCOUNTER', subtitle: 'Someone approaches...', color: '#3498DB' },
                'secret': { icon: 'âœ¨', title: 'SECRET ROOM', subtitle: 'You found something hidden!', color: '#F1C40F' },
                'exploration': { icon: '<span class="icon icon-xxl icon-explore"></span>', title: 'EXPLORATION', subtitle: 'An interesting discovery...', color: '#9B59B6' }
            };
            
            const config = roomConfigs[roomType] || roomConfigs['exploration'];
            document.getElementById('nonCombatRoomIcon').innerHTML = config.icon;
            document.getElementById('nonCombatRoomTitle').textContent = config.title;
            document.getElementById('nonCombatRoomTitle').style.color = config.color;
            document.getElementById('nonCombatRoomSubtitle').textContent = config.subtitle;
            
            // Hide all content sections first
            document.getElementById('storeContent').style.display = 'none';
            document.getElementById('npcContent').style.display = 'none';
            document.getElementById('secretContent').style.display = 'none';
            document.getElementById('explorationContent').style.display = 'none';
            
            // Get the content container to adjust width based on room type
            const contentContainer = document.getElementById('nonCombatRoomContent');
            
            // Show appropriate content and set container width
            switch (roomType) {
                case 'store':
                    // Store needs full width for 3-column layout
                    contentContainer.style.maxWidth = '1400px';
                    contentContainer.style.width = '95%';
                    populateStoreContent();
                    document.getElementById('storeContent').style.display = 'block';
                    break;
                case 'npc':
                    // NPC only needs width for buttons (~450px)
                    contentContainer.style.maxWidth = '500px';
                    contentContainer.style.width = 'auto';
                    populateNPCContent();
                    document.getElementById('npcContent').style.display = 'block';
                    break;
                case 'secret':
                    // Secret room is compact
                    contentContainer.style.maxWidth = '500px';
                    contentContainer.style.width = 'auto';
                    populateSecretContent();
                    document.getElementById('secretContent').style.display = 'block';
                    break;
                case 'exploration':
                    // Exploration only needs width for buttons (~500px)
                    contentContainer.style.maxWidth = '500px';
                    contentContainer.style.width = 'auto';
                    populateExplorationContent();
                    document.getElementById('explorationContent').style.display = 'block';
                    break;
            }
            
            // Handle multiplayer - client sees waiting message if not host
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                document.getElementById('nonCombatLeaveBtn').style.opacity = '0.5';
            } else {
                document.getElementById('nonCombatLeaveBtn').style.opacity = '1';
            }
            document.getElementById('nonCombatWaitingMsg').style.display = 'none';
            
            // Broadcast to clients in multiplayer
            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                sendWebSocketMessage({
                    type: 'non_combat_room',
                    action: 'enter',
                    roomType: roomType,
                    data: {
                        storeData: preGeneratedEncounter.storeData,
                        storeVideo: preGeneratedEncounter.storeVideo,
                        npcData: preGeneratedEncounter.npcData,
                        secretData: preGeneratedEncounter.secretData,
                        explorationData: preGeneratedEncounter.explorationData,
                        background: preGeneratedEncounter.background
                    }
                });
            }
        }
        
        // Populate store content
        function populateStoreContent() {
            const storeData = preGeneratedEncounter.storeData;
            if (!storeData) return;
            
            const itemsContainer = document.getElementById('storeItems');
            itemsContainer.innerHTML = '';
            
            // Check if client (can't buy)
            const isClient = multiplayerState.enabled && multiplayerState.role === 'client';
            
            // Get current gold for affordability check (clients use cache)
            let currentGold, currentMeals;
            if (isClient) {
                currentGold = multiplayerState.goldCache || 0;
                currentMeals = multiplayerState.partyMealsCache?.length || 0;
            } else {
                const sharedSave = loadSharedSave();
                currentGold = sharedSave?.dungeonState?.gold || 0;
                currentMeals = sharedSave?.dungeonState?.partyMeals?.length || 0;
            }
            
            storeData.items.forEach((item, index) => {
                const canAfford = currentGold >= item.price;
                const mealsFull = item.type === 'party_meal' && currentMeals >= 10;
                const isDisabled = !canAfford || mealsFull;
                
                const itemEl = document.createElement('div');
                itemEl.style.cssText = `
                    background: ${isDisabled ? 'rgba(100, 100, 100, 0.2)' : 'rgba(39, 174, 96, 0.2)'};
                    border: 2px solid ${isDisabled ? '#666' : '#27AE60'};
                    border-radius: 12px;
                    padding: 12px;
                    display: flex;
                    align-items: center;
                    gap: 15px;
                    opacity: ${isDisabled ? '0.6' : '1'};
                    cursor: pointer;
                `;
                
                // Add food tooltip on hover for consumables/meals
                if (item.type === 'consumable' || item.type === 'party_meal') {
                    itemEl.addEventListener('mouseenter', (e) => showFoodTooltip(e, item));
                    itemEl.addEventListener('mousemove', (e) => updateFoodTooltipPosition(e));
                    itemEl.addEventListener('mouseleave', () => hideFoodTooltip());
                }
                
                // Use actual item icon image at 128x128
                const iconSrc = item.icon || 'tunnelsofprivacy/items/healing_potions_a_cropped.png';
                
                itemEl.innerHTML = `
                    <div style="flex-shrink: 0;">
                        <img src="${iconSrc}" style="width: 96px; height: 96px; object-fit: contain; border-radius: 8px; background: rgba(0,0,0,0.3); padding: 4px;" onerror="this.src='tunnelsofprivacy/items/healing_potions_a_cropped.png'">
                    </div>
                    <div style="flex: 1; min-width: 0;">
                        <div style="color: ${isDisabled ? '#888' : '#27AE60'}; font-weight: bold; font-size: 15px; margin-bottom: 4px;">${item.name}</div>
                        <div style="color: #89A0B4; font-size: 11px; line-height: 1.4;">${item.description || ''}</div>
                        ${item.type === 'party_meal' ? `<div style="color: #FF9F43; font-size: 10px; margin-top: 4px;">ðŸ– Party Meal - Use at camp</div>` : ''}
                    </div>
                    <div style="text-align: center; flex-shrink: 0;">
                        <div style="color: ${canAfford ? '#FFD700' : '#E74C3C'}; font-size: 18px; font-weight: bold; margin-bottom: 6px;">ðŸ’° ${item.price}</div>
                        <button onclick="buyItem(${index})" ${isDisabled || isClient ? 'disabled' : ''} style="
                            padding: 8px 20px;
                            background: ${isDisabled || isClient ? '#555' : 'linear-gradient(135deg, #27AE60, #219A52)'};
                            border: none;
                            border-radius: 6px;
                            color: white;
                            cursor: ${isDisabled || isClient ? 'not-allowed' : 'pointer'};
                            font-weight: bold;
                            font-size: 13px;
                            box-shadow: ${isDisabled || isClient ? 'none' : '0 2px 8px rgba(39, 174, 96, 0.4)'};
                        ">${isClient ? 'HOST ONLY' : (mealsFull ? 'FULL' : (canAfford ? 'BUY' : 'NEED GOLD'))}</button>
                    </div>
                `;
                itemsContainer.appendChild(itemEl);
            });
            
            // Also render the inventory and equipment shop
            renderStoreInventoryGrid();
            loadHeroWeapons();
            selectEquipHero('zooko'); // Default to Zooko
        }
        
        // Populate NPC content
        function populateNPCContent() {
            const npcData = preGeneratedEncounter.npcData;
            if (!npcData) return;
            
            document.getElementById('npcName').textContent = npcData.name;
            document.getElementById('npcDialogue').textContent = `"${npcData.dialogue}"`;
            
            // Update cost/reward displays
            document.getElementById('npcHelpCost').textContent = `Cost: ${npcData.helpCost} Gold`;
            document.getElementById('npcHelpReward').textContent = `Reward: +${npcData.helpXpReward} XP`;
            document.getElementById('npcRobReward').textContent = `Steal: ${npcData.robGoldReward} Gold`;
            document.getElementById('npcZcashReward').textContent = `Reward: +${npcData.zcashXpReward} XP`;
            
            // Check if player can afford to help
            const sharedSave = loadSharedSave();
            const currentGold = sharedSave.dungeonState?.gold || 0;
            const helpBtn = document.getElementById('npcHelpBtn');
            if (currentGold < npcData.helpCost) {
                helpBtn.style.opacity = '0.5';
                document.getElementById('npcHelpCost').textContent = `Cost: ${npcData.helpCost} Gold (Not enough!)`;
            } else {
                helpBtn.style.opacity = '1';
            }
            
            // Reset choice UI
            document.getElementById('npcChoices').style.display = 'flex';
            document.getElementById('npcChoiceMade').style.display = 'none';
            
            // If choice already made (multiplayer sync), show result, otherwise enable buttons
            if (npcData.choiceMade) {
                disableNPCChoices();
            } else {
                enableNPCChoices();
            }
        }
        
        // Populate secret room content
        function populateSecretContent() {
            const secretData = preGeneratedEncounter.secretData;
            if (!secretData) return;
            
            document.getElementById('secretDescription').textContent = secretData.description;
            
            let rewardText = '';
            if (secretData.reward.gold) rewardText += `ðŸ’° ${secretData.reward.gold} Gold\n`;
            if (secretData.reward.xp) rewardText += `â­ ${secretData.reward.xp} XP\n`;
            if (secretData.reward.item) rewardText += `ðŸŽ ${secretData.reward.item}\n`;
            if (secretData.reward.lore) rewardText += `ðŸ“œ ${secretData.reward.lore}`;
            
            document.getElementById('secretRewardText').textContent = rewardText || 'Mystery reward!';
        }
        
        // Populate exploration content
        function populateExplorationContent() {
            const explorationData = preGeneratedEncounter.explorationData;
            if (!explorationData) return;
            
            document.getElementById('explorationDescription').textContent = explorationData.challenge?.description || 'An interesting discovery...';
            document.getElementById('explorationChallengeText').textContent = `Difficulty: ${explorationData.difficulty || 1}`;
            document.getElementById('explorationSuccessChance').textContent = `Success Chance: ${explorationData.successChance || 75}%`;
            
            // Update XP and damage displays
            document.getElementById('explorationOneXp').textContent = `Success: +${explorationData.oneHeroXp} XP (one hero)`;
            document.getElementById('explorationOneFail').textContent = `Fail: -${explorationData.oneHeroFailDamage} HP (one hero)`;
            document.getElementById('explorationPartyXp').textContent = `Success: +${explorationData.partyXp} XP (split)`;
            document.getElementById('explorationPartyFail').textContent = `Fail: -${explorationData.partyFailDamage} HP (all heroes)`;
            
            // Reset choice UI
            document.getElementById('explorationChoices').style.display = 'flex';
            document.getElementById('explorationChoiceMade').style.display = 'none';
            
            // If choice already made (multiplayer sync), show result, otherwise enable buttons
            if (explorationData.choiceMade) {
                disableExplorationChoices();
            } else {
                enableExplorationChoices();
            }
        }
        
        // Buy an item from the store
        function buyItem(itemIndex) {
            const storeData = preGeneratedEncounter.storeData;
            if (!storeData || !storeData.items[itemIndex]) return;
            
            const item = storeData.items[itemIndex];
            const sharedSave = loadSharedSave();
            
            if (!sharedSave.dungeonState) sharedSave.dungeonState = {};
            const currentGold = sharedSave.dungeonState.gold || 0;
            
            if (currentGold < item.price) {
                showNotification('Not enough gold!', 'error');
                return;
            }
            
            // Check if party meal - goes to partyMeals array AND an inventory slot
            if (item.type === 'party_meal') {
                if (!sharedSave.dungeonState.partyMeals) sharedSave.dungeonState.partyMeals = [];
                
                // Max 10 meal slots
                if (sharedSave.dungeonState.partyMeals.length >= 10) {
                    showNotification('Party meal inventory full! (10 max)', 'error');
                    return;
                }
                
                // Find an empty unlocked inventory slot
                let emptySlotIndex = -1;
                for (let i = 0; i < UNLOCK_ORDER.length && i < partyInventory.maxSlots; i++) {
                    const gridPos = UNLOCK_ORDER[i];
                    // Skip hero potion slots (they auto-refresh)
                    if (isHeroPotionSlot(gridPos)) continue;
                    if (partyInventory.items[gridPos] === null) {
                        emptySlotIndex = gridPos;
                        break;
                    }
                }
                
                if (emptySlotIndex === -1) {
                    showNotification('No empty inventory slots!', 'error');
                    return;
                }
                
                // Deduct gold
                sharedSave.dungeonState.gold = currentGold - item.price;
                
                // Add to partyMeals tracking array
                const mealData = {
                    id: item.id,
                    name: item.name,
                    icon: item.icon,
                    value: item.value,
                    description: item.description,
                    inventorySlot: emptySlotIndex // Track which slot it's in
                };
                sharedSave.dungeonState.partyMeals.push(mealData);
                
                // Also add to inventory grid for visual display
                partyInventory.items[emptySlotIndex] = {
                    id: item.id,
                    name: item.name,
                    icon: item.icon,
                    type: 'party_meal',
                    value: item.value,
                    description: item.description
                };
                
                saveSharedSave(sharedSave);
                updateGoldDisplay();
                
                // Sync inventory to clients
                if (multiplayerState.enabled && multiplayerState.role === 'host') {
                    sendInventoryUpdate();
                }
                
                // Don't reduce quantity for party meals - unlimited stock (casual game)
                // Just refresh displays
                populateStoreContent();
                showNotification(`Bought ${item.name}! (${sharedSave.dungeonState.partyMeals.length}/10 meals)`, 'success');
                return;
            }
            
            // Deduct gold
            sharedSave.dungeonState.gold = currentGold - item.price;
            
            // Add to inventory (simplified - just track consumables)
            if (!sharedSave.dungeonState.inventory) sharedSave.dungeonState.inventory = [];
            sharedSave.dungeonState.inventory.push({ ...item, quantity: 1 });
            
            saveSharedSave(sharedSave);
            updateGoldDisplay();
            
            // Don't reduce quantity - unlimited stock (casual game)
            // Just refresh display
            populateStoreContent();
            showNotification(`Bought ${item.name}!`, 'success');
        }
        
        // NPC Choice: Help (Good) - Lose gold, gain XP, play video
        function npcChoiceHelp() {
            const npcData = preGeneratedEncounter.npcData;
            if (!npcData || npcData.choiceMade) return;
            
            // Only host can make choices in multiplayer
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                showNotification('Only the host can make this choice', 'error');
                return;
            }
            
            const sharedSave = loadSharedSave();
            if (!sharedSave.dungeonState) sharedSave.dungeonState = {};
            const currentGold = sharedSave.dungeonState.gold || 0;
            
            // Check if player can afford
            if (currentGold < npcData.helpCost) {
                showNotification(`Not enough gold! Need ${npcData.helpCost}`, 'error');
                return;
            }
            
            npcData.choiceMade = true;
            
            // Show video overlay
            const overlay = document.getElementById('helpVideoOverlay');
            const video = document.getElementById('helpVideo');
            
            overlay.style.display = 'flex';
            video.currentTime = 0;
            video.volume = (settings.musicVolume || 50) / 150; // Use music volume setting
            
            // Play video
            video.play().catch(e => console.log('[Help Video] Autoplay blocked:', e));
            
            // When video ends, close overlay and award rewards
            video.onended = function() {
                overlay.style.display = 'none';
                
                // Deduct gold
                sharedSave.dungeonState.gold = currentGold - npcData.helpCost;
                
                // Award XP to all heroes
                const xpPerHero = Math.floor(npcData.helpXpReward / 4);
                ['zooko', 'nate', 'zancas', 'cyberaxe'].forEach(heroKey => {
                    if (sharedSave.heroes[heroKey]) {
                        sharedSave.heroes[heroKey].xp += xpPerHero;
                    }
                });
                
                saveSharedSave(sharedSave);
                
                // Show result
                showNPCChoiceResult('help', npcData.helpCost, npcData.helpXpReward);
                updateGoldDisplay();
                showNotification(`You helped ${npcData.name}! -${npcData.helpCost} Gold, +${npcData.helpXpReward} XP`, 'success');
            };
            
            // Broadcast to clients in multiplayer
            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                sendWebSocketMessage({
                    type: 'npc_choice',
                    choice: 'help',
                    cost: npcData.helpCost,
                    reward: npcData.helpXpReward
                });
            }
        }
        
        // NPC Choice: Rob (Bad) - Gain gold, no XP
        function npcChoiceRob() {
            const npcData = preGeneratedEncounter.npcData;
            if (!npcData || npcData.choiceMade) return;
            
            // Only host can make choices in multiplayer
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                showNotification('Only the host can make this choice', 'error');
                return;
            }
            
            const sharedSave = loadSharedSave();
            if (!sharedSave.dungeonState) sharedSave.dungeonState = {};
            
            // Add stolen gold
            sharedSave.dungeonState.gold = (sharedSave.dungeonState.gold || 0) + npcData.robGoldReward;
            
            saveSharedSave(sharedSave);
            npcData.choiceMade = true;
            
            // Show result
            showNPCChoiceResult('rob', 0, npcData.robGoldReward);
            updateGoldDisplay();
            showNotification(`You robbed ${npcData.name}! +${npcData.robGoldReward} Gold`, 'warning');
            
            // Broadcast to clients in multiplayer
            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                sendWebSocketMessage({
                    type: 'npc_choice',
                    choice: 'rob',
                    reward: npcData.robGoldReward
                });
            }
        }
        
        // NPC Choice: Ignore (Neutral) - Just leave
        function npcChoiceIgnore() {
            const npcData = preGeneratedEncounter.npcData;
            if (!npcData || npcData.choiceMade) return;
            
            // Only host can make choices in multiplayer
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                showNotification('Only the host can make this choice', 'error');
                return;
            }
            
            npcData.choiceMade = true;
            
            // Show result
            showNPCChoiceResult('ignore', 0, 0);
            showNotification(`You walked away from ${npcData.name}`, 'info');
            
            // Broadcast to clients in multiplayer
            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                sendWebSocketMessage({
                    type: 'npc_choice',
                    choice: 'ignore'
                });
            }
        }
        
        // NPC Choice: Tell about Zcash - Play video and award XP
        function npcChoiceZcash() {
            const npcData = preGeneratedEncounter.npcData;
            if (!npcData || npcData.choiceMade) return;
            
            // Only host can make choices in multiplayer
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                showNotification('Only the host can make this choice', 'error');
                return;
            }
            
            npcData.choiceMade = true;
            
            // Get scaled XP reward
            const zcashXp = npcData.zcashXpReward || 100;
            
            // Show video overlay
            const overlay = document.getElementById('zcashVideoOverlay');
            const video = document.getElementById('zcashVideo');
            
            overlay.style.display = 'flex';
            video.currentTime = 0;
            video.volume = (settings.musicVolume || 50) / 150; // Use music volume setting
            
            // Play video
            video.play().catch(e => console.log('[Zcash Video] Autoplay blocked:', e));
            
            // When video ends, close overlay and award XP
            video.onended = function() {
                overlay.style.display = 'none';
                
                // Award scaled XP to party
                const sharedSave = loadSharedSave();
                const xpPerHero = Math.floor(zcashXp / 4);
                ['zooko', 'nate', 'zancas', 'cyberaxe'].forEach(heroKey => {
                    if (sharedSave.heroes[heroKey]) {
                        sharedSave.heroes[heroKey].xp += xpPerHero;
                    }
                });
                saveSharedSave(sharedSave);
                
                // Show result
                showNPCChoiceResult('zcash', 0, zcashXp);
                showNotification(`You told ${npcData.name} about Zcash! +${zcashXp} XP`, 'success');
            };
            
            // Broadcast to clients in multiplayer
            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                sendWebSocketMessage({
                    type: 'npc_choice',
                    choice: 'zcash',
                    reward: zcashXp
                });
            }
        }
        
        // Close Zcash video overlay (skip video)
        function closeZcashVideo() {
            const overlay = document.getElementById('zcashVideoOverlay');
            const video = document.getElementById('zcashVideo');
            
            // Stop and reset video
            video.pause();
            video.currentTime = 0;
            video.onended = null; // Remove the onended handler
            
            // Hide overlay
            overlay.style.display = 'none';
            
            // Award XP if not already done (check if result is already shown)
            const resultDiv = document.getElementById('npcChoiceMade');
            if (resultDiv.style.display === 'none') {
                const npcData = preGeneratedEncounter.npcData;
                const zcashXp = npcData?.zcashXpReward || 100;
                const sharedSave = loadSharedSave();
                const xpPerHero = Math.floor(zcashXp / 4);
                ['zooko', 'nate', 'zancas', 'cyberaxe'].forEach(heroKey => {
                    if (sharedSave.heroes[heroKey]) {
                        sharedSave.heroes[heroKey].xp += xpPerHero;
                    }
                });
                saveSharedSave(sharedSave);
                
                showNPCChoiceResult('zcash', 0, zcashXp);
                showNotification(`You told ${npcData?.name || 'the NPC'} about Zcash! +${zcashXp} XP`, 'success');
            }
        }
        
        // Close Help video overlay (skip video)
        function closeHelpVideo() {
            const overlay = document.getElementById('helpVideoOverlay');
            const video = document.getElementById('helpVideo');
            
            // Stop and reset video
            video.pause();
            video.currentTime = 0;
            video.onended = null; // Remove the onended handler
            
            // Hide overlay
            overlay.style.display = 'none';
            
            // Award rewards if not already done (check if result is already shown)
            const resultDiv = document.getElementById('npcChoiceMade');
            if (resultDiv.style.display === 'none') {
                const npcData = preGeneratedEncounter.npcData;
                const sharedSave = loadSharedSave();
                if (!sharedSave.dungeonState) sharedSave.dungeonState = {};
                const currentGold = sharedSave.dungeonState.gold || 0;
                
                // Deduct gold
                sharedSave.dungeonState.gold = currentGold - (npcData?.helpCost || 0);
                
                // Award XP to all heroes
                const helpXp = npcData?.helpXpReward || 100;
                const xpPerHero = Math.floor(helpXp / 4);
                ['zooko', 'nate', 'zancas', 'cyberaxe'].forEach(heroKey => {
                    if (sharedSave.heroes[heroKey]) {
                        sharedSave.heroes[heroKey].xp += xpPerHero;
                    }
                });
                saveSharedSave(sharedSave);
                
                showNPCChoiceResult('help', npcData?.helpCost || 0, helpXp);
                updateGoldDisplay();
                showNotification(`You helped ${npcData?.name || 'the NPC'}! -${npcData?.helpCost || 0} Gold, +${helpXp} XP`, 'success');
            }
        }
        
        // Close Exploration video overlay (skip video)
        // Track which exploration choice was made so we process the right one on skip
        let explorationVideoChoice = null; // 'one' or 'party'
        
        function closeExplorationVideo() {
            const overlay = document.getElementById('explorationVideoOverlay');
            const video = document.getElementById('explorationVideo');
            
            // Stop and reset video
            video.pause();
            video.currentTime = 0;
            video.onended = null;
            
            // Hide overlay
            overlay.style.display = 'none';
            
            // Process the result if not already done
            const resultDiv = document.getElementById('explorationChoiceMade');
            if (resultDiv.style.display === 'none') {
                // Check which video was playing based on source
                const source = document.getElementById('explorationVideoSource');
                if (source.src.includes('cyberaxe_intro_a')) {
                    processExplorationSendOne();
                } else if (source.src.includes('nate_intro_a')) {
                    processExplorationSendParty();
                }
            }
        }
        
        // Hero intro video paths - each hero has two variants that alternate on click
        const heroIntroVideos = {
            zooko: ['tunnelsofprivacy/videos/zooko_intro.mp4', 'tunnelsofprivacy/videos/zooko_intro_a.mp4'],
            nate: ['tunnelsofprivacy/videos/nate_zashi.mp4', 'tunnelsofprivacy/videos/nate_intro_a.mp4'],
            zancas: ['tunnelsofprivacy/videos/zancas_intro.mp4', 'tunnelsofprivacy/videos/zancas_intro_a.mp4'],
            cyberaxe: ['tunnelsofprivacy/videos/cyberaxe_intro.mp4', 'tunnelsofprivacy/videos/cyberaxe_intro_a.mp4']
        };
        
        // Track which video variant to play next for each hero (0 = first, 1 = second)
        const heroIntroVideoToggle = {
            zooko: 0,
            nate: 0,
            zancas: 0,
            cyberaxe: 0
        };
        
        // Play hero intro video - alternates between two variants on each click
        function playHeroIntroVideo(heroName) {
            const overlay = document.getElementById('heroIntroVideoOverlay');
            const video = document.getElementById('heroIntroVideo');
            const source = document.getElementById('heroIntroVideoSource');
            
            // Get the video paths array for this hero
            const heroKey = heroName.toLowerCase();
            const videoPaths = heroIntroVideos[heroKey];
            if (!videoPaths || videoPaths.length === 0) {
                console.error('No intro video for hero:', heroName);
                return;
            }
            
            // Get current toggle state and select video
            const currentIndex = heroIntroVideoToggle[heroKey] || 0;
            const videoPath = videoPaths[currentIndex];
            
            // Toggle to the other variant for next click
            heroIntroVideoToggle[heroKey] = (currentIndex + 1) % videoPaths.length;
            
            source.src = videoPath;
            video.load();
            
            // Show overlay with flex
            overlay.style.display = 'flex';
            
            // Play video
            video.play().catch(err => {
                console.error('Failed to play hero intro video:', err);
            });
            
            // Auto-close 0.5 seconds before video ends (to avoid bad frame)
            video.onended = () => {
                closeHeroIntroVideo();
            };
            
            // Monitor time to close early
            video.ontimeupdate = () => {
                if (video.duration && video.currentTime >= video.duration - 0.5) {
                    closeHeroIntroVideo();
                }
            };
        }
        
        // Close hero intro video overlay
        function closeHeroIntroVideo() {
            const overlay = document.getElementById('heroIntroVideoOverlay');
            const video = document.getElementById('heroIntroVideo');
            
            // Stop and reset video
            video.pause();
            video.currentTime = 0;
            video.onended = null;
            video.ontimeupdate = null;
            
            // Hide overlay
            overlay.style.display = 'none';
        }
        
        // Show the result of NPC choice and disable buttons
        function showNPCChoiceResult(choice, cost, reward) {
            disableNPCChoices();
            
            const resultDiv = document.getElementById('npcChoiceMade');
            const resultText = document.getElementById('npcChoiceResult');
            
            resultDiv.style.display = 'block';
            
            switch (choice) {
                case 'help':
                    resultDiv.style.background = 'rgba(46, 204, 113, 0.2)';
                    resultDiv.style.border = '2px solid #2ECC71';
                    resultText.style.color = '#2ECC71';
                    resultText.textContent = `âœ¨ You showed kindness! (-${cost} Gold, +${reward} XP)`;
                    break;
                case 'rob':
                    resultDiv.style.background = 'rgba(231, 76, 60, 0.2)';
                    resultDiv.style.border = '2px solid #E74C3C';
                    resultText.style.color = '#E74C3C';
                    resultText.textContent = `ðŸ’€ You took what you wanted! (+${reward} Gold)`;
                    break;
                case 'zcash':
                    resultDiv.style.background = 'rgba(242, 201, 76, 0.2)';
                    resultDiv.style.border = '2px solid #F2C94C';
                    resultText.style.color = '#F2C94C';
                    resultText.textContent = `ðŸ’³ You spread the word about Zcash! (+${reward} XP)`;
                    break;
                case 'ignore':
                    resultDiv.style.background = 'rgba(149, 165, 166, 0.2)';
                    resultDiv.style.border = '2px solid #95A5A6';
                    resultText.style.color = '#95A5A6';
                    resultText.textContent = `ðŸš¶ You walked away without a word.`;
                    break;
            }
        }
        
        // Disable all NPC choice buttons
        function disableNPCChoices() {
            ['npcHelpBtn', 'npcRobBtn', 'npcZcashBtn', 'npcIgnoreBtn'].forEach(btnId => {
                const btn = document.getElementById(btnId);
                if (btn) {
                    btn.disabled = true;
                    btn.style.opacity = '0.5';
                    btn.style.pointerEvents = 'none';
                }
            });
        }
        
        // Enable all NPC choice buttons (reset for new encounter)
        function enableNPCChoices() {
            ['npcHelpBtn', 'npcRobBtn', 'npcZcashBtn', 'npcIgnoreBtn'].forEach(btnId => {
                const btn = document.getElementById(btnId);
                if (btn) {
                    btn.disabled = false;
                    btn.style.opacity = '1';
                    btn.style.pointerEvents = 'auto';
                }
            });
        }
        
        // Exploration Choice: Send One Hero - plays cyberaxe_intro_a video
        function explorationSendOne() {
            const explorationData = preGeneratedEncounter.explorationData;
            if (!explorationData || explorationData.choiceMade) return;
            
            // Only host can make choices in multiplayer
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                showNotification('Only the host can make this choice', 'error');
                return;
            }
            
            explorationData.choiceMade = true;
            
            // Show video overlay
            const overlay = document.getElementById('explorationVideoOverlay');
            const video = document.getElementById('explorationVideo');
            const source = document.getElementById('explorationVideoSource');
            
            source.src = 'tunnelsofprivacy/videos/cyberaxe_intro_a.mp4';
            video.load();
            overlay.style.display = 'flex';
            video.currentTime = 0;
            video.volume = (settings.musicVolume || 50) / 150;
            
            video.play().catch(e => console.log('[Exploration Video] Autoplay blocked:', e));
            
            // When video ends, process the exploration result
            video.onended = function() {
                overlay.style.display = 'none';
                processExplorationSendOne();
            };
            
            // Broadcast to clients in multiplayer (they see result after host's video)
            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                // Will send result after video ends in processExplorationSendOne
            }
        }
        
        // Process Send One Hero result (called after video)
        function processExplorationSendOne() {
            const explorationData = preGeneratedEncounter.explorationData;
            const sharedSave = loadSharedSave();
            
            // Pick a random living hero
            const livingHeroes = ['zooko', 'nate', 'zancas', 'cyberaxe'].filter(h => 
                sharedSave.heroes[h] && sharedSave.heroes[h].hp > 0
            );
            
            if (livingHeroes.length === 0) {
                showNotification('No heroes available!', 'error');
                return;
            }
            
            const chosenHero = livingHeroes[Math.floor(Math.random() * livingHeroes.length)];
            const heroDisplayName = chosenHero.charAt(0).toUpperCase() + chosenHero.slice(1);
            
            // Roll for success
            const roll = Math.random() * 100;
            const success = roll < explorationData.successChance;
            
            if (success) {
                sharedSave.heroes[chosenHero].xp += explorationData.oneHeroXp;
                showExplorationChoiceResult('one_success', chosenHero, explorationData.oneHeroXp, 0);
                showNotification(`${heroDisplayName} succeeded! +${explorationData.oneHeroXp} XP`, 'success');
            } else {
                const damage = explorationData.oneHeroFailDamage;
                sharedSave.heroes[chosenHero].hp = Math.max(0, sharedSave.heroes[chosenHero].hp - damage);
                showExplorationChoiceResult('one_fail', chosenHero, 0, damage);
                showNotification(`${heroDisplayName} failed! -${damage} HP`, 'error');
            }
            
            saveSharedSave(sharedSave);
            
            // Broadcast to clients in multiplayer
            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                sendWebSocketMessage({
                    type: 'exploration_choice',
                    choice: 'one',
                    success: success,
                    hero: chosenHero,
                    xp: success ? explorationData.oneHeroXp : 0,
                    damage: success ? 0 : explorationData.oneHeroFailDamage
                });
            }
        }
        
        // Exploration Choice: Send Entire Party - plays nate_intro_a video
        function explorationSendParty() {
            const explorationData = preGeneratedEncounter.explorationData;
            if (!explorationData || explorationData.choiceMade) return;
            
            // Only host can make choices in multiplayer
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                showNotification('Only the host can make this choice', 'error');
                return;
            }
            
            explorationData.choiceMade = true;
            
            // Show video overlay
            const overlay = document.getElementById('explorationVideoOverlay');
            const video = document.getElementById('explorationVideo');
            const source = document.getElementById('explorationVideoSource');
            
            source.src = 'tunnelsofprivacy/videos/nate_intro_a.mp4';
            video.load();
            overlay.style.display = 'flex';
            video.currentTime = 0;
            video.volume = (settings.musicVolume || 50) / 150;
            
            video.play().catch(e => console.log('[Exploration Video] Autoplay blocked:', e));
            
            // When video ends, process the exploration result
            video.onended = function() {
                overlay.style.display = 'none';
                processExplorationSendParty();
            };
        }
        
        // Process Send Party result (called after video)
        function processExplorationSendParty() {
            const explorationData = preGeneratedEncounter.explorationData;
            const sharedSave = loadSharedSave();
            
            // Roll for success
            const roll = Math.random() * 100;
            const success = roll < explorationData.successChance;
            
            if (success) {
                const xpPerHero = Math.floor(explorationData.partyXp / 4);
                ['zooko', 'nate', 'zancas', 'cyberaxe'].forEach(heroKey => {
                    if (sharedSave.heroes[heroKey]) {
                        sharedSave.heroes[heroKey].xp += xpPerHero;
                    }
                });
                showExplorationChoiceResult('party_success', null, explorationData.partyXp, 0);
                showNotification(`Party succeeded! +${explorationData.partyXp} XP`, 'success');
            } else {
                const damage = explorationData.partyFailDamage;
                ['zooko', 'nate', 'zancas', 'cyberaxe'].forEach(heroKey => {
                    if (sharedSave.heroes[heroKey]) {
                        sharedSave.heroes[heroKey].hp = Math.max(0, sharedSave.heroes[heroKey].hp - damage);
                    }
                });
                showExplorationChoiceResult('party_fail', null, 0, damage);
                showNotification(`Party failed! Everyone takes -${damage} HP`, 'error');
            }
            
            saveSharedSave(sharedSave);
            
            // Broadcast to clients in multiplayer
            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                sendWebSocketMessage({
                    type: 'exploration_choice',
                    choice: 'party',
                    success: success,
                    xp: success ? explorationData.partyXp : 0,
                    damage: success ? 0 : explorationData.partyFailDamage
                });
            }
        }
        
        // Exploration Choice: Retreat
        function explorationRetreat() {
            const explorationData = preGeneratedEncounter.explorationData;
            if (!explorationData || explorationData.choiceMade) return;
            
            // Only host can make choices in multiplayer
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                showNotification('Only the host can make this choice', 'error');
                return;
            }
            
            explorationData.choiceMade = true;
            
            showExplorationChoiceResult('retreat', null, 0, 0);
            showNotification('Party retreated safely', 'info');
            
            // Broadcast to clients in multiplayer
            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                sendWebSocketMessage({
                    type: 'exploration_choice',
                    choice: 'retreat'
                });
            }
        }
        
        // Show the result of exploration choice and disable buttons
        function showExplorationChoiceResult(resultType, hero, xp, damage) {
            disableExplorationChoices();
            
            const resultDiv = document.getElementById('explorationChoiceMade');
            const resultText = document.getElementById('explorationChoiceResult');
            
            resultDiv.style.display = 'block';
            
            const heroName = hero ? hero.charAt(0).toUpperCase() + hero.slice(1) : '';
            
            switch (resultType) {
                case 'one_success':
                    resultDiv.style.background = 'rgba(46, 204, 113, 0.2)';
                    resultDiv.style.border = '2px solid #2ECC71';
                    resultText.style.color = '#2ECC71';
                    resultText.textContent = `âœ¨ ${heroName} completed the challenge! (+${xp} XP)`;
                    break;
                case 'one_fail':
                    resultDiv.style.background = 'rgba(231, 76, 60, 0.2)';
                    resultDiv.style.border = '2px solid #E74C3C';
                    resultText.style.color = '#E74C3C';
                    resultText.textContent = `ðŸ’¥ ${heroName} failed! (-${damage} HP)`;
                    break;
                case 'party_success':
                    resultDiv.style.background = 'rgba(46, 204, 113, 0.2)';
                    resultDiv.style.border = '2px solid #2ECC71';
                    resultText.style.color = '#2ECC71';
                    resultText.textContent = `âœ¨ Party succeeded together! (+${xp} XP split)`;
                    break;
                case 'party_fail':
                    resultDiv.style.background = 'rgba(231, 76, 60, 0.2)';
                    resultDiv.style.border = '2px solid #E74C3C';
                    resultText.style.color = '#E74C3C';
                    resultText.textContent = `ðŸ’¥ Party failed! Everyone takes -${damage} HP`;
                    break;
                case 'retreat':
                    resultDiv.style.background = 'rgba(149, 165, 166, 0.2)';
                    resultDiv.style.border = '2px solid #95A5A6';
                    resultText.style.color = '#95A5A6';
                    resultText.textContent = `ðŸš¶ Party retreated without attempting.`;
                    break;
            }
        }
        
        // Disable all exploration choice buttons
        function disableExplorationChoices() {
            ['explorationSendOneBtn', 'explorationSendPartyBtn', 'explorationRetreatBtn'].forEach(btnId => {
                const btn = document.getElementById(btnId);
                if (btn) {
                    btn.disabled = true;
                    btn.style.opacity = '0.5';
                    btn.style.pointerEvents = 'none';
                }
            });
        }
        
        // Enable all exploration choice buttons (reset for new encounter)
        function enableExplorationChoices() {
            ['explorationSendOneBtn', 'explorationSendPartyBtn', 'explorationRetreatBtn'].forEach(btnId => {
                const btn = document.getElementById(btnId);
                if (btn) {
                    btn.disabled = false;
                    btn.style.opacity = '1';
                    btn.style.pointerEvents = 'auto';
                }
            });
        }
        
        // Leave non-combat room
        function leaveNonCombatRoom() {
            console.log('[NonCombat] Leaving room');
            
            // In multiplayer, clients wait for host
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                document.getElementById('nonCombatWaitingMsg').style.display = 'block';
                return;
            }
            
            // Host or single player - actually leave
            executeLeaveNonCombatRoom();
            
            // Broadcast to clients in multiplayer
            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                sendWebSocketMessage({
                    type: 'non_combat_room',
                    action: 'leave'
                });
            }
        }
        
        // Actually execute leaving the non-combat room
        function executeLeaveNonCombatRoom() {
            // Track current room type before clearing state
            const roomType = nonCombatRoomState.roomType;
            const roomId = preGeneratedEncounter.currentRoomId;
            
            // If leaving a store, mark it as found and save store data for revisiting
            if (roomType === 'store' && currentLevelLayout) {
                if (!currentLevelLayout.storeFound) {
                    currentLevelLayout.storeFound = true;
                    // Save the store data so player can revisit
                    currentLevelLayout.discoveredStoreData = {
                        merchantName: nonCombatRoomState.data?.storeData?.merchantName,
                        items: nonCombatRoomState.data?.storeData?.items || [],
                        greeting: nonCombatRoomState.data?.storeData?.greeting
                    };
                    // Save the store video so it stays consistent on revisit
                    currentLevelLayout.discoveredStoreVideo = nonCombatRoomState.data?.storeVideo;
                    saveLevelLayout();
                    console.log('[Store] Store discovered and saved for level', currentLevelLayout.level);
                    
                    // Update level progress for store visited
                    markStoreVisited();
                }
                // Mark store room explored (so it won't appear in random selection)
                if (roomId) {
                    markRoomExplored(roomId);
                    console.log(`[RoomTracking] Marked store room ${roomId} as explored`);
                }
                // Update the store button on dungeon menu
                updateStoreButtonState();
                // Stop store video
                stopStoreVideo();
            } else if (roomId) {
                // For non-store rooms (NPC, exploration, secret), mark as explored
                markRoomExplored(roomId);
                console.log(`[RoomTracking] Marked ${roomType} room ${roomId} as explored`);
            }
            
            // Save game state
            const sharedSave = loadSharedSave();
            if (sharedSave) {
                sharedSave.lastPlayed = Date.now();
                saveSharedSave(sharedSave);
            }
            
            // Reset state
            nonCombatRoomState.active = false;
            nonCombatRoomState.roomType = null;
            nonCombatRoomState.data = null;
            
            // Switch screens
            currentScreen = 'dungeonMenu';
            document.getElementById('nonCombatRoomScreen').style.display = 'none';
            document.getElementById('dungeonMenuScreen').style.display = 'block';
            
            // Move music controls back
            document.getElementById('musicControls').classList.remove('battleActive');
            document.getElementById('musicControls').classList.add('dungeonMenuActive');
            document.getElementById('musicTicker').classList.remove('battleActive');
            document.getElementById('musicTicker').classList.add('dungeonMenuActive');
            
            // Update dungeon menu displays
            updateDungeonMenuHeroes();
            updateGoldDisplay();
            
            // Hide waiting message
            document.getElementById('nonCombatWaitingMsg').style.display = 'none';
            
            // Reset pre-generated encounter and start generating next
            resetPreGeneratedEncounter();
            preGenerateNextEncounter();
            
            // Update level progress
            levelProgress.roomsExplored++;
            updateLevelProgressDisplay();
            saveLevelProgress();
        }
        
        // Client enters non-combat room (from host message)
        function clientEnterNonCombatRoom(roomType, data) {
            console.log('[NonCombat] Client entering room:', roomType);
            
            // Set up the encounter data from host
            preGeneratedEncounter.roomType = roomType;
            preGeneratedEncounter.storeData = data.storeData;
            preGeneratedEncounter.storeVideo = data.storeVideo;
            preGeneratedEncounter.npcData = data.npcData;
            preGeneratedEncounter.secretData = data.secretData;
            preGeneratedEncounter.explorationData = data.explorationData;
            preGeneratedEncounter.background = data.background;
            
            // Enter the room
            enterNonCombatRoom(roomType);
        }
        
        // ===== END NON-COMBAT ROOM SYSTEM =====
        
        // ===== LEVEL STORE SYSTEM =====
        
        // Enter the level store from dungeon menu (revisiting a discovered store)
        function enterLevelStore() {
            // Check if store was actually found
            if (!currentLevelLayout || !currentLevelLayout.storeFound) {
                showNotification('Store not yet discovered on this level!', 'error');
                return;
            }
            
            // Check if we have saved store data
            if (!currentLevelLayout.discoveredStoreData) {
                showNotification('Store data not available!', 'error');
                return;
            }
            
            console.log('[Store] Revisiting level store');
            
            // Set up the preGeneratedEncounter with saved store data
            preGeneratedEncounter.roomType = 'store';
            preGeneratedEncounter.storeData = currentLevelLayout.discoveredStoreData;
            // Use saved video or pick a new random one
            preGeneratedEncounter.storeVideo = currentLevelLayout.discoveredStoreVideo || getRandomTraderVideo();
            
            // Enter the store room (enterNonCombatRoom handles multiplayer broadcast)
            enterNonCombatRoom('store');
        }
        
        // Update the store button state based on whether store is found
        function updateStoreButtonState() {
            const storeBtn = document.getElementById('levelStoreBtn');
            const storeBtnText = document.getElementById('levelStoreBtnText');
            
            console.log('[StoreBtn] updateStoreButtonState called');
            console.log('[StoreBtn] currentLevelLayout:', currentLevelLayout);
            console.log('[StoreBtn] hasStore:', currentLevelLayout?.hasStore);
            console.log('[StoreBtn] storeFound:', currentLevelLayout?.storeFound);
            console.log('[StoreBtn] discoveredStoreData:', currentLevelLayout?.discoveredStoreData);
            
            if (!storeBtn || !storeBtnText) {
                console.log('[StoreBtn] Button elements not found!');
                return;
            }
            
            if (currentLevelLayout && currentLevelLayout.storeFound && currentLevelLayout.discoveredStoreData) {
                // Store was found - enable button
                storeBtn.disabled = false;
                storeBtn.classList.add('unlocked');
                storeBtnText.innerHTML = '<span class="icon icon-lg icon-store"></span> ENTER LEVEL STORE<br><span style="font-size: 12px; font-weight: 400;">ðŸ›’ Store Available!</span>';
            } else if (currentLevelLayout && currentLevelLayout.hasStore && !currentLevelLayout.storeFound) {
                // Level has a store but not found yet
                storeBtn.disabled = true;
                storeBtn.classList.remove('unlocked');
                storeBtnText.innerHTML = '<span class="icon icon-lg icon-store"></span> ENTER LEVEL STORE<br><span style="font-size: 12px; font-weight: 400;">(Not Found)</span>';
            } else {
                // No store on this level or no layout
                storeBtn.disabled = true;
                storeBtn.classList.remove('unlocked');
                storeBtnText.innerHTML = '<span class="icon icon-lg icon-store"></span> ENTER LEVEL STORE<br><span style="font-size: 12px; font-weight: 400;">(None on Level)</span>';
            }
            
            // Also update Dungeon Masters panel
            updateDungeonMastersStatus();
        }
        
        // ===== END LEVEL STORE SYSTEM =====
        
        // Update the Dungeon Masters panel level status
        function updateDungeonMastersStatus() {
            const bossStatusEl = document.getElementById('dmBossStatus');
            const miniBossStatusEl = document.getElementById('dmMiniBossStatus');
            const encountersStatusEl = document.getElementById('dmEncountersStatus');
            const storeStatusEl = document.getElementById('dmStoreStatus');
            const npcsStatusEl = document.getElementById('dmNPCsStatus');
            const explorationStatusEl = document.getElementById('dmExplorationStatus');
            const captivesStatusEl = document.getElementById('dmCaptivesStatus');
            const secretsStatusEl = document.getElementById('dmSecretsStatus');
            const roomsRemainingEl = document.getElementById('dmRoomsRemaining');
            
            // Helper function to count rooms by type
            function countRoomsByType(type) {
                if (!currentLevelLayout || !currentLevelLayout.rooms) return { explored: 0, total: 0 };
                const roomsOfType = currentLevelLayout.rooms.filter(r => r.type === type);
                const explored = roomsOfType.filter(r => r.explored).length;
                return { explored, total: roomsOfType.length };
            }
            
            // Helper function to update room status element
            function updateRoomTypeStatus(el, counts, noneText = 'None') {
                if (!el) return;
                if (counts.total === 0) {
                    el.textContent = noneText;
                    el.style.color = '#89A0B4';
                } else if (counts.explored === counts.total) {
                    el.textContent = `${counts.explored}/${counts.total} âœ“`;
                    el.style.color = '#27AE60';
                } else {
                    el.textContent = `${counts.explored}/${counts.total}`;
                    el.style.color = '#F2C94C';
                }
            }
            
            // Update boss status - 0/1 or 1/1 like other rooms
            if (bossStatusEl) {
                if (currentLevelLayout && currentLevelLayout.bossRoom?.explored) {
                    bossStatusEl.textContent = '1/1 âœ“';
                    bossStatusEl.style.color = '#27AE60';
                } else {
                    bossStatusEl.textContent = '0/1';
                    bossStatusEl.style.color = '#F2C94C';
                }
            }
            
            // Update mini-boss status
            const miniBossCounts = countRoomsByType(ROOM_TYPES.MINI_BOSS);
            updateRoomTypeStatus(miniBossStatusEl, miniBossCounts);
            
            // Update encounters (combat rooms) status
            const encountersCounts = countRoomsByType(ROOM_TYPES.COMBAT);
            updateRoomTypeStatus(encountersStatusEl, encountersCounts);
            
            // Update store status
            if (storeStatusEl) {
                if (currentLevelLayout && currentLevelLayout.storeFound) {
                    storeStatusEl.textContent = 'Found âœ“';
                    storeStatusEl.style.color = '#27AE60';
                } else if (currentLevelLayout && currentLevelLayout.hasStore) {
                    storeStatusEl.textContent = 'Not Found';
                    storeStatusEl.style.color = '#EB5757';
                } else {
                    storeStatusEl.textContent = 'None';
                    storeStatusEl.style.color = '#89A0B4';
                }
            }
            
            // Update NPC rooms status
            const npcCounts = countRoomsByType(ROOM_TYPES.NPC);
            updateRoomTypeStatus(npcsStatusEl, npcCounts);
            
            // Update exploration rooms status
            const explorationCounts = countRoomsByType(ROOM_TYPES.EXPLORATION);
            updateRoomTypeStatus(explorationStatusEl, explorationCounts);
            
            // Update captive rooms status
            const captiveCounts = countRoomsByType(ROOM_TYPES.CAPTIVE);
            updateRoomTypeStatus(captivesStatusEl, captiveCounts);
            
            // Update secret rooms status
            const secretCounts = countRoomsByType(ROOM_TYPES.SECRET);
            if (secretsStatusEl) {
                if (secretCounts.total === 0) {
                    secretsStatusEl.textContent = '???';
                    secretsStatusEl.style.color = '#89A0B4';
                } else if (secretCounts.explored === secretCounts.total) {
                    secretsStatusEl.textContent = `${secretCounts.explored}/${secretCounts.total} âœ“`;
                    secretsStatusEl.style.color = '#27AE60';
                } else {
                    // Show found secrets but hide total (mystery!)
                    secretsStatusEl.textContent = `${secretCounts.explored}/?`;
                    secretsStatusEl.style.color = '#F1C40F';
                }
            }
            
            // Update rooms remaining
            if (roomsRemainingEl && currentLevelLayout) {
                const unexploredRooms = currentLevelLayout.rooms.filter(r => !r.explored && r.type !== ROOM_TYPES.SECRET).length;
                const bossRemaining = currentLevelLayout.bossRoom && !currentLevelLayout.bossRoom.explored ? 1 : 0;
                const total = unexploredRooms + bossRemaining;
                
                if (total === 0) {
                    roomsRemainingEl.textContent = 'All Clear!';
                    roomsRemainingEl.style.color = '#27AE60';
                } else {
                    roomsRemainingEl.textContent = total.toString();
                    roomsRemainingEl.style.color = '#F2C94C';
                }
            }
            
            // Show/hide stairs down button based on boss defeated
            const stairsDownBtn2 = document.getElementById('stairsDownBtn2');
            if (stairsDownBtn2) {
                if (currentLevelLayout && currentLevelLayout.bossRoom?.explored) {
                    stairsDownBtn2.style.display = 'block';
                    // Disable for clients - only host can use stairs
                    if (multiplayerState.enabled && multiplayerState.role === 'client') {
                        stairsDownBtn2.disabled = true;
                        stairsDownBtn2.style.opacity = '0.5';
                        stairsDownBtn2.style.cursor = 'not-allowed';
                        stairsDownBtn2.innerHTML = '<span class="icon icon-md icon-stairs-down"></span> STAIRS<br><span style="font-size: 10px;">(HOST ONLY)</span>';
                    } else {
                        stairsDownBtn2.disabled = false;
                        stairsDownBtn2.style.opacity = '1';
                        stairsDownBtn2.style.cursor = 'pointer';
                        stairsDownBtn2.innerHTML = '<span class="icon icon-md icon-stairs-down"></span> STAIRS';
                    }
                } else {
                    stairsDownBtn2.style.display = 'none';
                }
            }
        }
        
        // Update the Next Room Preview UI
        function updateNextRoomPreview() {
            const nextRoomTypeEl = document.getElementById('nextRoomType');
            if (!nextRoomTypeEl) return;
            
            // Check if level is complete
            if (currentLevelLayout) {
                const allRoomsExplored = currentLevelLayout.rooms
                    .filter(r => r.type !== ROOM_TYPES.SECRET)
                    .every(r => r.explored);
                
                if (allRoomsExplored && currentLevelLayout.bossRoom?.explored) {
                    nextRoomTypeEl.innerHTML = 'ðŸ† LEVEL COMPLETE';
                    nextRoomTypeEl.style.color = '#27AE60';
                    nextRoomTypeEl.style.textShadow = '0 0 15px #27AE60';
                    return;
                }
            }
            
            const roomType = preGeneratedEncounter.roomType || 'combat';
            
            // Map room types to display text and icons
            const roomTypeDisplay = {
                'combat': { icon: '<span class="icon icon-md icon-combat"></span>', text: 'Combat', color: '#E74C3C' },
                'boss': { icon: 'ðŸ‘¹', text: 'BOSS BATTLE', color: '#8B45FF' },
                'mini_boss': { icon: 'ðŸ’€', text: 'Mini-Boss', color: '#E67E22' },
                'store': { icon: '<span class="icon icon-md icon-store"></span>', text: 'Store', color: '#27AE60' },
                'secret': { icon: 'âœ¨', text: 'Secret Room', color: '#F1C40F' },
                'npc': { icon: 'ðŸ‘¤', text: 'NPC Encounter', color: '#3498DB' },
                'exploration': { icon: '<span class="icon icon-md icon-explore"></span>', text: 'Exploration', color: '#9B59B6' }
            };
            
            const display = roomTypeDisplay[roomType] || roomTypeDisplay['combat'];
            nextRoomTypeEl.innerHTML = `${display.icon} ${display.text}`;
            nextRoomTypeEl.style.color = display.color;
            
            // Add glow effect for special rooms
            if (roomType === 'boss' || roomType === 'secret' || roomType === 'store') {
                nextRoomTypeEl.style.textShadow = `0 0 15px ${display.color}`;
            } else {
                nextRoomTypeEl.style.textShadow = 'none';
            }
        }
        
        // Update level layout display (rooms remaining by type)
        function updateLevelLayoutDisplay() {
            // Update the Rooms display to show actual room count from layout
            const roomsMaxEl = document.getElementById('dmRoomsMax');
            if (roomsMaxEl && currentLevelLayout && currentLevelLayout.generated) {
                roomsMaxEl.textContent = currentLevelLayout.totalRooms;
            }
        }
        
        // Update the Explore Level button loading bar
        function updateExploreLoadingBar(percent) {
            const loadingBar = document.getElementById('exploreLoadingBar');
            const exploreBtn = document.getElementById('exploreLevelBtn');
            const btnText = exploreBtn?.querySelector('.btnText');
            
            if (loadingBar) {
                loadingBar.style.width = percent + '%';
            }
            
            if (exploreBtn) {
                // Check if level is complete
                const levelComplete = currentLevelLayout && 
                    currentLevelLayout.rooms.filter(r => r.type !== ROOM_TYPES.SECRET).every(r => r.explored) && 
                    currentLevelLayout.bossRoom?.explored;
                
                if (levelComplete) {
                    exploreBtn.classList.add('ready');
                    if (btnText) btnText.innerHTML = 'ðŸ† LEVEL COMPLETE';
                } else if (percent >= 100) {
                    exploreBtn.classList.add('ready');
                    if (btnText) btnText.innerHTML = '<span class="icon icon-lg icon-combat"></span> EXPLORE LEVEL';
                } else if (percent > 0) {
                    exploreBtn.classList.remove('ready');
                    if (btnText) btnText.innerHTML = `PREPARING... ${percent}%`;
                } else {
                    exploreBtn.classList.remove('ready');
                    if (btnText) btnText.innerHTML = '<span class="icon icon-lg icon-combat"></span> EXPLORE LEVEL';
                }
            }
        }
        
        // Reset pre-generated encounter (call after battle ends)
        function resetPreGeneratedEncounter() {
            // Get current level from UI
            const dungeonLevelEl = document.getElementById('dungeonMenuLevel');
            const currentLevel = parseInt(dungeonLevelEl?.textContent) || 1;
            
            preGeneratedEncounter = {
                ready: false,
                generating: false,
                boss: null,
                mobs: [],
                captive: null,
                background: null,
                roomLevel: currentLevel,
                roomType: 'combat', // Will be set by preGenerateNextEncounter
                currentRoomId: null, // Will be set when room is selected
                storeData: null,
                secretData: null,
                npcData: null,
                explorationData: null
            };
            // Reset loading bar UI
            updateExploreLoadingBar(0);
        }
        
        // Change dungeon level (stairs up/down)
        function changeLevel(direction) {
            // In multiplayer, only host can change levels
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                console.log('[Stairs] Clients cannot change levels - waiting for host');
                showNotification('Only the party leader can use stairs', 'warning');
                return;
            }
            
            // Get current level from UI
            const dungeonLevelEl = document.getElementById('dungeonMenuLevel');
            let currentLevel = parseInt(dungeonLevelEl?.textContent) || 1;
            
            // Calculate new level (minimum 1)
            const newLevel = Math.max(1, currentLevel + direction);
            
            // Don't do anything if level didn't change
            if (newLevel === currentLevel) {
                console.log('[Stairs] Already at minimum level');
                return;
            }
            
            console.log(`[Stairs] Moving from level ${currentLevel} to level ${newLevel}`);
            
            // Update UI
            if (dungeonLevelEl) {
                dungeonLevelEl.textContent = newLevel;
            }
            
            // Update story background for new level
            updateDungeonMenuBackground();
            
            // Save to shared save (host only saves in multiplayer)
            if (!multiplayerState.enabled || multiplayerState.role === 'host') {
                const sharedSave = loadSharedSave();
                if (sharedSave) {
                    if (!sharedSave.dungeonState) {
                        sharedSave.dungeonState = {};
                    }
                    sharedSave.dungeonState.currentLevel = newLevel;
                    sharedSave.lastPlayed = Date.now();
                    saveSharedSave(sharedSave);
                    console.log('[Stairs] Game saved at level', newLevel);
                }
            }
            
            // Reset and regenerate encounter for new level
            preGeneratedEncounter = {
                ready: false,
                generating: false,
                boss: null,
                mobs: [],
                captive: null,
                background: null,
                roomLevel: newLevel,
                roomType: 'combat' // Will be set by preGenerateNextEncounter
            };
            updateExploreLoadingBar(0);
            
            // Load level progress for new level (or reset if no saved progress)
            loadLevelProgress();
            
            // Initialize level layout for new level
            initializeLevelLayout(newLevel);
            
            // Start generating the new encounter
            preGenerateNextEncounter();
            
            // In multiplayer, host broadcasts level change to all clients
            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                sendWebSocketMessage({
                    type: 'level_change',
                    newLevel: newLevel,
                    progress: levelProgress,
                    levelLayout: currentLevelLayout
                });
                console.log('[MP] Broadcast level change to clients:', newLevel);
            }
        }
        
        // Fast travel to a specific level (diag feature)
        function fastTravel() {
            // In multiplayer, only host can fast travel
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                console.log('[FastTravel] Clients cannot fast travel - waiting for host');
                showNotification('Only the party leader can fast travel', 'warning');
                return;
            }
            
            const input = document.getElementById('fastTravelLevel');
            const targetLevel = parseInt(input?.value) || 1;
            
            // Minimum level 1
            const newLevel = Math.max(1, targetLevel);
            
            // Get current level
            const dungeonLevelEl = document.getElementById('dungeonMenuLevel');
            const currentLevel = parseInt(dungeonLevelEl?.textContent) || 1;
            
            // Don't do anything if already at target level
            if (newLevel === currentLevel) {
                console.log('[FastTravel] Already at level', newLevel);
                return;
            }
            
            console.log(`[FastTravel] Traveling from level ${currentLevel} to level ${newLevel}`);
            
            // Update UI
            if (dungeonLevelEl) {
                dungeonLevelEl.textContent = newLevel;
            }
            
            // Update story background for new level
            updateDungeonMenuBackground();
            
            // Save to shared save (host only saves in multiplayer)
            if (!multiplayerState.enabled || multiplayerState.role === 'host') {
                const sharedSave = loadSharedSave();
                if (sharedSave) {
                    if (!sharedSave.dungeonState) {
                        sharedSave.dungeonState = {};
                    }
                    sharedSave.dungeonState.currentLevel = newLevel;
                    sharedSave.lastPlayed = Date.now();
                    saveSharedSave(sharedSave);
                    console.log('[FastTravel] Game saved at level', newLevel);
                }
            }
            
            // Reset and regenerate encounter for new level
            preGeneratedEncounter = {
                ready: false,
                generating: false,
                boss: null,
                mobs: [],
                captive: null,
                background: null,
                roomLevel: newLevel,
                roomType: 'combat' // Will be set by preGenerateNextEncounter
            };
            updateExploreLoadingBar(0);
            
            // Load level progress for new level (or reset if no saved progress)
            loadLevelProgress();
            
            // Initialize level layout for new level
            initializeLevelLayout(newLevel);
            
            // Start generating the new encounter
            preGenerateNextEncounter();
            
            // In multiplayer, host broadcasts level change to all clients
            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                sendWebSocketMessage({
                    type: 'level_change',
                    newLevel: newLevel,
                    progress: levelProgress,
                    levelLayout: currentLevelLayout
                });
                console.log('[MP] Broadcast level change to clients:', newLevel);
            }
        }
        
        // Chat state for battle
        let chatState = {
            visible: false,
            messages: [],  // { id, senderName, senderType, senderAvatar, text, timestamp }
            targetNpc: null,  // Currently selected NPC to chat with (deprecated - use targetEntity)
            targetEntity: null,  // Current chat target: null = broadcast, or { type, index, name }
            selectedModel: 2,  // Model ID 1-10 (default to free model 2)
            exhaustedModels: [],  // Track rate-limited models
            totalCost: 0,      // Running cost tally in dollars
            totalTokens: 0,    // Running token count
            ttsEnabled: true,  // TTS on by default
            ttsAvailable: false // Set by server check
        };
        
        // TTS audio queue and current audio
        let ttsAudioQueue = [];
        let ttsCurrentAudio = null;
        
        // Toggle TTS on/off
        function toggleTTS() {
            const checkbox = document.getElementById('ttsToggle');
            chatState.ttsEnabled = checkbox?.checked ?? false;
            console.log('[TTS] Enabled:', chatState.ttsEnabled);
        }
        
        // Check TTS availability on page load
        async function checkTTSAvailability() {
            try {
                const response = await fetch('/api/tts-status', { method: 'POST' });
                const data = await response.json();
                chatState.ttsAvailable = data.enabled;
                console.log('[TTS] Server availability:', data.enabled);
                
                // Update UI if TTS not available
                if (!data.enabled) {
                    const toggle = document.getElementById('ttsToggle');
                    const label = document.getElementById('ttsToggleLabel');
                    if (toggle) toggle.disabled = true;
                    if (label) label.title = 'TTS not available - piper-tts not installed on server';
                }
            } catch (e) {
                console.log('[TTS] Server check failed:', e);
                chatState.ttsAvailable = false;
            }
        }
        
        // Get voice type based on entity
        function getTTSVoiceType(senderType, senderName, entityVoiceType) {
            // If entity has LLM-assigned voice type, use that first
            if (entityVoiceType) {
                return entityVoiceType;
            }
            
            // Check if it's a hero name
            const heroNames = ['zooko', 'nate', 'zancas', 'cyberaxe'];
            const lowerName = (senderName || '').toLowerCase();
            if (heroNames.includes(lowerName)) {
                return lowerName;
            }
            
            // Map sender types to voice types (fallback)
            switch (senderType) {
                case 'boss': return 'boss';
                case 'mob': case 'enemy': return 'mob';
                case 'captive': return 'captive';
                case 'npc': return 'npc';
                case 'narrator': case 'system': return 'narrator';
                default: return 'default';
            }
        }
        
        // Play TTS for a message
        async function playTTS(text, senderType, senderName, entityVoiceType, entityPersonality, entityId = null) {
            if (!chatState.ttsEnabled || !chatState.ttsAvailable) return;
            
            // Skip empty or very short text
            if (!text || text.length < 2) return;
            
            // Skip action-only messages like *silence* or *growls*
            if (text.trim().startsWith('*') && text.trim().endsWith('*') && text.length < 30) {
                return;
            }
            
            try {
                const voiceType = getTTSVoiceType(senderType, senderName, entityVoiceType);
                console.log(`[TTS] Generating audio for "${text.substring(0, 30)}..." with voice: ${voiceType}, personality: ${entityPersonality || 'none'}, entityId: ${entityId || 'none'}`);
                
                const response = await fetch('/api/tts', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        text, 
                        voiceType, 
                        personality: entityPersonality || '',
                        entityId: entityId || null  // For consistent voice per entity
                    })
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    console.error('[TTS] Error:', error);
                    return;
                }
                
                // Get audio blob and play it
                const audioBlob = await response.blob();
                const audioUrl = URL.createObjectURL(audioBlob);
                
                // Queue audio playback
                ttsAudioQueue.push({ url: audioUrl, text: text.substring(0, 30) });
                playNextTTSAudio();
                
            } catch (e) {
                console.error('[TTS] Playback error:', e);
            }
        }
        
        // Play next audio in queue
        function playNextTTSAudio() {
            if (ttsCurrentAudio || ttsAudioQueue.length === 0) return;
            
            const { url, text } = ttsAudioQueue.shift();
            console.log(`[TTS] Playing: "${text}..."`);
            
            ttsCurrentAudio = new Audio(url);
            const ttsVol = (settings.voiceVolume || 90) / 250;
            ttsCurrentAudio.volume = ttsVol;
            
            ttsCurrentAudio.onended = () => {
                URL.revokeObjectURL(url);
                ttsCurrentAudio = null;
                playNextTTSAudio(); // Play next in queue
            };
            
            ttsCurrentAudio.onerror = (e) => {
                console.error('[TTS] Audio playback error:', e);
                URL.revokeObjectURL(url);
                ttsCurrentAudio = null;
                playNextTTSAudio();
            };
            
            ttsCurrentAudio.play().catch(e => {
                console.log('[TTS] Autoplay blocked, user interaction needed');
                ttsCurrentAudio = null;
            });
        }
        
        // ============ NARRATOR SYSTEM ============
        let narratorState = {
            levelData: null,
            isPlaying: false,
            isLoading: false,
            currentAudio: null,
            cachedNarrations: {} // Cache narrations per level
        };
        
        // Load level data JSON (per-level version with unique zone for each level)
        async function loadLevelData() {
            // Always fetch fresh to ensure we have per-level data
            try {
                const response = await fetch('tunnelsofprivacy/levels/level_data_perlevel.json?v=' + Date.now());
                narratorState.levelData = await response.json();
                return narratorState.levelData;
            } catch (e) {
                console.error('[Narrator] Failed to load level data:', e);
                return null;
            }
        }
        
        // Get zone info for current level
        function getZoneForLevel(level) {
            if (!narratorState.levelData) return null;
            
            for (const zone of narratorState.levelData.zones) {
                if (level >= zone.levelRange[0] && level <= zone.levelRange[1]) {
                    return zone;
                }
            }
            return null;
        }
        
        // Generate narrator text via LLM
        async function generateNarration(level, zone) {
            const cacheKey = `level_${level}`;
            if (narratorState.cachedNarrations[cacheKey]) {
                console.log('[Narrator] Using cached narration for level', level);
                return narratorState.cachedNarrations[cacheKey];
            }
            
            // Build context for LLM
            const arcInfo = narratorState.levelData.arcs[zone.arc];
            const enemyList = zone.enemies?.join(', ') || 'unknown threats';
            const miniboss = zone.miniboss ? `The miniboss ${zone.miniboss} lurks here.` : '';
            const boss = zone.boss ? `The boss ${zone.boss.name} - ${zone.boss.title} awaits.` : '';
            
            // Different prompt style based on RP mode setting
            const rpModeEnabled = settings.rpMode !== false;
            const styleInstructions = rpModeEnabled 
                ? 'Write a dramatic 2-3 sentence narration. Be atmospheric, evocative, and use rich fantasy language. Speak as an omniscient narrator with a dramatic flair.'
                : 'Write a simple 2-3 sentence description in plain, easy-to-understand English. No fancy words or dramatic language. Just describe what the heroes see in normal speech.';
            
            const prompt = `You are the narrator for "Tunnels of Privacy", a dungeon crawler RPG about protecting financial privacy.

CURRENT LEVEL: ${level}
ZONE: ${zone.name}
THIS LEVEL'S SCENE: ${zone.description}
ENEMIES: ${enemyList}
${miniboss}
${boss}

${styleInstructions} Use the scene description as your PRIMARY inspiration. Keep it under 50 words. Do not use quotation marks.`;

            try {
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        npcName: 'Narrator',
                        backstory: 'The omniscient narrator of the Tunnels of Privacy',
                        npcType: 'narrator',
                        conversation: [],
                        message: prompt,
                        playerName: 'Heroes',
                        modelId: chatState.selectedModel || 'groq/llama-3.3-70b-versatile',
                        rpMode: settings.rpMode !== false  // Honor user's RP mode setting
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    narratorState.cachedNarrations[cacheKey] = result.response;
                    return result.response;
                } else {
                    console.error('[Narrator] LLM error:', result.error);
                    checkForRateLimitError(result.error);
                    return `Level ${level}. ${zone.name}. ${zone.description}.`;
                }
            } catch (e) {
                console.error('[Narrator] API error:', e);
                checkForRateLimitError(e.message || String(e));
                return `Level ${level}. ${zone.name}. ${zone.description}.`;
            }
        }
        
        // Toggle narrator play/stop
        async function toggleNarrator() {
            const btn = document.getElementById('narratorBtn');
            const btnText = document.getElementById('narratorBtnText');
            
            // If playing, stop
            if (narratorState.isPlaying) {
                stopNarrator();
                return;
            }
            
            // If loading, ignore
            if (narratorState.isLoading) return;
            
            // Start loading
            narratorState.isLoading = true;
            btn.classList.add('loading');
            btnText.textContent = 'LOADING...';
            
            try {
                // Load level data if needed
                await loadLevelData();
                if (!narratorState.levelData) {
                    throw new Error('Failed to load level data');
                }
                
                // Get current level from save data
                const sharedSave = loadSharedSave();
                const currentLevel = sharedSave?.dungeonState?.currentLevel || 1;
                const zone = getZoneForLevel(currentLevel);
                
                if (!zone) {
                    throw new Error('No zone found for level ' + currentLevel);
                }
                
                // Generate narration
                btnText.textContent = 'GENERATING...';
                const narrationText = await generateNarration(currentLevel, zone);
                
                // Play TTS
                btnText.textContent = 'SPEAKING...';
                await playNarratorTTS(narrationText);
                
                // Update UI to playing state
                narratorState.isPlaying = true;
                narratorState.isLoading = false;
                btn.classList.remove('loading');
                btn.classList.add('playing');
                btnText.textContent = 'STOP';
                
            } catch (e) {
                console.error('[Narrator] Error:', e);
                narratorState.isLoading = false;
                btn.classList.remove('loading');
                btnText.textContent = 'NARRATE';
            }
        }
        
        // Play narrator TTS
        async function playNarratorTTS(text) {
            if (!chatState.ttsAvailable) {
                console.log('[Narrator] TTS not available, showing text only');
                // Could show text in UI instead
                return;
            }
            
            try {
                const response = await fetch('/api/tts', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        text: text, 
                        voiceType: 'narrator',
                        personality: 'dramatic, wise, omniscient'
                    })
                });
                
                if (!response.ok) {
                    throw new Error('TTS request failed');
                }
                
                const audioBlob = await response.blob();
                const audioUrl = URL.createObjectURL(audioBlob);
                
                narratorState.currentAudio = new Audio(audioUrl);
                const narrVol = (settings.voiceVolume || 90) / 250;
                narratorState.currentAudio.volume = narrVol;
                
                narratorState.currentAudio.onended = () => {
                    URL.revokeObjectURL(audioUrl);
                    narratorState.currentAudio = null;
                    narratorState.isPlaying = false;
                    
                    const btn = document.getElementById('narratorBtn');
                    const btnText = document.getElementById('narratorBtnText');
                    if (btn) btn.classList.remove('playing');
                    if (btnText) btnText.textContent = 'NARRATE';
                };
                
                narratorState.currentAudio.onerror = (e) => {
                    console.error('[Narrator] Audio error:', e);
                    URL.revokeObjectURL(audioUrl);
                    stopNarrator();
                };
                
                await narratorState.currentAudio.play();
                
            } catch (e) {
                console.error('[Narrator] TTS error:', e);
                throw e;
            }
        }
        
        // Stop narrator
        function stopNarrator() {
            if (narratorState.currentAudio) {
                narratorState.currentAudio.pause();
                narratorState.currentAudio = null;
            }
            
            narratorState.isPlaying = false;
            narratorState.isLoading = false;
            
            const btn = document.getElementById('narratorBtn');
            const btnText = document.getElementById('narratorBtnText');
            if (btn) {
                btn.classList.remove('playing', 'loading');
            }
            if (btnText) {
                btnText.textContent = 'NARRATE';
            }
        }
        
        // Select chat target entity
        function selectChatTarget(entity) {
            chatState.targetEntity = entity;
            
            // Update button visuals
            document.querySelectorAll('.chatTargetBtn').forEach(btn => {
                const isActive = entity === null ? 
                    btn.classList.contains('broadcast') : 
                    btn.dataset.entityType === entity?.type && btn.dataset.entityIndex === String(entity?.index);
                btn.classList.toggle('active', isActive);
            });
            
            // Update input placeholder
            const input = document.getElementById('chatInput');
            if (input) {
                if (entity === null) {
                    input.placeholder = 'Say something to everyone...';
                } else {
                    input.placeholder = `Say something to ${entity.name}...`;
                }
            }
            
            console.log('[Chat] Target:', entity ? entity.name : 'BROADCAST');
        }
        
        // Update chat target buttons based on current entities
        function updateChatTargets() {
            const container = document.getElementById('chatTargetSelector');
            if (!container) return;
            
            // Clear existing buttons (except broadcast)
            container.innerHTML = '<button class="chatTargetBtn broadcast' + (chatState.targetEntity === null ? ' active' : '') + '" onclick="selectChatTarget(null)" title="Speak to everyone">ðŸ“¢ ALL</button>';
            
            // Add boss/enemy buttons
            battleState.enemies.forEach((enemy, index) => {
                if (enemy.hp > 0) {
                    const btnClass = enemy.isMob ? 'hostile' : 'boss';
                    const isActive = chatState.targetEntity?.type === 'enemy' && chatState.targetEntity?.index === index;
                    const shortName = enemy.name.length > 10 ? enemy.name.substring(0, 9) + 'â€¦' : enemy.name;
                    const btn = document.createElement('button');
                    btn.className = `chatTargetBtn ${btnClass}${isActive ? ' active' : ''}`;
                    btn.dataset.entityType = 'enemy';
                    btn.dataset.entityIndex = index;
                    btn.onclick = () => selectChatTarget({ type: 'enemy', index, name: enemy.name, entity: enemy });
                    btn.title = enemy.name;
                    btn.textContent = `âš”ï¸ ${shortName}`;
                    container.appendChild(btn);
                }
            });
            
            // Add captive button if present
            if (battleState.captiveNpc && !battleState.captiveNpc.rescued) {
                const captive = battleState.captiveNpc;
                const isActive = chatState.targetEntity?.type === 'captive';
                const shortName = captive.name.length > 10 ? captive.name.substring(0, 9) + 'â€¦' : captive.name;
                const btn = document.createElement('button');
                btn.className = `chatTargetBtn friendly${isActive ? ' active' : ''}`;
                btn.dataset.entityType = 'captive';
                btn.dataset.entityIndex = '0';
                btn.onclick = () => selectChatTarget({ type: 'captive', index: 0, name: captive.name, entity: captive });
                btn.title = captive.name + ' (Captive)';
                btn.textContent = `â›“ï¸ ${shortName}`;
                container.appendChild(btn);
            }
        }
        
        // Select chat model (1-10)
        function selectChatModel(modelId) {
            // Don't allow selecting exhausted models
            if (chatState.exhaustedModels.includes(modelId)) {
                console.log(`[Chat] Model ${modelId} is exhausted (rate limited)`);
                return;
            }
            
            chatState.selectedModel = modelId;
            // Update button visuals - use onclick attribute to match model ID
            document.querySelectorAll('.modelBtn').forEach(btn => {
                // Extract model ID from onclick attribute: onclick="selectChatModel(X)"
                const onclickAttr = btn.getAttribute('onclick') || '';
                const match = onclickAttr.match(/selectChatModel\((\d+)\)/);
                const btnModelId = match ? parseInt(match[1]) : 0;
                btn.classList.toggle('active', btnModelId === modelId);
            });
            console.log(`[Chat] Selected model ${modelId}`);
        }
        
        // Mark a model as exhausted (rate limited)
        function markModelExhausted(modelId) {
            if (!chatState.exhaustedModels.includes(modelId)) {
                chatState.exhaustedModels.push(modelId);
                // Update button visual
                document.querySelectorAll('.modelBtn').forEach(btn => {
                    const onclickAttr = btn.getAttribute('onclick') || '';
                    const match = onclickAttr.match(/selectChatModel\((\d+)\)/);
                    const btnModelId = match ? parseInt(match[1]) : 0;
                    if (btnModelId === modelId) {
                        btn.classList.add('exhausted');
                        btn.title = btn.title + ' (RATE LIMITED)';
                    }
                });
                console.log(`[Chat] Model ${modelId} marked as exhausted`);
                
                // If current model is exhausted, switch to another free model
                if (chatState.selectedModel === modelId) {
                    const freeModels = [2, 4, 5];
                    const availableFree = freeModels.filter(m => !chatState.exhaustedModels.includes(m));
                    if (availableFree.length > 0) {
                        selectChatModel(availableFree[0]);
                    }
                }
            }
        }
        
        // Toggle chat window visibility
        function toggleChatWindow() {
            chatState.visible = !chatState.visible;
            const chatWindow = document.getElementById('battleChatWindow');
            if (chatWindow) {
                chatWindow.style.display = chatState.visible ? 'flex' : 'none';
                if (chatState.visible) {
                    document.getElementById('chatInput').focus();
                    updateChatTargets();  // Refresh entity buttons when opening
                }
            }
        }
        
        // Toggle chat window expand/shrink
        function toggleChatExpand() {
            const chatWindow = document.getElementById('battleChatWindow');
            const expandBtn = document.getElementById('chatExpandBtn');
            if (chatWindow) {
                chatWindow.classList.toggle('compact');
                const isCompact = chatWindow.classList.contains('compact');
                if (expandBtn) {
                    expandBtn.textContent = isCompact ? 'â‡•' : 'â‡•';
                    expandBtn.title = isCompact ? 'Expand' : 'Shrink';
                }
            }
        }
        
        // Typewriter effect for NPC messages
        function typewriterEffect(messageId, fullText, charIndex = 0) {
            const container = document.getElementById('chatMessages');
            if (!container) return;
            
            // Find the message element by data-id
            const msgElement = container.querySelector(`[data-msg-id="${messageId}"] .chatText`);
            if (!msgElement) return;
            
            // Also update the stored message text for consistency
            const msg = chatState.messages.find(m => m.id === messageId);
            if (msg) {
                msg.displayText = fullText.substring(0, charIndex);
            }
            
            // Update displayed text with cursor
            const displayText = fullText.substring(0, charIndex);
            msgElement.innerHTML = formatChatText(displayText) + (charIndex < fullText.length ? '<span class="typingCursor">â–Œ</span>' : '');
            
            // Continue typing if not done
            if (charIndex < fullText.length) {
                // Variable speed: faster for spaces, slower for punctuation
                const char = fullText[charIndex];
                let delay = 25; // Base speed (ms per char)
                if (char === ' ') delay = 15;
                else if ('.!?'.includes(char)) delay = 150;
                else if (',;:'.includes(char)) delay = 80;
                
                setTimeout(() => typewriterEffect(messageId, fullText, charIndex + 1), delay);
            } else {
                // Done typing - remove cursor
                msgElement.innerHTML = formatChatText(fullText);
                if (msg) msg.displayText = fullText;
            }
        }
        
        // Add message to chat
        function addChatMessage(senderName, senderType, senderAvatar, text, isNpc = false, voiceType = null, personality = null, entityId = null) {
            const message = {
                id: Date.now(),
                senderName,
                senderType,  // 'hostile', 'questable', 'friendly', 'player', 'boss', 'mob', 'captive'
                senderAvatar,
                text,
                displayText: isNpc ? '' : text,  // For typewriter effect
                isNpc,
                voiceType,  // LLM-assigned voice type
                personality,  // For TTS emotional adjustment
                entityId,  // Unique ID for consistent TTS voice
                timestamp: new Date().toLocaleTimeString()
            };
            
            // Add to front (newest first)
            chatState.messages.unshift(message);
            
            // Keep last 50 messages
            if (chatState.messages.length > 50) {
                chatState.messages.pop();
            }
            
            renderChatMessages();
            
            // Start typewriter effect for NPC messages
            if (isNpc && text.length > 0) {
                setTimeout(() => typewriterEffect(message.id, text, 0), 100);
                
                // Play TTS for NPC responses (pass entity's voiceType, personality, and ID)
                playTTS(text, senderType, senderName, voiceType, personality, entityId);
            }
            
            // Broadcast to other players if host (send full text, clients show instantly)
            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                sendWebSocketMessage({
                    type: 'chat_message',
                    message: { ...message, displayText: text }  // Send full text to clients
                });
            }
        }
        
        // Format chat text - convert *text* to italics, escape HTML
        function formatChatText(text) {
            // First escape HTML to prevent XSS
            const escaped = text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;');
            // Convert *text* to italics (common roleplay notation)
            return escaped.replace(/\*([^*]+)\*/g, '<em>$1</em>');
        }
        
        // Render chat messages
        function renderChatMessages() {
            const container = document.getElementById('chatMessages');
            if (!container) return;
            
            container.innerHTML = chatState.messages.map(msg => `
                <div class="chatMessage" data-msg-id="${msg.id}">
                    <div class="chatAvatar" style="background-image: url('${msg.senderAvatar}');"></div>
                    <div class="chatContent">
                        <div class="chatName ${msg.senderType}">${msg.senderName}</div>
                        <div class="chatText">${formatChatText(msg.displayText !== undefined ? msg.displayText : msg.text)}</div>
                    </div>
                </div>
            `).join('');
        }
        
        // Send chat message from player
        async function sendChatMessage() {
            const input = document.getElementById('chatInput');
            const sendBtn = document.getElementById('chatSendBtn');
            const statusEl = document.getElementById('chatStatus');
            const message = input.value.trim();
            
            if (!message) return;
            
            // Get player name
            const playerName = multiplayerState.enabled ? 
                (multiplayerState.playerName || 'Player') : 'Player';
            
            // Get current hero avatar (use first alive hero)
            const currentHero = battleState.heroes.find(h => h.hp > 0);
            const heroAvatar = currentHero ? 
                `people/${currentHero.name.toLowerCase()}_a_head_compressed.png` : 
                'people/zooko_a_head_compressed.png';
            
            // Add player message to chat
            addChatMessage(playerName, 'player', heroAvatar, message, false);
            
            // Clear input
            input.value = '';
            
            // In multiplayer, only host calls LLM
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                // Send to host for LLM processing, including target selection
                if (statusEl) statusEl.textContent = 'Sending to host...';
                sendWebSocketMessage({
                    type: 'chat_request',
                    playerName: playerName,
                    message: message,
                    targetEntity: chatState.targetEntity  // Include client's selected target
                });
                setTimeout(() => { if (statusEl) statusEl.textContent = ''; }, 2000);
                return;
            }
            
            // Get NPC to respond based on selected target
            let respondingNpc = null;
            
            // If a specific target is selected, use that
            if (chatState.targetEntity) {
                if (chatState.targetEntity.type === 'captive') {
                    respondingNpc = battleState.captiveNpc;
                } else if (chatState.targetEntity.type === 'enemy') {
                    respondingNpc = battleState.enemies[chatState.targetEntity.index];
                }
                
                // Validate the target is still valid
                if (respondingNpc && (respondingNpc.hp <= 0 || respondingNpc.rescued)) {
                    respondingNpc = null;
                    selectChatTarget(null);  // Reset to broadcast
                }
            }
            
            // If broadcast mode (ALL), give all NPCs a chance to respond via free will
            if (!chatState.targetEntity) {
                const allNpcs = [];
                
                // Add captive if present and can chat
                if (battleState.captiveNpc && !battleState.captiveNpc.rescued && battleState.captiveNpc.canChat) {
                    allNpcs.push(battleState.captiveNpc);
                }
                
                // Add all alive enemies with backstory
                battleState.enemies.forEach(enemy => {
                    if (enemy.hp > 0 && enemy.backstory) {
                        allNpcs.push(enemy);
                    }
                });
                
                if (allNpcs.length === 0) {
                    if (statusEl) statusEl.textContent = 'No one can talk';
                    addChatMessage('System', 'friendly', 'people/zooko_a_head_compressed.png', 
                        '*No one responds...*', true);
                    setTimeout(() => { if (statusEl) statusEl.textContent = ''; }, 2000);
                    return;
                }
                
                // Give each NPC a chance to respond (free will style)
                if (statusEl) statusEl.textContent = 'NPCs considering response...';
                for (const npc of allNpcs) {
                    triggerFreeWillChatResponse(npc, playerName, message);
                }
                setTimeout(() => { if (statusEl) statusEl.textContent = ''; }, 3000);
                return;
            }
            
            if (!respondingNpc) {
                // No NPC can respond
                if (statusEl) statusEl.textContent = 'No one can talk';
                addChatMessage('System', 'friendly', 'people/zooko_a_head_compressed.png', 
                    '*No one responds...*', true);
                setTimeout(() => { if (statusEl) statusEl.textContent = ''; }, 2000);
                return;
            }
            
            // Determine NPC type for the API
            const npcType = respondingNpc.isCaptive ? 'captive' : (respondingNpc.isBoss ? 'boss' : 'mob');
            
            // Disable send while waiting
            sendBtn.disabled = true;
            sendBtn.textContent = '...';
            
            // Start response timer
            const startTime = performance.now();
            let timerInterval = setInterval(() => {
                const elapsed = ((performance.now() - startTime) / 1000).toFixed(1);
                if (statusEl) statusEl.textContent = `Model ${chatState.selectedModel} - ${elapsed}s...`;
            }, 100);
            
            try {
                // Call server LLM API
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        npcName: respondingNpc.name,
                        backstory: respondingNpc.backstory || 'A mysterious creature.',
                        npcType: npcType,
                        conversation: chatState.messages.slice(0, 10).reverse(),
                        message: message,
                        playerName: playerName,
                        modelId: chatState.selectedModel,
                        rpMode: settings.rpMode !== false  // Default true for RP style
                    })
                });
                
                // Stop timer
                clearInterval(timerInterval);
                const totalTime = ((performance.now() - startTime) / 1000).toFixed(2);
                
                const result = await response.json();
                
                if (result.success) {
                    if (statusEl) statusEl.textContent = `Model ${chatState.selectedModel}: ${totalTime}s`;
                    // Clear status after 5 seconds
                    setTimeout(() => { if (statusEl && statusEl.textContent.includes(totalTime)) statusEl.textContent = ''; }, 5000);
                    
                    // Update cost tracking
                    if (result.usage) {
                        chatState.totalCost += result.usage.cost || 0;
                        chatState.totalTokens += (result.usage.promptTokens || 0) + (result.usage.completionTokens || 0);
                        const costDisplay = document.getElementById('chatCostDisplay');
                        if (costDisplay) {
                            costDisplay.textContent = `$${chatState.totalCost.toFixed(6)} | ${chatState.totalTokens} tok`;
                        }
                    }
                    
                    // Determine NPC type for color (captive = friendly, hostile enemy = hostile, etc)
                    const chatNpcType = respondingNpc.isCaptive ? 'friendly' :
                        (respondingNpc.hostile ? 'hostile' : 
                        (respondingNpc.questable ? 'questable' : 'friendly'));
                    
                    // Add NPC response (include LLM-assigned voiceType and personality)
                    addChatMessage(
                        respondingNpc.name,
                        chatNpcType,
                        respondingNpc.spritePath || 'people/zooko_a_head_compressed.png',
                        result.response,
                        true,
                        respondingNpc.voiceType,  // Pass entity's voice type
                        respondingNpc.personality  // Pass entity's personality for TTS
                    );
                    
                    // Process negotiation outcomes (betrayal, retreat, rage)
                    processNegotiation(respondingNpc, message, result.response);
                } else {
                    // Check for rate limit error
                    const errorMsg = result.error || 'Unknown';
                    const isRateLimit = errorMsg.toLowerCase().includes('rate') || 
                                       errorMsg.toLowerCase().includes('limit') ||
                                       errorMsg.toLowerCase().includes('quota') ||
                                       errorMsg.toLowerCase().includes('429') ||
                                       errorMsg.toLowerCase().includes('exceeded');
                    
                    if (isRateLimit) {
                        // Mark current model as exhausted
                        markModelExhausted(chatState.selectedModel);
                        if (statusEl) statusEl.textContent = `Model ${chatState.selectedModel} rate limited!`;
                        addChatMessage('System', 'friendly', 'people/zooko_a_head_compressed.png', 
                            `*Model ${chatState.selectedModel} is rate limited. Try another model.*`, true);
                        showRateLimitWarning();  // Show popup
                    } else {
                        if (statusEl) statusEl.textContent = `Error (${totalTime}s): ` + errorMsg;
                    }
                    console.error('Chat API error:', result.error);
                }
            } catch (error) {
                clearInterval(timerInterval);
                if (statusEl) statusEl.textContent = 'Connection error';
                console.error('Chat fetch error:', error);
            }
            
            sendBtn.disabled = false;
            sendBtn.textContent = 'Send';
        }
        
        // Clear chat when battle ends
        function clearBattleChat() {
            chatState.messages = [];
            chatState.visible = false;
            chatState.targetNpc = null;
            const chatWindow = document.getElementById('battleChatWindow');
            if (chatWindow) chatWindow.style.display = 'none';
            renderChatMessages();
        }
        
        // ============================================
        // NEGOTIATION SYSTEM - Mob Betrayal & Boss Retreat
        // ============================================
        
        // Initialize negotiation state for an enemy
        function initNegotiationState(enemy) {
            if (!enemy.negotiationState) {
                enemy.negotiationState = {
                    // Mob betrayal tracking
                    goldOffered: 0,           // Total gold offered so far
                    betrayalThreshold: enemy.isBoss ? 999999 : (50 + Math.floor(Math.random() * 150)),  // 50-200 gold for mobs
                    lowOfferCount: 0,         // Number of insultingly low offers
                    rageStacks: 0,            // Rage buildup (each stack = +10% HP)
                    
                    // Boss morale tracking
                    morale: 100,              // Boss morale (0-100)
                    insultCount: 0,           // Times insulted/threatened
                    failedAttacks: 0,         // Consecutive missed attacks
                    
                    // State flags
                    betrayed: false,          // Mob switched sides
                    retreated: false,         // Boss fled
                    enraged: false            // Currently enraged (double attack)
                };
            }
            return enemy.negotiationState;
        }
        
        // Process negotiation after each chat exchange
        function processNegotiation(npc, playerMessage, npcResponse) {
            if (!npc || npc.hp <= 0) return;
            
            const state = initNegotiationState(npc);
            const msgLower = playerMessage.toLowerCase();
            const responseLower = npcResponse.toLowerCase();
            
            // === MOB BETRAYAL LOGIC ===
            if (!npc.isBoss && npc.hostile) {
                // Check for gold offers in player message
                const goldMatch = msgLower.match(/(\d+)\s*(gold|coins?|gp|money)/i);
                if (goldMatch) {
                    const offeredGold = parseInt(goldMatch[1]);
                    
                    // Check if player actually HAS this gold
                    const sharedSave = loadSharedSave();
                    const currentGold = sharedSave?.dungeonState?.gold || 0;
                    
                    if (offeredGold > currentGold) {
                        // Player tried to offer gold they don't have - instant rage!
                        addChatMessage('System', 'system', null, `âŒ You only have ${currentGold} gold! ${npc.name} sees through your empty promise!`, false);
                        triggerRage(npc, 'Your LIES have enraged');
                        return;
                    }
                    
                    state.goldOffered += offeredGold;
                    state.lastOfferAmount = offeredGold;  // Track last offer for deduction on success
                    
                    // Check if offer is insulting (less than 10% of threshold)
                    if (offeredGold < state.betrayalThreshold * 0.1) {
                        state.lowOfferCount++;
                        
                        // After 3 low offers, mob gets enraged
                        if (state.lowOfferCount >= 3 && !state.enraged) {
                            triggerRage(npc, 'Your pathetic offers have enraged');
                        }
                    }
                    
                    // Check for betrayal - roll with modifier based on offer
                    const offerRatio = state.goldOffered / state.betrayalThreshold;
                    if (offerRatio >= 0.5) {  // At least 50% of threshold to have a chance
                        const betrayalRoll = rollD20();
                        const dc = Math.max(5, 20 - Math.floor(offerRatio * 15));  // DC 5-20 based on offer
                        
                        console.log(`[Negotiation] ${npc.name} betrayal check: d20(${betrayalRoll}) vs DC ${dc}, offer ratio: ${(offerRatio * 100).toFixed(0)}%`);
                        
                        if (betrayalRoll >= dc || state.goldOffered >= state.betrayalThreshold) {
                            triggerBetrayal(npc, state.goldOffered);
                            return;
                        } else if (betrayalRoll <= 3) {
                            // Critical fail - mob gets angry
                            triggerRage(npc, 'Your bribe attempt has angered');
                        }
                    }
                    
                    // Show offer progress
                    const progress = Math.min(100, (state.goldOffered / state.betrayalThreshold) * 100);
                    showDiceRoll(`ðŸ’° ${npc.name} considers your offer... (${progress.toFixed(0)}% convinced)`);
                }
                
                // Check for threats/insults making mob angry
                if (msgLower.match(/threat|kill|destroy|die|weak|pathetic|coward/i)) {
                    state.lowOfferCount++;
                    if (state.lowOfferCount >= 2 && !state.enraged) {
                        triggerRage(npc, 'Your threats have enraged');
                    }
                }
            }
            
            // === BOSS RETREAT/RAGE LOGIC ===
            if (npc.isBoss) {
                // Check for insults/threats
                if (msgLower.match(/weak|pathetic|coward|afraid|scared|flee|run away|give up/i)) {
                    state.insultCount++;
                    state.morale -= 10;
                    console.log(`[Negotiation] ${npc.name} morale: ${state.morale} (insulted)`);
                }
                
                // Check for intimidation in NPC response (they're worried)
                if (responseLower.match(/perhaps|maybe.*wrong|reconsider|mercy|spare|retreat|flee/i)) {
                    state.morale -= 5;
                }
                
                // Check morale + HP for retreat/rage
                const hpPercent = (npc.hp / npc.maxHp) * 100;
                if (hpPercent < 30 && state.morale < 50) {
                    // Boss is low HP and demoralized - roll for retreat or rage
                    const retreatRoll = rollD20();
                    console.log(`[Negotiation] ${npc.name} retreat check: d20(${retreatRoll}), HP: ${hpPercent.toFixed(0)}%, Morale: ${state.morale}`);
                    
                    if (retreatRoll <= 8) {
                        // Boss retreats!
                        triggerBossRetreat(npc);
                    } else if (retreatRoll >= 17 && !state.enraged) {
                        // Boss gets enraged instead!
                        triggerRage(npc, 'Cornered and desperate,');
                        state.enraged = true;
                    }
                }
            }
        }
        
        // Trigger mob betrayal - switch sides!
        function triggerBetrayal(mob, goldPaid) {
            const state = mob.negotiationState;
            state.betrayed = true;
            mob.hostile = false;
            
            // Deduct gold from player
            if (goldPaid > 0) {
                const sharedSave = JSON.parse(localStorage.getItem('top_shared_save') || '{}');
                if (!sharedSave.dungeonState) sharedSave.dungeonState = {};
                sharedSave.dungeonState.gold = Math.max(0, (sharedSave.dungeonState.gold || 0) - goldPaid);
                localStorage.setItem('top_shared_save', JSON.stringify(sharedSave));
                
                addChatMessage('System', 'system', null, `ðŸ’¸ Paid ${goldPaid} gold to ${mob.name}!`, false);
                updateGoldDisplay();
            }
            
            // Visual/audio feedback
            showDiceRoll(`âš”ï¸âž¡ï¸ðŸ¤ ${mob.name} BETRAYS THE BOSS!`);
            showBattleNotification(`${mob.name} switches sides!`);
            
            // Add chat message
            addChatMessage(mob.name, 'friendly', mob.spritePath, 
                `*${mob.name} turns against their former master!* "You've convinced me. Let's take down that tyrant together!"`, 
                true, mob.voiceType);
            
            // Change color to friendly
            mob.color = '#00FF00';
            
            renderBattle();
            updateBattleEnemyCards();
            
            console.log(`[Negotiation] ${mob.name} has betrayed the boss!`);
        }
        
        // Trigger boss retreat - they flee!
        function triggerBossRetreat(boss) {
            const state = boss.negotiationState;
            state.retreated = true;
            
            // Visual/audio feedback
            showDiceRoll(`ðŸƒ ${boss.name} RETREATS!`);
            showBattleNotification(`${boss.name} flees in terror!`);
            
            // Add chat message
            addChatMessage(boss.name, 'hostile', boss.spritePath,
                `*${boss.name} staggers back, fear in their eyes* "This isn't over! I'll return stronger!" *vanishes into the shadows*`,
                true, boss.voiceType);
            
            // Remove boss from battle (set HP to 0 but mark as retreated)
            boss.hp = 0;
            boss.retreated = true;
            
            // Award partial XP for retreat
            const partialXP = Math.floor((boss.stats?.experience || 100) * 0.5);
            battleState.heroes.forEach(h => {
                if (h.hp > 0) h.xp = (h.xp || 0) + Math.floor(partialXP / battleState.heroes.filter(x => x.hp > 0).length);
            });
            showDiceRoll(`ðŸ“œ Gained ${partialXP} XP from boss retreat!`);
            
            renderBattle();
            updateBattleEnemyCards();
            checkBattleEnd();
            
            console.log(`[Negotiation] ${boss.name} has retreated!`);
        }
        
        // Trigger rage - enemy gets stronger!
        function triggerRage(enemy, reason) {
            const state = enemy.negotiationState;
            state.rageStacks++;
            state.enraged = true;
            
            // Boost HP by 10% per rage stack
            const hpBoost = Math.floor(enemy.maxHp * 0.1);
            enemy.hp = Math.min(enemy.maxHp, enemy.hp + hpBoost);
            enemy.maxHp += hpBoost;
            
            // Boost damage slightly
            enemy.attackDamage = Math.floor(enemy.attackDamage * 1.1);
            
            // Visual/audio feedback
            const emoji = enemy.isBoss ? 'ðŸ‘¿' : 'ðŸ˜¤';
            showDiceRoll(`${emoji} ${reason} ${enemy.name}! (+${hpBoost} HP, +10% damage)`);
            showBattleNotification(`${enemy.name} enters a RAGE!`);
            
            // Add chat message
            addChatMessage(enemy.name, 'hostile', enemy.spritePath,
                `*${enemy.name}'s eyes glow with fury* "ENOUGH! You will PAY for this!"`,
                true, enemy.voiceType);
            
            // Change color to indicate rage
            enemy.color = '#FF0000';
            
            renderBattle();
            updateBattleEnemyCards();
            
            console.log(`[Negotiation] ${enemy.name} has entered a rage! (stack ${state.rageStacks})`);
        }
        
        // Update boss morale when they take damage or miss attacks
        function updateBossMorale(boss, event) {
            if (!boss || !boss.isBoss) return;
            
            const state = initNegotiationState(boss);
            
            switch (event) {
                case 'took_damage':
                    state.morale -= 5;
                    break;
                case 'missed_attack':
                    state.failedAttacks++;
                    state.morale -= 3 * state.failedAttacks;  // Gets worse with consecutive misses
                    break;
                case 'hit_attack':
                    state.failedAttacks = 0;  // Reset on successful hit
                    state.morale = Math.min(100, state.morale + 5);  // Slight morale boost
                    break;
                case 'ally_died':
                    state.morale -= 15;
                    break;
            }
            
            state.morale = Math.max(0, Math.min(100, state.morale));
            
            // Check for retreat/rage at critical morale
            const hpPercent = (boss.hp / boss.maxHp) * 100;
            if (state.morale < 30 && hpPercent < 40 && !state.retreated && !state.enraged) {
                const crisisRoll = rollD20();
                console.log(`[Negotiation] ${boss.name} crisis check: d20(${crisisRoll}), HP: ${hpPercent.toFixed(0)}%, Morale: ${state.morale}`);
                
                if (crisisRoll <= 10) {
                    triggerBossRetreat(boss);
                } else if (crisisRoll >= 16) {
                    triggerRage(boss, 'Pushed to the brink,');
                }
            }
        }
        
        // Check for enraged double attack
        function shouldDoDoubleAttack(enemy) {
            if (!enemy.negotiationState?.enraged) return false;
            
            // 30% chance for double attack when enraged
            const doubleRoll = rollD20();
            if (doubleRoll >= 15) {
                showDiceRoll(`âš¡ ${enemy.name}'s rage fuels a DOUBLE ATTACK!`);
                return true;
            }
            return false;
        }

        // Generate unique encounter data via Dungeon Master LLM
        async function generateEncounter(type, baseData, roomLevel, retryCount = 0) {
            const maxRetries = 2;
            try {
                const response = await fetch('/api/generate-encounter', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        type: type,
                        baseData: baseData,
                        roomLevel: roomLevel,
                        useFreeModel: !settings.llmUsePaid
                    })
                });
                
                const result = await response.json();
                if (result.success && result.data) {
                    console.log(`[DM] Generated ${type}:`, result.data);
                    return result.data;
                } else {
                    console.warn(`[DM] Failed to generate ${type}:`, result.error || result.raw);
                    // Retry on JSON parse failure
                    if (retryCount < maxRetries && result.error && result.error.includes('JSON')) {
                        console.log(`[DM] Retrying ${type} generation (attempt ${retryCount + 2}/${maxRetries + 1})...`);
                        return generateEncounter(type, baseData, roomLevel, retryCount + 1);
                    }
                    return null;
                }
            } catch (error) {
                console.error('[DM] Encounter generation error:', error);
                return null;
            }
        }
        
        // Apply generated data to boss/mob
        function applyGeneratedData(enemy, generated) {
            if (!generated) return;
            
            // Generate unique entity ID for TTS voice consistency
            // Server caches voice assignment per entityId
            enemy.entityId = 'entity_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            
            // Apply name
            if (generated.name) {
                enemy.name = generated.name;
            }
            
            // Apply backstory
            if (generated.backstory) {
                enemy.backstory = generated.backstory;
            }
            
            // Apply personality
            if (generated.personality) {
                enemy.personality = generated.personality;
            }
            
            // Apply voice type (LLM-chosen based on gender/nature)
            if (generated.voiceType) {
                enemy.voiceType = generated.voiceType;
            }
            
            // Apply gender
            if (generated.gender) {
                enemy.gender = generated.gender;
            }
            
            // Apply stat modifiers
            if (generated.statModifiers) {
                if (generated.statModifiers.hpMod) {
                    enemy.hp = Math.max(1, enemy.hp + generated.statModifiers.hpMod);
                    enemy.maxHp = Math.max(1, enemy.maxHp + generated.statModifiers.hpMod);
                }
                if (generated.statModifiers.damageMod) {
                    enemy.attackDamage = Math.max(1, enemy.attackDamage + generated.statModifiers.damageMod);
                }
                if (generated.statModifiers.acMod) {
                    enemy.ac = Math.max(1, enemy.ac + generated.statModifiers.acMod);
                }
            }
            
            // Apply negotiation options
            if (generated.negotiation) {
                enemy.negotiation = generated.negotiation;
            }
            
            // Apply gold drop amount (LLM-determined based on backstory)
            if (generated.goldDrop !== undefined) {
                enemy.goldDrop = generated.goldDrop;
            } else {
                // Default gold based on enemy type and dungeon level
                const dungeonLevel = battleState.currentLevel || 1;
                const levelMultiplier = 1 + (dungeonLevel - 1) * 0.5; // +50% per level
                if (enemy.isBoss) {
                    // Boss: base 50-150, scales with level
                    enemy.goldDrop = Math.floor((50 + Math.floor(Math.random() * 100)) * levelMultiplier);
                } else {
                    // Regular enemy: base 5-25, scales with level
                    enemy.goldDrop = Math.floor((5 + Math.floor(Math.random() * 20)) * levelMultiplier);
                }
            }
            
            // Apply opening line
            if (generated.openingLine) {
                enemy.openingLine = generated.openingLine;
            }
        }
        
        // Trigger NPC free will chat (autonomous chat)
        function triggerFreeWillChat(npc, trigger) {
            if (!settings.llmFreeWill) return;
            if (!npc || !npc.backstory) return;
            
            // Don't spam - check cooldown
            if (npc.lastFreeWillChat && Date.now() - npc.lastFreeWillChat < 10000) return;
            npc.lastFreeWillChat = Date.now();
            
            // Build a context-specific prompt
            let contextPrompt = '';
            switch (trigger) {
                case 'battle_start':
                    if (npc.openingLine) {
                        addChatMessage(npc.name, npc.hostile ? 'hostile' : 'friendly', 
                            npc.spritePath || 'people/zooko_a_head_compressed.png', npc.openingLine, true, npc.voiceType, npc.personality, npc.entityId);
                        return;
                    }
                    contextPrompt = 'The battle just started. Say something to intimidate or greet the heroes.';
                    break;
                case 'took_damage':
                    contextPrompt = 'You just took damage! React with pain, anger, or determination.';
                    break;
                case 'dealt_damage':
                    contextPrompt = 'You just hit a hero! Gloat, taunt, or comment on your attack.';
                    break;
                case 'low_health':
                    contextPrompt = 'You are badly wounded. Express fear, defiance, or consider surrendering.';
                    break;
                case 'ally_died':
                    contextPrompt = 'One of your allies just died. React with grief, rage, or indifference.';
                    break;
                default:
                    return; // Unknown trigger, skip
            }
            
            // Make async LLM call for free will response
            (async () => {
                try {
                    const response = await fetch('/api/chat', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            npcName: npc.name,
                            backstory: npc.backstory,
                            npcType: npc.isBoss ? 'boss' : 'mob',
                            conversation: chatState.messages.slice(0, 5).reverse(),
                            message: contextPrompt,
                            playerName: 'System',
                            modelId: settings.llmUsePaid ? 3 : 2,  // Use Groq models for speed
                            rpMode: settings.rpMode !== false
                        })
                    });
                    
                    const result = await response.json();
                    if (result.success && result.response) {
                        const npcType = npc.hostile ? 'hostile' : (npc.questable ? 'questable' : 'friendly');
                        addChatMessage(npc.name, npcType, npc.spritePath || 'people/zooko_a_head_compressed.png', 
                            result.response, true, npc.voiceType, npc.personality, npc.entityId);
                    } else if (result.error) {
                        checkForRateLimitError(result.error);
                    }
                } catch (error) {
                    console.error('[Free Will] Chat error:', error);
                    checkForRateLimitError(error.message || String(error));
                }
            })();
        }
        
        // Trigger free will response to player broadcast message (ALL mode)
        // Each NPC decides if they want to respond based on personality/context
        function triggerFreeWillChatResponse(npc, playerName, playerMessage) {
            if (!npc || !npc.backstory) return;
            
            // Don't spam - check cooldown (shorter than regular free will)
            if (npc.lastFreeWillChat && Date.now() - npc.lastFreeWillChat < 3000) return;
            
            // 1d6 dice roll - only respond on a 1 (~17% chance)
            const diceRoll = Math.floor(Math.random() * 6) + 1;
            if (diceRoll !== 1) return;
            
            npc.lastFreeWillChat = Date.now();
            console.log(`[Free Will] ${npc.name} rolled a 1! Considering response...`);
            
            // Make async LLM call - NPC decides if they want to respond
            (async () => {
                try {
                    const response = await fetch('/api/chat', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            npcName: npc.name,
                            backstory: npc.backstory,
                            npcType: npc.isBoss ? 'boss' : (npc.isCaptive ? 'captive' : 'mob'),
                            conversation: chatState.messages.slice(0, 5).reverse(),
                            message: playerMessage,
                            playerName: playerName,
                            modelId: settings.llmUsePaid ? 3 : 2,  // Use Groq models for speed
                            rpMode: settings.rpMode !== false
                        })
                    });
                    
                    const result = await response.json();
                    if (result.success && result.response) {
                        // Skip if response indicates no response (silence, ignoring, etc)
                        const responseLower = result.response.toLowerCase();
                        if (responseLower.includes('*silence*') || 
                            responseLower.includes('*ignores*') ||
                            responseLower.includes('*says nothing*') ||
                            responseLower === '...' ||
                            result.response.trim().length < 3) {
                            return; // NPC chose not to respond
                        }
                        
                        const npcType = npc.hostile ? 'hostile' : (npc.questable ? 'questable' : 'friendly');
                        addChatMessage(npc.name, npcType, npc.spritePath || 'people/zooko_a_head_compressed.png', 
                            result.response, true, npc.voiceType, npc.personality, npc.entityId);
                    } else if (result.error) {
                        checkForRateLimitError(result.error);
                    }
                } catch (error) {
                    console.error('[Free Will Response] Chat error:', error);
                    checkForRateLimitError(error.message || String(error));
                }
            })();
        }
        
        // Start a battle encounter
        async function startBattle() {
            // Multiplayer clients cannot start battles - only host
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                showNotification('Only host can start battles', 'error');
                return;
            }
            
            // Check if all rooms are explored
            if (currentLevelLayout) {
                const allRoomsExplored = currentLevelLayout.rooms
                    .filter(r => r.type !== ROOM_TYPES.SECRET)
                    .every(r => r.explored);
                
                if (allRoomsExplored && currentLevelLayout.bossRoom?.explored) {
                    showNotification('Level Complete! All rooms explored. Advance to the next level.', 'success');
                    return;
                }
                
                if (allRoomsExplored && !currentLevelLayout.bossRoom?.accessible) {
                    // All normal rooms explored but boss not unlocked - this shouldn't happen
                    currentLevelLayout.bossRoom.accessible = true;
                    console.log('[LevelLayout] Force-unlocking boss room');
                }
            }
            
            // Check room type - route to non-combat room if not a combat type
            const roomType = preGeneratedEncounter.roomType || 'combat';
            const nonCombatTypes = ['store', 'npc', 'secret', 'exploration'];
            
            if (nonCombatTypes.includes(roomType)) {
                // This is a non-combat room - use the non-combat room system
                enterNonCombatRoom(roomType);
                return;
            }
            
            // Combat room types: 'combat', 'boss', 'mini_boss'
            // Stop dungeon menu story background animation
            stopDungeonMenuAnimation();
            
            // Switch to battle screen
            currentScreen = 'battle';
            document.getElementById('dungeonMenuScreen').style.display = 'none';
            document.getElementById('battleScreen').style.display = 'block';
            
            // Show boss battle announcement if this is a boss room
            if (roomType === 'boss' || roomType === 'mini_boss') {
                const currentLevel = parseInt(document.getElementById('dungeonLevel')?.textContent) || 1;
                const bossText = roomType === 'boss' ? 'BOSS BATTLE' : 'MINI-BOSS BATTLE';
                showBossBattleAnnouncement(bossText, currentLevel);
            }
            
            // If multiplayer host, notify clients
            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                sendWebSocketMessage({ type: 'game_start', screen: 'battle' });
            }
            
            // Move music controls and ticker to bottom left during battle
            document.getElementById('musicControls').classList.add('battleActive');
            document.getElementById('musicTicker').classList.add('battleActive');
            
            // Update gold display for battle screen
            updateGoldDisplay();
            
            // Start dice roll ticker
            startDiceRollTicker();
            
            // Initialize canvas
            battleState.canvas = document.getElementById('battleCanvas');
            battleState.ctx = battleState.canvas.getContext('2d');
            
            // Set canvas size
            battleState.canvas.width = window.innerWidth;
            battleState.canvas.height = window.innerHeight - 180;
            
            // Multiplayer client: Wait for battle_init from host
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                showDiceRoll('Waiting for host to start battle...');
                return; // Don't generate battle - wait for host's battle_init message
            }
            
            // Check if we have pre-generated encounter ready
            const usePreGenerated = preGeneratedEncounter.ready;
            
            // Load enemy data (only if not pre-generated)
            let bossesData = [];
            let mobsData = [];
            if (!usePreGenerated) {
                try {
                    const difficultyFile = getBossDifficultyFile();
                    const bossResponse = await fetch(difficultyFile);
                    bossesData = await bossResponse.json();
                    const mobResponse = await fetch('tunnelsofprivacy/mobs/mobs_data.json');
                    const mobObj = await mobResponse.json();
                    mobsData = mobObj.mobs || [];
                } catch(e) {
                    console.error('Failed to load enemy data:', e);
                }
            }
            
            // Load shared save to get hero stats
            const sharedSave = loadSharedSave();
            
            // Setup heroes with sprites
            battleState.heroes = [
                { 
                    name: 'Zooko', 
                    hp: sharedSave?.heroes?.zooko?.hp ?? 30, 
                    maxHp: sharedSave?.heroes?.zooko?.maxHp ?? 30,
                    xp: sharedSave?.heroes?.zooko?.xp ?? 0,
                    level: sharedSave?.heroes?.zooko?.level ?? 1,
                    healsRemaining: 2,
                    stats: sharedSave?.heroes?.zooko || {},
                    color: '#F2C94C',
                    x: 0, y: 0, platform: null, facing: 'center',
                    sprite: new Image(),
                    spritePath: 'tunnelsofprivacy/heros/zooko.png',
                    backpackSprite: new Image(),
                    backpackPath: 'tunnelsofprivacy/gear/zooko_backpack.png',
                    potions: [{ anim: null, visible: true }, { anim: null, visible: true }]
                },
                { 
                    name: 'Nate', 
                    hp: sharedSave?.heroes?.nate?.hp ?? 28, 
                    maxHp: sharedSave?.heroes?.nate?.maxHp ?? 30,
                    xp: sharedSave?.heroes?.nate?.xp ?? 0,
                    level: sharedSave?.heroes?.nate?.level ?? 1,
                    healsRemaining: 2,
                    stats: sharedSave?.heroes?.nate || {},
                    color: '#E74C3C',
                    x: 0, y: 0, platform: null, facing: 'center',
                    sprite: new Image(),
                    spritePath: 'tunnelsofprivacy/heros/nate.png',
                    backpackSprite: new Image(),
                    backpackPath: 'tunnelsofprivacy/gear/nate_backpack.png',
                    potions: [{ anim: null, visible: true }, { anim: null, visible: true }]
                },
                { 
                    name: 'Zancas', 
                    hp: sharedSave?.heroes?.zancas?.hp ?? 24, 
                    maxHp: sharedSave?.heroes?.zancas?.maxHp ?? 26,
                    xp: sharedSave?.heroes?.zancas?.xp ?? 0,
                    level: sharedSave?.heroes?.zancas?.level ?? 1,
                    healsRemaining: 2,
                    stats: sharedSave?.heroes?.zancas || {},
                    color: '#27AE60',
                    x: 0, y: 0, platform: null, facing: 'center',
                    sprite: new Image(),
                    spritePath: 'tunnelsofprivacy/heros/zancas.png',
                    backpackSprite: new Image(),
                    backpackPath: 'tunnelsofprivacy/gear/zancas_backpack.png',
                    potions: [{ anim: null, visible: true }, { anim: null, visible: true }]
                },
                { 
                    name: 'CyberAxe', 
                    hp: sharedSave?.heroes?.cyberaxe?.hp ?? 32, 
                    maxHp: sharedSave?.heroes?.cyberaxe?.maxHp ?? 35,
                    xp: sharedSave?.heroes?.cyberaxe?.xp ?? 0,
                    level: sharedSave?.heroes?.cyberaxe?.level ?? 1,
                    healsRemaining: 2,
                    stats: sharedSave?.heroes?.cyberaxe || {},
                    color: '#2E86DE',
                    x: 0, y: 0, platform: null, facing: 'center',
                    sprite: new Image(),
                    spritePath: 'tunnelsofprivacy/heros/cyberaxe.png',
                    backpackSprite: new Image(),
                    backpackPath: 'tunnelsofprivacy/gear/cyberaxe_backpack.png',
                    potions: [{ anim: null, visible: true }, { anim: null, visible: true }]
                }
            ];
            
            // Initialize animation controllers for heroes
            battleState.heroes.forEach(hero => {
                const heroKey = hero.name.toLowerCase();
                let idlePath = HERO_ANIM_PATHS[heroKey]?.idle;
                // Handle array of idle variants - pick random one
                if (Array.isArray(idlePath)) {
                    idlePath = idlePath[Math.floor(Math.random() * idlePath.length)];
                }
                if (idlePath) {
                    initAnimation(hero, idlePath, 'pingpong');
                }
            });
            
            // Load hero sprites with cache busting (fallback for when animation not loaded)
            battleState.heroes.forEach(hero => {
                hero.sprite.onload = () => {
                    renderBattle(); // Re-render when each sprite loads
                };
                // Add timestamp to prevent caching
                hero.sprite.src = hero.spritePath + '?v=' + Date.now();
                
                // Load backpack gear sprites
                if (hero.backpackPath) {
                    hero.backpackSprite.onload = () => {
                        renderBattle(); // Re-render when backpack loads
                    };
                    hero.backpackSprite.src = hero.backpackPath + '?v=' + Date.now();
                }
                
                // Initialize health potion static sprites
                if (hero.potions) {
                    const potionPath = 'tunnelsofprivacy/items/healing_potions_a_cropped.png';
                    // Load shared potion sprite once per hero
                    hero.potionSprite = new Image();
                    hero.potionSprite.onload = () => renderBattle();
                    hero.potionSprite.src = potionPath + '?v=' + Date.now();
                    
                    hero.potions.forEach((potion, idx) => {
                        potion.visible = idx < hero.healsRemaining;  // Show based on heals remaining
                    });
                }
            });
            
            // Setup enemies from loaded data (level 2 for testing)
            battleState.enemies = [];
            battleState.captiveNpc = null;  // Captive NPC to rescue
            const roomLevel = usePreGenerated ? preGeneratedEncounter.roomLevel : 2;
            
            // Show loading indicator for LLM generation (only if not pre-generated)
            if (!usePreGenerated) {
                showDiceRoll('Dungeon Master is preparing the encounter...');
            }
            
            if (usePreGenerated && preGeneratedEncounter.boss) {
                // Use pre-generated boss
                const boss = preGeneratedEncounter.boss.baseData;
                // Use standardized sprite path based on boss level
                const bossLevel = boss.mainLevel || preGeneratedEncounter.roomLevel;
                const bossSpritePath = `tunnelsofprivacy/bosses/lvl${bossLevel}/boss_lvl${bossLevel}.png`;
                const bossEnemy = {
                    name: boss.name,
                    species: boss.name,
                    hp: boss.stats.hp || 50,
                    maxHp: boss.stats.maxHp || 50,
                    ac: boss.stats.ac,
                    attackDamage: boss.stats.attackDamage,
                    speed: boss.stats.speed,
                    dex: boss.stats.initiative || 0,
                    hostile: boss.behavior?.hostile !== false,
                    backstory: boss.backstory || null,
                    isBoss: true,
                    bossLevel: bossLevel, // Store for animation lookup
                    color: '#8B45FF',
                    x: 0, y: 0, platform: null, facing: 'center',
                    sprite: new Image(),
                    spritePath: bossSpritePath,
                    isMob: false
                };
                applyGeneratedData(bossEnemy, preGeneratedEncounter.boss.generated);
                if (settings.diagMode) {
                    bossEnemy.hp = 5;
                    bossEnemy.maxHp = 5;
                }
                battleState.enemies.push(bossEnemy);
                console.log('[Battle] Using pre-generated boss:', bossEnemy.name);
            } else {
                // Generate boss on-the-fly (fallback)
                let boss = bossesData.find(b => b.mainLevel === roomLevel);
                
                // If no exact match, pick a random boss
                if (!boss && bossesData.length > 0) {
                    console.warn(`[Battle] No boss found for level ${roomLevel}, picking random boss`);
                    boss = bossesData[Math.floor(Math.random() * bossesData.length)];
                }
                
                if (boss) {
                    // Use standardized sprite path based on boss level
                    const bossLevel = boss.mainLevel || roomLevel;
                    const bossSpritePath = `tunnelsofprivacy/bosses/lvl${bossLevel}/boss_lvl${bossLevel}.png`;
                    const bossEnemy = {
                        name: boss.name,
                        species: boss.name,
                        hp: boss.stats.hp || 50,
                        maxHp: boss.stats.maxHp || 50,
                        ac: boss.stats.ac,
                        attackDamage: boss.stats.attackDamage,
                        speed: boss.stats.speed,
                        dex: boss.stats.initiative || 0,
                        hostile: boss.behavior?.hostile !== false,
                        backstory: boss.backstory || null,
                        isBoss: true,
                        bossLevel: bossLevel, // Store for animation lookup
                        color: '#8B45FF',
                        x: 0, y: 0, platform: null, facing: 'center',
                        sprite: new Image(),
                        spritePath: bossSpritePath,
                        isMob: false
                    };
                    const generatedBoss = await generateEncounter('boss', boss, roomLevel);
                    applyGeneratedData(bossEnemy, generatedBoss);
                    if (settings.diagMode) {
                        bossEnemy.hp = 5;
                        bossEnemy.maxHp = 5;
                    }
                    battleState.enemies.push(bossEnemy);
                }
            }
            
            if (usePreGenerated && preGeneratedEncounter.mobs.length > 0) {
                // Use pre-generated mobs
                for (const mobData of preGeneratedEncounter.mobs) {
                    const mob = mobData.baseData;
                    const mobEnemy = {
                        name: mob.name,
                        species: mob.name,
                        hp: mob.stats.hp || 15,
                        maxHp: mob.stats.maxHp || 15,
                        ac: mob.stats.ac,
                        attackDamage: mob.stats.attackDamage,
                        speed: mob.stats.speed,
                        dex: 0,
                        hostile: mob.behavior?.hostile !== false,
                        backstory: mob.backstory || null,
                        isBoss: false,
                        color: '#5C3317',
                        x: 0, y: 0, platform: null, facing: 'center',
                        sprite: new Image(),
                        spritePath: mob.spritePath,
                        isMob: true,
                        mobId: mob.id || '' // Store mob ID for size lookup
                    };
                    applyGeneratedData(mobEnemy, mobData.generated);
                    applyEarlyLevelScaling(mobEnemy, roomLevel);
                    if (settings.diagMode) {
                        mobEnemy.hp = 5;
                        mobEnemy.maxHp = 5;
                    }
                    battleState.enemies.push(mobEnemy);
                    console.log('[Battle] Using pre-generated mob:', mobEnemy.name);
                }
            } else if (!usePreGenerated) {
                // Generate mobs on-the-fly (fallback)
                const hostileMobs = mobsData.filter(m => m.behavior?.hostile && (m.minLevel === undefined || m.minLevel <= roomLevel));
                const mobCount = getMobCountForLevel(roomLevel);
                console.log(`[Battle] Spawning ${mobCount} mobs for level ${roomLevel}`);
                for (let i = 0; i < mobCount && i < hostileMobs.length; i++) {
                    const mob = hostileMobs[Math.floor(Math.random() * hostileMobs.length)];
                    const mobEnemy = {
                        name: mob.name,
                        species: mob.name,
                        hp: mob.stats.hp || 15,
                        maxHp: mob.stats.maxHp || 15,
                        ac: mob.stats.ac,
                        attackDamage: mob.stats.attackDamage,
                        speed: mob.stats.speed,
                        dex: 0,
                        hostile: mob.behavior?.hostile !== false,
                        backstory: mob.backstory || null,
                        isBoss: false,
                        color: '#5C3317',
                        x: 0, y: 0, platform: null, facing: 'center',
                        sprite: new Image(),
                        spritePath: mob.spritePath,
                        isMob: true,
                        mobId: mob.id || '' // Store mob ID for size lookup
                    };
                    const generatedMob = await generateEncounter('mob', mob, roomLevel);
                    applyGeneratedData(mobEnemy, generatedMob);
                    applyEarlyLevelScaling(mobEnemy, roomLevel);
                    if (settings.diagMode) {
                        mobEnemy.hp = 5;
                        mobEnemy.maxHp = 5;
                    }
                    battleState.enemies.push(mobEnemy);
                }
            }
            
            // Setup captive NPC
            if (usePreGenerated && preGeneratedEncounter.captive) {
                // Use pre-generated captive
                const captiveData = preGeneratedEncounter.captive.generated;
                const captiveSpritePath = `tunnelsofprivacy/npcs/captives/prisoners (${preGeneratedEncounter.captive.spriteNum}).png`;
                
                battleState.captiveNpc = {
                    name: captiveData?.name || 'Mysterious Prisoner',
                    species: captiveData?.species || 'human',
                    gender: captiveData?.gender || 'unknown',
                    voiceType: captiveData?.voiceType || null,
                    entityId: 'captive_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                    backstory: captiveData?.backstory || 'A prisoner needing rescue.',
                    personality: captiveData?.personality || 'grateful',
                    rescueReward: captiveData?.rescueReward || { gold: 20 },
                    goldReward: captiveData?.rescueReward?.gold || captiveData?.goldReward || 20,
                    dialogueOnRescue: captiveData?.dialogueOnRescue || 'Thank you for saving me!',
                    rescued: false,
                    x: 0,
                    y: 0,
                    sprite: new Image(),
                    spritePath: captiveSpritePath,
                    color: '#F2C94C',
                    isCaptive: true,
                    isMob: false,
                    canChat: true,
                    hostile: false,
                    hp: 1,
                    maxHp: 1
                };
                
                battleState.captiveNpc.sprite.onerror = () => {
                    console.log('[DM] Captive sprite not found, using fallback circle:', captiveSpritePath);
                };
                battleState.captiveNpc.sprite.onload = () => {
                    renderBattle();
                };
                battleState.captiveNpc.sprite.src = battleState.captiveNpc.spritePath + '?v=' + Date.now();
                console.log('[Battle] Using pre-generated captive:', battleState.captiveNpc.name);
            } else if (!usePreGenerated && Math.random() > 0.5) {
                // Generate captive on-the-fly (fallback)
                const captiveData = await generateEncounter('captive', {}, roomLevel);
                const captiveSpriteNum = Math.floor(Math.random() * 12) + 1;
                const captiveSpritePath = `tunnelsofprivacy/npcs/captives/prisoners (${captiveSpriteNum}).png`;
                
                battleState.captiveNpc = {
                    name: captiveData?.name || 'Mysterious Prisoner',
                    species: captiveData?.species || 'human',
                    gender: captiveData?.gender || 'unknown',
                    voiceType: captiveData?.voiceType || null,
                    entityId: 'captive_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                    backstory: captiveData?.backstory || 'A prisoner needing rescue.',
                    personality: captiveData?.personality || 'grateful',
                    rescueReward: captiveData?.rescueReward || { gold: 20 },
                    goldReward: captiveData?.rescueReward?.gold || captiveData?.goldReward || 20,
                    dialogueOnRescue: captiveData?.dialogueOnRescue || 'Thank you for saving me!',
                    rescued: false,
                    x: 0,
                    y: 0,
                    sprite: new Image(),
                    spritePath: captiveSpritePath,
                    color: '#F2C94C',
                    isCaptive: true,
                    isMob: false,
                    canChat: true,
                    hostile: false,
                    hp: 1,
                    maxHp: 1
                };
                
                battleState.captiveNpc.sprite.onerror = () => {
                    console.log('[DM] Captive sprite not found, using fallback circle:', captiveSpritePath);
                };
                battleState.captiveNpc.sprite.onload = () => {
                    renderBattle();
                };
                battleState.captiveNpc.sprite.src = battleState.captiveNpc.spritePath + '?v=' + Date.now();
                console.log('[DM] Captive NPC generated:', battleState.captiveNpc.name, 'sprite:', captiveSpritePath);
            }
            
            // Load enemy sprites
            battleState.enemies.forEach(enemy => {
                enemy.sprite.onload = () => {
                    renderBattle();
                };
                enemy.sprite.src = enemy.spritePath + '?v=' + Date.now();
            });
            
            // Load video background
            const selectedVideo = getRandomRoomVideo();
            battleState.backgroundVideoPath = selectedVideo;
            battleState.useVideoBackground = true;
            
            const videoEl = document.getElementById('battleBackgroundVideo');
            if (videoEl) {
                videoEl.querySelector('source').src = selectedVideo;
                videoEl.load();
                videoEl.style.display = 'block';
                
                // Wait for video to load metadata, then capture first frame for platform detection
                let platformsDetected = false; // Flag to ensure we only detect once
                
                videoEl.onloadeddata = () => {
                    // Check if video has valid dimensions
                    if (videoEl.videoWidth === 0 || videoEl.videoHeight === 0) {
                        generateFallbackLayout();
                        renderBattle();
                        return;
                    }
                    
                    // Need to seek to first frame and wait for it to render
                    // onloadeddata doesn't guarantee a frame is available to draw
                    videoEl.currentTime = 0.1; // Seek slightly into video to ensure frame exists
                };
                
                // onseeked fires after seek completes and frame is available
                videoEl.onseeked = () => {
                    // Only run platform detection once
                    if (platformsDetected) return;
                    platformsDetected = true;
                    
                    // Capture first frame to an image for platform detection
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = videoEl.videoWidth;
                    tempCanvas.height = videoEl.videoHeight;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.drawImage(videoEl, 0, 0);
                    
                    // Create image from first frame
                    battleState.backgroundImage = new Image();
                    battleState.backgroundImage.onload = () => {
                        
                        // Only host runs floor scanning
                        if (!multiplayerState.enabled || multiplayerState.role === 'host') {
                            // Run floor scanning to detect platforms
                            generateBattleLayout();
                            
                            // After layout is generated, send to clients
                            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                                sendBattleInitToClients();
                            }
                        }
                        
                        renderBattle();
                    };
                    battleState.backgroundImage.src = tempCanvas.toDataURL('image/png');
                    
                    // Start playing video
                    videoEl.play().catch(e => console.log('[Battle] Video autoplay blocked:', e));
                };
                
                videoEl.onerror = () => {
                    console.error('[Battle] Video failed to load:', selectedVideo);
                    // Fallback to static image
                    battleState.useVideoBackground = false;
                    videoEl.style.display = 'none';
                    loadFallbackBackground();
                };
            } else {
                // No video element, use fallback
                loadFallbackBackground();
            }
            
            // Reset pre-generated encounter after using it
            if (usePreGenerated) {
                resetPreGeneratedEncounter();
            }
            
            // Calculate initiative for all combatants
            const allCombatants = [...battleState.heroes, ...battleState.enemies];
            allCombatants.forEach(c => {
                const dexMod = calculateModifier(c.stats?.dex || c.dex || 10);
                c.initiative = rollD20() + dexMod;
            });
            
            // Setup turn order sorted by initiative (highest first)
            battleState.turnOrder = allCombatants.sort((a, b) => b.initiative - a.initiative);
            battleState.currentTurn = 0;
            battleState.active = true;
            battleState.won = false;
            battleState.hadBoss = battleState.enemies.some(e => e.isBoss); // Track if this is a boss battle
            battleState.targetingMode = false;
            battleState.pendingAction = null;
            battleState.allHeroes = []; // Reset for fresh battle - will be populated on retreat/death
            
            // Start hero idle particle effects
            startHeroIdleParticles();
            
            // Initialize boss animations (for bosses with sprite sheet animations)
            battleState.enemies.forEach(enemy => {
                if (enemy.isBoss && enemy.bossLevel) {
                    const bossKey = 'lvl' + enemy.bossLevel;
                    const bossAnimPaths = BOSS_ANIM_PATHS[bossKey];
                    if (bossAnimPaths && bossAnimPaths.idle) {
                        initAnimation(enemy, bossAnimPaths.idle, 'pingpong');
                        console.log(`[Battle] Initialized boss animation for level ${enemy.bossLevel}`);
                    }
                }
            });
            
            // Check for heroes that entered battle already knocked out (0 HP)
            battleState.heroes.forEach(hero => {
                if (hero.hp <= 0) {
                    const heroKey = hero.name.toLowerCase();
                    const paths = HERO_ANIM_PATHS[heroKey];
                    if (paths && paths.knockout) {
                        setAnimationState(hero, 'knockout', 'once');
                        console.log(`[Battle] ${hero.name} entered battle knocked out`);
                    }
                }
            });
            
            // Update UI
            updateBattleTurnInfo();
            updateBattleHeroCards();
            updateBattleEnemyCards();
            
            // Open chat window by default when entering battle
            chatState.visible = true;
            const chatWindow = document.getElementById('battleChatWindow');
            if (chatWindow) chatWindow.style.display = 'flex';
            updateChatTargets();  // Refresh entity buttons with enemy names
            
            // Render initial state (will re-render when bg loads)
            renderBattle();
            
            // Trigger free will chat for boss at battle start
            const mainBoss = battleState.enemies.find(e => e.isBoss);
            if (mainBoss) {
                setTimeout(() => triggerFreeWillChat(mainBoss, 'battle_start'), 1000);
            }
            
            // Show captive NPC notification if present
            if (battleState.captiveNpc) {
                setTimeout(() => {
                    showBattleNotification(`A prisoner is here: ${battleState.captiveNpc.name}!`);
                }, 2000);
            }
            
            // Start battle animation loop for continuous updates (targeting highlights, etc.)
            function battleAnimationLoop() {
                if (battleState.active) {
                    renderBattle();
                    requestAnimationFrame(battleAnimationLoop);
                }
            }
            battleAnimationLoop();
            
            // If first turn is AI, process it automatically
            const firstCombatant = battleState.turnOrder[0];
            if (!battleState.heroes.includes(firstCombatant)) {
                setTimeout(() => processAITurn(firstCombatant), 1500);
            }
        }
        
        // Fallback to static background image if video fails
        function loadFallbackBackground() {
            const backgroundOptions = [
                'backgrounds_lvl1 (8).png',
                'backgrounds_lvl1 (10).png',
                'backgrounds_lvl1 (12).png',
                'backgrounds_lvl1 (14).png',
                'backgrounds_lvl1 (15).png',
                'backgrounds_lvl1 (16).png'
            ];
            const selectedBg = backgroundOptions[Math.floor(Math.random() * backgroundOptions.length)];
            battleState.backgroundPath = `tunnelsofprivacy/backgrounds/lvl1-10/${selectedBg}`;
            battleState.useVideoBackground = false;
            
            battleState.backgroundImage = new Image();
            battleState.backgroundImage.onload = () => {
                // Only host runs floor scanning
                if (!multiplayerState.enabled || multiplayerState.role === 'host') {
                    generateBattleLayout();
                    if (multiplayerState.enabled && multiplayerState.role === 'host') {
                        sendBattleInitToClients();
                    }
                }
                renderBattle();
            };
            battleState.backgroundImage.src = battleState.backgroundPath;
        }
        
        // Send battle initialization data to clients (called after floor scanning completes)
        function sendBattleInitToClients() {
            const canvas = battleState.canvas;
            const battleData = {
                backgroundPath: battleState.backgroundPath,
                backgroundVideoPath: battleState.backgroundVideoPath,
                useVideoBackground: battleState.useVideoBackground,
                canvasWidth: canvas.width,
                canvasHeight: canvas.height,
                heroes: battleState.heroes.map(h => ({
                    name: h.name,
                    hp: h.hp,
                    maxHp: h.maxHp,
                    xp: h.xp,
                    healsRemaining: h.healsRemaining,
                    stats: h.stats,
                    x: h.x / canvas.width,
                    y: h.y / canvas.height,
                    platform: h.platform,
                    initiative: h.initiative,
                    spritePath: h.spritePath
                })),
                enemies: battleState.enemies.map(e => ({
                    name: e.name,
                    species: e.species,
                    hp: e.hp,
                    maxHp: e.maxHp,
                    ac: e.ac,
                    attackDamage: e.attackDamage,
                    speed: e.speed,
                    dex: e.dex,
                    hostile: e.hostile,
                    x: e.x / canvas.width,
                    y: e.y / canvas.height,
                    platform: e.platform,
                    initiative: e.initiative,
                    spritePath: e.spritePath,
                    isMob: e.isMob,
                    isBoss: e.isBoss,
                    goldDrop: e.goldDrop || 0,
                    backstory: e.backstory
                })),
                // Include captive NPC data for clients (full mob-like data)
                captiveNpc: battleState.captiveNpc ? {
                    name: battleState.captiveNpc.name,
                    species: battleState.captiveNpc.species,
                    backstory: battleState.captiveNpc.backstory,
                    personality: battleState.captiveNpc.personality,
                    rescueReward: battleState.captiveNpc.rescueReward,
                    goldReward: battleState.captiveNpc.goldReward || battleState.captiveNpc.rescueReward?.gold || 0,
                    dialogueOnRescue: battleState.captiveNpc.dialogueOnRescue,
                    rescued: battleState.captiveNpc.rescued,
                    hp: battleState.captiveNpc.hp || 1,
                    maxHp: battleState.captiveNpc.maxHp || 1,
                    x: battleState.captiveNpc.x / canvas.width,
                    y: battleState.captiveNpc.y / canvas.height,
                    spritePath: battleState.captiveNpc.spritePath,
                    color: battleState.captiveNpc.color,
                    isCaptive: true,
                    isMob: false,
                    canChat: true,
                    hostile: false,
                    facing: battleState.captiveNpc.facing || 'center'
                } : null,
                turnOrder: battleState.turnOrder.map(c => c.name),
                currentTurn: battleState.currentTurn
            };
            sendWebSocketMessage({ type: 'battle_init', battleData: battleData });
        }

        
        // Detect platforms using multi-method approach
        function detectPlatforms() {
            if (!battleState.backgroundImage || !battleState.backgroundImage.complete) {
                return [];
            }
            
            const tempCanvas = document.createElement('canvas');
            const ctx = tempCanvas.getContext('2d');
            tempCanvas.width = battleState.backgroundImage.width;
            tempCanvas.height = battleState.backgroundImage.height;
            
            ctx.drawImage(battleState.backgroundImage, 0, 0);
            const imageData = ctx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            const data = imageData.data;
            
            const allPlatforms = [];
            
            // METHOD 1: Adaptive thresholding with local contrast
            const method1 = detectByAdaptiveThreshold(data, tempCanvas.width, tempCanvas.height);
            allPlatforms.push(...method1);
            
            // METHOD 2: Multi-angle edge detection
            const method2 = detectByMultiAngle(data, tempCanvas.width, tempCanvas.height);
            allPlatforms.push(...method2);
            
            // METHOD 3: Color clustering
            const method3 = detectByColorClustering(data, tempCanvas.width, tempCanvas.height);
            allPlatforms.push(...method3);
            
            // Score and rank all platforms
            const scored = allPlatforms.map(p => ({
                ...p,
                score: scorePlatform(p, data, tempCanvas.width, tempCanvas.height)
            }));
            
            // Filter minimum score and sort
            const valid = scored.filter(p => p.score > 0.3).sort((a, b) => b.score - a.score);
            
            // Scale to canvas size
            const scaleX = battleState.canvas.width / tempCanvas.width;
            const scaleY = battleState.canvas.height / tempCanvas.height;
            
            return valid.map(p => ({
                x: p.x * scaleX,
                y: p.y * scaleY,
                w: p.w * scaleX,
                h: p.h * scaleY,
                type: p.type,
                score: p.score,
                color: p.color
            }));
        }
        
        // Adaptive thresholding - find LIGHT horizontal floor areas using box scanning
        function detectByAdaptiveThreshold(data, width, height) {
            const platforms = [];
            const boxWidth = 150; // Scan boxes 150px wide
            const boxHeight = 50; // 50px tall boxes
            const boxStepX = 50; // Move box right by 50px
            const boxStepY = 25; // Move box down by 25px
            const minBrightness = 100;
            
            // Scan bottom 60% of image only
            for (let boxY = Math.floor(height * 0.6); boxY < height - boxHeight - 10; boxY += boxStepY) {
                for (let boxX = 0; boxX < width - boxWidth; boxX += boxStepX) {
                    // Sample the entire box
                    let boxBrightnessSum = 0;
                    let boxSamples = 0;
                    
                    for (let dy = 0; dy < boxHeight; dy += 5) {
                        for (let dx = 0; dx < boxWidth; dx += 5) {
                            const x = boxX + dx;
                            const y = boxY + dy;
                            const i = (y * width + x) * 4;
                            const brightness = (data[i] + data[i+1] + data[i+2]) / 3;
                            boxBrightnessSum += brightness;
                            boxSamples++;
                        }
                    }
                    
                    const avgBrightness = boxBrightnessSum / boxSamples;
                    
                    // Check if box is bright enough
                    if (avgBrightness > minBrightness) {
                        // Depth test: trace down to find distance to ground
                        const depthScore = calculateDepthScore(data, width, height, boxX, boxY, boxWidth, boxHeight, avgBrightness);
                        
                        // Only accept platforms with good depth scores (close to ground or at bottom)
                        if (depthScore > 0.5) {
                            platforms.push({
                                x: boxX, y: boxY, w: boxWidth, h: boxHeight,
                                type: 'adaptive', color: '#FF00FF',
                                depthScore: depthScore
                            });
                        }
                    }
                }
            }
            
            return platforms;
        }
        
        // Multi-angle edge detection - find LIGHT floor areas at various slopes using boxes
        function detectByMultiAngle(data, width, height) {
            const platforms = [];
            const angles = [0, 5, -5];
            const boxWidth = 150;
            const boxHeight = 50;
            const boxStepX = 50;
            const boxStepY = 30;
            const minBrightness = 100;
            
            angles.forEach(angle => {
                const rad = angle * Math.PI / 180;
                const tanAngle = Math.tan(rad);
                
                for (let baseY = Math.floor(height * 0.6); baseY < height - boxHeight - 10; baseY += boxStepY) {
                    for (let boxX = 0; boxX < width - boxWidth; boxX += boxStepX) {
                        const centerY = Math.floor(baseY + boxX * tanAngle);
                        if (centerY < 0 || centerY >= height - boxHeight - 10) continue;
                        
                        // Sample box at this position
                        let boxBrightnessSum = 0;
                        let boxSamples = 0;
                        
                        for (let dy = 0; dy < boxHeight; dy += 5) {
                            for (let dx = 0; dx < boxWidth; dx += 5) {
                                const x = boxX + dx;
                                const y = centerY + dy;
                                if (y >= height) continue;
                                const i = (y * width + x) * 4;
                                const brightness = (data[i] + data[i+1] + data[i+2]) / 3;
                                boxBrightnessSum += brightness;
                                boxSamples++;
                            }
                        }
                        
                        const avgBrightness = boxBrightnessSum / boxSamples;
                        
                        if (avgBrightness > minBrightness) {
                            // Depth test
                            const depthScore = calculateDepthScore(data, width, height, boxX, centerY, boxWidth, boxHeight, avgBrightness);
                            
                            if (depthScore > 0.5) {
                                platforms.push({
                                    x: boxX, y: centerY, w: boxWidth, h: boxHeight,
                                    type: 'angle', color: '#00FFFF',
                                    depthScore: depthScore
                                });
                            }
                        }
                    }
                }
            });
            
            return platforms;
        }
        
        // Color clustering - find LIGHT colored horizontal floor regions using boxes
        function detectByColorClustering(data, width, height) {
            const platforms = [];
            const boxWidth = 150;
            const boxHeight = 50;
            const boxStepX = 50;
            const boxStepY = 25;
            const colorTolerance = 60;
            const minBrightness = 100;
            
            for (let boxY = Math.floor(height * 0.6); boxY < height - boxHeight - 10; boxY += boxStepY) {
                for (let boxX = 0; boxX < width - boxWidth; boxX += boxStepX) {
                    // Sample box at this position
                    let avgR = 0, avgG = 0, avgB = 0;
                    let samples = 0;
                    
                    for (let dy = 0; dy < boxHeight; dy += 5) {
                        for (let dx = 0; dx < boxWidth; dx += 5) {
                            const x = boxX + dx;
                            const y = boxY + dy;
                            const i = (y * width + x) * 4;
                            avgR += data[i];
                            avgG += data[i+1];
                            avgB += data[i+2];
                            samples++;
                        }
                    }
                    
                    avgR /= samples;
                    avgG /= samples;
                    avgB /= samples;
                    const brightness = (avgR + avgG + avgB) / 3;
                    
                    // Only consider LIGHT boxes as potential floor
                    if (brightness > minBrightness) {
                        // Depth test
                        const depthScore = calculateDepthScore(data, width, height, boxX, boxY, boxWidth, boxHeight, brightness);
                        
                        if (depthScore > 0.5) {
                            platforms.push({
                                x: boxX, y: boxY, w: boxWidth, h: boxHeight,
                                type: 'cluster', color: '#00FF00',
                                depthScore: depthScore
                            });
                        }
                    }
                }
            }
            
            return platforms;
        }
        
        // Calculate depth score - traces downward to find distance to ground
        function calculateDepthScore(data, width, height, boxX, boxY, boxWidth, boxHeight, platformBrightness) {
            const centerX = boxX + Math.floor(boxWidth / 2);
            const startY = boxY + boxHeight;
            const maxDepth = 200; // Don't trace more than 200px down
            
            let distanceToGround = 0;
            let foundGround = false;
            
            // Trace straight down from center of platform
            for (let y = startY; y < Math.min(height, startY + maxDepth); y += 5) {
                const i = (y * width + centerX) * 4;
                const brightness = (data[i] + data[i+1] + data[i+2]) / 3;
                
                // Check for ground indicators:
                // 1. Hit bottom of image
                if (y >= height - 10) {
                    distanceToGround = y - startY;
                    foundGround = true;
                    break;
                }
                
                // 2. Hit much darker area (void/background)
                if (brightness < 50) {
                    distanceToGround = y - startY;
                    foundGround = true;
                    break;
                }
                
                // 3. Hit similar brightness (continuous support)
                if (Math.abs(brightness - platformBrightness) < 30) {
                    // Keep tracing, we're still on connected surface
                    continue;
                }
            }
            
            // If we traced all the way down without finding ground, it's floating
            if (!foundGround) {
                return 0;
            }
            
            // Score based on distance to ground
            // 0 distance (at bottom) = 1.0 score
            // 50px or more = 0.5 score (minimum acceptable)
            // >200px = rejected above
            const score = 1.0 - (distanceToGround / 400);
            return Math.max(0.5, score);
        }
        
        // Score platform quality
        function scorePlatform(platform, data, width, height) {
            let score = 0;
            
            // Width score (wider = better, cap at 800px)
            const widthScore = Math.min(1.0, platform.w / 800);
            score += widthScore * 0.5;
            
            // Position score (lower on screen = better, floors are at bottom)
            const positionScore = platform.y / height;
            score += positionScore * 0.3;
            
            // Brightness consistency (floors should be consistently LIGHT)
            let brightnessSum = 0;
            let sampleCount = 0;
            for (let x = platform.x; x < platform.x + platform.w; x += 10) {
                const idx = (Math.floor(platform.y) * width + Math.floor(x)) * 4;
                const brightness = (data[idx] + data[idx+1] + data[idx+2]) / 3;
                brightnessSum += brightness;
                sampleCount++;
            }
            const avgBrightness = brightnessSum / sampleCount;
            const brightnessScore = avgBrightness > 100 ? Math.min(1.0, avgBrightness / 200) : 0;
            score += brightnessScore * 0.2;
            
            return score;
        }
        
        // Check if position is in chat window exclusion zone
        function isInChatExclusionZone(x, y, canvas) {
            // Chat window is positioned at: right: 20px, bottom: 10px, width: 350px, height: 600px
            // Exclusion zone: bottom-right corner of canvas
            const chatRight = 20;
            const chatWidth = 350;
            const chatHeight = 600;
            const chatBottom = 10;
            const buffer = 50; // Extra buffer around chat
            
            const chatLeft = canvas.width - chatRight - chatWidth - buffer;
            const chatTop = canvas.height - chatBottom - chatHeight - buffer;
            
            return x > chatLeft && y > chatTop;
        }
        
        // Generate battle layout using detected platforms
        function generateBattleLayout() {
            const canvas = battleState.canvas;
            battleState.platforms = [];
            
            // Detect platforms
            const detected = detectPlatforms();
            
            if (detected.length < 7) {
                return generateFallbackLayout();
            }
            
            // Safe zone filtering - check X bounds AND avoid chat window area
            const marginX = 160; // 300px sprite / 2 + 10px buffer
            
            const safe = detected.filter(p => {
                const centerX = p.x + p.w / 2;
                const centerY = p.y + p.h / 2;
                // Must be within X margins AND not in chat exclusion zone
                return centerX > marginX && centerX < canvas.width - marginX && 
                       !isInChatExclusionZone(centerX, centerY, canvas);
            });
            
            // Calculate required platforms: 4 heroes + enemies (up to ~20)
            const requiredPlatforms = 4 + battleState.enemies.length;
            
            if (safe.length < requiredPlatforms) {
                return generateFallbackLayout();
            }
            
            // Shuffle safe platforms for variety each battle
            const shuffled = [...safe].sort(() => Math.random() - 0.5);
            
            // Pick platforms ensuring spatial separation
            // Reduce distance for more enemies to fit them all
            const baseMinDistance = 200;
            const minDistance = battleState.enemies.length > 5 ? 120 : baseMinDistance;
            const selected = [];
            
            for (let i = 0; i < shuffled.length && selected.length < requiredPlatforms; i++) {
                const candidate = shuffled[i];
                const candidateX = candidate.x + candidate.w / 2;
                const candidateY = candidate.y;
                
                // Check if candidate overlaps with already selected platforms
                let overlaps = false;
                for (const existing of selected) {
                    const existingX = existing.x + existing.w / 2;
                    const existingY = existing.y;
                    
                    const dx = candidateX - existingX;
                    const dy = candidateY - existingY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < minDistance) {
                        overlaps = true;
                        break;
                    }
                }
                
                if (!overlaps) {
                    selected.push(candidate);
                }
            }
            
            // Need enough non-overlapping platforms for heroes + enemies
            if (selected.length < requiredPlatforms) {
                return generateFallbackLayout();
            }
            
            // Position heroes
            for (let i = 0; i < 4; i++) {
                const p = selected[i];
                battleState.platforms.push(p);
                
                // Center of detection box
                const centerX = p.x + p.w / 2;
                const centerY = p.y + p.h / 2;
                
                // We need to solve: floor contact point (heroY + scaledBoxSize/2) = centerY
                // scaledBoxSize = 300 * (0.6 + heroY / canvas.height * 0.4)
                // This is circular, so we iterate to solve
                let heroY = centerY - 150; // Initial guess
                for (let iter = 0; iter < 5; iter++) {
                    const depthScale = 0.6 + (heroY / canvas.height) * 0.4;
                    const scaledBoxSize = 300 * depthScale;
                    heroY = centerY - scaledBoxSize / 2;
                }
                
                battleState.heroes[i].platform = p;
                battleState.heroes[i].x = centerX;
                battleState.heroes[i].y = heroY;
                battleState.heroes[i].facing = 'center';
            }
            
            // Position enemies
            for (let i = 0; i < battleState.enemies.length; i++) {
                const ep = selected[4 + i];
                battleState.platforms.push(ep);
                
                // Center of detection box
                const centerX = ep.x + ep.w / 2;
                const centerY = ep.y + ep.h / 2;
                
                const enemy = battleState.enemies[i];
                
                if (enemy.isMob) {
                    // For mobs: enemy.y is at FEET (bottom of sprite)
                    // Sprite bottom should be at centerY
                    enemy.x = centerX;
                    enemy.y = centerY;
                } else {
                    // For bosses: solve for Y position where floor contact point = centerY
                    let enemyY = centerY - 150; // Initial guess
                    for (let iter = 0; iter < 5; iter++) {
                        const depthScale = 0.6 + (enemyY / canvas.height) * 0.4;
                        const scaledBoxSize = 300 * depthScale;
                        enemyY = centerY - scaledBoxSize / 2;
                    }
                    enemy.x = centerX;
                    enemy.y = enemyY;
                }
                
                enemy.platform = ep;
                enemy.facing = 'center';
            }
            
            // Position captive NPC if present (right side, below enemies)
            if (battleState.captiveNpc && !battleState.captiveNpc.rescued) {
                battleState.captiveNpc.x = canvas.width * 0.70;
                battleState.captiveNpc.y = canvas.height * 0.80;
                battleState.captiveNpc.facing = 'center';
            }
            
            battleState.detectedPlatforms = detected;
        }
        
        // Fallback positioning
        function generateFallbackLayout() {
            const canvas = battleState.canvas;
            const safePositions = {
                heroes: [
                    { x: 0.20, y: 0.40 },
                    { x: 0.25, y: 0.55 },
                    { x: 0.15, y: 0.65 },
                    { x: 0.30, y: 0.75 }
                ],
                // Extended enemy positions - spread across battle area, avoiding chat window zone
                // Chat window is bottom-right (roughly x > 0.70, y > 0.50), so keep enemies left of that
                // Positions ordered for visual variety: corners first, then fill in
                // Y values at 0.60+ to keep enemies on ground (40% from bottom)
                enemies: [
                    // First 4 - spread horizontally, grounded
                    { x: 0.55, y: 0.60 }, { x: 0.68, y: 0.62 }, { x: 0.50, y: 0.65 }, { x: 0.62, y: 0.68 },
                    // Next 4 - fill in gaps  
                    { x: 0.58, y: 0.63 }, { x: 0.65, y: 0.60 }, { x: 0.52, y: 0.67 }, { x: 0.70, y: 0.64 },
                    // Next 4 - continue spreading
                    { x: 0.54, y: 0.66 }, { x: 0.60, y: 0.61 }, { x: 0.66, y: 0.65 }, { x: 0.56, y: 0.62 },
                    // Next 4 - fill remaining gaps
                    { x: 0.63, y: 0.67 }, { x: 0.51, y: 0.63 }, { x: 0.68, y: 0.66 }, { x: 0.57, y: 0.64 },
                    // Final 4 - last gaps
                    { x: 0.64, y: 0.62 }, { x: 0.53, y: 0.68 }, { x: 0.59, y: 0.65 }, { x: 0.67, y: 0.61 }
                ]
            };
            
            for (let i = 0; i < 4; i++) {
                const pos = safePositions.heroes[i];
                const heroX = canvas.width * pos.x;
                const heroY = canvas.height * pos.y;
                
                const platform = {
                    x: heroX - 50, y: heroY + 140, w: 100, h: 10,
                    type: 'fallback', color: '#6B4FA0'
                };
                
                battleState.platforms.push(platform);
                battleState.heroes[i].platform = platform;
                battleState.heroes[i].x = heroX;
                battleState.heroes[i].y = heroY;
                battleState.heroes[i].facing = 'center';
            }
            
            for (let i = 0; i < battleState.enemies.length; i++) {
                // Use modulo to wrap around if we have more enemies than positions
                const pos = safePositions.enemies[i % safePositions.enemies.length];
                // Add slight random offset if wrapping to avoid exact overlap
                const wrapOffset = Math.floor(i / safePositions.enemies.length) * 0.03;
                const enemyX = canvas.width * (pos.x + wrapOffset);
                const enemyY = canvas.height * pos.y;
                
                const enemyPlatform = {
                    x: enemyX - 75, y: enemyY + 140, w: 150, h: 10,
                    type: 'fallback', color: '#4A2A6B'
                };
                
                battleState.platforms.push(enemyPlatform);
                battleState.enemies[i].platform = enemyPlatform;
                battleState.enemies[i].x = enemyX;
                battleState.enemies[i].y = enemyY;
                battleState.enemies[i].facing = 'center';
            }
            
            // Position captive NPC if present (right side, below enemies - like a prisoner)
            if (battleState.captiveNpc && !battleState.captiveNpc.rescued) {
                const captiveX = canvas.width * 0.70;  // Right side, clear of chat window
                const captiveY = canvas.height * 0.80;  // Lower area (front of room)
                battleState.captiveNpc.x = captiveX;
                battleState.captiveNpc.y = captiveY;
                battleState.captiveNpc.facing = 'center';
            }
        }
        

        // Handle canvas clicks for targeting
        function handleBattleClick(event) {
            const rect = battleState.canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // Handle swap targeting (hero selection)
            if (battleState.swapTargetingMode && battleState.swapInitiator) {
                for (const hero of battleState.heroes) {
                    if (hero === battleState.swapInitiator || hero.hp <= 0) continue;
                    
                    const canvas = battleState.canvas;
                    const depthScale = 0.6 + (hero.y / canvas.height) * 0.4;
                    const hitWidth = 64 * depthScale;
                    const hitHeight = 64 * depthScale;
                    const hitX = hero.x - hitWidth / 2;
                    const hitY = hero.y - hitHeight / 2;
                    
                    if (x >= hitX && x <= hitX + hitWidth && y >= hitY && y <= hitY + hitHeight) {
                        const initiator = battleState.swapInitiator;
                        
                        // Multiplayer: Client sends to host
                        if (multiplayerState.enabled && multiplayerState.role === 'client') {
                            sendWebSocketMessage({
                                type: 'player_action',
                                action: 'swap',
                                target: battleState.heroes.indexOf(hero),
                                hero: initiator.name
                            });
                            
                            // Exit swap mode
                            battleState.swapTargetingMode = false;
                            battleState.swapInitiator = null;
                            battleState.canvas.style.cursor = 'default';
                            return;
                        }
                        
                        // Swap positions
                        const tempX = initiator.x;
                        const tempY = initiator.y;
                        const tempPlatform = initiator.platform;
                        
                        initiator.x = hero.x;
                        initiator.y = hero.y;
                        initiator.platform = hero.platform;
                        
                        hero.x = tempX;
                        hero.y = tempY;
                        hero.platform = tempPlatform;
                        
                        // Play swap sound for initiator
                        playSfx(initiator.name.toLowerCase() + 'Swap');
                        
                        showDiceRoll(`${initiator.name} swapped positions with ${hero.name}!`);
                        
                        // Exit swap mode
                        battleState.swapTargetingMode = false;
                        battleState.swapInitiator = null;
                        battleState.canvas.style.cursor = 'default';
                        
                        // Swap uses all action points
                        advanceTurn();
                        
                        // Host broadcasts state
                        if (multiplayerState.enabled && multiplayerState.role === 'host') {
                            broadcastGameState();
                        }
                        return;
                    }
                }
                return;
            }
            
            // Handle enemy targeting
            if (!battleState.targetingMode || !battleState.pendingAction) return;
            
            // Check if click hit an enemy
            for (const enemy of battleState.enemies) {
                if (enemy.hp <= 0 || !enemy.hostile) continue;
                
                const canvas = battleState.canvas;
                const depthScale = 0.6 + (enemy.y / canvas.height) * 0.4;
                let hitWidth, hitHeight, hitX, hitY;
                
                if (enemy.isMob) {
                    // Use actual sprite dimensions for proper aspect ratio
                    const imgWidth = enemy.sprite?.naturalWidth || 768;
                    const imgHeight = enemy.sprite?.naturalHeight || 768;
                    const mobAspectRatio = imgWidth / imgHeight;
                    
                    // Small mobs use sizeScale for differentiation
                    const baseHeight = 75 * (enemy.sizeScale || 2.5);
                    
                    const spriteHeight = baseHeight * depthScale;
                    const spriteWidth = spriteHeight * mobAspectRatio;
                    hitWidth = spriteWidth;
                    hitHeight = spriteHeight;
                    hitX = enemy.x - hitWidth / 2;
                    hitY = enemy.y - hitHeight / 2;
                } else {
                    hitWidth = 200 * depthScale;
                    hitHeight = 200 * depthScale;
                    hitX = enemy.x - hitWidth / 2;
                    hitY = enemy.y - hitHeight / 2;
                }
                
                if (x >= hitX && x <= hitX + hitWidth && y >= hitY && y <= hitY + hitHeight) {
                    // Target found!
                    const attacker = battleState.turnOrder[battleState.currentTurn];
                    const enemyIndex = battleState.enemies.indexOf(enemy);
                    
                    // Multiplayer: Client sends to host
                    if (multiplayerState.enabled && multiplayerState.role === 'client') {
                        sendWebSocketMessage({
                            type: 'player_action',
                            action: battleState.pendingAction,
                            target: enemyIndex,
                            hero: attacker.name
                        });
                        
                        // Exit targeting mode
                        battleState.targetingMode = false;
                        battleState.pendingAction = null;
                        battleState.canvas.style.cursor = 'default';
                        return;
                    }
                    
                    executeAttack(attacker, enemy, battleState.pendingAction);
                    
                    // Exit targeting mode
                    battleState.targetingMode = false;
                    battleState.pendingAction = null;
                    battleState.canvas.style.cursor = 'default';
                    return;
                }
            }
        }
        
        // Draw turn indicator (bouncing chevron/arrow) above active combatant
        function drawTurnIndicator(ctx, x, y, depthScale, isEnemy = false) {
            const time = performance.now();
            // Bouncing animation: oscillate up and down
            const bounce = Math.sin(time / 200) * 8 * depthScale;
            // Pulsing glow
            const pulse = 0.5 + Math.sin(time / 300) * 0.3;
            
            const indicatorY = y - bounce;
            const size = 20 * depthScale;
            
            ctx.save();
            
            // Glow effect
            ctx.shadowColor = isEnemy ? '#FF4444' : '#00FF88';
            ctx.shadowBlur = 15 * pulse * depthScale;
            
            // Draw downward-pointing chevron/arrow
            ctx.beginPath();
            ctx.moveTo(x - size, indicatorY - size);  // Top left
            ctx.lineTo(x, indicatorY);                 // Bottom center (point)
            ctx.lineTo(x + size, indicatorY - size);  // Top right
            
            ctx.strokeStyle = isEnemy ? '#FF6666' : '#00FF88';
            ctx.lineWidth = 4 * depthScale;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.stroke();
            
            // Inner lighter stroke
            ctx.beginPath();
            ctx.moveTo(x - size * 0.6, indicatorY - size * 0.6);
            ctx.lineTo(x, indicatorY - size * 0.1);
            ctx.lineTo(x + size * 0.6, indicatorY - size * 0.6);
            ctx.strokeStyle = isEnemy ? '#FFAAAA' : '#AAFFCC';
            ctx.lineWidth = 2 * depthScale;
            ctx.stroke();
            
            ctx.restore();
        }
        
        // Render battle scene
        function renderBattle() {
            const ctx = battleState.ctx;
            const canvas = battleState.canvas;
            
            // Setup click handler
            if (!canvas.hasClickHandler) {
                canvas.addEventListener('click', handleBattleClick);
                canvas.hasClickHandler = true;
            }
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw background - video plays behind transparent canvas, or draw static image
            if (battleState.useVideoBackground) {
                // Video is playing behind canvas via HTML video element
                // Canvas stays transparent to show video
            } else if (battleState.backgroundImage && battleState.backgroundImage.complete && battleState.backgroundImage.naturalHeight !== 0) {
                ctx.drawImage(battleState.backgroundImage, 0, 0, canvas.width, canvas.height);
            } else {
                // Fallback: Clear canvas with gradient
                ctx.fillStyle = '#1a0f2e';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw starry background
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                for (let i = 0; i < 100; i++) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    const r = Math.random() * 2;
                    ctx.beginPath();
                    ctx.arc(x, y, r, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Draw detected platform spawn areas if hitboxes enabled
            if (settings.showHitboxes && battleState.detectedPlatforms) {
                battleState.detectedPlatforms.forEach(platform => {
                    // Different colors for different detection methods
                    let fillColor, strokeColor;
                    
                    if (platform.type === 'detected') {
                        // Edge detection = GREEN
                        fillColor = 'rgba(0, 255, 0, 0.2)';
                        strokeColor = 'rgba(0, 255, 0, 0.8)';
                    } else if (platform.type === 'sampled') {
                        // Grid sampling = MAGENTA
                        fillColor = 'rgba(255, 0, 255, 0.2)';
                        strokeColor = 'rgba(255, 0, 255, 0.8)';
                    } else if (platform.type === 'gradient') {
                        // Gradient/flat area = CYAN
                        fillColor = 'rgba(0, 255, 255, 0.2)';
                        strokeColor = 'rgba(0, 255, 255, 0.8)';
                    } else {
                        // Unknown = WHITE
                        fillColor = 'rgba(255, 255, 255, 0.2)';
                        strokeColor = 'rgba(255, 255, 255, 0.8)';
                    }
                    
                    ctx.fillStyle = fillColor;
                    ctx.fillRect(platform.x, platform.y, platform.w, platform.h);
                    
                    ctx.strokeStyle = strokeColor;
                    ctx.lineWidth = 1;
                    ctx.strokeRect(platform.x, platform.y, platform.w, platform.h);
                });
            }
            
            // Draw platforms
            battleState.platforms.forEach(platform => {
                // Don't draw platforms, keep them invisible for collision only
                // ctx.fillStyle = platform.color;
                // ctx.fillRect(platform.x, platform.y, platform.w, platform.h);
                
                // Platform edge highlight
                // ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                // ctx.lineWidth = 2;
                // ctx.strokeRect(platform.x, platform.y, platform.w, platform.h);
            });
            
            // Draw heroes
            battleState.heroes.forEach(hero => {
                // Calculate depth-based scale (higher Y = farther back = smaller)
                // Y range: 0 (top) to canvas.height (bottom)
                // Scale range: 0.6 (top/far) to 1.0 (bottom/near)
                const depthScale = 0.6 + (hero.y / canvas.height) * 0.4;
                
                // Green highlight for swap targeting (other heroes)
                if (battleState.swapTargetingMode && hero !== battleState.swapInitiator && hero.hp > 0) {
                    ctx.save();
                    ctx.strokeStyle = '#00FF00';
                    ctx.lineWidth = 4 * depthScale;
                    ctx.shadowColor = '#00FF00';
                    ctx.shadowBlur = 20 * depthScale;
                    const pulseSize = Math.sin(Date.now() / 200) * 3 * depthScale;
                    const boxWidth = 300 * depthScale;
                    const boxHeight = 300 * depthScale;
                    ctx.strokeRect(
                        hero.x - boxWidth / 2 - pulseSize,
                        hero.y - boxHeight / 2 - pulseSize,
                        boxWidth + pulseSize * 2,
                        boxHeight + pulseSize * 2
                    );
                    ctx.restore();
                }
                
                // Update animation frame
                const currentTime = performance.now();
                updateAnimation(hero, currentTime);
                
                // Draw hero sprite (animated or fallback)
                const spriteWidth = 300 * depthScale;
                const spriteHeight = 300 * depthScale;
                const spriteX = hero.x - spriteWidth / 2;
                // Per-hero offset adjustments (scaled with depth)
                let offsetY = 10 * depthScale; // Default (Zooko, Nate)
                if (hero.name === 'Zancas') {
                    offsetY = 20 * depthScale; // Zancas down 10px more
                } else if (hero.name === 'CyberAxe') {
                    offsetY = 13 * depthScale; // CyberAxe down 3px more
                }
                const spriteY = hero.y - spriteHeight / 2 + offsetY;
                
                const flipX = hero.facing === 'left';
                drawAnimatedSprite(ctx, hero, spriteX, spriteY, spriteWidth, spriteHeight, flipX);
                
                // Draw turn indicator above active hero
                const currentCombatant = battleState.turnOrder[battleState.currentTurn];
                if (currentCombatant && currentCombatant === hero) {
                    // Position above hero's head
                    const indicatorY = spriteY - 10 * depthScale;
                    drawTurnIndicator(ctx, hero.x, indicatorY, depthScale, false);
                }
                
                // Draw backpack at hero's feet (in front of the hero)
                if (hero.backpackSprite && hero.backpackSprite.complete && hero.backpackSprite.naturalHeight > 0) {
                    // Per-hero backpack sizes
                    const backpackSizes = { 'Zooko': 110, 'Nate': 110, 'Zancas': 110, 'CyberAxe': 100 };
                    const backpackSize = backpackSizes[hero.name] || 100;
                    const backpackWidth = backpackSize * depthScale;
                    const backpackHeight = backpackSize * depthScale;
                    // Position backpack at feet (lower left of hero) - per-hero Y offset
                    const backpackYOffsets = { 'Zooko': 100, 'Nate': 90, 'Zancas': 95, 'CyberAxe': 90 };
                    const backpackYOffset = backpackYOffsets[hero.name] || 100;
                    const backpackX = hero.x - backpackWidth / 2 - (60 * depthScale);
                    const backpackY = hero.y + (backpackYOffset * depthScale); // At feet level
                    
                    // Draw shadow behind backpack for depth
                    ctx.save();
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                    ctx.shadowBlur = 12 * depthScale;
                    ctx.shadowOffsetX = 4 * depthScale;
                    ctx.shadowOffsetY = 4 * depthScale;
                    ctx.drawImage(hero.backpackSprite, backpackX, backpackY, backpackWidth, backpackHeight);
                    ctx.restore();
                    
                    // Draw health potions in front of backpack (left and right)
                    if (hero.potions) {
                        const potionSize = 40 * depthScale;
                        const potionSpacing = 10 * depthScale;  // Space from backpack edge
                        // Per-hero inward offset for potions (Zooko, Nate, Zancas need potions closer together)
                        const potionInward = (hero.name === 'Zooko' || hero.name === 'Nate' || hero.name === 'Zancas') ? 5 * depthScale : 0;
                        
                        hero.potions.forEach((potion, idx) => {
                            if (!potion.visible || !hero.potionSprite || !hero.potionSprite.complete) return;
                            
                            // Position: left potion on left of backpack, right potion on right
                            const potionX = idx === 0 
                                ? backpackX - potionSpacing + potionInward  // Left potion (moved right)
                                : backpackX + backpackWidth - potionSize + potionSpacing - potionInward;  // Right potion (moved left)
                            const potionY = backpackY + (backpackHeight - potionSize) / 2 + (15 * depthScale);  // Lowered
                            
                            // Draw static potion sprite
                            ctx.drawImage(hero.potionSprite, potionX, potionY, potionSize, potionSize);
                        });
                    }
                }
                
                // Fallback check - if no animation and no static sprite loaded
                if ((!hero.anim || !hero.anim.sheet) && (!hero.sprite || !hero.sprite.complete || hero.sprite.naturalHeight === 0)) {
                    // Fallback to colored circle if sprite not loaded
                    ctx.fillStyle = hero.color;
                    ctx.beginPath();
                    ctx.arc(hero.x, hero.y, 90 * depthScale, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                
                // Ground-plane nameplate (at hero's feet, tilted for 3D perspective)
                ctx.save();
                
                // Position at hero's feet (bottom of sprite area)
                const groundY = hero.y + 160 * depthScale;  // Below hero sprite (moved down)
                
                // Calculate tilt based on screen position (left=-5Â°, middle=0Â°, right=+5Â°)
                const screenThird = canvas.width / 3;
                let tiltAngle = 0;
                if (hero.x < screenThird) {
                    // Left third: -5 degrees
                    tiltAngle = -5;
                } else if (hero.x > screenThird * 2) {
                    // Right third: +5 degrees
                    tiltAngle = 5;
                }
                // Middle third: 0 degrees (no tilt)
                
                // Convert degrees to radians for sin calculation
                const tiltRadians = tiltAngle * Math.PI / 180;
                const tiltSkew = Math.sin(tiltRadians);  // sin(5Â°) â‰ˆ 0.087, sin(-5Â°) â‰ˆ -0.087, sin(0Â°) = 0
                
                // Apply perspective transform - squish vertically for ground plane effect
                // 50% taller than original 35% = 52.5% scale
                ctx.translate(hero.x, groundY);
                ctx.transform(1, tiltSkew, 0, 0.525, 0, 0);  // Dynamic tilt + 52.5% vertical scale
                ctx.translate(-hero.x, -groundY);
                
                const barWidth = 100 * depthScale;
                const barHeight = 20 * depthScale;  // Taller since it gets squished
                const barX = hero.x - barWidth / 2;
                const barY = groundY;
                
                // Shadow/glow under the nameplate
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.beginPath();
                ctx.ellipse(hero.x, barY + barHeight + 10 * depthScale, barWidth * 0.6, 8 * depthScale, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Hero name (above HP bar on ground)
                ctx.fillStyle = '#FFFFFF';
                ctx.font = `bold ${Math.floor(16 * depthScale)}px Inter`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText(hero.name.toUpperCase(), hero.x, barY - 2 * depthScale);
                
                // HP bar background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(barX, barY, barWidth, barHeight);
                
                // HP bar border
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 2;
                ctx.strokeRect(barX, barY, barWidth, barHeight);
                
                // HP fill (GREEN -> YELLOW for heroes)
                const hpPercent = hero.hp / hero.maxHp;
                ctx.fillStyle = hpPercent > 0.5 ? '#27AE60' : hpPercent > 0.25 ? '#F39C12' : '#F1C40F';
                ctx.fillRect(barX + 2, barY + 2, (barWidth - 4) * hpPercent, barHeight - 4);
                
                // HP text INSIDE bar (centered)
                ctx.fillStyle = '#FFFFFF';
                ctx.font = `bold ${Math.floor(14 * depthScale)}px JetBrains Mono`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(`${hero.hp}/${hero.maxHp}`, hero.x, barY + barHeight / 2);
                
                ctx.restore();  // Restore normal transform
            });
            
            // Draw enemies
            battleState.enemies.forEach(enemy => {
                // Calculate depth-based scale (higher Y = farther back = smaller)
                const depthScale = 0.6 + (enemy.y / canvas.height) * 0.4;
                
                // Update boss animations
                if (enemy.anim) {
                    const currentTime = performance.now();
                    updateAnimation(enemy, currentTime);
                }
                
                // Draw enemy sprite
                if (enemy.sprite && enemy.sprite.complete && enemy.sprite.naturalHeight !== 0) {
                    let spriteWidth, spriteHeight, spriteX, spriteY;
                    
                    if (enemy.isMob) {
                        // Use actual sprite dimensions for proper aspect ratio
                        const imgWidth = enemy.sprite.naturalWidth || 768;
                        const imgHeight = enemy.sprite.naturalHeight || 768;
                        const mobAspectRatio = imgWidth / imgHeight;
                        
                        // Random size scale - stored on enemy for consistency
                        // Small mobs: 1.5-3.0, Normal mobs: 2.0-5.0
                        if (enemy.sizeScale === undefined) {
                            const isSmallMob = SMALL_MOB_IDS.includes(enemy.mobId);
                            enemy.sizeScale = isSmallMob ? (1.5 + Math.random() * 1.5) : (2.0 + Math.random() * 3.0);
                        }
                        
                        const baseHeight = 75 * enemy.sizeScale;
                        spriteHeight = baseHeight * depthScale;
                        spriteWidth = spriteHeight * mobAspectRatio;
                        spriteX = enemy.x - spriteWidth / 2;
                        // Center sprite on enemy.y
                        spriteY = enemy.y - spriteHeight / 2;
                    } else {
                        // Bosses: use actual image dimensions for proper aspect ratio
                        // For animated bosses, use frame size; otherwise use sprite dimensions
                        let imgWidth, imgHeight;
                        if (enemy.anim && enemy.anim.frameSize) {
                            // Animated boss - frames are square
                            imgWidth = enemy.anim.frameSize;
                            imgHeight = enemy.anim.frameSize;
                        } else {
                            // Static boss sprite
                            imgWidth = enemy.sprite.naturalWidth || 300;
                            imgHeight = enemy.sprite.naturalHeight || 300;
                        }
                        const bossAspectRatio = imgWidth / imgHeight;
                        
                        // Base height that looks good, scaled by depth
                        // Level 100 boss (Auric Hoard Dragon) is 2.5x larger
                        const isLevel100 = enemy.spritePath && enemy.spritePath.includes('lvl100');
                        const sizeMultiplier = isLevel100 ? 2.5 : 1.0;
                        const baseHeight = 250 * depthScale * sizeMultiplier;
                        spriteHeight = baseHeight;
                        spriteWidth = baseHeight * bossAspectRatio;
                        spriteX = enemy.x - spriteWidth / 2;
                        // Center sprite on enemy.y (same as mobs)
                        spriteY = enemy.y - spriteHeight / 2;
                    }
                    
                    // Check if this enemy has animation (boss with sprite sheets)
                    if (enemy.anim && enemy.anim.sheet) {
                        const flipX = enemy.facing === 'left';
                        drawAnimatedSprite(ctx, enemy, spriteX, spriteY, spriteWidth, spriteHeight, flipX);
                    } else {
                        ctx.save();
                        if (enemy.facing === 'left') {
                            ctx.translate(enemy.x, enemy.y);
                            ctx.scale(-1, 1);
                            ctx.translate(-enemy.x, -enemy.y);
                        }
                        ctx.drawImage(enemy.sprite, spriteX, spriteY, spriteWidth, spriteHeight);
                        ctx.restore();
                    }
                } else {
                    // Fallback to colored circle if sprite not loaded
                    ctx.fillStyle = enemy.color;
                    ctx.beginPath();
                    ctx.arc(enemy.x, enemy.y, 50 * depthScale, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
                
                // Draw turn indicator above active enemy
                const currentCombatant = battleState.turnOrder[battleState.currentTurn];
                if (currentCombatant && currentCombatant === enemy) {
                    // Calculate top of sprite for indicator position
                    let indicatorTopY;
                    if (enemy.isMob) {
                        const sizeScale = enemy.sizeScale || 1.0;
                        const baseHeight = 75 * sizeScale;
                        indicatorTopY = enemy.y - (baseHeight * depthScale) / 2 - 15 * depthScale;
                    } else {
                        const isLevel100 = enemy.spritePath && enemy.spritePath.includes('lvl100');
                        const sizeMultiplier = isLevel100 ? 2.5 : 1.0;
                        const baseHeight = 250 * depthScale * sizeMultiplier;
                        indicatorTopY = enemy.y - baseHeight / 2 - 15 * depthScale;
                    }
                    drawTurnIndicator(ctx, enemy.x, indicatorTopY, depthScale, true);
                }
                
                // Calculate HP bar position first, then build labels above it
                let barOffsetY;
                if (enemy.isMob) {
                    const mobAspectRatio = 1344 / 768;
                    // Use the stored random size scale
                    const sizeScale = enemy.sizeScale || 1.0;
                    const baseHeight = 75 * sizeScale;
                    const spriteHeight = baseHeight * depthScale;
                    // Sprite is centered on enemy.y, so top is at enemy.y - spriteHeight/2
                    barOffsetY = enemy.y - spriteHeight / 2 - (5 * depthScale);
                } else {
                    // For bosses: sprite is now centered on enemy.y (same as mobs)
                    // Level 100 boss is 2x larger
                    const isLevel100 = enemy.spritePath && enemy.spritePath.includes('lvl100');
                    const sizeMultiplier = isLevel100 ? 2.0 : 1.0;
                    const baseHeight = 250 * depthScale * sizeMultiplier;
                    // Sprite top is at enemy.y - baseHeight/2
                    barOffsetY = enemy.y - baseHeight / 2 - (5 * depthScale);
                }
                
                // HP bar with text inside
                const barWidth = 100 * depthScale;
                const barHeight = 14 * depthScale;
                const barX = enemy.x - barWidth / 2;
                const barY = barOffsetY;
                
                // Calculate label positions (build upward from HP bar)
                const speciesOffsetY = barY - (5 * depthScale);  // Species just above bar
                const nameOffsetY = speciesOffsetY - (12 * depthScale);  // Name above species
                
                // Name (unique name - RED for enemies)
                ctx.fillStyle = '#FF4444';
                ctx.font = `bold ${Math.floor(14 * depthScale)}px Inter`;
                ctx.textAlign = 'center';
                ctx.fillText(enemy.name.toUpperCase(), enemy.x, nameOffsetY);
                
                // Species/Type (smaller, between name and bar) - ALWAYS show
                ctx.fillStyle = '#AAAAAA';
                if (enemy.isMob) {
                    // Mobs: species in gray, normal weight
                    ctx.font = `${Math.floor(10 * depthScale)}px Inter`;
                    ctx.fillText(enemy.species || 'Creature', enemy.x, speciesOffsetY);
                } else {
                    // Bosses: species in gray but BOLD
                    ctx.font = `bold ${Math.floor(10 * depthScale)}px Inter`;
                    ctx.fillText(enemy.species || 'Boss', enemy.x, speciesOffsetY);
                }
                
                // Background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(barX, barY, barWidth, barHeight);
                
                // HP fill (RED for enemies)
                const hpPercent = enemy.hp / enemy.maxHp;
                ctx.fillStyle = hpPercent > 0.5 ? '#E74C3C' : hpPercent > 0.25 ? '#C0392B' : '#A93226';
                ctx.fillRect(barX, barY, barWidth * hpPercent, barHeight);
                
                // HP text INSIDE bar (centered)
                ctx.fillStyle = '#FFFFFF';
                ctx.font = `bold ${Math.floor(10 * depthScale)}px JetBrains Mono`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(`${enemy.hp}/${enemy.maxHp}`, enemy.x, barY + barHeight / 2);
                ctx.textBaseline = 'alphabetic';  // Reset
                
                // Gold display BELOW HP bar (public ledger - they use Bitcoin/gold, not Zcash!)
                const goldAmount = enemy.goldDrop || 0;
                const goldY = barY + barHeight + (12 * depthScale);
                ctx.fillStyle = '#FFD700';  // Gold color
                ctx.font = `bold ${Math.floor(10 * depthScale)}px JetBrains Mono`;
                ctx.textAlign = 'center';
                ctx.fillText(`ðŸ’° ${goldAmount}`, enemy.x, goldY);
                
                // Highlight clickable enemies in targeting mode
                if (battleState.targetingMode && enemy.hostile) {
                    const depthScale = 0.6 + (enemy.y / canvas.height) * 0.4;
                    let highlightWidth, highlightHeight, highlightX, highlightY;
                    
                    if (enemy.isMob) {
                        const mobAspectRatio = 1344 / 768;
                        const baseHeight = 75;
                        const spriteHeight = baseHeight * depthScale;
                        const spriteWidth = spriteHeight * mobAspectRatio;
                        highlightWidth = spriteWidth + 20;
                        highlightHeight = spriteHeight + 20;
                        highlightX = enemy.x - highlightWidth / 2;
                        highlightY = enemy.y - highlightHeight / 2;
                    } else {
                        highlightWidth = 220 * depthScale;
                        highlightHeight = 220 * depthScale;
                        highlightX = enemy.x - highlightWidth / 2;
                        highlightY = enemy.y - highlightHeight / 2;
                    }
                    
                    // Pulsing glow effect
                    const pulseAlpha = 0.3 + Math.sin(Date.now() / 200) * 0.2;
                    ctx.strokeStyle = `rgba(255, 255, 0, ${pulseAlpha})`;
                    ctx.lineWidth = 4;
                    ctx.strokeRect(highlightX, highlightY, highlightWidth, highlightHeight);
                    
                    // Glow shadow
                    ctx.shadowColor = 'rgba(255, 255, 0, 0.8)';
                    ctx.shadowBlur = 20;
                    ctx.strokeRect(highlightX, highlightY, highlightWidth, highlightHeight);
                    ctx.shadowBlur = 0;
                }
            });
            
            // Draw captive NPC if present and not rescued (rendered like a mob)
            if (battleState.captiveNpc && !battleState.captiveNpc.rescued && battleState.captiveNpc.x > 0) {
                const captive = battleState.captiveNpc;
                const depthScale = 0.6 + (captive.y / canvas.height) * 0.4;
                
                // Draw captive sprite (static image) or fallback to colored circle
                if (captive.sprite && captive.sprite.complete && captive.sprite.naturalHeight !== 0) {
                    // Static captive image - use actual aspect ratio
                    const imgWidth = captive.sprite.naturalWidth;
                    const imgHeight = captive.sprite.naturalHeight;
                    const aspectRatio = imgWidth / imgHeight;
                    
                    // Scale to reasonable size (base height ~250px at full scale - 25% larger)
                    const baseHeight = 250;
                    const spriteHeight = baseHeight * depthScale;
                    const spriteWidth = spriteHeight * aspectRatio;
                    const spriteX = captive.x - spriteWidth / 2;
                    const spriteY = captive.y - spriteHeight;  // Bottom at captive.y
                    
                    ctx.save();
                    if (captive.facing === 'left') {
                        ctx.translate(captive.x, captive.y);
                        ctx.scale(-1, 1);
                        ctx.translate(-captive.x, -captive.y);
                    }
                    ctx.drawImage(captive.sprite, spriteX, spriteY, spriteWidth, spriteHeight);
                    ctx.restore();
                } else {
                    // Fallback to gold circle (like mobs fallback)
                    ctx.fillStyle = captive.color || '#F2C94C';
                    ctx.beginPath();
                    ctx.arc(captive.x, captive.y, 50 * depthScale, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    
                    // Add chain icon in center
                    ctx.fillStyle = '#8B4513';
                    ctx.font = `bold ${Math.floor(24 * depthScale)}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('â›“ï¸', captive.x, captive.y);
                }
                
                // Captive name and HP bar - positioned above sprite (same as enemies)
                const captiveBaseHeight = 250;
                const spriteHeight = captiveBaseHeight * depthScale;
                const barOffsetY = captive.y - spriteHeight - (5 * depthScale);
                
                // HP bar with text inside (if captive has HP)
                const barWidth = 80 * depthScale;
                const barHeight = 14 * depthScale;
                const barX = captive.x - barWidth / 2;
                const barY = barOffsetY;
                
                // Calculate label positions (build upward from HP bar - same as enemies)
                const speciesOffsetY = barY - (5 * depthScale);  // Species just above bar
                const nameOffsetY = speciesOffsetY - (12 * depthScale);  // Name above species
                
                // Name (GOLD for friendly)
                ctx.fillStyle = '#F2C94C';
                ctx.font = `bold ${Math.floor(14 * depthScale)}px Inter`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'alphabetic';
                ctx.fillText(captive.name.toUpperCase(), captive.x, nameOffsetY);
                
                // Species label below name
                ctx.fillStyle = '#27AE60';
                ctx.font = `${Math.floor(10 * depthScale)}px Inter`;
                ctx.fillText(`â›“ï¸ ${captive.species || 'Captive'}`, captive.x, speciesOffsetY);
                
                // Draw HP bar
                if (captive.hp && captive.maxHp) {
                    // Background
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(barX, barY, barWidth, barHeight);
                    
                    // HP fill (GREEN for friendly)
                    const hpPercent = captive.hp / captive.maxHp;
                    ctx.fillStyle = '#27AE60';
                    ctx.fillRect(barX, barY, barWidth * hpPercent, barHeight);
                    
                    // HP text INSIDE bar
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = `bold ${Math.floor(10 * depthScale)}px JetBrains Mono`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(`${captive.hp}/${captive.maxHp}`, captive.x, barY + barHeight / 2);
                    ctx.textBaseline = 'alphabetic';
                    
                    // Gold display BELOW HP bar (public ledger - NPCs also on transparent chain)
                    const goldAmount = captive.goldDrop || 0;
                    const goldY = barY + barHeight + (12 * depthScale);
                    ctx.fillStyle = '#FFD700';
                    ctx.font = `bold ${Math.floor(10 * depthScale)}px JetBrains Mono`;
                    ctx.textAlign = 'center';
                    ctx.fillText(`ðŸ’° ${goldAmount}`, captive.x, goldY);
                }
            }
            
            // Update and render particle system
            const now = performance.now();
            const deltaTime = particleSystem.lastTime ? now - particleSystem.lastTime : 16;
            particleSystem.lastTime = now;
            particleSystem.update(deltaTime);
            particleSystem.render(ctx);
            
            // Draw hitboxes if enabled
            if (settings.showHitboxes) {
                // Draw hero spawn area boxes (scaled with depth)
                battleState.heroes.forEach(hero => {
                    const depthScale = 0.6 + (hero.y / canvas.height) * 0.4;
                    const boxSize = 300 * depthScale;
                    ctx.strokeStyle = '#00FF00';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(hero.x - boxSize / 2, hero.y - boxSize / 2, boxSize, boxSize);
                    
                    // Draw center point (hero.x, hero.y)
                    ctx.fillStyle = '#00FF00';
                    ctx.beginPath();
                    ctx.arc(hero.x, hero.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw FLOOR CONTACT POINT - bottom center of hitbox where feet should touch
                    const floorY = hero.y + boxSize / 2;
                    ctx.fillStyle = '#FF00FF';
                    ctx.beginPath();
                    ctx.arc(hero.x, floorY, 8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Draw x/y coordinates at top of hitbox
                    const topY = hero.y - boxSize / 2 - 5;
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = 'bold 12px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(`x:${Math.round(hero.x)} y:${Math.round(hero.y)}`, hero.x, topY);
                });
                
                // Draw enemy spawn area boxes (scaled with depth)
                battleState.enemies.forEach(enemy => {
                    const depthScale = 0.6 + (enemy.y / canvas.height) * 0.4;
                    
                    let boxSize, boxY, topY;
                    if (enemy.isMob) {
                        // Mobs: hitbox matches sprite size (aspect ratio 1.75:1)
                        const mobAspectRatio = 1344 / 768;
                        // Use the stored random size scale
                        const sizeScale = enemy.sizeScale || 1.0;
                        const baseHeight = 75 * sizeScale;
                        const spriteHeight = baseHeight * depthScale;
                        const spriteWidth = spriteHeight * mobAspectRatio;
                        // Hitbox centered on enemy.y
                        ctx.strokeStyle = '#FF0000';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(enemy.x - spriteWidth / 2, enemy.y - spriteHeight / 2, spriteWidth, spriteHeight);
                        
                        // Draw center point at enemy.y
                        ctx.fillStyle = '#FF00FF';
                        ctx.beginPath();
                        ctx.arc(enemy.x, enemy.y, 8, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#FFFFFF';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        
                        // Top of hitbox for coordinates
                        topY = enemy.y - spriteHeight / 2 - 5;
                    } else {
                        // Bosses: hitbox from feet (enemy.y) upward to match sprite
                        const isLevel100 = enemy.spritePath && enemy.spritePath.includes('lvl100');
                        const sizeMultiplier = isLevel100 ? 2.0 : 1.0;
                        const boxHeight = 250 * depthScale * sizeMultiplier;
                        const boxWidth = boxHeight * ((enemy.sprite?.naturalWidth || 300) / (enemy.sprite?.naturalHeight || 300));
                        ctx.strokeStyle = '#FF0000';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(enemy.x - boxWidth / 2, enemy.y - boxHeight, boxWidth, boxHeight);
                        
                        // Draw floor contact point at enemy.y (feet)
                        ctx.fillStyle = '#FF00FF';
                        ctx.beginPath();
                        ctx.arc(enemy.x, enemy.y, 8, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#FFFFFF';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        
                        // Top of hitbox for coordinates
                        topY = enemy.y - boxHeight - 5;
                    }
                    
                    // Draw x/y coordinates at top of hitbox
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = 'bold 12px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(`x:${Math.round(enemy.x)} y:${Math.round(enemy.y)}`, enemy.x, topY);
                });
                
                // Draw platform hitboxes
                battleState.platforms.forEach(platform => {
                    ctx.strokeStyle = '#FFFF00';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(platform.x, platform.y, platform.w, platform.h);
                });
            }
        }
        
        // Update turn info display
        function updateBattleTurnInfo() {
            const currentHero = battleState.turnOrder[battleState.currentTurn];
            const turnInfo = document.getElementById('battleTurnInfo');
            
            // Safety check: currentHero can be undefined if turnOrder is empty or currentTurn is out of bounds
            if (!currentHero) {
                if (turnInfo) turnInfo.textContent = 'Waiting...';
                return;
            }
            
            if (turnInfo) {
                let turnText = `${currentHero.name.toUpperCase()}'S TURN`;
                
                // Multiplayer: Show if it's you or waiting
                if (multiplayerState.enabled) {
                    if (multiplayerState.role === 'client') {
                        if (multiplayerState.myHeroes.includes(currentHero.name.toLowerCase())) {
                            turnText += ' (YOU)';
                        } else {
                            turnText = `Waiting for ${currentHero.name.toUpperCase()}...`;
                        }
                    }
                }
                
                turnInfo.textContent = turnText;
            }
            
            // Update active hero card highlighting
            document.querySelectorAll('.battleHeroCard').forEach(card => card.classList.remove('active'));
            const activeCard = document.getElementById(`battleCard${currentHero.name}`);
            if (activeCard) activeCard.classList.add('active');
            
            // Trigger myturn animation if hero has one (plays once, returns to idle)
            if (battleState.heroes.includes(currentHero) && currentHero.hp > 0) {
                const heroKey = currentHero.name.toLowerCase();
                const paths = HERO_ANIM_PATHS[heroKey];
                if (paths && paths.myturn) {
                    setAnimationState(currentHero, 'myturn', 'once', () => {
                        setAnimationState(currentHero, 'idle', 'pingpong');
                    });
                }
            }
            
            // Disable/enable buttons based on turn in multiplayer
            if (multiplayerState.enabled) {
                const isMyTurn = multiplayerState.myHeroes.includes(currentHero.name.toLowerCase());
                document.querySelectorAll('.battleButton').forEach(btn => {
                    // Always allow retreat/leave and talk buttons
                    if (btn.textContent.includes('RETREAT') || btn.textContent.includes('LEAVE') || btn.textContent.includes('TALK')) return;
                    btn.disabled = !isMyTurn;
                    btn.style.opacity = isMyTurn ? '1' : '0.3';
                });
            }
        }
        
        // Update gold display in both dungeon menu and battle screen
        function updateGoldDisplay() {
            let gold = 0;
            
            // Clients use cached gold from host, host/single-player use localStorage
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                gold = multiplayerState.goldCache || 0;
            } else {
                const sharedSave = loadSharedSave();
                gold = sharedSave?.dungeonState?.gold || 0;
            }
            
            const dungeonMenuGold = document.getElementById('dungeonMenuGold');
            const battleGold = document.getElementById('battleGold');
            
            if (dungeonMenuGold) dungeonMenuGold.textContent = gold;
            if (battleGold) battleGold.textContent = gold;
            
            // Update shielded store gold display (if revealed)
            updateStoreGoldDisplay();
        }
        
        // Update battle hero card stats
        function updateBattleHeroCards() {
            // Include all heroes from original selection (alive or dead)
            const allHeroNames = ['nate', 'zooko', 'cyberaxe', 'zancas'];
            
            allHeroNames.forEach(heroName => {
                const hero = battleState.heroes.find(h => h.name.toLowerCase() === heroName);
                const card = document.getElementById(`battleCard${heroName.charAt(0).toUpperCase() + heroName.slice(1)}`);
                
                if (card) {
                    // Grey out if hero is dead/retreated
                    if (!hero || hero.hp <= 0 || hero.retreated) {
                        card.style.opacity = '0.3';
                        card.style.filter = 'grayscale(100%)';
                    } else {
                        card.style.opacity = '1';
                        card.style.filter = 'none';
                    }
                }
                
                if (!hero) return; // Skip if hero not in battle
                
                const hpEl = document.getElementById(`b${heroName}-hp`);
                const maxHpEl = document.getElementById(`b${heroName}-maxhp`);
                const acEl = document.getElementById(`b${heroName}-ac`);
                const xpEl = document.getElementById(`b${heroName}-xp`);
                const healsEl = document.getElementById(`b${heroName}-heals`);
                
                if (hpEl) hpEl.textContent = hero.hp;
                if (maxHpEl) maxHpEl.textContent = hero.maxHp;
                if (acEl) acEl.textContent = hero.stats.ac || 10;
                if (xpEl) xpEl.textContent = hero.xp || 0;
                
                // Update level display
                const levelEl = document.getElementById(`b${heroName}-level`);
                if (levelEl) levelEl.textContent = hero.level || 1;
                
                // Update heal potions display (now stacked vertically)
                if (healsEl) {
                    const healsRemaining = hero.healsRemaining || 0;
                    let potionsHTML = '';
                    for (let i = 0; i < 2; i++) {
                        if (i < healsRemaining) {
                            potionsHTML += '<img src="tunnelsofprivacy/items/healing_potions_a_cropped.png" style="width:26px;height:26px;display:block;margin-bottom:3px;">';
                        } else {
                            potionsHTML += '<img src="tunnelsofprivacy/items/healing_potions_a_empty.png" style="width:26px;height:26px;display:block;margin-bottom:3px;opacity:0.3;">';
                        }
                    }
                    healsEl.innerHTML = potionsHTML;
                }
                
                // Update weapon slot with enchantment glow
                const weaponSlot = document.getElementById(`b${heroName}-weapon`);
                if (weaponSlot) {
                    const weaponStats = getWeaponStats(heroName);
                    if (weaponStats) {
                        const enchantGlow = weaponStats.enchantment 
                            ? `filter: drop-shadow(0 0 4px ${weaponStats.enchantment.color}) drop-shadow(0 0 8px ${weaponStats.enchantment.color});` 
                            : '';
                        weaponSlot.innerHTML = `<img src="${weaponStats.icon}" alt="${weaponStats.fullName}" style="width: 80%; height: 80%; object-fit: contain; ${enchantGlow}">`;
                        weaponSlot.title = `${weaponStats.fullName}\nDMG: ${weaponStats.damage} | DEF: ${weaponStats.defense} | CRIT: ${weaponStats.crit}%${weaponStats.enchantment ? '\nâœ¨ ' + weaponStats.enchantment.name : ''}`;
                    }
                }
            });
            
            // Setup tooltips for battle equipment slots
            setupBattleWeaponTooltips();
        }
        
        // Setup weapon tooltips for battle hero cards
        function setupBattleWeaponTooltips() {
            const tooltip = document.getElementById('weaponTooltip');
            if (!tooltip) return;
            
            document.querySelectorAll('.battleEquipSlot[data-slottype="weapon"]').forEach(slot => {
                // Remove existing listeners to prevent duplicates
                slot.removeEventListener('mouseenter', slot._tooltipEnter);
                slot.removeEventListener('mouseleave', slot._tooltipLeave);
                
                slot._tooltipEnter = (e) => {
                    e.stopPropagation();
                    const heroName = slot.dataset.hero;
                    if (!heroName) return;
                    
                    // Hide info tooltip if showing
                    hideTooltip();
                    
                    tooltip.innerHTML = getWeaponTooltipHTML(heroName);
                    tooltip.style.opacity = '1';
                    
                    const rect = slot.getBoundingClientRect();
                    const tooltipWidth = 240;
                    
                    // Position tooltip above the slot
                    let left = rect.left + (rect.width / 2) - (tooltipWidth / 2);
                    if (left < 10) left = 10;
                    if (left + tooltipWidth > window.innerWidth - 10) {
                        left = window.innerWidth - tooltipWidth - 10;
                    }
                    
                    tooltip.style.left = left + 'px';
                    tooltip.style.top = (rect.top - 180) + 'px';
                };
                
                slot._tooltipLeave = () => {
                    tooltip.style.opacity = '0';
                };
                
                slot.addEventListener('mouseenter', slot._tooltipEnter);
                slot.addEventListener('mouseleave', slot._tooltipLeave);
            });
        }
        
        // Update battle enemy cards
        function updateBattleEnemyCards() {
            const container = document.getElementById('battleEnemyCards');
            if (!container) return;
            
            // Sort enemies: bosses first, then mobs
            const sortedEnemies = [...battleState.enemies].sort((a, b) => {
                if (a.isMob === b.isMob) return 0;
                return a.isMob ? 1 : -1; // Bosses (isMob=false) first
            });
            
            // Count total cards including captive
            const totalCards = sortedEnemies.length + (battleState.captiveNpc && !battleState.captiveNpc.rescued ? 1 : 0);
            
            // Set 3-column layout if more than 8 cards to prevent overlap with music controls
            if (totalCards > 8) {
                container.classList.add('threeColumns');
            } else {
                container.classList.remove('threeColumns');
            }
            
            // Clear and rebuild cards
            container.innerHTML = '';
            
            sortedEnemies.forEach((enemy, index) => {
                const card = document.createElement('div');
                card.className = 'battleEnemyCard';
                card.id = `enemyCard${index}`;
                card.dataset.enemyIndex = battleState.enemies.indexOf(enemy);
                
                // Check if this mob has betrayed and is now friendly
                const isBetrayed = enemy.negotiationState?.betrayed || !enemy.hostile;
                
                if (!enemy.isMob) {
                    card.classList.add('boss');
                }
                
                if (enemy.hp <= 0) {
                    card.classList.add('dead');
                }
                
                // Style betrayed mobs as friendly (green)
                if (isBetrayed && !enemy.isBoss) {
                    card.classList.add('friendly');
                    card.style.borderColor = '#00FF00';
                    card.style.boxShadow = '0 0 15px rgba(0, 255, 0, 0.4)';
                }
                
                // Add targetable class if in targeting mode and hostile
                if (battleState.targetingMode && enemy.hostile && enemy.hp > 0) {
                    card.classList.add('targetable');
                }
                
                // Portrait
                const portrait = document.createElement('div');
                portrait.className = 'battleEnemyPortrait';
                portrait.style.backgroundImage = `url('${enemy.spritePath}')`;
                // Green border for betrayed mobs
                if (isBetrayed && !enemy.isBoss) {
                    portrait.style.borderColor = '#00FF00';
                }
                card.appendChild(portrait);
                
                // Name - add ally indicator for betrayed mobs
                const name = document.createElement('div');
                name.className = 'battleEnemyName';
                if (isBetrayed && !enemy.isBoss) {
                    name.innerHTML = `ðŸ¤ ${enemy.name.toUpperCase()}`;
                    name.style.color = '#00FF00';
                } else {
                    name.textContent = enemy.name.toUpperCase();
                }
                card.appendChild(name);
                
                // HP stat - green for betrayed mobs
                const hpStat = document.createElement('div');
                hpStat.className = 'battleEnemyStat';
                hpStat.style.color = isBetrayed && !enemy.isBoss ? '#00FF00' : '#ff6b6b';
                hpStat.innerHTML = `HP: <span>${enemy.hp}</span>/<span>${enemy.maxHp}</span>`;
                card.appendChild(hpStat);
                
                // AC stat
                const acStat = document.createElement('div');
                acStat.className = 'battleEnemyStat';
                acStat.innerHTML = `AC: <span>${enemy.ac || 10}</span>`;
                card.appendChild(acStat);
                
                // Gold stat (public ledger - enemies use Bitcoin/gold, not Zcash!)
                const goldStat = document.createElement('div');
                goldStat.className = 'battleEnemyStat';
                goldStat.style.color = '#FFD700';
                goldStat.innerHTML = `ðŸ’° <span>${enemy.goldDrop || 0}</span>`;
                card.appendChild(goldStat);
                
                // Click handler for targeting
                card.addEventListener('click', () => {
                    if (battleState.targetingMode && enemy.hostile && enemy.hp > 0) {
                        const attacker = battleState.turnOrder[battleState.currentTurn];
                        executeAttack(attacker, enemy, battleState.pendingAction);
                        
                        // Exit targeting mode
                        battleState.targetingMode = false;
                        battleState.pendingAction = null;
                        document.getElementById('battleCanvas').style.cursor = 'default';
                        updateBattleEnemyCards(); // Refresh to remove targetable class
                    }
                });
                
                // Hover to show privacy breach tooltip (hold for 0.3s)
                let privacyTimeout = null;
                card.addEventListener('mouseenter', (e) => {
                    privacyTimeout = setTimeout(() => {
                        showEnemyPrivacyTooltip(e, enemy);
                    }, 300);
                });
                card.addEventListener('mousemove', (e) => {
                    updateEnemyPrivacyTooltipPosition(e);
                });
                card.addEventListener('mouseleave', () => {
                    clearTimeout(privacyTimeout);
                    hideEnemyPrivacyTooltip();
                });
                
                container.appendChild(card);
            });
            
            // Add captive card if present and not rescued
            if (battleState.captiveNpc && !battleState.captiveNpc.rescued) {
                const captive = battleState.captiveNpc;
                const card = document.createElement('div');
                card.className = 'battleEnemyCard captive';
                card.id = 'captiveCard';
                
                // Portrait
                const portrait = document.createElement('div');
                portrait.className = 'battleEnemyPortrait';
                portrait.style.backgroundImage = `url('${captive.spritePath}')`;
                card.appendChild(portrait);
                
                // Name with chain emoji
                const name = document.createElement('div');
                name.className = 'battleEnemyName';
                name.textContent = `â›“ï¸ ${captive.name.toUpperCase()}`;
                card.appendChild(name);
                
                // HP stat
                const hpStat = document.createElement('div');
                hpStat.className = 'battleEnemyStat';
                hpStat.style.color = '#27AE60';
                hpStat.innerHTML = `HP: <span>${captive.hp || '?'}</span>/<span>${captive.maxHp || '?'}</span>`;
                card.appendChild(hpStat);
                
                // AC stat
                const acStat = document.createElement('div');
                acStat.className = 'battleEnemyStat';
                acStat.innerHTML = `AC: <span>${captive.ac || 10}</span>`;
                card.appendChild(acStat);
                
                // Gold stat (captive's reward - public on Bitcoin/gold network!)
                const goldStat = document.createElement('div');
                goldStat.className = 'battleEnemyStat';
                goldStat.style.color = '#FFD700';
                goldStat.innerHTML = `ðŸ’° <span>${captive.goldReward || 0}</span>`;
                card.appendChild(goldStat);
                
                // "CAPTIVE" label
                const label = document.createElement('div');
                label.className = 'battleEnemyStat';
                label.style.color = '#F2C94C';
                label.style.fontWeight = 'bold';
                label.textContent = 'CAPTIVE';
                card.appendChild(label);
                
                // Hover-to-enlarge functionality (hold for 0.5s)
                let hoverTimeout = null;
                card.addEventListener('mouseenter', () => {
                    hoverTimeout = setTimeout(() => {
                        const rect = card.getBoundingClientRect();
                        card.style.position = 'fixed';
                        card.style.left = rect.left + 'px';
                        card.style.top = rect.top + 'px';
                        card.classList.add('enlarged');
                    }, 500);
                });
                card.addEventListener('mouseleave', () => {
                    clearTimeout(hoverTimeout);
                    card.classList.remove('enlarged');
                    card.style.position = '';
                    card.style.left = '';
                    card.style.top = '';
                });
                
                container.appendChild(card);
            }
        }
        
        // D&D modifier calculation
        function calculateModifier(stat) {
            return Math.floor((stat - 10) / 2);
        }
        
        // Find closest hero to an enemy
        function findClosestHero(enemy, heroes) {
            let target = heroes[0];
            let minDistance = Math.sqrt(Math.pow(enemy.x - target.x, 2) + Math.pow(enemy.y - target.y, 2));
            
            for (let i = 1; i < heroes.length; i++) {
                const hero = heroes[i];
                const distance = Math.sqrt(Math.pow(enemy.x - hero.x, 2) + Math.pow(enemy.y - hero.y, 2));
                if (distance < minDistance) {
                    minDistance = distance;
                    target = hero;
                }
            }
            return target;
        }
        
        // Dice rolling functions
        function rollD20() {
            return Math.floor(Math.random() * 20) + 1;
        }
        
        function rollD6(count = 1) {
            let total = 0;
            for (let i = 0; i < count; i++) {
                total += Math.floor(Math.random() * 6) + 1;
            }
            return total;
        }
        
        // Dice roll ticker system
        let diceRollTickerInterval = null;
        const diceRollTickerMessages = [
            'â³ ...Waiting to Roll... â³',
            'ðŸŽ® ...Tunnels of Privacy... ðŸŽ®',
            '...Created by CyberAxe for Zcash...'
        ];
        let diceRollTickerIndex = 0;
        let diceRollTickerCharIndex = 0;
        let currentMessage = '';
        
        function startDiceRollTicker() {
            if (diceRollTickerInterval) return; // Already running
            const display = document.getElementById('diceRollDisplay');
            if (display) {
                display.style.overflow = 'visible';
                display.style.whiteSpace = 'normal';
            }
            
            // Waterfall effect: reveal text from center outward
            diceRollTickerInterval = setInterval(() => {
                const display = document.getElementById('diceRollDisplay');
                if (display) {
                    const message = diceRollTickerMessages[diceRollTickerIndex];
                    const totalLength = message.length;
                    
                    if (diceRollTickerCharIndex < totalLength) {
                        // Build text from center outward
                        const center = Math.floor(totalLength / 2);
                        const revealRadius = Math.floor(diceRollTickerCharIndex / 2);
                        
                        let visibleText = '';
                        for (let i = 0; i < totalLength; i++) {
                            const distanceFromCenter = Math.abs(i - center);
                            if (distanceFromCenter <= revealRadius) {
                                visibleText += message[i];
                            } else {
                                visibleText += ' ';
                            }
                        }
                        
                        display.innerHTML = visibleText;
                        diceRollTickerCharIndex++;
                    } else {
                        // Hold full message for 2 seconds
                        if (diceRollTickerCharIndex === totalLength) {
                            display.innerHTML = message;
                        }
                        diceRollTickerCharIndex++;
                        
                        // After holding, move to next message
                        if (diceRollTickerCharIndex > totalLength + 13) { // 13 frames * 150ms â‰ˆ 2 seconds
                            diceRollTickerIndex = (diceRollTickerIndex + 1) % diceRollTickerMessages.length;
                            diceRollTickerCharIndex = 0;
                        }
                    }
                }
            }, 150);
        }
        
        function stopDiceRollTicker() {
            if (diceRollTickerInterval) {
                clearInterval(diceRollTickerInterval);
                diceRollTickerInterval = null;
                diceRollTickerIndex = 0;
                diceRollTickerCharIndex = 0;
            }
        }
        
        // Display dice roll result
        function showDiceRoll(text) {
            const display = document.getElementById('diceRollDisplay');
            if (display) {
                stopDiceRollTicker();
                display.style.overflow = 'visible';
                display.style.whiteSpace = 'normal';
                display.innerHTML = text;
                display.style.display = 'block';
                setTimeout(() => {
                    display.style.overflow = 'hidden';
                    display.style.whiteSpace = 'nowrap';
                    diceRollTickerPosition = 0;
                    startDiceRollTicker();
                }, 3000);
            }
        }
        
        // Show battle notification banner
        function showBattleNotification(text) {
            const notification = document.getElementById('battleNotification');
            if (notification) {
                notification.textContent = text;
                notification.style.display = 'block';
                setTimeout(() => {
                    notification.style.display = 'none';
                }, 3000);
            }
        }
        
        // Confirmation modal system
        let confirmationCallback = null;
        
        function showConfirmation(title, message, callback) {
            document.getElementById('confirmationTitle').textContent = title;
            document.getElementById('confirmationMessage').textContent = message;
            confirmationCallback = callback;
            document.getElementById('confirmationModal').style.display = 'block';
        }
        
        function confirmModalAction(confirmed) {
            document.getElementById('confirmationModal').style.display = 'none';
            if (confirmationCallback) {
                confirmationCallback(confirmed);
                confirmationCallback = null;
            }
        }
        
        // Handle battle actions
        function battleAction(action) {
            if (action === 'retreat') {
                // Check if battle is won (leave instead of retreat)
                if (battleState.won && multiplayerState.enabled) {
                    // Only host can leave after victory - clients wait
                    if (multiplayerState.role === 'host') {
                        // Host clicked leave - end battle for everyone
                        sendWebSocketMessage({ type: 'battle_end', reason: 'victory' });
                        setTimeout(() => {
                            endBattle();
                        }, 1000);
                    } else {
                        // Client clicked leave - show persistent message to wait for host
                        const notification = document.getElementById('battleNotification');
                        if (notification) {
                            notification.textContent = 'Waiting for host to leave...';
                            notification.style.display = 'block';
                        }
                    }
                    return;
                }
                
                // SIMPLIFIED RETREAT: Host retreats = everyone retreats immediately
                if (multiplayerState.enabled) {
                    if (multiplayerState.role === 'host') {
                        // Host retreat - force everyone to retreat
                        showBattleNotification('PARTY RETREATS!');
                        
                        // Save current hero stats before ending
                        battleState.allHeroes = [...battleState.heroes];
                        
                        // Notify all clients to end battle immediately
                        sendWebSocketMessage({
                            type: 'battle_end',
                            reason: 'retreat',
                            heroStats: battleState.heroes.map(h => ({
                                name: h.name,
                                hp: h.hp,
                                maxHp: h.maxHp
                            }))
                        });
                        
                        setTimeout(() => {
                            const notification = document.getElementById('battleNotification');
                            if (notification) notification.style.display = 'none';
                            endBattle();
                        }, 1500);
                    }
                    // Client retreat button is disabled - shouldn't reach here
                } else {
                    // Single player - just end battle
                    endBattle();
                }
                return;
            }
            
            // Talk action - toggle chat window (no turn cost, can use anytime)
            if (action === 'talk') {
                toggleChatWindow();
                return;
            }
            
            const currentCombatant = battleState.turnOrder[battleState.currentTurn];
            
            // Check if it's a hero's turn
            const isHeroTurn = battleState.heroes.includes(currentCombatant);
            
            if (!isHeroTurn) {
                console.log('Not hero turn');
                return;
            }
            
            // Multiplayer: Check if this is my hero
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                if (!multiplayerState.myHeroes.includes(currentCombatant.name.toLowerCase())) {
                    showDiceRoll('Not your turn!');
                    return;
                }
            }
            
            // Check if hero is disabled (0 HP)
            if (currentCombatant.hp <= 0) {
                showDiceRoll(`${currentCombatant.name} is disabled!`);
                advanceTurn();
                return;
            }
            
            // Reset defending state when hero takes a new action
            if (currentCombatant.defending) {
                currentCombatant.defending = false;
                // Reset from defend animation to idle
                const heroKey = currentCombatant.name.toLowerCase();
                const paths = HERO_ANIM_PATHS[heroKey];
                if (paths && paths.defend) {
                    setAnimationState(currentCombatant, 'idle', 'pingpong');
                }
            }
            
            // Enter targeting mode for attacks
            if (action === 'light' || action === 'heavy' || action === 'special') {
                // Multiplayer: Client enters targeting mode but won't execute until host confirms
                battleState.targetingMode = true;
                battleState.pendingAction = action;
                // Show targeting UI feedback
                document.getElementById('battleCanvas').style.cursor = 'crosshair';
                // Highlight enemies on canvas and cards
                updateBattleEnemyCards();
                renderBattle();
                return;
            }
            
            // Defend action - reduce damage by 50% until next turn
            if (action === 'defend') {
                // Multiplayer: Client sends to host
                if (multiplayerState.enabled && multiplayerState.role === 'client') {
                    sendWebSocketMessage({
                        type: 'player_action',
                        action: 'defend',
                        hero: currentCombatant.name
                    });
                    return;
                }
                
                currentCombatant.defending = true;
                
                // Trigger defend animation (ping-pong while defending)
                const heroKey = currentCombatant.name.toLowerCase();
                const paths = HERO_ANIM_PATHS[heroKey];
                if (paths && paths.defend) {
                    setAnimationState(currentCombatant, 'defend', 'pingpong');
                }
                
                showDiceRoll(`${currentCombatant.name} defends!`);
                advanceTurn();
                return;
            }
            
            // Heal action - restore 50% of max HP (costs 1 action point)
            if (action === 'heal') {
                if (currentCombatant.healsRemaining <= 0) {
                    showDiceRoll(`${currentCombatant.name} has no heals left!`);
                    return;
                }
                
                // Multiplayer: Client sends to host
                if (multiplayerState.enabled && multiplayerState.role === 'client') {
                    sendWebSocketMessage({
                        type: 'player_action',
                        action: 'heal',
                        hero: currentCombatant.name
                    });
                    return;
                }
                
                const healAmount = Math.floor(currentCombatant.maxHp * 0.5);
                currentCombatant.hp = Math.min(currentCombatant.maxHp, currentCombatant.hp + healAmount);
                currentCombatant.healsRemaining--;
                currentCombatant.usedHeal = true; // Mark that heal was used this turn
                
                // Hide a potion sprite (consume the rightmost visible one)
                if (currentCombatant.potions) {
                    for (let i = currentCombatant.potions.length - 1; i >= 0; i--) {
                        if (currentCombatant.potions[i].visible) {
                            currentCombatant.potions[i].visible = false;
                            break;
                        }
                    }
                }
                
                // Trigger heal animation if hero has one (plays once, returns to idle)
                const heroKey = currentCombatant.name.toLowerCase();
                const paths = HERO_ANIM_PATHS[heroKey];
                if (paths && paths.heal) {
                    setAnimationState(currentCombatant, 'heal', 'once', () => {
                        setAnimationState(currentCombatant, 'idle', 'pingpong');
                    });
                }
                // Play hero heal sound
                playSfx(heroKey + 'Heal');
                
                showDiceRoll(`${currentCombatant.name} heals for ${healAmount} HP! (1 action used)`);
                updateBattleHeroCards();
                
                // Disable heavy and special buttons after heal
                document.getElementById('battleHeavyBtn').disabled = true;
                document.getElementById('battleHeavyBtn').style.opacity = '0.5';
                document.getElementById('battleSpecialBtn').disabled = true;
                document.getElementById('battleSpecialBtn').style.opacity = '0.5';
                
                // Host broadcasts state
                if (multiplayerState.enabled && multiplayerState.role === 'host') {
                    broadcastGameState();
                }
                
                return; // Don't advance turn
            }
            
            // Swap action - swap positions with another hero
            if (action === 'swap') {
                // Multiplayer: Client enters swap targeting mode
                battleState.swapTargetingMode = true;
                battleState.swapInitiator = currentCombatant;
                document.getElementById('battleCanvas').style.cursor = 'pointer';
                showDiceRoll(`${currentCombatant.name}: Select a hero to swap with`);
                renderBattle();
                return;
            }
            
            // Taunt action - draw enemy aggro with CHA check
            if (action === 'taunt') {
                // Multiplayer: Client sends to host
                if (multiplayerState.enabled && multiplayerState.role === 'client') {
                    sendWebSocketMessage({
                        type: 'player_action',
                        action: 'taunt',
                        hero: currentCombatant.name
                    });
                    return;
                }
                
                const chaModifier = calculateModifier(currentCombatant.stats?.cha || 10);
                const tauntRoll = rollD20() + chaModifier;
                const tauntDC = 12; // Base difficulty
                
                // Trigger taunt animation if hero has one (plays once, returns to idle)
                const heroKey = currentCombatant.name.toLowerCase();
                const paths = HERO_ANIM_PATHS[heroKey];
                if (paths && paths.taunt) {
                    setAnimationState(currentCombatant, 'taunt', 'once', () => {
                        setAnimationState(currentCombatant, 'idle', 'pingpong');
                    });
                }
                // Play hero taunt sound
                playSfx(heroKey + 'Taunt');
                
                if (tauntRoll >= tauntDC) {
                    currentCombatant.taunting = true;
                    currentCombatant.tauntTurns = 3; // Lasts 3 turns
                    showDiceRoll(`${currentCombatant.name} taunts! d20(${tauntRoll}) SUCCESS!`);
                } else {
                    showDiceRoll(`${currentCombatant.name} taunt fails! d20(${tauntRoll}) vs DC ${tauntDC}`);
                }
                advanceTurn();
                
                // Host broadcasts state
                if (multiplayerState.enabled && multiplayerState.role === 'host') {
                    broadcastGameState();
                }
                return;
            }
            
            // Skip action - end turn without doing anything
            if (action === 'skip') {
                // Multiplayer: Client sends to host
                if (multiplayerState.enabled && multiplayerState.role === 'client') {
                    sendWebSocketMessage({
                        type: 'player_action',
                        action: 'skip',
                        hero: currentCombatant.name
                    });
                    return;
                }
                
                showDiceRoll(`${currentCombatant.name} skips turn.`);
                advanceTurn();
                
                // Host broadcasts state
                if (multiplayerState.enabled && multiplayerState.role === 'host') {
                    broadcastGameState();
                }
                return;
            }
        }
        
        // Execute attack on target
        function executeAttack(attacker, target, actionType) {
            // Check if hero has attack animation
            const isHero = battleState.heroes.includes(attacker);
            const heroKey = isHero ? attacker.name.toLowerCase() : null;
            const animState = actionType + '_attack'; // 'light_attack', 'heavy_attack', 'special_attack'
            const paths = heroKey ? HERO_ANIM_PATHS[heroKey] : null;
            const hasAnimation = paths && paths[animState];
            
            // Trigger attack animation if hero has one
            if (hasAnimation) {
                setAnimationState(attacker, animState, 'once', () => {
                    setAnimationState(attacker, 'idle', 'pingpong');
                });
            }
            
            // Spawn projectile particle effect for light attacks (hero-specific effects)
            if (isHero && actionType === 'light') {
                // Get per-hero projectile offset
                const heroName = attacker.name.toLowerCase();
                const projOffset = heroProjectileOffsets[heroName] || { x: 0, y: 0 };
                const lightAttackEffect = `tunnelsofprivacy/effects/heros/${heroName}_light_attack.json`;
                const enchantColor = getHeroEnchantmentColor(heroName);
                
                // Spawn projectile from hero to target
                particleSystem.spawnProjectile(
                    lightAttackEffect,
                    attacker.x + projOffset.x,
                    attacker.y - 50 + projOffset.y, // Base offset + per-hero offset
                    target.x,
                    target.y - 30, // Offset up from target feet
                    { scale: 1.0, duration: 1.5, colorOverride: enchantColor }
                );
            }
            
            // Spawn rising particle effect for heavy attacks (spawn at target, rise upward)
            if (isHero && actionType === 'heavy') {
                const heroName = attacker.name.toLowerCase();
                const heavyAttackEffect = `tunnelsofprivacy/effects/heros/${heroName}_heavy_attack.json`;
                const enchantColor = getHeroEnchantmentColor(heroName);
                
                // Spawn at target's feet (bottom of hitbox), particles rise upward off screen
                // target.y is center of sprite, add ~150px to get to feet (half of ~300px sprite height)
                particleSystem.spawnRising(
                    heavyAttackEffect,
                    target.x,
                    target.y + 120, // Bottom of target sprite (feet)
                    { scale: 1.2, duration: 2.5, riseDistance: 400, colorOverride: enchantColor }
                );
            }
            
            // Spawn special attack particles on BOTH hero and target simultaneously
            if (isHero && actionType === 'special') {
                const heroName = attacker.name.toLowerCase();
                const specialAttackEffect = `tunnelsofprivacy/effects/heros/${heroName}_special_attack.json`;
                const enchantColor = getHeroEnchantmentColor(heroName);
                
                // Spawn on the hero (centered on hero sprite)
                particleSystem.spawn(
                    specialAttackEffect,
                    attacker.x,
                    attacker.y - 50, // Slightly above center
                    { scale: 1.5, colorOverride: enchantColor }
                );
                
                // Spawn on the target (centered on target sprite)
                particleSystem.spawn(
                    specialAttackEffect,
                    target.x,
                    target.y - 30, // Slightly above center
                    { scale: 1.5, colorOverride: enchantColor }
                );
            }
            
            // Delay attack logic to sync with animation (2 seconds)
            const delay = hasAnimation ? 2000 : 0;
            
            setTimeout(() => {
                executeAttackLogic(attacker, target, actionType);
            }, delay);
        }
        
        // Actual attack logic (separated for animation delay)
        function executeAttackLogic(attacker, target, actionType) {
            const attackerStats = attacker.stats || {};
            const str = attackerStats.str || 10;
            const dex = attackerStats.dex || 10;
            const wis = attackerStats.wis || 10;
            
            // Get weapon stats for heroes
            let weaponDamage = 0;
            let weaponCrit = 0;
            const attackerKey = attacker.name?.toLowerCase();
            if (attackerKey && HERO_WEAPONS[attackerKey]) {
                const weaponStats = getWeaponStats(attackerKey);
                if (weaponStats) {
                    weaponDamage = weaponStats.damage;
                    weaponCrit = weaponStats.crit;
                }
            }
            
            let attackRoll = rollD20();
            let modifier = 0;
            let damageRoll = 0;
            let attackName = '';
            let isCritical = false;
            
            // Check for critical hit based on weapon crit chance
            if (weaponCrit > 0 && Math.random() * 100 < weaponCrit) {
                isCritical = true;
            }
            
            // Calculate attack and damage based on action type
            if (actionType === 'light') {
                modifier = calculateModifier(dex);
                attackRoll += calculateModifier(str);
                damageRoll = rollD6(1) + modifier + weaponDamage;
                attackName = 'Light Attack';
            }
            
            // Play hero attack sound (if attacker is a hero)
            if (battleState.heroes.includes(attacker)) {
                playHeroAttackSfx(attacker.name, actionType);
            }
            
            if (actionType === 'heavy') {
                modifier = calculateModifier(str);
                attackRoll += modifier;
                damageRoll = rollD6(2) + modifier + weaponDamage;
                attackName = 'Heavy Attack';
            } else if (actionType === 'special') {
                modifier = calculateModifier(wis);
                attackRoll += modifier;
                damageRoll = rollD6(3) + modifier + weaponDamage;
                attackName = 'Special Attack';
            }
            
            // Apply critical hit bonus (double damage)
            if (isCritical) {
                damageRoll *= 2;
            }
            
            // Check if attack hits
            const targetAC = target.ac || 10;
            
            // Award 1 XP for attempting attack
            attacker.xp = (attacker.xp || 0) + 1;
            
            if (attackRoll >= targetAC) {
                // Apply defending reduction
                if (target.defending) {
                    damageRoll = Math.floor(damageRoll / 2);
                    target.defending = false;
                    
                    // Award 3 XP to defender for successfully defending
                    if (battleState.heroes.includes(target)) {
                        target.xp = (target.xp || 0) + 3;
                    }
                }
                
                // Apply weapon defense reduction for heroes being attacked
                const targetKey = target.name?.toLowerCase();
                if (targetKey && HERO_WEAPONS[targetKey]) {
                    const targetWeaponStats = getWeaponStats(targetKey);
                    if (targetWeaponStats && targetWeaponStats.defense > 0) {
                        damageRoll = Math.max(1, damageRoll - targetWeaponStats.defense);
                    }
                }
                
                // Store final damage for display
                const finalDamage = damageRoll;
                
                target.hp = Math.max(0, target.hp - finalDamage);
                
                // Spawn hit particle effect at target position
                if (target.x && target.y) {
                    const depthScale = 0.6 + (target.y / (battleState.canvas?.height || 720)) * 0.4;
                    
                    // Use hero-specific special effects for special attacks
                    if (actionType === 'special' && battleState.heroes.includes(attacker)) {
                        const heroName = attacker.name.toLowerCase();
                        const specialEffects = {
                            zooko: 'zooko_special',
                            nate: 'nate_special',
                            zancas: 'zancas_special',
                            cyberaxe: 'cyberaxe_electric'
                        };
                        const effectName = specialEffects[heroName] || 'combo_a';
                        spawnParticleEffect(effectName, target.x, target.y, depthScale * 1.5);
                        // Add break effect too for extra impact
                        spawnParticleEffect('red_break_a', target.x, target.y, depthScale);
                    } else {
                        // Regular attack - random break effect
                        const breakEffects = ['red_break_a', 'red_break_b', 'red_break_c', 'blue_break_a', 'yellow_break_a'];
                        const effectName = breakEffects[Math.floor(Math.random() * breakEffects.length)];
                        spawnParticleEffect(effectName, target.x, target.y, depthScale);
                    }
                }
                
                // Update boss morale when they take damage
                if (target.isBoss) {
                    updateBossMorale(target, 'took_damage');
                }
                
                // Play enemy hit sound if target is enemy
                if (battleState.enemies.includes(target)) {
                    playEnemySfx(target, 'hit');
                }
                
                // Trigger free will chat for damaged enemy
                if (battleState.enemies.includes(target) && target.hp > 0) {
                    if (target.hp < target.maxHp * 0.3) {
                        triggerFreeWillChat(target, 'low_health');
                    } else {
                        triggerFreeWillChat(target, 'took_damage');
                    }
                }
                
                // Trigger free will chat for attacker if enemy dealt damage
                if (battleState.enemies.includes(attacker)) {
                    triggerFreeWillChat(attacker, 'dealt_damage');
                }
                
                // Calculate XP multiplier based on dungeon level (same formula as gold)
                const dungeonLevel = battleState.currentLevel || 1;
                const xpMultiplier = 1 + (dungeonLevel - 1) * 0.25; // +25% per level (half of gold scaling)
                
                // Award XP for hitting, bonus for crit - scaled by dungeon level
                const baseXP = isCritical ? 5 : 2;
                const scaledXP = Math.floor(baseXP * xpMultiplier);
                attacker.xp += scaledXP;
                
                // Generate dice rolls for display
                const numDice = actionType === 'light' ? 1 : (actionType === 'heavy' ? 2 : 3);
                const diceRolls = [];
                for (let i = 0; i < numDice; i++) {
                    diceRolls.push(Math.floor(Math.random() * 6) + 1);
                }
                const diceTotal = diceRolls.reduce((a, b) => a + b, 0);
                const critText = isCritical ? ' <span style="color:#FFD700; font-weight:bold;">ðŸ’¥ CRITICAL!</span>' : '';
                const weaponText = weaponDamage > 0 ? ` +${weaponDamage}âš”ï¸` : '';
                showDiceRoll(`ðŸŽ² Rolled: ${diceRolls.join(', ')}${weaponText} = <span style="color:#00ff00">${finalDamage}</span> vs <span style="color:#00ff00">${targetAC}</span> <span style="color:#00ff00">âœ“</span>${critText}`);
            } else {
                // Miss - award XP to defender if they're a hero (scaled)
                if (battleState.heroes.includes(target)) {
                    const dungeonLevel = battleState.currentLevel || 1;
                    const xpMultiplier = 1 + (dungeonLevel - 1) * 0.25;
                    const scaledDodgeXP = Math.floor(1 * xpMultiplier);
                    target.xp = (target.xp || 0) + scaledDodgeXP;
                }
                // Generate fake dice rolls for display
                const numDice = actionType === 'light' ? 1 : (actionType === 'heavy' ? 2 : 3);
                const diceRolls = [];
                for (let i = 0; i < numDice; i++) {
                    diceRolls.push(Math.floor(Math.random() * 6) + 1);
                }
                const diceTotal = diceRolls.reduce((a, b) => a + b, 0);
                showDiceRoll(`ðŸŽ² Rolled: ${diceRolls.join(', ')} = <span style="color:#ff0000">${diceTotal}</span> vs <span style="color:#ff0000">${targetAC}</span> <span style="color:#ff0000">âœ—</span>`);
            }
            
            renderBattle();
            updateBattleEnemyCards();
            updateBattleHeroCards();
            updateChatTargets();  // Update chat target buttons
            
            // Check if target is dead
            if (target.hp <= 0) {
                // Play enemy death sound if target is enemy
                if (battleState.enemies.includes(target)) {
                    playEnemySfx(target, 'die');
                }
                
                // Spawn death particle effect at target position
                if (target.x && target.y) {
                    const depthScale = 0.6 + (target.y / (battleState.canvas?.height || 720)) * 0.4;
                    // Use multiple effects for a bigger death burst
                    spawnParticleEffect('red_break_a', target.x, target.y, depthScale * 1.5);
                    spawnParticleEffect('red_break_b', target.x - 20, target.y, depthScale * 1.2);
                    spawnParticleEffect('red_break_c', target.x + 20, target.y, depthScale * 1.2);
                }
                
                // Calculate XP multiplier based on dungeon level
                const dungeonLevel = battleState.currentLevel || 1;
                const xpMultiplier = 1 + (dungeonLevel - 1) * 0.25; // +25% per level
                
                // Award XP for killing blow - scaled by dungeon level, bonus for bosses
                const baseKillXP = target.isBoss ? 50 : 10;
                const scaledKillXP = Math.floor(baseKillXP * xpMultiplier);
                attacker.xp += scaledKillXP;
                
                // Award gold from enemy (scales with dungeon level)
                const levelMultiplier = 1 + (dungeonLevel - 1) * 0.5;
                const baseGold = target.isBoss ? 100 : 10;
                const goldDrop = target.goldDrop || Math.floor(baseGold * levelMultiplier);
                const sharedSave = JSON.parse(localStorage.getItem('top_shared_save') || '{}');
                if (!sharedSave.dungeonState) sharedSave.dungeonState = {};
                sharedSave.dungeonState.gold = (sharedSave.dungeonState.gold || 0) + goldDrop;
                localStorage.setItem('top_shared_save', JSON.stringify(sharedSave));
                
                addChatMessage('System', 'system', null, `ðŸ’° ${attacker.name} looted ${goldDrop} gold from ${target.name}!`, false);
                updateGoldDisplay();
                updateBattleHeroCards();
                
                // Update boss morale when ally dies
                const boss = battleState.enemies.find(e => e.isBoss && e.hp > 0);
                if (boss && target !== boss) {
                    updateBossMorale(boss, 'ally_died');
                }
                
                // Remove from battle
                battleState.enemies = battleState.enemies.filter(e => e !== target);
                battleState.turnOrder = battleState.turnOrder.filter(c => c !== target);
                
                // Check win condition
                if (battleState.enemies.length === 0) {
                    battleState.won = true;
                    
                    // Track level progress - room explored
                    incrementRoomsExplored();
                    
                    // Check if this battle had a boss
                    if (battleState.hadBoss) {
                        markBossDefeated();
                    }
                    
                    // Award 100 XP to all heroes for clearing the room
                    battleState.heroes.forEach(hero => {
                        hero.xp = (hero.xp || 0) + 100;
                    });
                    updateBattleHeroCards();
                    
                    showBattleNotification('ROOM CLEARED!');
                    
                    // Rescue captive NPC if present
                    if (battleState.captiveNpc && !battleState.captiveNpc.rescued) {
                        battleState.captiveNpc.rescued = true;
                        incrementCaptivesFreed(); // Track captive rescue
                        
                        // Award 250 XP to all heroes for rescuing the captive
                        battleState.heroes.forEach(hero => {
                            hero.xp = (hero.xp || 0) + 250;
                        });
                        updateBattleHeroCards();
                        
                        setTimeout(() => {
                            // Show rescue dialogue
                            addChatMessage(
                                battleState.captiveNpc.name,
                                'friendly',
                                'people/zooko_a_head_compressed.png',
                                battleState.captiveNpc.dialogueOnRescue,
                                true,
                                battleState.captiveNpc.voiceType
                            );
                            
                            // Give reward
                            const reward = battleState.captiveNpc.rescueReward;
                            let rewardText = 'Rescued ' + battleState.captiveNpc.name + '! +250 XP';
                            if (reward.gold) {
                                rewardText += ` +${reward.gold} gold`;
                            }
                            if (reward.item) {
                                rewardText += ` +${reward.item}`;
                            }
                            if (reward.info) {
                                setTimeout(() => {
                                    addChatMessage(
                                        battleState.captiveNpc.name,
                                        'friendly',
                                        'people/zooko_a_head_compressed.png',
                                        `*whispers* ${reward.info}`,
                                        true,
                                        battleState.captiveNpc.voiceType
                                    );
                                }, 2000);
                            }
                            showBattleNotification(rewardText);
                            
                            // Update UI to remove captive from chat targets and HUD
                            updateChatTargets();
                            updateBattleEnemyCards();
                        }, 1500);
                    }
                    
                    // Change retreat button to leave
                    const retreatBtn = document.querySelector('.battleButton.retreat');
                    if (retreatBtn) {
                        retreatBtn.textContent = 'ðŸšª LEAVE';
                    }
                    // Broadcast final state (includes captive.rescued = true)
                    if (multiplayerState.enabled && multiplayerState.role === 'host') {
                        broadcastGameState();
                    }
                    return;
                }
            }
            
            advanceTurn();
            
            // Broadcast state after action
            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                broadcastGameState();
            }
        }
        
        // Process AI turn
        function processAITurn(combatant) {
            if (!combatant.hostile) {
                // Check if this is a betrayed mob that should attack enemies
                if (combatant.negotiationState?.betrayed) {
                    // Betrayed mob attacks hostile enemies (prioritize boss)
                    const hostileEnemies = battleState.enemies.filter(e => e.hostile && e.hp > 0 && e !== combatant);
                    if (hostileEnemies.length > 0) {
                        // Prioritize boss
                        const boss = hostileEnemies.find(e => e.isBoss);
                        const target = boss || hostileEnemies[0];
                        
                        const attackRoll = rollD20();
                        const damage = combatant.attackDamage || rollD6(1);
                        
                        if (attackRoll >= (target.ac || 10)) {
                            target.hp = Math.max(0, target.hp - damage);
                            showDiceRoll(`ðŸ¤ ${combatant.name} BETRAYS! Attacks ${target.name} for ${damage} damage!`);
                            
                            if (target.hp <= 0) {
                                showBattleNotification(`${target.name} defeated by betrayal!`);
                                battleState.enemies = battleState.enemies.filter(e => e !== target);
                                battleState.turnOrder = battleState.turnOrder.filter(c => c !== target);
                            }
                        } else {
                            showDiceRoll(`ðŸ¤ ${combatant.name} attacks ${target.name}: MISS!`);
                        }
                        
                        renderBattle();
                        updateBattleEnemyCards();
                        advanceTurn();
                        return;
                    }
                }
                
                // Friendly/neutral NPCs skip turn
                showDiceRoll(`${combatant.name} waits...`);
                advanceTurn();
                return;
            }
            
            // Hostile AI: pick closest hero and attack
            const aliveHeroes = battleState.heroes.filter(h => h.hp > 0);
            if (aliveHeroes.length === 0) {
                // Game over
                showBattleNotification('DEFEAT! ALL HEROES FALLEN!');
                
                // Notify clients if multiplayer
                if (multiplayerState.enabled && multiplayerState.role === 'host') {
                    sendWebSocketMessage({
                        type: 'battle_end',
                        reason: 'defeat'
                    });
                }
                
                setTimeout(() => {
                    // Hide notification
                    const notification = document.getElementById('battleNotification');
                    if (notification) notification.style.display = 'none';
                    
                    endBattle();
                }, 2000);
                return;
            }
            
            // Check for taunting heroes first
            const tauntingHeroes = aliveHeroes.filter(h => h.taunting && h.tauntTurns > 0);
            let target;
            
            if (tauntingHeroes.length > 0) {
                // Roll to resist taunt
                const resistRoll = rollD20();
                const resistDC = 15; // Base resist DC
                
                if (resistRoll < resistDC) {
                    // Failed to resist, attack taunter
                    target = tauntingHeroes[0];
                    showDiceRoll(`${combatant.name} is taunted by ${target.name}!`);
                } else {
                    // Resisted taunt, clear taunt status
                    tauntingHeroes.forEach(h => {
                        h.taunting = false;
                        h.tauntTurns = 0;
                    });
                    showDiceRoll(`${combatant.name} resists taunt! d20(${resistRoll})`);
                    // Fall through to normal targeting
                    target = findClosestHero(combatant, aliveHeroes);
                }
            } else {
                // No taunters, find closest hero
                target = findClosestHero(combatant, aliveHeroes);
            }
            
            // AI attack roll
            const attackRoll = rollD20();
            const damage = combatant.attackDamage || rollD6(1);
            
            // Play enemy attack sound
            playEnemySfx(combatant, 'attack');
            
            // Trigger boss attack animation if available
            if (combatant.isBoss && combatant.anim) {
                const bossKey = 'lvl' + combatant.bossLevel;
                const bossAnimPaths = BOSS_ANIM_PATHS[bossKey];
                if (bossAnimPaths && bossAnimPaths.attack) {
                    setAnimationState(combatant, 'attack', 'once', () => {
                        // Return to idle after attack
                        setAnimationState(combatant, 'idle', 'pingpong');
                    });
                }
            }
            
            // Spawn mob attack particle effect (randomly choose light or heavy style)
            const useLightAttack = Math.random() > 0.5;
            if (useLightAttack) {
                // Light attack: projectile from mob to hero target
                const lightEffect = MOB_LIGHT_ATTACK_EFFECTS[Math.floor(Math.random() * MOB_LIGHT_ATTACK_EFFECTS.length)];
                particleSystem.spawnProjectile(
                    lightEffect,
                    combatant.x,
                    combatant.y - 30, // From mob center
                    target.x,
                    target.y - 50, // To hero center
                    { scale: 1.0, duration: 1.2 }
                );
            } else {
                // Heavy attack: rising effect from hero's feet upward
                const heavyEffect = MOB_HEAVY_ATTACK_EFFECTS[Math.floor(Math.random() * MOB_HEAVY_ATTACK_EFFECTS.length)];
                particleSystem.spawnRising(
                    heavyEffect,
                    target.x,
                    target.y + 100, // Start at hero's feet
                    { scale: 1.0, duration: 2.0, riseDistance: 350 }
                );
            }
            
            // Don't damage heroes already at 0 HP
            if (target.hp <= 0) {
                showDiceRoll(`${combatant.name} ignores disabled ${target.name}`);
                advanceTurn();
                return;
            }
            
            if (attackRoll >= (target.stats?.ac || 10)) {
                let finalDamage = damage;
                if (target.defending) {
                    finalDamage = Math.floor(damage / 2);
                    target.defending = false;
                    // Reset from defend animation (hit animation will play next)
                }
                
                target.hp = Math.max(0, target.hp - finalDamage);
                
                // Trigger hit animation if hero has one (and not knocked out)
                if (battleState.heroes.includes(target) && target.hp > 0) {
                    const heroKey = target.name.toLowerCase();
                    const paths = HERO_ANIM_PATHS[heroKey];
                    if (paths && paths.hit) {
                        setAnimationState(target, 'hit', 'once', () => {
                            setAnimationState(target, 'idle', 'pingpong');
                        });
                    }
                    // Play hero hit sound
                    playSfx(heroKey + 'Hit');
                }
                
                showDiceRoll(`${combatant.name} attacks ${target.name}: HIT for ${finalDamage} damage!`);
                
                // Update boss morale on successful hit
                if (combatant.isBoss) {
                    updateBossMorale(combatant, 'hit_attack');
                }
            } else {
                showDiceRoll(`${combatant.name} attacks ${target.name}: MISS!`);
                
                // Update boss morale on missed attack
                if (combatant.isBoss) {
                    updateBossMorale(combatant, 'missed_attack');
                }
            }
            
            renderBattle();
            updateBattleHeroCards();
            updateBattleEnemyCards();
            updateChatTargets();  // Update chat target buttons
            
            // Broadcast AI action to clients
            broadcastGameState();
            
            // Check if hero died
            if (target.hp <= 0) {
                // Trigger knockout animation if available
                if (battleState.heroes.includes(target)) {
                    const heroKey = target.name.toLowerCase();
                    const paths = HERO_ANIM_PATHS[heroKey];
                    if (paths && paths.knockout) {
                        setAnimationState(target, 'knockout', 'once');
                    }
                    // Play hero knockout sound
                    playSfx(heroKey + 'Knockout');
                    // Stop hero idle particles when knocked out
                    stopHeroIdleParticle(target.name);
                }
                
                const allHeroesDead = battleState.heroes.every(h => h.hp <= 0);
                if (allHeroesDead) {
                    showBattleNotification('DEFEAT! ALL HEROES FALLEN!');
                    
                    // Notify clients if multiplayer
                    if (multiplayerState.enabled && multiplayerState.role === 'host') {
                        sendWebSocketMessage({
                            type: 'battle_end',
                            reason: 'defeat'
                        });
                    }
                    
                    setTimeout(() => {
                        // Hide notification
                        const notification = document.getElementById('battleNotification');
                        if (notification) notification.style.display = 'none';
                        
                        endBattle();
                    }, 2000);
                    return;
                }
            }
            
            // Check for enraged double attack
            if (shouldDoDoubleAttack(combatant)) {
                // Do a second attack after a short delay
                setTimeout(() => {
                    if (combatant.hp > 0 && battleState.active) {
                        const stillAliveHeroes = battleState.heroes.filter(h => h.hp > 0);
                        if (stillAliveHeroes.length > 0) {
                            const secondTarget = findClosestHero(combatant, stillAliveHeroes);
                            const secondRoll = rollD20();
                            const secondDamage = combatant.attackDamage || rollD6(1);
                            
                            if (secondRoll >= (secondTarget.stats?.ac || 10)) {
                                let finalDmg = secondDamage;
                                if (secondTarget.defending) {
                                    finalDmg = Math.floor(secondDamage / 2);
                                    secondTarget.defending = false;
                                }
                                secondTarget.hp = Math.max(0, secondTarget.hp - finalDmg);
                                showDiceRoll(`âš¡ ${combatant.name} RAGE ATTACK: ${finalDmg} damage to ${secondTarget.name}!`);
                            } else {
                                showDiceRoll(`âš¡ ${combatant.name} rage attack MISSES ${secondTarget.name}!`);
                            }
                            renderBattle();
                            updateBattleHeroCards();
                            
                            // Check for hero death
                            if (secondTarget.hp <= 0) {
                                // Stop hero idle particles when knocked out
                                stopHeroIdleParticle(secondTarget.name);
                                
                                const allDead = battleState.heroes.every(h => h.hp <= 0);
                                if (allDead) {
                                    showBattleNotification('DEFEAT!');
                                    setTimeout(() => endBattle(), 2000);
                                    return;
                                }
                            }
                        }
                    }
                    advanceTurn();
                }, 800);
                return;  // Don't advance turn yet - wait for double attack
            }
            
            advanceTurn();
        }
        
        // Advance to next turn
        function advanceTurn() {
            battleState.currentTurn = (battleState.currentTurn + 1) % battleState.turnOrder.length;
            const nextCombatant = battleState.turnOrder[battleState.currentTurn];
            
            // Reset action state for new turn
            battleState.heroes.forEach(hero => {
                hero.usedHeal = false;
            });
            
            // Re-enable all buttons at start of turn
            const heavyBtn = document.getElementById('battleHeavyBtn');
            const specialBtn = document.getElementById('battleSpecialBtn');
            if (heavyBtn) {
                heavyBtn.disabled = false;
                heavyBtn.style.opacity = '1';
            }
            if (specialBtn) {
                specialBtn.disabled = false;
                specialBtn.style.opacity = '1';
            }
            
            // Decrement taunt turns for all heroes
            battleState.heroes.forEach(hero => {
                if (hero.tauntTurns > 0) {
                    hero.tauntTurns--;
                    if (hero.tauntTurns <= 0) {
                        hero.taunting = false;
                    }
                }
            });
            
            updateBattleTurnInfo();
            
            // Broadcast turn advancement to clients
            broadcastGameState();
            
            // Auto-skip if current combatant has 0 HP or is retreated
            if (nextCombatant && (nextCombatant.hp <= 0 || nextCombatant.retreated)) {
                if (battleState.heroes.includes(nextCombatant)) {
                    showDiceRoll(`${nextCombatant.name} is disabled - skipping turn`);
                }
                setTimeout(() => advanceTurn(), 500);
                return;
            }
            
            // If next turn is AI, process automatically
            if (!battleState.heroes.includes(nextCombatant)) {
                setTimeout(() => processAITurn(nextCombatant), 1000);
            }
        }
        
        // End battle and return to dungeon menu
        function endBattle() {
            // Save hero stats to shared save
            const sharedSave = loadSharedSave();
            if (sharedSave && sharedSave.heroes) {
                // Use allHeroes to include dead/retreated heroes
                const heroesToSave = battleState.allHeroes.length > 0 ? battleState.allHeroes : battleState.heroes;
                
                heroesToSave.forEach(hero => {
                    const heroKey = hero.name.toLowerCase();
                    if (sharedSave.heroes[heroKey]) {
                        // Save all stats back to save file
                        sharedSave.heroes[heroKey].hp = hero.hp ?? 0;
                        sharedSave.heroes[heroKey].maxHp = hero.maxHp ?? 0;
                        sharedSave.heroes[heroKey].str = hero.stats?.str ?? sharedSave.heroes[heroKey].str;
                        sharedSave.heroes[heroKey].dex = hero.stats?.dex ?? sharedSave.heroes[heroKey].dex;
                        sharedSave.heroes[heroKey].con = hero.stats?.con ?? sharedSave.heroes[heroKey].con;
                        sharedSave.heroes[heroKey].int = hero.stats?.int ?? sharedSave.heroes[heroKey].int;
                        sharedSave.heroes[heroKey].wis = hero.stats?.wis ?? sharedSave.heroes[heroKey].wis;
                        sharedSave.heroes[heroKey].cha = hero.stats?.cha ?? sharedSave.heroes[heroKey].cha;
                        sharedSave.heroes[heroKey].xp = hero.xp ?? 0;
                        sharedSave.heroes[heroKey].level = hero.level ?? 1;
                    }
                });
                
                // Save current dungeon level
                const dungeonLevelEl = document.getElementById('dungeonMenuLevel');
                if (dungeonLevelEl && sharedSave.dungeonState) {
                    sharedSave.dungeonState.currentLevel = parseInt(dungeonLevelEl.textContent) || 1;
                }
                
                saveSharedSave(sharedSave);
                
                // Host saves to localStorage only - clients will update from next state_update
            }
            
            battleState.active = false;
            currentScreen = 'dungeonMenu';
            stopBattleVideo(); // Stop and hide video background
            stopHeroIdleParticles(); // Stop all hero particle effects
            particleSystem.clear(); // Clear any remaining particles
            document.getElementById('battleScreen').style.display = 'none';
            document.getElementById('dungeonMenuScreen').style.display = 'block';
            
            // Move music controls back to center
            document.getElementById('musicControls').classList.remove('battleActive');
            document.getElementById('musicControls').classList.add('dungeonMenuActive');
            document.getElementById('musicTicker').classList.remove('battleActive');
            document.getElementById('musicTicker').classList.add('dungeonMenuActive');
            
            // Update dungeon menu hero displays with saved stats
            updateDungeonMenuHeroes();
            updateGoldDisplay();
            
            // Move music controls and ticker back to center bottom
            document.getElementById('musicControls').classList.remove('battleActive');
            document.getElementById('musicTicker').classList.remove('battleActive');
            
            // Clear battle chat
            clearBattleChat();
            
            // Clear TTS voice cache (entities leaving room)
            fetch('/api/tts/clear-voice-cache', { method: 'POST' })
                .catch(e => console.log('[TTS] Voice cache clear failed (server offline?):', e.message));
            
            // Pre-generate next encounter while player is in dungeon menu
            preGenerateNextEncounter();
        }
        
        // ===== END BATTLE SYSTEM =====
        
        // Exit portal and return to arcade game
        function exitPortal() {
            try {
                // Load shared save (may not exist - that's OK)
                const sharedSave = loadSharedSave();
                
                // If we have a save, update it before leaving
                if (sharedSave) {
                    // Get current dungeon level
                    const dungeonLevelEl = document.getElementById('dungeonMenuLevel') || document.getElementById('dungeonLevel');
                    const currentLevel = dungeonLevelEl ? (parseInt(dungeonLevelEl.textContent) || 1) : 1;
                    
                    // Update dungeon state
                    sharedSave.dungeonState = {
                        currentLevel: currentLevel,
                        inventory: sharedSave.dungeonState?.inventory || [],
                        gold: sharedSave.dungeonState?.gold || 0,
                        questProgress: sharedSave.dungeonState?.questProgress || {
                            hasScepter: false,
                            hasReturned: false,
                            bossesDefeated: []
                        }
                    };
                    sharedSave.lastPlayed = Date.now();
                    
                    // Save updated shared state
                    saveSharedSave(sharedSave);
                }
                
                // Navigate to arcade (no save required)
                window.location.href = 'zlock_consensus.html';
            } catch (e) {
                console.error('Failed to exit portal:', e);
                // Still try to navigate even on error
                window.location.href = 'zlock_consensus.html';
            }
        }
        
        // Update hero stat display (both title and dungeon screens)
        function updateHeroDisplay(heroName, stats) {
            const prefix = heroName.toLowerCase();
            
            // Title screen hero stats
            const levelEl = document.getElementById(`${prefix}-level`);
            const hpEl = document.getElementById(`${prefix}-hp`);
            const maxhpEl = document.getElementById(`${prefix}-maxhp`);
            const strEl = document.getElementById(`${prefix}-str`);
            const dexEl = document.getElementById(`${prefix}-dex`);
            const conEl = document.getElementById(`${prefix}-con`);
            const intEl = document.getElementById(`${prefix}-int`);
            const wisEl = document.getElementById(`${prefix}-wis`);
            const chaEl = document.getElementById(`${prefix}-cha`);
            const xpEl = document.getElementById(`${prefix}-xp`);
            
            // Dungeon screen hero stats (prefixed with 'd')
            const dhpEl = document.getElementById(`d${prefix}-hp`);
            const dmaxhpEl = document.getElementById(`d${prefix}-maxhp`);
            const dxpEl = document.getElementById(`d${prefix}-xp`);
            const dstrEl = document.getElementById(`d${prefix}-str`);
            const ddexEl = document.getElementById(`d${prefix}-dex`);
            const dconEl = document.getElementById(`d${prefix}-con`);
            const dintEl = document.getElementById(`d${prefix}-int`);
            const dwisEl = document.getElementById(`d${prefix}-wis`);
            const dchaEl = document.getElementById(`d${prefix}-cha`);
            
            // Update title screen
            if (levelEl) levelEl.textContent = stats.level || 1;
            if (hpEl) hpEl.textContent = stats.hp || 0;
            if (maxhpEl) maxhpEl.textContent = stats.maxHp || 0;
            if (strEl) strEl.textContent = stats.str || 0;
            if (dexEl) dexEl.textContent = stats.dex || 0;
            if (conEl) conEl.textContent = stats.con || 0;
            if (intEl) intEl.textContent = stats.int || 0;
            if (wisEl) wisEl.textContent = stats.wis || 0;
            if (chaEl) chaEl.textContent = stats.cha || 0;
            if (xpEl) xpEl.textContent = stats.xp || 0;
            
            // Update dungeon screen
            if (dhpEl) dhpEl.textContent = stats.hp || 0;
            if (dmaxhpEl) dmaxhpEl.textContent = stats.maxHp || 0;
            if (dxpEl) dxpEl.textContent = stats.xp || 0;
            if (dstrEl) dstrEl.textContent = stats.str || 0;
            if (ddexEl) ddexEl.textContent = stats.dex || 0;
            if (dconEl) dconEl.textContent = stats.con || 0;
            if (dintEl) dintEl.textContent = stats.int || 0;
            if (dwisEl) dwisEl.textContent = stats.wis || 0;
            if (dchaEl) dchaEl.textContent = stats.cha || 0;
        }
        
        // Update dungeon menu hero stats from save
        function updateDungeonMenuHeroes() {
            // Start story background animation when entering dungeon menu (do this first!)
            if (currentScreen === 'dungeonMenu') {
                startDungeonMenuAnimation();
                updateDifficultyButtons(); // Ensure difficulty button shows current selection
            }
            
            // Load hero weapons state
            loadHeroWeapons();
            
            // Clients use cached stats from host broadcasts, host uses localStorage
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                // Client: Display from cache
                updateHeroDisplay('zooko', multiplayerState.heroStatsCache.zooko || {});
                updateHeroDisplay('nate', multiplayerState.heroStatsCache.nate || {});
                updateHeroDisplay('zancas', multiplayerState.heroStatsCache.zancas || {});
                updateHeroDisplay('cyberaxe', multiplayerState.heroStatsCache.cyberaxe || {});
            } else {
                // Host or solo: Load from localStorage
                const sharedSave = loadSharedSave();
                if (!sharedSave || !sharedSave.heroes) return;
                
                updateHeroDisplay('zooko', sharedSave.heroes.zooko);
                updateHeroDisplay('nate', sharedSave.heroes.nate);
                updateHeroDisplay('zancas', sharedSave.heroes.zancas);
                updateHeroDisplay('cyberaxe', sharedSave.heroes.cyberaxe);
            }
            
            // Update hero card equipment displays
            updateHeroCardEquipment();
        }
        
        // Update hero card equipment slot displays (dungeon menu)
        function updateHeroCardEquipment() {
            const heroes = ['zooko', 'nate', 'zancas', 'cyberaxe'];
            
            heroes.forEach(heroName => {
                const weaponSlot = document.getElementById(`d${heroName}-weapon`);
                if (weaponSlot) {
                    const weaponStats = getWeaponStats(heroName);
                    if (weaponStats) {
                        // Update icon with enchantment glow
                        const enchantGlow = weaponStats.enchantment 
                            ? `filter: drop-shadow(0 0 6px ${weaponStats.enchantment.color}) drop-shadow(0 0 12px ${weaponStats.enchantment.color});` 
                            : '';
                        weaponSlot.innerHTML = `<img src="${weaponStats.icon}" alt="${weaponStats.fullName}" style="width: 80%; height: 80%; object-fit: contain; ${enchantGlow}">`;
                        
                        // Update title with stats
                        weaponSlot.title = `${weaponStats.fullName}\nDMG: ${weaponStats.damage} | DEF: ${weaponStats.defense} | CRIT: ${weaponStats.crit}%${weaponStats.enchantment ? '\nâœ¨ ' + weaponStats.enchantment.name : ''}`;
                    }
                }
            });
            
            // Setup tooltips for hero card equipment slots
            setupHeroCardWeaponTooltips();
        }
        
        // Setup weapon tooltips for hero card equipment slots
        function setupHeroCardWeaponTooltips() {
            const tooltip = document.getElementById('weaponTooltip');
            if (!tooltip) return;
            
            document.querySelectorAll('.heroEquipSlot[data-slottype="weapon"]').forEach(slot => {
                // Remove existing listeners to prevent duplicates
                slot.removeEventListener('mouseenter', slot._tooltipEnter);
                slot.removeEventListener('mouseleave', slot._tooltipLeave);
                
                slot._tooltipEnter = (e) => {
                    e.stopPropagation();
                    const heroName = slot.dataset.hero;
                    if (!heroName) return;
                    
                    // Hide info tooltip if showing
                    hideTooltip();
                    
                    tooltip.innerHTML = getWeaponTooltipHTML(heroName);
                    tooltip.style.opacity = '1';
                    
                    const rect = slot.getBoundingClientRect();
                    const tooltipWidth = 240;
                    
                    // Position tooltip to the right, or left if near edge
                    let left = rect.right + 10;
                    if (left + tooltipWidth > window.innerWidth) {
                        left = rect.left - tooltipWidth - 10;
                    }
                    
                    tooltip.style.left = left + 'px';
                    tooltip.style.top = Math.max(10, rect.top - 50) + 'px';
                };
                
                slot._tooltipLeave = () => {
                    tooltip.style.opacity = '0';
                };
                
                slot.addEventListener('mouseenter', slot._tooltipEnter);
                slot.addEventListener('mouseleave', slot._tooltipLeave);
            });
        }
        
        // Refresh all game data and broadcast to clients
        function refreshGameData() {
            const sharedSave = loadSharedSave();
            
            if (!sharedSave) {
                showNotification('No save data found', 'error');
                return;
            }
            
            // Update local displays
            updateDungeonMenuHeroes();
            
            // If multiplayer host, broadcast current game state
            if (multiplayerState.enabled && multiplayerState.role === 'host' && battleState.active) {
                broadcastGameState();
                showNotification('Data refreshed and synced to all players', 'success');
            } else if (multiplayerState.enabled && multiplayerState.role === 'client') {
                showNotification('Data refreshed from cache', 'info');
            } else {
                showNotification('Data refreshed', 'success');
            }
        }
        
        // Start adventure - switch from title to dungeon menu
        function startAdventure() {
            // Check if save exists and warn user
            const existingSave = loadSharedSave();
            if (existingSave && (existingSave.arcadeState || existingSave.dungeonState)) {
                showConfirmation(
                    'START NEW ADVENTURE?',
                    'This will replace your current save game. Save to file first if you want to keep your progress!',
                    (confirmed) => {
                        if (!confirmed) return;
                        showSinglePlayerHeroSelection();
                    }
                );
                return;
            }
            
            // No save exists, show hero selection for rolling stats
            showSinglePlayerHeroSelection();
        }
        
        // Show hero selection modal for single player mode
        function showSinglePlayerHeroSelection() {
            // Mark as single player mode (not multiplayer)
            multiplayerState.enabled = false;
            multiplayerState.role = 'host'; // Act as host for single player
            multiplayerState.myHeroes = ['zooko', 'nate', 'zancas', 'cyberaxe']; // Own all heroes
            multiplayerState.playerHeroes = {
                zooko: { playerName: 'You' },
                nate: { playerName: 'You' },
                zancas: { playerName: 'You' },
                cyberaxe: { playerName: 'You' }
            };
            multiplayerState.playerName = 'Adventurer';
            
            // Show hero selection modal
            document.getElementById('heroSelectionModal').style.display = 'block';
            document.getElementById('musicControls').classList.add('heroSelectionActive');
            document.getElementById('musicTicker').classList.add('battleActive');
            
            // Hide room code section for single player
            const codeDisplay = document.getElementById('heroSelectionCode');
            if (codeDisplay) codeDisplay.parentElement.style.display = 'none';
            
            // Hide player name input row for single player
            const playerNameInput = document.getElementById('playerNameInput');
            if (playerNameInput) playerNameInput.parentElement.style.display = 'none';
            
            // Hide PLAYERS count box for single player
            const playerCountBox = document.getElementById('playerCountBox');
            if (playerCountBox) playerCountBox.style.display = 'none';
            
            // Hide Connected Players list for single player
            const connectedPlayersList = document.getElementById('connectedPlayersList');
            if (connectedPlayersList) connectedPlayersList.style.display = 'none';
            
            // Change title to ROLL HERO STATS for single player
            const heroSelectionTitle = document.getElementById('heroSelectionTitle');
            if (heroSelectionTitle) heroSelectionTitle.textContent = 'ROLL HERO STATS';
            
            // Update waiting message for single player
            const waitingMsg = document.getElementById('heroWaitingMessage');
            if (waitingMsg) waitingMsg.textContent = 'All heroes are yours! Roll stats for each hero.';
            
            // Mark all heroes as selected by this player
            document.querySelectorAll('.heroSelectCard').forEach(card => {
                card.classList.add('selected');
                card.style.borderWidth = '5px';
                const playerLabel = card.querySelector('.heroPlayerLabel');
                if (playerLabel) {
                    playerLabel.textContent = 'You';
                    playerLabel.style.display = 'block';
                }
            });
            
            // Hide reconnect options, show game start options
            const reconnectOptions = document.getElementById('reconnectOptions');
            const gameStartOptions = document.getElementById('gameStartOptions');
            const backBtn = document.getElementById('heroSelectionBackBtn');
            if (reconnectOptions) reconnectOptions.style.display = 'none';
            if (gameStartOptions) gameStartOptions.style.display = 'block';
            if (backBtn) backBtn.style.display = 'none';
            
            // Update hero stats display first
            updateHeroSelectionStats();
            
            // Go directly to roll phase (phase 2) for single player
            inRollPhase = true;
            heroSelectionHasSave = false; // Force allowing rolls
            document.getElementById('gameStartPhase1').style.display = 'none';
            document.getElementById('gameStartPhase2').style.display = 'block';
            
            // Show roll buttons for all heroes
            showAllRollButtons();
            
            // Clear any previous rolled stats
            multiplayerState.rolledHeroStats = {};
            
            // Update status
            updateRollPhaseStatus();
        }
        
        function proceedWithNewAdventure() {
            const titleScreen = document.getElementById('titleScreen');
            const dungeonMenuScreen = document.getElementById('dungeonMenuScreen');
            
            if (titleScreen) titleScreen.style.display = 'none';
            if (dungeonMenuScreen) dungeonMenuScreen.style.display = 'block';
            
            currentScreen = 'dungeonMenu';
            
            // Center music controls for dungeon menu
            document.getElementById('musicControls').classList.add('dungeonMenuActive');
            document.getElementById('musicTicker').classList.add('dungeonMenuActive');
            
            // Create fresh save
            let sharedSave = createDefaultSharedSave();
            saveSharedSave(sharedSave);
            
            // Sync dungeon level display
            if (sharedSave && sharedSave.arcadeState && sharedSave.arcadeState.level) {
                const dungeonMenuLevel = document.getElementById('dungeonMenuLevel');
                if (dungeonMenuLevel) {
                    dungeonMenuLevel.textContent = sharedSave.arcadeState.level;
                }
                // Set room level for encounter generation
                preGeneratedEncounter.roomLevel = sharedSave.arcadeState.level;
            }
            // Also check dungeonState.currentLevel (from stairs)
            if (sharedSave && sharedSave.dungeonState && sharedSave.dungeonState.currentLevel) {
                const dungeonMenuLevel = document.getElementById('dungeonMenuLevel');
                if (dungeonMenuLevel) {
                    dungeonMenuLevel.textContent = sharedSave.dungeonState.currentLevel;
                }
                preGeneratedEncounter.roomLevel = sharedSave.dungeonState.currentLevel;
            }
            
            // Load hero stats from save to dungeon menu
            updateDungeonMenuHeroes();
            
            // Update gold display directly (we know it's 42 from fresh save)
            const dungeonMenuGold = document.getElementById('dungeonMenuGold');
            if (dungeonMenuGold) dungeonMenuGold.textContent = sharedSave.dungeonState.gold;
            
            // Apply client UI restrictions
            applyClientUIRestrictions();
            
            // Initialize level layout for current level (BEFORE broadcasting to clients)
            const currentLevel = preGeneratedEncounter.roomLevel || 1;
            initializeLevelLayout(currentLevel);
            
            // Pre-generate next encounter while player is in dungeon menu
            preGenerateNextEncounter();
            
            // If multiplayer host, notify clients to start and send save data
            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                sendWebSocketMessage({ 
                    type: 'game_start', 
                    screen: 'dungeonMenu',
                    saveData: sharedSave,
                    levelLayout: currentLevelLayout,
                    levelProgress: levelProgress
                });
            }
        }
        
        // Apply client UI restrictions (disable host-only buttons)
        function applyClientUIRestrictions() {
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                // HIDE EXPLORE LEVEL button and its container row
                const exploreLevelBtn = document.getElementById('exploreLevelBtn');
                if (exploreLevelBtn && exploreLevelBtn.parentElement) {
                    exploreLevelBtn.parentElement.style.display = 'none';
                }
                
                // HIDE STAIRS buttons (UP/DOWN)
                const stairsUpBtn = document.getElementById('stairsUpBtn');
                if (stairsUpBtn) {
                    stairsUpBtn.style.display = 'none';
                }
                const stairsDownBtn = document.getElementById('stairsDownBtn');
                if (stairsDownBtn) {
                    stairsDownBtn.style.display = 'none';
                }
                const stairsDownBtn2 = document.getElementById('stairsDownBtn2');
                if (stairsDownBtn2) {
                    stairsDownBtn2.style.display = 'none';
                }
                
                // HIDE FAST TRAVEL button and input
                const fastTravelBtn = document.getElementById('fastTravelBtn');
                if (fastTravelBtn) {
                    fastTravelBtn.style.display = 'none';
                }
                const fastTravelInput = document.getElementById('fastTravelLevel');
                if (fastTravelInput) {
                    fastTravelInput.style.display = 'none';
                }
                
                // Disable DIFFICULTY buttons (keep visible but disabled)
                const diffButtons = ['diffCasualBtn', 'diffNormalBtn', 'diffExpertBtn'];
                diffButtons.forEach(btnId => {
                    const btn = document.getElementById(btnId);
                    if (btn) {
                        btn.disabled = true;
                        btn.style.cursor = 'not-allowed';
                        btn.title = 'Only party leader can change difficulty';
                    }
                });
                
                // HIDE STORE button
                const storeBtn = document.getElementById('levelStoreBtn');
                if (storeBtn) {
                    storeBtn.style.display = 'none';
                }
                
                // HIDE CAMP button
                const campBtn = document.getElementById('campBtn');
                if (campBtn) {
                    campBtn.style.display = 'none';
                }
                
                // HIDE DUNGEON MASTERS button
                const dmBtn = document.getElementById('dungeonMastersBtn');
                if (dmBtn) {
                    dmBtn.style.display = 'none';
                }
                
                // INVENTORY button stays visible (no changes needed)
            }
        }
        
        // Pause game
        function pauseGame() {
            if (currentScreen === 'title') return; // Can't pause on title screen
            
            isPaused = true;
            const pauseScreen = document.getElementById('pauseScreen');
            if (pauseScreen) pauseScreen.style.display = 'flex';
            
            // Show resync button only for clients in multiplayer
            const resyncBtn = document.getElementById('resyncBtn');
            if (resyncBtn) {
                resyncBtn.style.display = (multiplayerState.enabled && multiplayerState.role === 'client') ? 'block' : 'none';
            }
        }
        
        // Request resync from host (client only)
        function requestResync() {
            if (!multiplayerState.enabled || multiplayerState.role !== 'client') {
                showNotification('Resync only available for clients', 'error');
                return;
            }
            
            multiplayerState.awaitingResync = true;
            sendWebSocketMessage({ type: 'request_resync' });
            showNotification('Requesting resync from host...', 'info');
        }
        
        // Resume game
        function resumeGame() {
            isPaused = false;
            const pauseScreen = document.getElementById('pauseScreen');
            if (pauseScreen) pauseScreen.style.display = 'none';
        }
        
        // Save game from pause menu
        function saveGameFromPause() {
            try {
                let sharedSave = loadSharedSave();
                if (!sharedSave) {
                    // Create new save if none exists
                    sharedSave = createDefaultSharedSave();
                }
                
                // Update last played timestamp
                sharedSave.lastPlayed = Date.now();
                
                // Save to localStorage
                if (saveSharedSave(sharedSave)) {
                    alert('Game saved successfully!');
                    // Update button states to reflect save exists
                    updateTitleScreenButtons();
                } else {
                    alert('Failed to save game!');
                }
            } catch (e) {
                console.error('Save error:', e);
                alert('Error saving game: ' + e.message);
            }
        }
        
        // Download save file
        function downloadSaveFile() {
            try {
                const sharedSave = loadSharedSave();
                if (!sharedSave) {
                    alert('No save data to download!');
                    return;
                }
                
                // Update timestamp
                sharedSave.lastPlayed = Date.now();
                saveSharedSave(sharedSave);
                
                // Create filename with date/time
                const now = new Date();
                const dateStr = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
                const hours = now.getHours();
                const minutes = String(now.getMinutes()).padStart(2, '0');
                const ampm = hours >= 12 ? 'pm' : 'am';
                const hour12 = hours % 12 || 12;
                const timeStr = `${hour12}_${minutes}_${ampm}`;
                
                const level = sharedSave.dungeonState ? sharedSave.dungeonState.currentLevel : 1;
                const filename = `tunnelsofprivacy-save-level${level}-${dateStr}-${timeStr}.json`;
                
                // Download JSON
                const jsonString = JSON.stringify(sharedSave, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                alert(`Save file downloaded: ${filename}`);
            } catch (e) {
                console.error('Download error:', e);
                alert('Error downloading save file: ' + e.message);
            }
        }
        
        // Show settings from pause
        function showSettingsFromPause() {
            showSettings();
        }
        
        // Quit to menu
        function quitToMenu() {
            // Save game state before quitting
            const sharedSave = loadSharedSave();
            if (sharedSave) {
                // Update dungeon level if visible
                const dungeonLevelEl = document.getElementById('dungeonMenuLevel');
                if (dungeonLevelEl && sharedSave.dungeonState) {
                    sharedSave.dungeonState.currentLevel = parseInt(dungeonLevelEl.textContent) || 1;
                }
                sharedSave.lastPlayed = Date.now();
                saveSharedSave(sharedSave);
            }
            
            // Stop dungeon menu story background animation
            stopDungeonMenuAnimation();
            
            isPaused = false;
            currentScreen = 'title';
            
            const pauseScreen = document.getElementById('pauseScreen');
            const dungeonMenuScreen = document.getElementById('dungeonMenuScreen');
            const titleScreen = document.getElementById('titleScreen');
            const battleScreen = document.getElementById('battleScreen');
            
            if (pauseScreen) pauseScreen.style.display = 'none';
            if (dungeonMenuScreen) dungeonMenuScreen.style.display = 'none';
            if (battleScreen) battleScreen.style.display = 'none';
            if (titleScreen) titleScreen.style.display = 'block';
            
            // Reset music controls to title screen position (bottom left)
            document.getElementById('musicControls').classList.remove('dungeonMenuActive');
            document.getElementById('musicTicker').classList.remove('dungeonMenuActive');
            
            // Reload hero stats from save
            const savedData = loadSharedSave();
            const heroStatsEl = document.getElementById('heroStats');
            
            if (savedData && savedData.heroes) {
                // Show hero party
                if (heroStatsEl) heroStatsEl.style.display = 'block';
                
                // Update each hero's display
                updateHeroDisplay('zooko', savedData.heroes.zooko);
                updateHeroDisplay('nate', savedData.heroes.nate);
                updateHeroDisplay('zancas', savedData.heroes.zancas);
                updateHeroDisplay('cyberaxe', savedData.heroes.cyberaxe);
            } else {
                // Hide hero party when no save exists
                if (heroStatsEl) heroStatsEl.style.display = 'none';
            }
            
            // Update CONTINUE button state based on save existence
            updateTitleScreenButtons();
        }
        
        // ESC key listener
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                e.preventDefault();
                
                // Close all panels first
                const overlay = document.getElementById('overlay');
                const settingsPanel = document.getElementById('settingsPanel');
                const loadSavePanel = document.getElementById('loadSavePanel');
                
                if (overlay && overlay.style.display === 'block') {
                    closeAllPanels();
                    return;
                }
                
                // Toggle pause
                if (isPaused) {
                    resumeGame();
                } else {
                    pauseGame();
                }
            }
        });
        
        // ===== GAMEPAD FUNCTIONS =====
        function onGamepadConnected(e) {
            gamepadConnected = true;
            gamepadIndex = e.gamepad.index;
            console.log(`ðŸŽ® Controller Connected: ${e.gamepad.id}`);
        }
        
        function onGamepadDisconnected(e) {
            if (e.gamepad.index === gamepadIndex) {
                gamepadConnected = false;
                gamepadIndex = null;
                gamepadButtonStates = {};
                console.log('ðŸŽ® Controller Disconnected');
            }
        }
        
        function updateGamepad() {
            if (!gamepadConnected || gamepadIndex === null) return;
            
            // Don't process gamepad input while loading modal is visible
            const loadingModal = document.getElementById('loadingModal');
            if (loadingModal && loadingModal.style.display !== 'none') return;
            
            const now = Date.now();
            if (now - lastGamepadUpdate < gamepadUpdateInterval) return;
            lastGamepadUpdate = now;
            
            const gamepads = navigator.getGamepads();
            const gamepad = gamepads[gamepadIndex];
            
            if (!gamepad) return;
            
            // Process buttons
            gamepad.buttons.forEach((button, index) => {
                const wasPressed = gamepadButtonStates[index] || false;
                const isPressed = button.pressed;
                
                // Button just pressed (rising edge)
                if (isPressed && !wasPressed) {
                    handleGamepadButtonPress(index);
                }
                
                gamepadButtonStates[index] = isPressed;
            });
        }
        
        function handleGamepadButtonPress(buttonIndex) {
            // ===== SETTINGS PANEL NAVIGATION =====
            const settingsPanel = document.getElementById('settingsPanel');
            if (settingsPanel && settingsPanel.style.display === 'block') {
                // B button - Close
                if (buttonIndex === GamepadButtons.B) {
                    closeAllPanels();
                    return;
                }
                return; // Block all other inputs when settings is open
            }
            // ===== END SETTINGS PANEL NAVIGATION =====
            
            // ===== LOAD SAVE PANEL NAVIGATION =====
            const loadSavePanel = document.getElementById('loadSavePanel');
            if (loadSavePanel && loadSavePanel.style.display === 'block') {
                // B button - Close
                if (buttonIndex === GamepadButtons.B) {
                    closeAllPanels();
                    return;
                }
                return; // Block all other inputs when load save panel is open
            }
            // ===== END LOAD SAVE PANEL NAVIGATION =====
            
            // ===== TITLE SCREEN NAVIGATION =====
            if (currentScreen === 'title') {
                // A button - Start Adventure
                if (buttonIndex === GamepadButtons.A) {
                    startAdventure();
                    return;
                }
                // Y button - Settings
                else if (buttonIndex === GamepadButtons.Y) {
                    showSettings();
                    return;
                }
                // B button - Load Save File
                else if (buttonIndex === GamepadButtons.B) {
                    showLoadSave();
                    return;
                }
                // BACK button (SELECT) - Exit Portal
                else if (buttonIndex === GamepadButtons.SELECT) {
                    exitPortal();
                    return;
                }
            }
            // ===== END TITLE SCREEN NAVIGATION =====
            
            // ===== PAUSE MENU NAVIGATION =====
            if (isPaused) {
                // A button - Resume
                if (buttonIndex === GamepadButtons.A) {
                    resumeGame();
                    return;
                }
                // B button - Resume (also works)
                else if (buttonIndex === GamepadButtons.B) {
                    resumeGame();
                    return;
                }
                // Y button - Settings
                else if (buttonIndex === GamepadButtons.Y) {
                    showSettingsFromPause();
                    return;
                }
                // SELECT button - Quit to Menu
                else if (buttonIndex === GamepadButtons.SELECT) {
                    quitToMenu();
                    return;
                }
            }
            // ===== END PAUSE MENU NAVIGATION =====
            
            // START button - Pause/Resume
            if (buttonIndex === GamepadButtons.START) {
                if (currentScreen === 'title') return; // Can't pause on title screen
                
                if (isPaused) {
                    resumeGame();
                } else {
                    pauseGame();
                }
                return;
            }
        }
        
        // Poll gamepad in animation loop
        function gamepadLoop() {
            updateGamepad();
            requestAnimationFrame(gamepadLoop);
        }
        
        // Gamepad polling for Click to Enter
        function pollGamepadForClickToPlay() {
            const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
            for (let i = 0; i < gamepads.length; i++) {
                const gp = gamepads[i];
                if (gp && gp.buttons[0] && gp.buttons[0].pressed) { // A button
                    const clickToPlayPrompt = document.getElementById('clickToPlayPrompt');
                    if (clickToPlayPrompt && clickToPlayPrompt.style.display !== 'none') {
                        clickToPlayPrompt.click();
                        return;
                    }
                }
            }
            
            // Continue polling if loading modal is visible
            const loadingModal = document.getElementById('loadingModal');
            if (loadingModal && loadingModal.style.display !== 'none') {
                requestAnimationFrame(pollGamepadForClickToPlay);
            }
        }
        // ===== END GAMEPAD FUNCTIONS =====
        
        // Initialize on page load
        // Preload images and audio into browser cache
        function preloadAssets() {
            const imageList = [
                // Story intro backgrounds (sprite sheets for dungeon menu animation)
                'story/intro/intro_a.png',
                'story/intro/intro_b.png',
                'story/intro/intro_c.png',
                'story/intro/intro_d.png',
                'story/intro/intro_e.png',
                'story/intro/intro_f.png',
                // Story level backgrounds
                'story/lvl1/story_lvl_1.png',
                'story/lvl1/story_lvl_1_loop.png',
                'story/lvl2/story_lvl_2.png',
                'story/lvl2/story_lvl_2_idle.png',
                'story/lvl3/story_lvl_3.png',
                'story/lvl3/story_lvl_3_idle.png',
                'story/lvl4/story_lvl_4.png',
                'story/lvl4/story_lvl_4_idle.png',
                'story/lvl5/story_lvl_5.png',
                'story/lvl5/story_lvl_5_idle.png',
                'story/lvl6/story_lvl_6.png',
                'story/lvl6/story_lvl_6_idle.png',
                'story/lvl7/story_lvl_7.png',
                'story/lvl7/story_lvl_7_idle.png',
                'story/lvl8/story_lvl_8.png',
                'story/lvl8/story_lvl_8_idle.png',
                'story/lvl9/story_lvl_9.png',
                'story/lvl9/story_lvl_9_idle.png',
                'story/lvl10/story_lvl_10.png',
                'story/lvl10/story_lvl_10_idle.png',
                // Story up (ascension) backgrounds
                'story/up_1/story_up_1.png',
                'story/up_1/story_up_1_idle.png',
                'story/up_2/story_up_2.png',
                'story/up_2/story_up_2_idle.png',
                'story/up_3/story_up_3.png',
                'story/up_3/story_up_3_idle.png',
                'story/up_4/story_up_4.png',
                'story/up_4/story_up_4_idle.png',
                'story/up_5/story_up_5.png',
                'story/up_5/story_up_5_idle.png',
                // Story end
                'story/end/end.png',
                // Character head icons
                'people/zooko_a_head_compressed.png',
                'people/Nate_a_head_compressed.png',
                'people/Zancas_a_head_compressed.png',
                'people/cyberaxe_a_head_compressed.png',
                // Hero sprite sheet animations
                'tunnelsofprivacy/heros/zooko_idle.png',
                'tunnelsofprivacy/heros/zooko_idle_a.png',
                'tunnelsofprivacy/heros/zooko_idle_b.png',
                'tunnelsofprivacy/heros/zooko_light_attack.png',
                'tunnelsofprivacy/heros/zooko_heavy_attack.png',
                'tunnelsofprivacy/heros/zooko_special_attack.png',
                'tunnelsofprivacy/heros/zooko_knockout.png',
                'tunnelsofprivacy/heros/zooko_hit.png',
                'tunnelsofprivacy/heros/zooko_def.png',
                'tunnelsofprivacy/heros/nate_idle.png',
                'tunnelsofprivacy/heros/nate_idle_a.png',
                'tunnelsofprivacy/heros/nate_idle_b.png',
                'tunnelsofprivacy/heros/nate_idle_c.png',
                'tunnelsofprivacy/heros/nate_light_attack.png',
                'tunnelsofprivacy/heros/nate_heavy_attack.png',
                'tunnelsofprivacy/heros/nate_special_attack.png',
                'tunnelsofprivacy/heros/nate_special_attack_a.png',
                'tunnelsofprivacy/heros/nate_knockout.png',
                'tunnelsofprivacy/heros/nate_hit.png',
                'tunnelsofprivacy/heros/nate_def.png',
                'tunnelsofprivacy/heros/nate_heal.png',
                'tunnelsofprivacy/heros/nate_taunt.png',
                'tunnelsofprivacy/heros/nate_myturn.png',
                'tunnelsofprivacy/heros/zancas_idle.png',
                'tunnelsofprivacy/heros/zancas_idle_a.png',
                'tunnelsofprivacy/heros/zancas_idle_b.png',
                'tunnelsofprivacy/heros/zancas_light_attack.png',
                'tunnelsofprivacy/heros/zancas_heavy_attack.png',
                'tunnelsofprivacy/heros/zancas_special_attack.png',
                'tunnelsofprivacy/heros/zancas_knockout.png',
                'tunnelsofprivacy/heros/zancas_hit.png',
                'tunnelsofprivacy/heros/zancas_def.png',
                'tunnelsofprivacy/heros/zancas_heal.png',
                'tunnelsofprivacy/heros/cyberaxe_idle.png',
                'tunnelsofprivacy/heros/cyberaxe_idle_a.png',
                'tunnelsofprivacy/heros/cyberaxe_idle_b.png',
                'tunnelsofprivacy/heros/cyberaxe_light_attack.png',
                'tunnelsofprivacy/heros/cyberaxe_heavy_attack.png',
                'tunnelsofprivacy/heros/cyberaxe_special_attack.png',
                'tunnelsofprivacy/heros/cyberaxe_knockout.png',
                'tunnelsofprivacy/heros/cyberaxe_hit.png',
                'tunnelsofprivacy/heros/cyberaxe_def.png',
                // Battle backgrounds (lvl 1-10)
                'tunnelsofprivacy/backgrounds/lvl1-10/backgrounds_lvl1 (8).png',
                'tunnelsofprivacy/backgrounds/lvl1-10/backgrounds_lvl1 (10).png',
                'tunnelsofprivacy/backgrounds/lvl1-10/backgrounds_lvl1 (12).png',
                'tunnelsofprivacy/backgrounds/lvl1-10/backgrounds_lvl1 (14).png',
                'tunnelsofprivacy/backgrounds/lvl1-10/backgrounds_lvl1 (15).png',
                'tunnelsofprivacy/backgrounds/lvl1-10/backgrounds_lvl1 (16).png',
                // Boss sprites (levels 1-26 and 51-99)
                'tunnelsofprivacy/bosses/lvl1/boss_lvl1.png',
                'tunnelsofprivacy/bosses/lvl2/boss_lvl2.png',
                'tunnelsofprivacy/bosses/lvl3/boss_lvl3.png',
                'tunnelsofprivacy/bosses/lvl4/boss_lvl4.png',
                'tunnelsofprivacy/bosses/lvl5/boss_lvl5.png',
                'tunnelsofprivacy/bosses/lvl6/boss_lvl6.png',
                'tunnelsofprivacy/bosses/lvl7/boss_lvl7.png',
                'tunnelsofprivacy/bosses/lvl8/boss_lvl8.png',
                'tunnelsofprivacy/bosses/lvl9/boss_lvl9.png',
                'tunnelsofprivacy/bosses/lvl10/boss_lvl10.png',
                'tunnelsofprivacy/bosses/lvl11/boss_lvl11.png',
                'tunnelsofprivacy/bosses/lvl12/boss_lvl12.png',
                'tunnelsofprivacy/bosses/lvl13/boss_lvl13.png',
                'tunnelsofprivacy/bosses/lvl14/boss_lvl14.png',
                'tunnelsofprivacy/bosses/lvl15/boss_lvl15.png',
                'tunnelsofprivacy/bosses/lvl16/boss_lvl16.png',
                'tunnelsofprivacy/bosses/lvl17/boss_lvl17.png',
                'tunnelsofprivacy/bosses/lvl18/boss_lvl18.png',
                'tunnelsofprivacy/bosses/lvl19/boss_lvl19.png',
                'tunnelsofprivacy/bosses/lvl20/boss_lvl20.png',
                'tunnelsofprivacy/bosses/lvl21/boss_lvl21.png',
                'tunnelsofprivacy/bosses/lvl22/boss_lvl22.png',
                'tunnelsofprivacy/bosses/lvl23/boss_lvl23.png',
                'tunnelsofprivacy/bosses/lvl24/boss_lvl24.png',
                'tunnelsofprivacy/bosses/lvl25/boss_lvl25.png',
                'tunnelsofprivacy/bosses/lvl26/boss_lvl26.png',
                // Levels 27-50
                'tunnelsofprivacy/bosses/lvl27/boss_lvl27.png',
                'tunnelsofprivacy/bosses/lvl28/boss_lvl28.png',
                'tunnelsofprivacy/bosses/lvl29/boss_lvl29.png',
                'tunnelsofprivacy/bosses/lvl30/boss_lvl30.png',
                'tunnelsofprivacy/bosses/lvl31/boss_lvl31.png',
                'tunnelsofprivacy/bosses/lvl32/boss_lvl32.png',
                'tunnelsofprivacy/bosses/lvl33/boss_lvl33.png',
                'tunnelsofprivacy/bosses/lvl34/boss_lvl34.png',
                'tunnelsofprivacy/bosses/lvl35/boss_lvl35.png',
                'tunnelsofprivacy/bosses/lvl36/boss_lvl36.png',
                'tunnelsofprivacy/bosses/lvl37/boss_lvl37.png',
                'tunnelsofprivacy/bosses/lvl38/boss_lvl38.png',
                'tunnelsofprivacy/bosses/lvl39/boss_lvl39.png',
                'tunnelsofprivacy/bosses/lvl40/boss_lvl40.png',
                'tunnelsofprivacy/bosses/lvl41/boss_lvl41.png',
                'tunnelsofprivacy/bosses/lvl42/boss_lvl42.png',
                'tunnelsofprivacy/bosses/lvl43/boss_lvl43.png',
                'tunnelsofprivacy/bosses/lvl44/boss_lvl44.png',
                'tunnelsofprivacy/bosses/lvl45/boss_lvl45.png',
                'tunnelsofprivacy/bosses/lvl46/boss_lvl46.png',
                'tunnelsofprivacy/bosses/lvl47/boss_lvl47.png',
                'tunnelsofprivacy/bosses/lvl48/boss_lvl48.png',
                'tunnelsofprivacy/bosses/lvl49/boss_lvl49.png',
                'tunnelsofprivacy/bosses/lvl50/boss_lvl50.png',
                // New wide bosses (917x512) levels 51-99
                'tunnelsofprivacy/bosses/lvl51/boss_lvl51.png',
                'tunnelsofprivacy/bosses/lvl52/boss_lvl52.png',
                'tunnelsofprivacy/bosses/lvl53/boss_lvl53.png',
                'tunnelsofprivacy/bosses/lvl54/boss_lvl54.png',
                'tunnelsofprivacy/bosses/lvl55/boss_lvl55.png',
                'tunnelsofprivacy/bosses/lvl56/boss_lvl56.png',
                'tunnelsofprivacy/bosses/lvl57/boss_lvl57.png',
                'tunnelsofprivacy/bosses/lvl58/boss_lvl58.png',
                'tunnelsofprivacy/bosses/lvl59/boss_lvl59.png',
                'tunnelsofprivacy/bosses/lvl60/boss_lvl60.png',
                'tunnelsofprivacy/bosses/lvl61/boss_lvl61.png',
                'tunnelsofprivacy/bosses/lvl62/boss_lvl62.png',
                'tunnelsofprivacy/bosses/lvl63/boss_lvl63.png',
                'tunnelsofprivacy/bosses/lvl64/boss_lvl64.png',
                'tunnelsofprivacy/bosses/lvl65/boss_lvl65.png',
                'tunnelsofprivacy/bosses/lvl66/boss_lvl66.png',
                'tunnelsofprivacy/bosses/lvl67/boss_lvl67.png',
                'tunnelsofprivacy/bosses/lvl68/boss_lvl68.png',
                'tunnelsofprivacy/bosses/lvl69/boss_lvl69.png',
                'tunnelsofprivacy/bosses/lvl70/boss_lvl70.png',
                'tunnelsofprivacy/bosses/lvl71/boss_lvl71.png',
                'tunnelsofprivacy/bosses/lvl72/boss_lvl72.png',
                'tunnelsofprivacy/bosses/lvl73/boss_lvl73.png',
                'tunnelsofprivacy/bosses/lvl74/boss_lvl74.png',
                'tunnelsofprivacy/bosses/lvl75/boss_lvl75.png',
                'tunnelsofprivacy/bosses/lvl76/boss_lvl76.png',
                'tunnelsofprivacy/bosses/lvl77/boss_lvl77.png',
                'tunnelsofprivacy/bosses/lvl78/boss_lvl78.png',
                'tunnelsofprivacy/bosses/lvl79/boss_lvl79.png',
                'tunnelsofprivacy/bosses/lvl80/boss_lvl80.png',
                'tunnelsofprivacy/bosses/lvl81/boss_lvl81.png',
                'tunnelsofprivacy/bosses/lvl82/boss_lvl82.png',
                'tunnelsofprivacy/bosses/lvl83/boss_lvl83.png',
                'tunnelsofprivacy/bosses/lvl84/boss_lvl84.png',
                'tunnelsofprivacy/bosses/lvl85/boss_lvl85.png',
                'tunnelsofprivacy/bosses/lvl86/boss_lvl86.png',
                'tunnelsofprivacy/bosses/lvl87/boss_lvl87.png',
                'tunnelsofprivacy/bosses/lvl88/boss_lvl88.png',
                'tunnelsofprivacy/bosses/lvl89/boss_lvl89.png',
                'tunnelsofprivacy/bosses/lvl90/boss_lvl90.png',
                'tunnelsofprivacy/bosses/lvl91/boss_lvl91.png',
                'tunnelsofprivacy/bosses/lvl92/boss_lvl92.png',
                'tunnelsofprivacy/bosses/lvl93/boss_lvl93.png',
                'tunnelsofprivacy/bosses/lvl94/boss_lvl94.png',
                'tunnelsofprivacy/bosses/lvl95/boss_lvl95.png',
                'tunnelsofprivacy/bosses/lvl96/boss_lvl96.png',
                'tunnelsofprivacy/bosses/lvl97/boss_lvl97.png',
                'tunnelsofprivacy/bosses/lvl98/boss_lvl98.png',
                'tunnelsofprivacy/bosses/lvl99/boss_lvl99.png',
                'tunnelsofprivacy/bosses/lvl100/boss_lvl100.png',
                'tunnelsofprivacy/bosses/lvl100/boss_lvl100_idle.png',
                'tunnelsofprivacy/bosses/lvl100/boss_lvl100_attack.png',
                // Captive/prisoner sprites
                'tunnelsofprivacy/npcs/captives/prisoners (1).png',
                'tunnelsofprivacy/npcs/captives/prisoners (2).png',
                'tunnelsofprivacy/npcs/captives/prisoners (3).png',
                'tunnelsofprivacy/npcs/captives/prisoners (4).png',
                'tunnelsofprivacy/npcs/captives/prisoners (5).png',
                'tunnelsofprivacy/npcs/captives/prisoners (6).png',
                'tunnelsofprivacy/npcs/captives/prisoners (7).png',
                'tunnelsofprivacy/npcs/captives/prisoners (8).png',
                'tunnelsofprivacy/npcs/captives/prisoners (9).png',
                'tunnelsofprivacy/npcs/captives/prisoners (10).png',
                'tunnelsofprivacy/npcs/captives/prisoners (11).png',
                'tunnelsofprivacy/npcs/captives/prisoners (12).png',
                // Item sprites
                'tunnelsofprivacy/items/healing_potions_a_cropped.png',
                'tunnelsofprivacy/items/healing_potions_a_empty.png',
                // Party meal sprites
                'tunnelsofprivacy/items/meal_1.png',
                'tunnelsofprivacy/items/meal_2.png',
                'tunnelsofprivacy/items/meal_3.png',
                'tunnelsofprivacy/items/meal_4.png',
                'tunnelsofprivacy/items/meal_5.png',
                'tunnelsofprivacy/items/meal_6.png',
                'tunnelsofprivacy/items/meal_7.png',
                'tunnelsofprivacy/items/meal_8.png',
                'tunnelsofprivacy/items/meal_9.png',
                'tunnelsofprivacy/items/meal_10.png',
                // Particle effect atlases
                'effect/atlas_a.png',
                'effect/atlas_b.png',
                'effect/atlas_c.png',
                'effect/atlas_d.png',
                'effect/atlas_e.png',
                'effect/atlas_f.png',
                'effect/atlas_g.png',
                'effect/smoke_effects.png',
                'effect/misc1_effects.png',
                // Gear/backpack sprites
                'tunnelsofprivacy/gear/zooko_backpack.png',
                'tunnelsofprivacy/gear/nate_backpack.png',
                'tunnelsofprivacy/gear/zancas_backpack.png',
                'tunnelsofprivacy/gear/cyberaxe_backpack.png',
                // Common mob sprites (basic enemies)
                'tunnelsofprivacy/mobs/beetle1.png',
                'tunnelsofprivacy/mobs/beetle2.png',
                'tunnelsofprivacy/mobs/blob1.png',
                'tunnelsofprivacy/mobs/blob2.png',
                'tunnelsofprivacy/mobs/rat1.png',
                'tunnelsofprivacy/mobs/spider1.png',
                'tunnelsofprivacy/mobs/worm1.png',
                'tunnelsofprivacy/mobs/mite1.png',
                'tunnelsofprivacy/mobs/moth1.png',
                'tunnelsofprivacy/mobs/moth2.png',
                'tunnelsofprivacy/mobs/orb1.png',
                'tunnelsofprivacy/mobs/gnawer1.png',
                'tunnelsofprivacy/mobs/goblin1.png',
                'tunnelsofprivacy/mobs/insect1.png',
                'tunnelsofprivacy/mobs/creature1.png',
                'tunnelsofprivacy/mobs/creature2.png',
                'tunnelsofprivacy/mobs/creature3.png',
                'tunnelsofprivacy/mobs/creature4.png',
                'tunnelsofprivacy/mobs/creature5.png',
                'tunnelsofprivacy/mobs/creature6.png',
                // UI Icons
                'tunnelsofprivacy/icons/arcade.png',
                'tunnelsofprivacy/icons/back.png',
                'tunnelsofprivacy/icons/border.png',
                'tunnelsofprivacy/icons/camping.png',
                'tunnelsofprivacy/icons/combat.png',
                'tunnelsofprivacy/icons/difficulty_easy.png',
                'tunnelsofprivacy/icons/difficulty_hard.png',
                'tunnelsofprivacy/icons/difficulty_normal.png',
                'tunnelsofprivacy/icons/donate.png',
                'tunnelsofprivacy/icons/dungeon_master.png',
                'tunnelsofprivacy/icons/explore.png',
                'tunnelsofprivacy/icons/goldbag.png',
                'tunnelsofprivacy/icons/heart.png',
                'tunnelsofprivacy/icons/heart_a.png',
                'tunnelsofprivacy/icons/help.png',
                'tunnelsofprivacy/icons/inventory.png',
                'tunnelsofprivacy/icons/lootcrate.png',
                'tunnelsofprivacy/icons/music_back.png',
                'tunnelsofprivacy/icons/music_forward.png',
                'tunnelsofprivacy/icons/music_pause.png',
                'tunnelsofprivacy/icons/music_play.png',
                'tunnelsofprivacy/icons/narrate.png',
                'tunnelsofprivacy/icons/party_inventory.png',
                'tunnelsofprivacy/icons/questlog.png',
                'tunnelsofprivacy/icons/settings.png',
                'tunnelsofprivacy/icons/stairs_down.png',
                'tunnelsofprivacy/icons/stairs_up.png',
                'tunnelsofprivacy/icons/store.png',
                'tunnelsofprivacy/icons/volume.png',
                'tunnelsofprivacy/icons/zcashbag.png',
                // Event backgrounds - Exploration (11 images)
                'tunnelsofprivacy/events/explore/explore (1).png',
                'tunnelsofprivacy/events/explore/explore (2).png',
                'tunnelsofprivacy/events/explore/explore (3).png',
                'tunnelsofprivacy/events/explore/explore (4).png',
                'tunnelsofprivacy/events/explore/explore (5).png',
                'tunnelsofprivacy/events/explore/explore (6).png',
                'tunnelsofprivacy/events/explore/explore (7).png',
                'tunnelsofprivacy/events/explore/explore (8).png',
                'tunnelsofprivacy/events/explore/explore (9).png',
                'tunnelsofprivacy/events/explore/explore (10).png',
                'tunnelsofprivacy/events/explore/explore (11).png',
                // Event backgrounds - NPC Encounters (10 images)
                'tunnelsofprivacy/events/encoutners/encoutners (1).png',
                'tunnelsofprivacy/events/encoutners/encoutners (2).png',
                'tunnelsofprivacy/events/encoutners/encoutners (3).png',
                'tunnelsofprivacy/events/encoutners/encoutners (4).png',
                'tunnelsofprivacy/events/encoutners/encoutners (5).png',
                'tunnelsofprivacy/events/encoutners/encoutners (6).png',
                'tunnelsofprivacy/events/encoutners/encoutners (7).png',
                'tunnelsofprivacy/events/encoutners/encoutners (8).png',
                'tunnelsofprivacy/events/encoutners/encoutners (9).png',
                'tunnelsofprivacy/events/encoutners/encoutners (10).png'
            ];
            
            artTotal = imageList.length;
            assetsToLoad += imageList.length;
            
            // Preload images (also populates spriteSheetCache for animation system)
            imageList.forEach(imagePath => {
                const img = new Image();
                img.src = imagePath;
                img.addEventListener('load', () => {
                    // Cache sprite sheets for animation system
                    if (imagePath.includes('tunnelsofprivacy/heros/')) {
                        spriteSheetCache[imagePath] = img;
                    }
                    artLoaded++;
                    assetsLoaded++;
                    updateLoadingProgress();
                }, { once: true });
                img.addEventListener('error', (e) => {
                    console.error(`Failed to preload: ${imagePath}`, e);
                    artLoaded++;
                    assetsLoaded++;
                    updateLoadingProgress();
                }, { once: true });
            });
            
            // Preload music if enabled
            if (musicEnabled && musicVolume > 0) {
                audioTotal = 1;
                assetsToLoad += 1;
                
                const musicPlayer = document.getElementById('musicPlayer');
                if (musicPlayer) {
                    musicPlayer.volume = Math.min(1.0, musicVolume / 500);
                    musicPlayer.preload = 'metadata'; // Changed from 'auto' to avoid hanging
                    
                    // Set a timeout in case music doesn't load
                    const musicTimeout = setTimeout(() => {
                        audioLoaded++;
                        assetsLoaded++;
                        updateLoadingProgress();
                    }, 3000); // 3 second timeout
                    
                    musicPlayer.addEventListener('loadedmetadata', () => {
                        clearTimeout(musicTimeout);
                        audioLoaded++;
                        assetsLoaded++;
                        updateLoadingProgress();
                    }, { once: true });
                    
                    musicPlayer.addEventListener('error', (e) => {
                        console.error('Failed to preload music', e);
                        clearTimeout(musicTimeout);
                        audioLoaded++;
                        assetsLoaded++;
                        updateLoadingProgress();
                    }, { once: true });
                    
                    musicPlayer.load();
                } else {
                    // Music player doesn't exist, skip it
                    audioLoaded++;
                    assetsLoaded++;
                    updateLoadingProgress();
                }
            }
            
            // Preload SFX - use simpler approach that doesn't hang
            const sfxKeys = Object.keys(SFX_PATHS);
            const sfxCount = sfxKeys.length;
            audioTotal += sfxCount;
            assetsToLoad += sfxCount;
            
            // Track which SFX have been counted to prevent double-counting
            const sfxCounted = new Set();
            
            sfxKeys.forEach(key => {
                const path = SFX_PATHS[key];
                const audio = new Audio();
                audio.preload = 'metadata'; // Use metadata instead of auto - faster and more reliable
                
                const markLoaded = () => {
                    if (!sfxCounted.has(key)) {
                        sfxCounted.add(key);
                        audioLoaded++;
                        assetsLoaded++;
                        updateLoadingProgress();
                    }
                };
                
                audio.addEventListener('loadedmetadata', markLoaded, { once: true });
                audio.addEventListener('canplaythrough', markLoaded, { once: true });
                audio.addEventListener('error', (e) => {
                    console.warn(`SFX preload failed (will load on demand): ${key}`);
                    markLoaded();
                }, { once: true });
                
                // Short timeout fallback - SFX will load on demand if needed
                setTimeout(markLoaded, 5000);
                
                audio.src = path;
            });
            
            // Preload particle effect atlases and JSON configs
            preloadParticleEffects();
            
            // Preload all hero and boss animation sprite sheets
            preloadAllAnimations();
            
            updateLoadingProgress();
        }
        
        // Update loading progress indicator
        function updateLoadingProgress() {
            const loadingIndicator = document.getElementById('loadingIndicator');
            const loadingBar = document.getElementById('loadingBar');
            const loadingArt = document.getElementById('loadingArt');
            const loadingSound = document.getElementById('loadingSound');
            
            if (loadingIndicator && assetsToLoad > 0) {
                const percent = Math.floor((assetsLoaded / assetsToLoad) * 100);
                loadingIndicator.textContent = `${percent}%`;
                
                if (loadingBar) {
                    loadingBar.style.width = `${percent}%`;
                    loadingBar.textContent = `${percent}%`;
                }
                
                // Update category counts
                if (loadingArt) {
                    loadingArt.innerHTML = `ðŸŽ¨ Art: <span style="color: #8B45FF; font-weight: bold;">${artLoaded}/${artTotal}</span>`;
                }
                if (loadingSound) {
                    loadingSound.innerHTML = `<span class="icon icon-sm icon-volume"></span> Sound: <span style="color: #8B45FF; font-weight: bold;">${audioLoaded}/${audioTotal}</span>`;
                }
            }
            
            checkAllAssetsReady();
        }
        
        function checkAllAssetsReady() {
            if (assetsToLoad > 0 && assetsLoaded >= assetsToLoad && !allAssetsReady) {
                allAssetsReady = true;
                
                const loadingIndicator = document.getElementById('loadingIndicator');
                const loadingBar = document.getElementById('loadingBar');
                const loadingModal = document.getElementById('loadingModal');
                const loadingNote = document.getElementById('loadingNote');
                const clickToPlayPrompt = document.getElementById('clickToPlayPrompt');
                
                if (loadingIndicator) {
                    loadingIndicator.textContent = 'âœ“ All Assets Ready!';
                    loadingIndicator.style.color = '#2ECC71';
                }
                
                if (loadingBar) {
                    loadingBar.style.width = '100%';
                    loadingBar.textContent = '100%';
                    loadingBar.style.background = 'linear-gradient(90deg, #2ECC71, #27AE60)';
                }
                
                if (loadingNote) {
                    loadingNote.style.display = 'none';
                }
                
                if (clickToPlayPrompt) {
                    clickToPlayPrompt.style.display = 'block';
                    
                    // Start gamepad polling for A button
                    pollGamepadForClickToPlay();
                    
                    const handleClick = () => {
                        // Start music when user clicks - always start with main theme
                        if (musicEnabled && musicVolume > 0 && !musicStarted) {
                            loadMusic(themeTracks[0]); // Always start with main theme (index 0)
                        }
                        
                        // Fade out and remove loading modal
                        if (loadingModal) {
                            loadingModal.style.opacity = '0';
                            loadingModal.style.transition = 'opacity 0.5s ease';
                            setTimeout(() => {
                                loadingModal.style.display = 'none';
                            }, 500);
                        }
                        
                        // Remove click handler
                        clickToPlayPrompt.removeEventListener('click', handleClick);
                        document.removeEventListener('keydown', handleKeyDown);
                    };
                    
                    const handleKeyDown = (e) => {
                        if (e.key === 'a' || e.key === 'A' || e.key === 'Enter') {
                            handleClick();
                        }
                    };
                    
                    clickToPlayPrompt.addEventListener('click', handleClick);
                    document.addEventListener('keydown', handleKeyDown);
                }
            }
        }
        
        // ===== MULTIPLAYER WEBSOCKET FUNCTIONS =====
        
        function connectWebSocket() {
            if (multiplayerState.ws && multiplayerState.ws.readyState === WebSocket.OPEN) {
                return; // Already connected
            }
            
            const wsUrl = `ws://${window.location.hostname}:8765`;
            console.log('[MP] Connecting to WebSocket:', wsUrl);
            
            multiplayerState.ws = new WebSocket(wsUrl);
            
            multiplayerState.ws.onopen = () => {
                console.log('[MP] WebSocket connected');
                multiplayerState.enabled = true;
            };
            
            multiplayerState.ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                handleWebSocketMessage(data);
            };
            
            multiplayerState.ws.onerror = (error) => {
                console.error('[MP] WebSocket error:', error);
                showNotification('Multiplayer connection error', 'error');
            };
            
            multiplayerState.ws.onclose = () => {
                console.log('[MP] WebSocket closed');
                if (multiplayerState.enabled && !multiplayerState.isReconnecting) {
                    showNotification('Disconnected from multiplayer', 'warning');
                    resetMultiplayerState();
                }
            };
        }
        
        function handleWebSocketMessage(data) {
            console.log('[MP] Received:', data);
            
            switch(data.type) {
                case 'room_created':
                    multiplayerState.roomCode = data.code;
                    multiplayerState.role = 'host';
                    multiplayerState.myPlayerId = data.player_id;
                    // Get player name from data (set by user on title screen)
                    if (data.players && data.players[0]) {
                        multiplayerState.playerName = data.players[0].name;
                    }
                    // Store initial player list
                    if (data.players) {
                        multiplayerState.connectedPlayers = data.players;
                    }
                    showNotification(`Room created: ${data.code}`, 'success');
                    // Host enters hero selection immediately
                    showHeroSelection();
                    break;
                
                case 'joined':
                    multiplayerState.roomCode = data.code;
                    multiplayerState.role = 'client';
                    multiplayerState.myPlayerId = data.player_id;
                    // Store player list
                    if (data.players) {
                        multiplayerState.connectedPlayers = data.players;
                        // Find my name from the list
                        const me = data.players.find(p => p.id === data.player_id);
                        if (me) {
                            multiplayerState.playerName = me.name;
                        }
                    }
                    
                    // Check if this is a reconnection
                    if (data.reconnected) {
                        multiplayerState.isReconnecting = true;
                        showNotification(`Reconnected to room: ${data.code}`, 'success');
                    } else {
                        multiplayerState.isReconnecting = false;
                        showNotification(`Joined room: ${data.code}`, 'success');
                    }
                    
                    // Show hero selection
                    showHeroSelection();
                    
                    // Sync current hero selections from host (if any heroes already selected)
                    if (data.heroes && Object.keys(data.heroes).length > 0) {
                        updateHeroSelection({ heroes: data.heroes, players: data.players });
                    }
                    break;
                
                case 'error':
                    showNotification(data.message, 'error');
                    break;
                
                case 'name_taken':
                    // Name is already in use - prompt to change
                    showNotification(data.message, 'error');
                    // Generate a new random name and show it to user
                    const newRandomName = generateRandomPlayerName();
                    multiplayerState.playerName = newRandomName;
                    const nameInput = document.getElementById('multiplayerPlayerName');
                    if (nameInput) {
                        nameInput.value = newRandomName;
                        nameInput.focus();
                        nameInput.select();
                    }
                    // Close WebSocket since we were rejected
                    if (multiplayerState.ws) {
                        multiplayerState.ws.close();
                        multiplayerState.ws = null;
                    }
                    break;
                
                case 'players_update':
                    // Update connected players list
                    if (data.players) {
                        multiplayerState.connectedPlayers = data.players;
                    }
                    // Update hero selections if provided
                    if (data.heroes) {
                        updateHeroSelection({ heroes: data.heroes });
                    } else {
                        // Just update the player list display
                        updateConnectedPlayersListOnly();
                    }
                    break;
                
                case 'player_joined':
                    showNotification(`Player joined (${data.player_count} total)`, 'info');
                    // If host, send current inventory and equipment to new player
                    if (multiplayerState.role === 'host') {
                        sendInventoryUpdate(); // This now includes equipment
                    }
                    break;
                
                case 'hero_selected':
                    // Update player list if provided
                    if (data.players) {
                        multiplayerState.connectedPlayers = data.players;
                    }
                    // Store heroes data for roll phase tracking
                    if (data.heroes) {
                        multiplayerState.playerHeroes = data.heroes;
                    }
                    // Update hero selections
                    updateHeroSelection(data);
                    break;
                
                case 'hero_stats_rolled':
                    // Another player rolled stats for their hero - update display
                    if (data.hero && data.stats) {
                        const heroKey = data.hero;
                        const stats = data.stats;
                        
                        // Update the hero card display
                        const fields = ['str', 'dex', 'con', 'int', 'wis', 'cha', 'hp', 'ac'];
                        fields.forEach(field => {
                            const el = document.getElementById(`sel-${heroKey}-${field}`);
                            if (el && stats[field] !== undefined) el.textContent = stats[field];
                        });
                        const maxHpEl = document.getElementById(`sel-${heroKey}-maxhp`);
                        if (maxHpEl && stats.maxHp !== undefined) maxHpEl.textContent = stats.maxHp;
                        
                        // Store in multiplayerState so host can use it
                        if (!multiplayerState.rolledHeroStats) {
                            multiplayerState.rolledHeroStats = {};
                        }
                        multiplayerState.rolledHeroStats[heroKey] = stats;
                        
                        // Update roll phase status (to check if all have rolled)
                        updateRollPhaseStatus();
                        
                        const heroName = heroKey.charAt(0).toUpperCase() + heroKey.slice(1);
                        showNotification(`${heroName}'s stats rolled by player`, 'info');
                    }
                    break;
                
                case 'player_action':
                    // Host receives client action
                    if (multiplayerState.role === 'host') {
                        processClientAction(data);
                    }
                    break;
                
                case 'request_resync':
                    // Client is requesting a full state resync
                    if (multiplayerState.role === 'host') {
                        console.log('[HOST] Client requested resync');
                        const sharedSave = loadSharedSave();
                        
                        // Send game_start with current screen and full state (existing message type)
                        sendWebSocketMessage({
                            type: 'game_start',
                            screen: currentScreen,
                            saveData: sharedSave,
                            levelLayout: currentLevelLayout,
                            levelProgress: levelProgress
                        });
                        
                        // Also sync inventory/equipment (existing message type)
                        sendInventoryUpdate();
                        
                        // If in battle, also send battle state (existing message type)
                        if (battleState.active) {
                            broadcastGameState();
                        }
                    }
                    break;
                
                case 'state_update':
                    // Client receives state from host
                    if (multiplayerState.role === 'client') {
                        updateGameStateFromHost(data.state);
                    }
                    break;
                
                case 'battle_init':
                    // Client receives battle initialization from host
                    if (multiplayerState.role === 'client') {
                        initializeBattleFromHost(data.battleData);
                    }
                    break;
                
                case 'battle_end':
                    // Host notifies battle has ended
                    if (multiplayerState.role === 'client') {
                        const reason = data.reason;
                        if (reason === 'retreat') {
                            showBattleNotification('PARTY RETREATS!');
                            
                            // Update hero stats from host if provided
                            if (data.heroStats) {
                                data.heroStats.forEach(stats => {
                                    const hero = battleState.heroes.find(h => h.name === stats.name);
                                    if (hero) {
                                        hero.hp = stats.hp;
                                        hero.maxHp = stats.maxHp;
                                    }
                                    // Also update cache
                                    const heroKey = stats.name.toLowerCase();
                                    if (multiplayerState.heroStatsCache[heroKey]) {
                                        multiplayerState.heroStatsCache[heroKey].hp = stats.hp;
                                        multiplayerState.heroStatsCache[heroKey].maxHp = stats.maxHp;
                                    }
                                });
                            }
                        } else if (reason === 'defeat') {
                            showBattleNotification('DEFEAT! ALL HEROES FALLEN!');
                        }
                        
                        setTimeout(() => {
                            // Hide notification
                            const notification = document.getElementById('battleNotification');
                            if (notification) notification.style.display = 'none';
                            
                            // Client: Switch UI and display from cached stats
                            battleState.active = false;
                            currentScreen = 'dungeonMenu';
                            stopBattleVideo(); // Stop and hide video background
                            document.getElementById('battleScreen').style.display = 'none';
                            document.getElementById('dungeonMenuScreen').style.display = 'block';
                            
                            // Move music controls and ticker back to center bottom
                            document.getElementById('musicControls').classList.remove('battleActive');
                            document.getElementById('musicControls').classList.add('dungeonMenuActive');
                            document.getElementById('musicTicker').classList.remove('battleActive');
                            document.getElementById('musicTicker').classList.add('dungeonMenuActive');
                            
                            // Update dungeon menu from cached stats (already updated from state_update broadcasts)
                            updateDungeonMenuHeroes();
                            updateGoldDisplay();
                        }, 1500);
                    }
                    break;
                
                case 'non_combat_room':
                    // Host notifies about non-combat room (store, NPC, secret, exploration)
                    if (multiplayerState.role === 'client') {
                        if (data.action === 'enter') {
                            // Client enters non-combat room with host's data
                            clientEnterNonCombatRoom(data.roomType, data.data);
                        } else if (data.action === 'leave') {
                            // Host left - client follows immediately
                            console.log('[MP] Host left non-combat room, following...');
                            executeLeaveNonCombatRoom();
                            showNotification('Party left the room', 'info');
                        }
                    }
                    break;
                
                case 'npc_choice':
                    // Host made NPC choice (help/rob/ignore) - sync to clients
                    if (multiplayerState.role === 'client') {
                        const choice = data.choice;
                        console.log('[MP] Received NPC choice from host:', choice);
                        
                        // Mark choice as made
                        if (preGeneratedEncounter.npcData) {
                            preGeneratedEncounter.npcData.choiceMade = true;
                        }
                        
                        // Show the result
                        showNPCChoiceResult(choice, data.cost || 0, data.reward || 0);
                        
                        // Show notification based on choice
                        const npcName = preGeneratedEncounter.npcData?.name || 'the NPC';
                        if (choice === 'help') {
                            showNotification(`Host helped ${npcName}! -${data.cost} Gold, +${data.reward} XP`, 'success');
                        } else if (choice === 'rob') {
                            showNotification(`Host robbed ${npcName}! +${data.reward} Gold`, 'warning');
                        } else if (choice === 'zcash') {
                            // Play video for clients too
                            const overlay = document.getElementById('zcashVideoOverlay');
                            const video = document.getElementById('zcashVideo');
                            overlay.style.display = 'flex';
                            video.currentTime = 0;
                            video.volume = (settings.musicVolume || 50) / 150;
                            video.play().catch(e => console.log('[Zcash Video] Autoplay blocked:', e));
                            video.onended = function() {
                                overlay.style.display = 'none';
                            };
                            showNotification(`Host told ${npcName} about Zcash! +${data.reward} XP`, 'success');
                        } else {
                            showNotification(`Host ignored ${npcName}`, 'info');
                        }
                    }
                    break;
                
                case 'exploration_choice':
                    // Host made exploration choice (one/party/retreat) - sync to clients
                    if (multiplayerState.role === 'client') {
                        const expChoice = data.choice;
                        console.log('[MP] Received exploration choice from host:', expChoice);
                        
                        // Mark choice as made
                        if (preGeneratedEncounter.explorationData) {
                            preGeneratedEncounter.explorationData.choiceMade = true;
                        }
                        
                        // Show the result based on choice and success
                        if (expChoice === 'one') {
                            const heroName = data.hero ? data.hero.charAt(0).toUpperCase() + data.hero.slice(1) : 'Hero';
                            if (data.success) {
                                showExplorationChoiceResult('one_success', data.hero, data.xp, 0);
                                showNotification(`${heroName} succeeded! +${data.xp} XP`, 'success');
                            } else {
                                showExplorationChoiceResult('one_fail', data.hero, 0, data.damage);
                                showNotification(`${heroName} failed! -${data.damage} HP`, 'error');
                            }
                        } else if (expChoice === 'party') {
                            if (data.success) {
                                showExplorationChoiceResult('party_success', null, data.xp, 0);
                                showNotification(`Party succeeded! +${data.xp} XP`, 'success');
                            } else {
                                showExplorationChoiceResult('party_fail', null, 0, data.damage);
                                showNotification(`Party failed! Everyone takes -${data.damage} HP`, 'error');
                            }
                        } else {
                            showExplorationChoiceResult('retreat', null, 0, 0);
                            showNotification('Party retreated safely', 'info');
                        }
                    }
                    break;
                
                case 'level_change':
                    // Host notifies level change from stairs/fast travel
                    if (multiplayerState.role === 'client') {
                        const newLevel = data.newLevel;
                        console.log('[MP] Received level change from host:', newLevel);
                        
                        // Update UI
                        const dungeonLevelEl = document.getElementById('dungeonMenuLevel');
                        if (dungeonLevelEl) {
                            dungeonLevelEl.textContent = newLevel;
                        }
                        
                        // Update story background for new level
                        updateDungeonMenuBackground();
                        
                        // Reset encounter state for new level (client doesn't generate, waits for host)
                        preGeneratedEncounter = {
                            ready: false,
                            generating: false,
                            boss: null,
                            mobs: [],
                            captive: null,
                            background: null,
                            roomLevel: newLevel
                        };
                        updateExploreLoadingBar(0);
                        
                        // Full sync of level progress and layout from host
                        updateLevelProgressFromHost(data.progress, data.levelLayout);
                        
                        showNotification(`Party moved to level ${newLevel}`, 'info');
                    }
                    break;
                
                case 'level_progress_update':
                    // Host broadcasts level progress changes to clients
                    if (multiplayerState.role === 'client') {
                        console.log('[MP] Received level progress update from host');
                        updateLevelProgressFromHost(data.progress, data.levelLayout);
                    }
                    break;
                
                case 'difficulty_change':
                    // Host notifies difficulty change
                    if (multiplayerState.role === 'client') {
                        const newDifficulty = data.difficulty;
                        console.log('[MP] Received difficulty change from host:', newDifficulty);
                        
                        // Update local setting (don't save - client doesn't persist host settings)
                        settings.difficulty = newDifficulty;
                        
                        // Update button visuals
                        updateDifficultyButtons();
                        
                        // Reset encounter state (client waits for host to regenerate)
                        preGeneratedEncounter = {
                            ready: false,
                            generating: false,
                            boss: null,
                            mobs: [],
                            captive: null,
                            background: null,
                            roomLevel: preGeneratedEncounter.roomLevel || 1
                        };
                        updateExploreLoadingBar(0);
                        
                        const difficultyNames = { 'casual': 'Casual', 'normal': 'Normal', 'expert': 'Expert' };
                        showNotification(`Difficulty changed to ${difficultyNames[newDifficulty]}`, 'info');
                    }
                    break;
                
                case 'kicked':
                    showNotification(data.message, 'error');
                    resetMultiplayerState();
                    break;
                
                case 'camp_started':
                    // Host started camping - show camping screen on client
                    if (multiplayerState.role === 'client') {
                        console.log('[MP] Received camp_started from host');
                        
                        campState.active = true;
                        campState.selectedHours = data.hours;
                        campState.hoursRemaining = data.hours;
                        
                        // Hide dungeon menu, show camping screen
                        document.getElementById('dungeonMenuScreen').style.display = 'none';
                        const campingScreen = document.getElementById('campingScreen');
                        if (campingScreen) {
                            campingScreen.style.display = 'block';
                        }
                        
                        // Load and play camp video (same as host)
                        const videoEl = document.getElementById('campVideo');
                        if (videoEl && data.videoSrc) {
                            videoEl.querySelector('source').src = data.videoSrc;
                            videoEl.load();
                            videoEl.volume = (settings.bgSoundVolume ?? 25) / 500; // Use settings
                            videoEl.play().catch(e => console.log('[Camp] Video autoplay blocked:', e));
                        }
                        
                        // Update UI
                        document.getElementById('campTimeRemaining').textContent = data.hours;
                        document.getElementById('campProgressBar').style.width = '0%';
                        document.getElementById('campHealedSoFar').textContent = '0';
                        document.getElementById('campEventLog').innerHTML = '<div style="color: #89A0B4; font-size: 12px; text-align: center;">The campfire crackles softly...</div>';
                        
                        // Add initial camp event from host
                        if (data.initialEvent) {
                            addCampEvent(data.initialEvent);
                        }
                        
                        showNotification(`Party leader is setting up camp for ${data.hours} hours`, 'info');
                    }
                    break;
                
                case 'camp_completed':
                    // Host finished camping
                    if (multiplayerState.role === 'client') {
                        console.log('[MP] Received camp_completed from host');
                        
                        campState.active = false;
                        
                        // Stop video
                        const campVideoEl = document.getElementById('campVideo');
                        if (campVideoEl) {
                            campVideoEl.pause();
                        }
                        
                        // Update hero stats cache from host data (this is what updateDungeonMenuHeroes reads)
                        if (data.heroes) {
                            data.heroes.forEach(heroData => {
                                const heroKey = heroData.name.toLowerCase();
                                if (multiplayerState.heroStatsCache[heroKey]) {
                                    multiplayerState.heroStatsCache[heroKey].hp = heroData.hp;
                                    multiplayerState.heroStatsCache[heroKey].maxHp = heroData.maxHp;
                                } else {
                                    multiplayerState.heroStatsCache[heroKey] = { hp: heroData.hp, maxHp: heroData.maxHp };
                                }
                            });
                        }
                        
                        // Return to dungeon menu
                        document.getElementById('campingScreen').style.display = 'none';
                        document.getElementById('dungeonMenuScreen').style.display = 'block';
                        updateDungeonMenuHeroes();
                        
                        if (data.cancelled) {
                            showNotification('Host broke camp early', 'info');
                        } else {
                            showNotification(`Party rested for ${data.hoursRested} hours! +${data.healedAmount} HP healed.`, 'success');
                        }
                    }
                    break;
                
                case 'party_level_update':
                    // Host set party level - update client hero stats
                    if (multiplayerState.role === 'client') {
                        // Update hero stats cache for display
                        if (data.heroes) {
                            multiplayerState.heroStatsCache = data.heroes;
                        }
                        
                        // Update dungeon menu display
                        updateDungeonMenuHeroes();
                        
                        // Update party level input to match
                        const partyLevelInput = document.getElementById('partyLevelInput');
                        if (partyLevelInput) {
                            partyLevelInput.value = data.targetLevel;
                        }
                        
                        showNotification(`Party level set to ${data.targetLevel}!`, 'success');
                    }
                    break;
                
                case 'inventory_update':
                    // Host synced inventory - update client's local inventory
                    if (multiplayerState.role === 'client') {
                        handleInventoryUpdate(data);
                    }
                    break;
                
                case 'equipment_update':
                    // Host synced equipment - update client's local equipment
                    if (multiplayerState.role === 'client') {
                        handleEquipmentUpdate(data);
                    }
                    break;
                
                case 'camp_progress':
                    // Host sends progress updates during camping
                    if (multiplayerState.role === 'client' && campState.active) {
                        document.getElementById('campProgressBar').style.width = `${data.progress}%`;
                        document.getElementById('campTimeRemaining').textContent = data.hoursRemaining;
                        document.getElementById('campHealedSoFar').textContent = data.healedSoFar;
                    }
                    break;
                
                case 'camp_event':
                    // Host sends camp event text
                    if (multiplayerState.role === 'client' && campState.active) {
                        addCampEvent(data.text);
                    }
                    break;
                
                case 'host_disconnected':
                    showNotification(data.message, 'error');
                    resetMultiplayerState();
                    currentScreen = 'title';
                    stopBattleVideo(); // Stop and hide video background
                    document.getElementById('battleScreen').style.display = 'none';
                    document.getElementById('dungeonMenuScreen').style.display = 'none';
                    document.getElementById('titleScreen').style.display = 'block';
                    break;
                
                case 'player_disconnected':
                    if (multiplayerState.role === 'host') {
                        handlePlayerDisconnect(data.player_id);
                    }
                    
                    // Update hero selection UI if heroes were released
                    if (data.heroes) {
                        updateHeroSelection({ heroes: data.heroes, players: data.players });
                        
                        // Show notification about released heroes
                        if (data.released_heroes && data.released_heroes.length > 0) {
                            const heroNames = data.released_heroes.map(h => h.charAt(0).toUpperCase() + h.slice(1)).join(', ');
                            showNotification(`Player disconnected - ${heroNames} now available`, 'info');
                        }
                    }
                    break;
                
                case 'request_sync':
                    // Client requesting full sync after reconnection
                    if (multiplayerState.role === 'host') {
                        // Transfer heroes back from host to reconnecting player
                        if (data.heroes && Array.isArray(data.heroes)) {
                            data.heroes.forEach(heroName => {
                                const heroKey = heroName.toLowerCase();
                                // Remove from host's control
                                const hostIndex = multiplayerState.myHeroes.indexOf(heroKey);
                                if (hostIndex > -1) {
                                    multiplayerState.myHeroes.splice(hostIndex, 1);
                                    showNotification(`${heroName} returned to player control`, 'info');
                                }
                            });
                        }
                        
                        const sharedSave = loadSharedSave();
                        
                        if (sharedSave) {
                            // Send current save state to rejoining client
                            sendWebSocketMessage({ 
                                type: 'sync_state', 
                                screen: currentScreen,
                                saveData: sharedSave,
                                inventory: {
                                    items: partyInventory.items,
                                    maxSlots: partyInventory.maxSlots,
                                    partyLevel: partyInventory.partyLevel
                                },
                                equipment: heroEquipment
                            });
                            
                            // If in battle, also send battle_init
                            if (currentScreen === 'battle' && battleState.active) {
                                setTimeout(() => {
                                    sendBattleInitToClients();
                                }, 100);
                            }
                        }
                    }
                    break;
                
                case 'sync_state':
                    // Client receiving sync after reconnection
                    if (multiplayerState.role === 'client') {
                        // Update inventory from host
                        if (data.inventory) {
                            handleInventoryUpdate(data);
                        }
                        
                        // Update equipment from host
                        if (data.equipment) {
                            heroEquipment = data.equipment;
                        }
                        
                        // Save host's save data
                        if (data.saveData) {
                            saveSharedSave(data.saveData);
                            
                            // Populate heroStatsCache
                            if (data.saveData.heroes) {
                                ['zooko', 'nate', 'zancas', 'cyberaxe'].forEach(heroKey => {
                                    const heroData = data.saveData.heroes[heroKey];
                                    if (heroData) {
                                        multiplayerState.heroStatsCache[heroKey] = {
                                            hp: heroData.hp,
                                            maxHp: heroData.maxHp,
                                            xp: heroData.xp,
                                            level: heroData.level,
                                            str: heroData.str,
                                            dex: heroData.dex,
                                            con: heroData.con,
                                            int: heroData.int,
                                            wis: heroData.wis,
                                            cha: heroData.cha
                                        };
                                    }
                                });
                            }
                        }
                        
                        // Hide modals and title screen
                        document.getElementById('titleScreen').style.display = 'none';
                        document.getElementById('heroSelectionModal').style.display = 'none';
                        document.getElementById('musicControls').classList.remove('heroSelectionActive');
                        
                        // Go to the screen where host is
                        if (data.screen === 'dungeonMenu') {
                            stopBattleVideo(); // Stop and hide video background
                            document.getElementById('battleScreen').style.display = 'none';
                            document.getElementById('musicTicker').classList.remove('battleActive');
                            document.getElementById('musicControls').classList.add('dungeonMenuActive');
                            document.getElementById('musicTicker').classList.add('dungeonMenuActive');
                            document.getElementById('dungeonMenuScreen').style.display = 'block';
                            currentScreen = 'dungeonMenu';
                            updateDungeonMenuHeroes();
                            applyClientUIRestrictions();
                            showNotification('Rejoined game!', 'success');
                        } else if (data.screen === 'battle') {
                            document.getElementById('dungeonMenuScreen').style.display = 'none';
                            document.getElementById('musicTicker').classList.remove('dungeonMenuActive');
                            document.getElementById('musicControls').classList.remove('dungeonMenuActive');
                            document.getElementById('battleScreen').style.display = 'block';
                            document.getElementById('musicTicker').classList.add('battleActive');
                            document.getElementById('musicControls').classList.add('battleActive');
                            currentScreen = 'battle';
                            showNotification('Rejoined battle - waiting for sync...', 'info');
                        }
                    }
                    break;
                
                case 'code_changed':
                    multiplayerState.roomCode = data.code;
                    showNotification(`Room code changed to: ${data.code}`, 'info');
                    // Update hero selection display if visible
                    const heroCodeDisplay = document.getElementById('heroSelectionCode');
                    if (heroCodeDisplay && heroCodeDisplay.textContent !== '******') {
                        heroCodeDisplay.textContent = data.code;
                    }
                    break;
                
                case 'skip_turn':
                    // Advance turn (force skip)
                    advanceTurn();
                    break;
                
                case 'roll_phase_start':
                    // Host started roll phase - clients show roll buttons
                    if (multiplayerState.role === 'client') {
                        inRollPhase = true;
                        // This is a new game, not reconnecting
                        multiplayerState.isReconnecting = false;
                        // CRITICAL: Force heroSelectionHasSave to false for clients
                        // Client's local save is irrelevant - host is starting a NEW game
                        heroSelectionHasSave = false;
                        showAllRollButtons();
                        // Show phase 2 UI
                        document.getElementById('gameStartPhase1').style.display = 'none';
                        document.getElementById('gameStartPhase2').style.display = 'block';
                        // Hide reconnect options since this is a new game
                        const reconnectOpts = document.getElementById('reconnectOptions');
                        if (reconnectOpts) reconnectOpts.style.display = 'none';
                        updateRollPhaseStatus();
                        showNotification('Roll phase started! Roll stats for your hero.', 'info');
                    }
                    break;
                
                case 'roll_phase_cancel':
                    // Host cancelled roll phase - clients hide roll buttons
                    if (multiplayerState.role === 'client') {
                        inRollPhase = false;
                        hideAllRollButtons();
                        // Show phase 1 UI
                        document.getElementById('gameStartPhase1').style.display = 'block';
                        document.getElementById('gameStartPhase2').style.display = 'none';
                        showNotification('Roll phase cancelled by host.', 'info');
                    }
                    break;
                
                case 'game_start':
                    // Host started the game - clients follow
                    if (multiplayerState.role === 'client') {
                        // Save host's save data to local storage
                        if (data.saveData) {
                            saveSharedSave(data.saveData);
                            
                            // Populate heroStatsCache from saveData for client display
                            if (data.saveData.heroes) {
                                ['zooko', 'nate', 'zancas', 'cyberaxe'].forEach(heroKey => {
                                    const heroData = data.saveData.heroes[heroKey];
                                    if (heroData) {
                                        multiplayerState.heroStatsCache[heroKey] = {
                                            hp: heroData.hp,
                                            maxHp: heroData.maxHp,
                                            xp: heroData.xp,
                                            level: heroData.level,
                                            str: heroData.str,
                                            dex: heroData.dex,
                                            con: heroData.con,
                                            int: heroData.int,
                                            wis: heroData.wis,
                                            cha: heroData.cha
                                        };
                                    }
                                });
                            }
                            
                            // Cache gold from saveData for client display
                            if (data.saveData.dungeonState) {
                                multiplayerState.goldCache = data.saveData.dungeonState.gold || 0;
                            }
                        }
                        
                        document.getElementById('titleScreen').style.display = 'none';
                        document.getElementById('heroSelectionModal').style.display = 'none';
                        // Reset music controls position
                        document.getElementById('musicControls').classList.remove('heroSelectionActive');
                        
                        if (data.screen === 'dungeonMenu') {
                            stopBattleVideo(); // Stop and hide video background
                            document.getElementById('battleScreen').style.display = 'none';
                            document.getElementById('musicTicker').classList.remove('battleActive');
                            document.getElementById('musicControls').classList.add('dungeonMenuActive');
                            document.getElementById('musicTicker').classList.add('dungeonMenuActive');
                            document.getElementById('dungeonMenuScreen').style.display = 'block';
                            currentScreen = 'dungeonMenu';
                            
                            // Load hero stats from save
                            updateDungeonMenuHeroes();
                            updateGoldDisplay();
                            
                            // Update level display from save data
                            const currentLevel = data.saveData?.dungeonState?.currentLevel || 1;
                            const dungeonMenuLevel = document.getElementById('dungeonMenuLevel');
                            if (dungeonMenuLevel) {
                                dungeonMenuLevel.textContent = currentLevel;
                            }
                            
                            // Use level layout from HOST - never generate locally
                            if (data.levelLayout) {
                                currentLevelLayout = data.levelLayout;
                                console.log('[MP Client] Using host level layout:', currentLevelLayout.totalRooms, 'rooms');
                            }
                            if (data.levelProgress) {
                                levelProgress.roomsExplored = data.levelProgress.roomsExplored || 0;
                                levelProgress.roomsMax = data.levelProgress.roomsMax || '?';
                                levelProgress.bossDefeated = data.levelProgress.bossDefeated || false;
                                levelProgress.storeVisited = data.levelProgress.storeVisited || false;
                                levelProgress.captivesFreed = data.levelProgress.captivesFreed || 0;
                                levelProgress.totalBossesDefeated = data.levelProgress.totalBossesDefeated || 0;
                            }
                            
                            // Update UI from received data
                            updateLevelProgressDisplay();
                            updateDungeonMastersStatus();
                            updateStoreButtonState();
                            
                            // Apply client UI restrictions
                            applyClientUIRestrictions();
                        } else if (data.screen === 'battle') {
                            // Stop dungeon menu story background animation
                            stopDungeonMenuAnimation();
                            
                            // Client waits for battle_init message from host
                            // Just show the screen, don't initialize yet
                            document.getElementById('dungeonMenuScreen').style.display = 'none';
                            document.getElementById('battleScreen').style.display = 'block';
                            document.getElementById('musicTicker').classList.add('battleActive');
                            document.getElementById('musicControls').classList.add('battleActive');
                            currentScreen = 'battle';
                            
                            // Initialize canvas
                            battleState.canvas = document.getElementById('battleCanvas');
                            battleState.ctx = battleState.canvas.getContext('2d');
                            battleState.canvas.width = window.innerWidth;
                            battleState.canvas.height = window.innerHeight - 180;
                            battleState.active = true;
                            
                            // Move music controls to battle position
                            document.getElementById('musicControls').classList.add('battleActive');
                            
                            showNotification('Waiting for host to initialize battle...', 'info');
                            return; // Wait for battle_init
                        } else {
                            // Fallback to dungeon menu for any other screen value
                            stopBattleVideo(); // Stop and hide video background
                            document.getElementById('battleScreen').style.display = 'none';
                            document.getElementById('musicTicker').classList.remove('battleActive');
                            document.getElementById('musicControls').classList.add('dungeonMenuActive');
                            document.getElementById('musicTicker').classList.add('dungeonMenuActive');
                            document.getElementById('dungeonMenuScreen').style.display = 'block';
                            currentScreen = 'dungeonMenu';
                            updateDungeonMenuHeroes();
                            updateGoldDisplay();
                            
                            // Initialize level layout from saved data
                            const currentLevel = data.saveData?.dungeonState?.currentLevel || 1;
                            initializeLevelLayout(currentLevel);
                            
                            applyClientUIRestrictions();
                        }
                        
                        // Check if this was a resync response
                        if (multiplayerState.awaitingResync) {
                            multiplayerState.awaitingResync = false;
                            showNotification('âœ… Resynced with host!', 'success');
                        } else {
                            showNotification('Host started the game!', 'success');
                        }
                    }
                    break;
                
                case 'chat_message':
                    // Receive chat message broadcast from host
                    if (multiplayerState.role === 'client' && data.message) {
                        // Skip if this is our own message (we already added it locally)
                        const myName = multiplayerState.playerName || 'Player';
                        if (data.message.senderName === myName && !data.message.isNpc) {
                            break;
                        }
                        // Add to local chat without re-broadcasting
                        chatState.messages.unshift(data.message);
                        if (chatState.messages.length > 50) {
                            chatState.messages.pop();
                        }
                        renderChatMessages();
                    }
                    break;
                
                case 'chat_request':
                    // Host receives chat request from client - process LLM and broadcast
                    if (multiplayerState.role === 'host') {
                        handleClientChatRequest(data);
                    }
                    break;
                
                case 'animation_sync':
                    // Client receives animation update from host
                    if (multiplayerState.role === 'client' && data.combatantName && data.animState) {
                        // Find the combatant by name
                        const combatant = battleState.heroes.find(h => h.name === data.combatantName) ||
                                          battleState.enemies.find(e => e.name === data.combatantName);
                        if (combatant) {
                            // Apply animation locally without re-broadcasting
                            setAnimationState(combatant, data.animState, data.playMode || 'pingpong', null, false);
                        }
                    }
                    break;
                
                default:
                    console.warn('[MP] Unhandled message type:', data.type, data);
                    break;
            }
            
            // Log message to debug panel
            logDebugMessage(data.type, data, 'in');
            updateDebugStatus();
        }
        
        // Handle chat request from client (host-only)
        async function handleClientChatRequest(data) {
            const playerName = data.playerName || 'Player';
            const message = data.message || '';
            const clientTarget = data.targetEntity;  // Client's selected target
            
            // Get player's hero avatar
            const heroAvatar = 'people/zooko_a_head_compressed.png';
            
            // Add player message to chat (will broadcast)
            addChatMessage(playerName, 'player', heroAvatar, message, false);
            
            // Get NPC to respond based on client's target selection
            let respondingNpc = null;
            
            if (clientTarget) {
                // Use client's selected target
                if (clientTarget.type === 'captive') {
                    respondingNpc = battleState.captiveNpc;
                } else if (clientTarget.type === 'enemy' && clientTarget.index !== undefined) {
                    respondingNpc = battleState.enemies[clientTarget.index];
                }
                
                // Validate target is still valid
                if (respondingNpc && (respondingNpc.hp <= 0 || respondingNpc.rescued)) {
                    respondingNpc = null;
                }
            }
            
            // If no specific target (broadcast mode / ALL), give all NPCs a chance to respond via free will
            if (!clientTarget) {
                // Trigger free will for all alive NPCs - each decides if they want to respond
                const allNpcs = [];
                
                // Add captive if present and can chat
                if (battleState.captiveNpc && !battleState.captiveNpc.rescued && battleState.captiveNpc.canChat) {
                    allNpcs.push(battleState.captiveNpc);
                }
                
                // Add all alive enemies with backstory
                battleState.enemies.forEach(enemy => {
                    if (enemy.hp > 0 && enemy.backstory) {
                        allNpcs.push(enemy);
                    }
                });
                
                if (allNpcs.length === 0) {
                    addChatMessage('System', 'friendly', 'people/zooko_a_head_compressed.png', 
                        '*No one responds...*', true);
                    return;
                }
                
                // Give each NPC a chance to respond (free will style)
                for (const npc of allNpcs) {
                    triggerFreeWillChatResponse(npc, playerName, message);
                }
                return;
            }

            if (!respondingNpc) {
                addChatMessage('System', 'friendly', 'people/zooko_a_head_compressed.png', 
                    '*No one responds...*', true);
                return;
            }
            
            try {
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        npcName: respondingNpc.name,
                        backstory: respondingNpc.backstory || 'A mysterious creature.',
                        npcType: respondingNpc.isBoss ? 'boss' : 'mob',
                        conversation: chatState.messages.slice(0, 10).reverse(),
                        message: message,
                        playerName: playerName,
                        rpMode: settings.rpMode !== false
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    const npcType = respondingNpc.hostile ? 'hostile' : 
                        (respondingNpc.questable ? 'questable' : 'friendly');
                    
                    addChatMessage(
                        respondingNpc.name,
                        npcType,
                        respondingNpc.spritePath || 'people/zooko_a_head_compressed.png',
                        result.response,
                        true,
                        respondingNpc.voiceType
                    );
                } else if (result.error) {
                    checkForRateLimitError(result.error);
                }
            } catch (error) {
                console.error('Chat fetch error:', error);
                checkForRateLimitError(error.message || String(error));
            }
        }
        
        function sendWebSocketMessage(data) {
            if (multiplayerState.ws && multiplayerState.ws.readyState === WebSocket.OPEN) {
                multiplayerState.ws.send(JSON.stringify(data));
                logDebugMessage(data.type, data, 'out');
                updateDebugStatus();
            } else {
                console.error('[MP] WebSocket not connected. State:', multiplayerState.ws ? multiplayerState.ws.readyState : 'null');
            }
        }
        
        function createMultiplayerRoom() {
            // Get player name
            const playerNameInput = document.getElementById('multiplayerPlayerName');
            const playerName = playerNameInput ? playerNameInput.value.trim() : '';
            if (!playerName) {
                multiplayerState.playerName = generateRandomPlayerName();
            } else {
                multiplayerState.playerName = playerName;
            }
            
            // Save player name to settings
            settings.playerName = multiplayerState.playerName;
            saveSettings();
            
            // Close settings panel
            closeAllPanels();
            
            connectWebSocket();
            setTimeout(() => {
                sendWebSocketMessage({ type: 'create_room', player_name: playerName });
            }, 100);
        }
        
        function joinMultiplayerRoom() {
            const code = document.getElementById('joinRoomCodeInput').value.trim().toUpperCase();
            if (code.length !== 6) {
                showNotification('Please enter a 6-character room code', 'error');
                return;
            }
            
            // Get player name
            const playerNameInput = document.getElementById('multiplayerPlayerName');
            const playerName = playerNameInput ? playerNameInput.value.trim() : '';
            if (!playerName) {
                multiplayerState.playerName = generateRandomPlayerName();
            } else {
                multiplayerState.playerName = playerName;
            }
            
            // Save player name to settings
            settings.playerName = multiplayerState.playerName;
            saveSettings();
            
            connectWebSocket();
            setTimeout(() => {
                sendWebSocketMessage({ type: 'join_room', code, player_name: multiplayerState.playerName });
            }, 100);
        }
        
        function quickJoinRoom() {
            const code = document.getElementById('titleJoinCode').value.trim().toUpperCase();
            if (code.length !== 6) {
                showNotification('Please enter a 6-character room code', 'error');
                return;
            }
            
            // Get player name
            const playerNameInput = document.getElementById('multiplayerPlayerName');
            const playerName = playerNameInput ? playerNameInput.value.trim() : '';
            if (!playerName) {
                multiplayerState.playerName = generateRandomPlayerName();
            } else {
                multiplayerState.playerName = playerName;
            }
            
            // Save player name to settings
            settings.playerName = multiplayerState.playerName;
            saveSettings();
            
            connectWebSocket();
            setTimeout(() => {
                sendWebSocketMessage({ type: 'join_room', code, player_name: multiplayerState.playerName });
            }, 100);
        }
        
        function leaveRoom() {
            if (multiplayerState.ws) {
                multiplayerState.ws.close();
            }
            resetMultiplayerState();
            document.getElementById('connectionStatus').style.display = 'none';
            document.getElementById('joinRoomBtn').style.display = 'block';
            document.getElementById('leaveRoomBtn').style.display = 'none';
            showNotification('Left room', 'info');
        }
        
        function stopHosting() {
            if (multiplayerState.ws) {
                multiplayerState.ws.close();
            }
            resetMultiplayerState();
            const roomCodeDisplay = document.getElementById('roomCodeDisplay');
            const createRoomBtn = document.getElementById('createRoomBtn');
            const changeCodeBtn = document.getElementById('changeCodeBtn');
            const stopHostingBtn = document.getElementById('stopHostingBtn');
            const hostControlsBtn = document.getElementById('hostControlsBtn');
            if (roomCodeDisplay) roomCodeDisplay.style.display = 'none';
            if (createRoomBtn) createRoomBtn.style.display = 'block';
            if (changeCodeBtn) changeCodeBtn.style.display = 'none';
            if (stopHostingBtn) stopHostingBtn.style.display = 'none';
            if (hostControlsBtn) hostControlsBtn.style.display = 'none';
            showNotification('Stopped hosting', 'info');
        }
        
        function changeRoomCode() {
            if (confirm('Changing the room code will disconnect all players. Continue?')) {
                sendWebSocketMessage({ type: 'change_code' });
            }
        }
        
        function changeRoomCodeFromPanel() {
            closeHostControls();
            changeRoomCode();
        }
        
        function resetMultiplayerState() {
            multiplayerState.enabled = false;
            multiplayerState.role = null;
            multiplayerState.roomCode = null;
            multiplayerState.myHeroes = [];
            multiplayerState.myPlayerId = null;
            multiplayerState.playerHeroes = {};
            multiplayerState.connectedPlayers = [];
            if (multiplayerState.ws) {
                multiplayerState.ws.close();
                multiplayerState.ws = null;
            }
        }
        
        function toggleRoomCodeVisibility() {
            const codeSpan = document.getElementById('heroSelectionCode');
            const btn = event.target;
            
            if (codeSpan.textContent === '******') {
                codeSpan.textContent = multiplayerState.roomCode;
                btn.textContent = 'ðŸ‘ HIDE';
            } else {
                codeSpan.textContent = '******';
                btn.textContent = 'ðŸ‘ SHOW';
            }
        }
        
        // Toggle shielded gold visibility in store
        function toggleStoreGoldVisibility() {
            const goldDisplay = document.getElementById('storeGoldDisplay');
            const btn = document.getElementById('storeGoldToggleBtn');
            if (!goldDisplay || !btn) return;
            
            const sharedSave = loadSharedSave();
            const currentGold = sharedSave?.dungeonState?.gold || 0;
            
            if (goldDisplay.dataset.revealed === 'true') {
                // Hide it
                goldDisplay.textContent = 'ðŸ›¡ï¸ðŸ›¡ï¸ðŸ›¡ï¸ðŸ›¡ï¸';
                goldDisplay.dataset.revealed = 'false';
                btn.innerHTML = 'ðŸ›¡ï¸ REVEAL';
                btn.style.background = 'linear-gradient(135deg, rgba(155, 89, 182, 0.4), rgba(155, 89, 182, 0.2))';
                btn.style.borderColor = '#9B59B6';
                btn.style.color = '#BB8FCE';
            } else {
                // Show it
                goldDisplay.textContent = currentGold.toLocaleString();
                goldDisplay.dataset.revealed = 'true';
                btn.innerHTML = 'ðŸ‘ HIDE';
                btn.style.background = 'linear-gradient(135deg, rgba(255, 215, 0, 0.4), rgba(255, 215, 0, 0.2))';
                btn.style.borderColor = '#FFD700';
                btn.style.color = '#FFD700';
            }
        }
        
        // Update store gold display (call after purchases)
        function updateStoreGoldDisplay() {
            const goldDisplay = document.getElementById('storeGoldDisplay');
            if (!goldDisplay) return;
            
            // Only update if revealed
            if (goldDisplay.dataset.revealed === 'true') {
                const sharedSave = loadSharedSave();
                const currentGold = sharedSave?.dungeonState?.gold || 0;
                goldDisplay.textContent = currentGold.toLocaleString();
            }
        }
        
        function cancelHeroSelection() {
            // For single player, just go back without confirm
            if (!multiplayerState.enabled) {
                document.getElementById('heroSelectionModal').style.display = 'none';
                document.getElementById('musicControls').classList.remove('heroSelectionActive');
                document.getElementById('musicTicker').classList.remove('battleActive');
                
                // Restore hidden elements
                const codeDisplay = document.getElementById('heroSelectionCode');
                if (codeDisplay) codeDisplay.parentElement.style.display = '';
                const playerNameInput = document.getElementById('playerNameInput');
                if (playerNameInput) playerNameInput.parentElement.style.display = '';
                const backBtn = document.getElementById('heroSelectionBackBtn');
                if (backBtn) backBtn.style.display = '';
                const playerCountBox = document.getElementById('playerCountBox');
                if (playerCountBox) playerCountBox.style.display = '';
                const connectedPlayersList = document.getElementById('connectedPlayersList');
                if (connectedPlayersList) connectedPlayersList.style.display = '';
                const heroSelectionTitle = document.getElementById('heroSelectionTitle');
                if (heroSelectionTitle) heroSelectionTitle.textContent = 'SELECT YOUR HERO';
                const waitingMsg = document.getElementById('heroWaitingMessage');
                if (waitingMsg) waitingMsg.textContent = 'Click heroes to select. Players can select multiple heroes.';
                
                // Reset hero card selections
                document.querySelectorAll('.heroSelectCard').forEach(card => {
                    card.classList.remove('selected', 'taken');
                    card.style.borderWidth = '3px';
                    card.style.opacity = '1';
                    const playerLabel = card.querySelector('.heroPlayerLabel');
                    if (playerLabel) playerLabel.style.display = 'none';
                });
                
                // Reset multiplayer state
                multiplayerState.myHeroes = [];
                multiplayerState.playerHeroes = {};
                multiplayerState.role = null;
                return;
            }
            
            if (confirm('Leave multiplayer session?')) {
                document.getElementById('heroSelectionModal').style.display = 'none';
                // Move music controls back to center
                document.getElementById('musicControls').classList.remove('heroSelectionActive');
                document.getElementById('musicTicker').classList.remove('battleActive');
                if (multiplayerState.role === 'host') {
                    stopHosting();
                } else {
                    leaveRoom();
                }
            }
        }
        
        function showHeroSelection() {
            document.getElementById('heroSelectionModal').style.display = 'block';
            // Move music controls to left
            document.getElementById('musicControls').classList.add('heroSelectionActive');
            document.getElementById('musicTicker').classList.add('battleActive');
            // Update room code display
            const codeDisplay = document.getElementById('heroSelectionCode');
            if (codeDisplay && multiplayerState.roomCode) {
                codeDisplay.textContent = multiplayerState.roomCode;
            }
            // Set player name input to current player name
            const nameInput = document.getElementById('playerNameInput');
            if (nameInput) {
                nameInput.value = multiplayerState.playerName;
            }
            
            // Show reconnect options if this is a reconnection
            const reconnectOptions = document.getElementById('reconnectOptions');
            const gameStartOptions = document.getElementById('gameStartOptions');
            if (multiplayerState.isReconnecting) {
                if (reconnectOptions) reconnectOptions.style.display = 'block';
                if (gameStartOptions) gameStartOptions.style.display = 'none';
            } else {
                if (reconnectOptions) reconnectOptions.style.display = 'none';
                // Also ensure gameStartOptions shows phase 1 and hides phase 2 on fresh start
                if (gameStartOptions) {
                    document.getElementById('gameStartPhase1').style.display = 'block';
                    document.getElementById('gameStartPhase2').style.display = 'none';
                }
            }
            
            // Update hero selection cards with current stats
            updateHeroSelectionStats();
        }
        
        // Update hero selection cards with stats from save or defaults
        function updateHeroSelectionStats() {
            // Try to load existing save data
            const saveData = localStorage.getItem(STORAGE_KEYS.SHARED_SAVE);
            let heroes = null;
            let gold = 0;
            let hasSave = false;
            
            if (saveData) {
                try {
                    const parsed = JSON.parse(saveData);
                    if (parsed.heroes) {
                        heroes = parsed.heroes;
                        hasSave = true;
                    }
                    if (parsed.dungeonState?.gold !== undefined) {
                        gold = parsed.dungeonState.gold;
                    }
                } catch (e) {
                    console.warn('Failed to parse save data for hero selection:', e);
                }
            }
            
            // If no save, use default values
            if (!heroes) {
                heroes = createDefaultSharedSave().heroes;
                gold = 0;
            }
            
            // Update each hero's stats on the selection cards
            const heroNames = ['zooko', 'nate', 'zancas', 'cyberaxe'];
            heroNames.forEach(heroKey => {
                const hero = heroes[heroKey];
                if (hero) {
                    // Update HP
                    const hpEl = document.getElementById(`sel-${heroKey}-hp`);
                    const maxHpEl = document.getElementById(`sel-${heroKey}-maxhp`);
                    if (hpEl) hpEl.textContent = hero.hp || 0;
                    if (maxHpEl) maxHpEl.textContent = hero.maxHp || 0;
                    
                    // Update XP and Level
                    const xpEl = document.getElementById(`sel-${heroKey}-xp`);
                    const levelEl = document.getElementById(`sel-${heroKey}-level`);
                    if (xpEl) xpEl.textContent = hero.xp || 0;
                    if (levelEl) levelEl.textContent = hero.level || 1;
                    
                    // Update base stats
                    const stats = ['str', 'dex', 'con', 'int', 'wis', 'cha', 'ac'];
                    stats.forEach(stat => {
                        const el = document.getElementById(`sel-${heroKey}-${stat}`);
                        if (el) el.textContent = hero[stat] || 0;
                    });
                }
            });
            
            // Update party gold display (now in top bar)
            const goldEl = document.getElementById('sel-party-gold-top');
            if (goldEl) goldEl.textContent = gold;
            
            // Show/hide roll buttons based on new game status
            updateRollButtonsVisibility(hasSave);
        }
        
        // Track if we have a saved game (affects roll button visibility)
        let heroSelectionHasSave = false;
        
        // Current dice roll state
        let currentDiceRollHero = null;
        let rolledStats = { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 };
        let rolledDice = {}; // Store individual die values for display
        
        // Update roll button visibility - only show for claimed heroes on new game
        function updateRollButtonsVisibility(hasSave) {
            heroSelectionHasSave = hasSave;
            const heroNames = ['zooko', 'nate', 'zancas', 'cyberaxe'];
            
            heroNames.forEach(heroKey => {
                const rollBtn = document.querySelector(`.heroRollButton[data-hero="${heroKey}"]`);
                if (rollBtn) {
                    // Show roll button only if: no save AND this player owns this hero
                    const isMyHero = multiplayerState.myHeroes.includes(heroKey);
                    if (!hasSave && isMyHero) {
                        rollBtn.classList.add('visible');
                    } else {
                        rollBtn.classList.remove('visible');
                    }
                }
            });
        }
        
        // Open the dice roll modal for a specific hero
        function openDiceRollModal(heroName) {
            // Verify this player owns this hero
            if (!multiplayerState.myHeroes.includes(heroName)) {
                showNotification('You can only roll stats for your own heroes', 'error');
                return;
            }
            
            // Verify it's a new game (no save)
            if (heroSelectionHasSave) {
                showNotification('Can only roll stats for new games', 'error');
                return;
            }
            
            currentDiceRollHero = heroName;
            
            // Set hero name in modal title
            const heroDisplayName = heroName.charAt(0).toUpperCase() + heroName.slice(1);
            document.getElementById('diceRollHeroName').textContent = heroDisplayName.toUpperCase();
            
            // Reset dice display
            const stats = ['str', 'dex', 'con', 'int', 'wis', 'cha'];
            stats.forEach(stat => {
                const row = document.querySelector(`.diceStatRow[data-stat="${stat}"]`);
                if (row) {
                    row.querySelectorAll('.die').forEach(die => {
                        die.textContent = '-';
                        die.classList.remove('rolling');
                    });
                    row.querySelector('.diceStatTotal').textContent = '-';
                }
            });
            
            document.getElementById('diceRollHP').textContent = '-';
            document.getElementById('diceRollAC').textContent = '-';
            document.getElementById('diceRollTotal').textContent = '-';
            
            // Show modal
            document.getElementById('diceRollModal').classList.add('visible');
        }
        
        // Close the dice roll modal without accepting
        function closeDiceRollModal() {
            document.getElementById('diceRollModal').classList.remove('visible');
            currentDiceRollHero = null;
        }
        
        // Roll a single d6
        function rollD6() {
            return Math.floor(Math.random() * 6) + 1;
        }
        
        // Roll 3d6 and return { dice: [d1, d2, d3], total: sum }
        function roll3d6() {
            const dice = [rollD6(), rollD6(), rollD6()];
            return { dice, total: dice[0] + dice[1] + dice[2] };
        }
        
        // Calculate HP from CON: 10 + CON modifier (CON - 10) / 2
        function calculateHP(con) {
            const modifier = Math.floor((con - 10) / 2);
            return Math.max(1, 10 + modifier);
        }
        
        // Calculate AC from DEX: 10 + DEX modifier
        function calculateAC(dex) {
            const modifier = Math.floor((dex - 10) / 2);
            return 10 + modifier;
        }
        
        // Roll all dice with animation
        function rollAllDice() {
            const stats = ['str', 'dex', 'con', 'int', 'wis', 'cha'];
            
            // Start rolling animation on all dice
            stats.forEach(stat => {
                const row = document.querySelector(`.diceStatRow[data-stat="${stat}"]`);
                if (row) {
                    row.querySelectorAll('.die').forEach(die => {
                        die.classList.add('rolling');
                    });
                }
            });
            
            // Animate dice for 1 second with random values
            let animationFrames = 0;
            const maxFrames = 20;
            
            const animateInterval = setInterval(() => {
                animationFrames++;
                
                // Show random values during animation
                stats.forEach(stat => {
                    const row = document.querySelector(`.diceStatRow[data-stat="${stat}"]`);
                    if (row) {
                        row.querySelectorAll('.die').forEach(die => {
                            die.textContent = rollD6();
                        });
                    }
                });
                
                if (animationFrames >= maxFrames) {
                    clearInterval(animateInterval);
                    
                    // Final roll - these are the real values
                    stats.forEach(stat => {
                        const result = roll3d6();
                        rolledStats[stat] = result.total;
                        rolledDice[stat] = result.dice;
                        
                        const row = document.querySelector(`.diceStatRow[data-stat="${stat}"]`);
                        if (row) {
                            const dice = row.querySelectorAll('.die');
                            dice[0].textContent = result.dice[0];
                            dice[1].textContent = result.dice[1];
                            dice[2].textContent = result.dice[2];
                            dice.forEach(die => die.classList.remove('rolling'));
                            
                            const totalEl = row.querySelector('.diceStatTotal');
                            totalEl.textContent = result.total;
                            
                            // Color code the total based on value
                            if (result.total >= 18) {
                                totalEl.style.color = '#9B59B6'; // Purple for 18
                            } else if (result.total >= 13) {
                                totalEl.style.color = '#27AE60'; // Green for 13-17
                            } else if (result.total < 8) {
                                totalEl.style.color = '#E74C3C'; // Red for <8
                            } else {
                                totalEl.style.color = '#F2C94C'; // Default gold for 8-12
                            }
                        }
                    });
                    
                    // Calculate and display derived stats
                    const hp = calculateHP(rolledStats.con);
                    const ac = calculateAC(rolledStats.dex);
                    const total = rolledStats.str + rolledStats.dex + rolledStats.con + rolledStats.int + rolledStats.wis + rolledStats.cha;
                    document.getElementById('diceRollHP').textContent = hp;
                    document.getElementById('diceRollAC').textContent = ac;
                    
                    const totalEl = document.getElementById('diceRollTotal');
                    totalEl.textContent = total;
                    
                    // Color code total: Red <40, Yellow 41-60, Green 61-80, Purple >80
                    if (total > 80) {
                        totalEl.style.color = '#9B59B6'; // Purple for 81+
                    } else if (total >= 61) {
                        totalEl.style.color = '#27AE60'; // Green for 61-80
                    } else if (total >= 41) {
                        totalEl.style.color = '#F2C94C'; // Yellow for 41-60
                    } else {
                        totalEl.style.color = '#E74C3C'; // Red for 40 and below
                    }
                }
            }, 50);
        }
        
        // Accept the rolled stats and apply them to the hero
        function acceptRolledStats() {
            if (!currentDiceRollHero) return;
            
            // Verify we have rolled (check if any stat is non-zero)
            if (rolledStats.str === 0) {
                showNotification('Roll the dice first!', 'error');
                return;
            }
            
            const heroKey = currentDiceRollHero;
            
            // Calculate derived stats
            const hp = calculateHP(rolledStats.con);
            const ac = calculateAC(rolledStats.dex);
            
            // Update the hero card display
            document.getElementById(`sel-${heroKey}-str`).textContent = rolledStats.str;
            document.getElementById(`sel-${heroKey}-dex`).textContent = rolledStats.dex;
            document.getElementById(`sel-${heroKey}-con`).textContent = rolledStats.con;
            document.getElementById(`sel-${heroKey}-int`).textContent = rolledStats.int;
            document.getElementById(`sel-${heroKey}-wis`).textContent = rolledStats.wis;
            document.getElementById(`sel-${heroKey}-cha`).textContent = rolledStats.cha;
            document.getElementById(`sel-${heroKey}-hp`).textContent = hp;
            document.getElementById(`sel-${heroKey}-maxhp`).textContent = hp;
            document.getElementById(`sel-${heroKey}-ac`).textContent = ac;
            
            // Store in multiplayerState for when game starts
            if (!multiplayerState.rolledHeroStats) {
                multiplayerState.rolledHeroStats = {};
            }
            multiplayerState.rolledHeroStats[heroKey] = {
                str: rolledStats.str,
                dex: rolledStats.dex,
                con: rolledStats.con,
                int: rolledStats.int,
                wis: rolledStats.wis,
                cha: rolledStats.cha,
                hp: hp,
                maxHp: hp,
                ac: ac,
                xp: 0,
                level: 1
            };
            
            // In multiplayer, broadcast rolled stats to other players
            if (multiplayerState.ws && multiplayerState.ws.readyState === WebSocket.OPEN) {
                sendWebSocketMessage({
                    type: 'hero_stats_rolled',
                    hero: heroKey,
                    stats: multiplayerState.rolledHeroStats[heroKey]
                });
            }
            
            showNotification(`${heroKey.charAt(0).toUpperCase() + heroKey.slice(1)}'s stats accepted!`, 'success');
            
            // Close modal
            closeDiceRollModal();
            
            // Update roll phase status (check if all heroes rolled)
            updateRollPhaseStatus();
            
            // Reset rolled stats for next roll
            rolledStats = { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 };
        }
        
        function updatePlayerName() {
            const nameInput = document.getElementById('playerNameInput');
            const newName = nameInput.value.trim() || 'Player';
            multiplayerState.playerName = newName;
            
            // Always notify server of name change
            sendWebSocketMessage({ 
                type: 'update_name', 
                playerName: newName 
            });
        }
        
        function selectHero(heroName) {
            // In single player mode, heroes cannot be selected/deselected
            if (!multiplayerState.enabled) {
                // Just show a message if they try to click
                showNotification('All heroes are yours in single player!', 'info');
                return;
            }
            
            const card = document.querySelector(`.heroSelectCard[data-hero="${heroName}"]`);
            
            // If clicking own hero, deselect it
            if (multiplayerState.myHeroes.includes(heroName)) {
                multiplayerState.myHeroes = multiplayerState.myHeroes.filter(h => h !== heroName);
                card.classList.remove('selected');
                card.style.borderWidth = '3px';
                sendWebSocketMessage({ type: 'deselect_hero', hero: heroName });
                showNotification('Hero deselected', 'info');
                
                // Hide roll button when deselected
                const rollBtn = card.querySelector('.heroRollButton');
                if (rollBtn) rollBtn.classList.remove('visible');
                
                return;
            }
            
            // Check if already taken by someone else
            if (card.classList.contains('taken')) {
                showNotification('Hero already taken', 'error');
                return;
            }
            
            // Select new hero (no limit on how many per player)
            multiplayerState.myHeroes.push(heroName);
            card.classList.add('selected');
            card.style.borderWidth = '5px';
            
            // Show roll button only if in roll phase
            if (inRollPhase) {
                const rollBtn = card.querySelector('.heroRollButton');
                if (rollBtn) rollBtn.classList.add('visible');
            }
            
            // Get player name from input, or use current playerName from state
            const nameInput = document.getElementById('playerNameInput');
            const playerName = nameInput.value.trim() || multiplayerState.playerName;
            multiplayerState.playerName = playerName;
            
            sendWebSocketMessage({ 
                type: 'select_hero', 
                hero: heroName, 
                playerName: playerName 
            });
        }
        
        function updateHeroSelection(data) {
            // Store heroes data in multiplayerState for roll phase tracking
            multiplayerState.playerHeroes = data.heroes || {};
            
            // Reset all cards first
            document.querySelectorAll('.heroSelectCard').forEach(card => {
                card.classList.remove('taken');
                card.classList.remove('selected');
                card.style.opacity = '1';
                card.style.cursor = 'pointer';
                card.style.borderWidth = '3px';
                const takenLabel = card.querySelector('.heroTakenLabel');
                const playerLabel = card.querySelector('.heroPlayerLabel');
                if (takenLabel) takenLabel.style.display = 'none';
                if (playerLabel) playerLabel.style.display = 'none';
            });
            
            // Re-apply selected state for my heroes
            multiplayerState.myHeroes.forEach(heroName => {
                const card = document.querySelector(`.heroSelectCard[data-hero="${heroName}"]`);
                if (card) {
                    card.classList.add('selected');
                    card.style.borderWidth = '5px';
                }
            });
            
            // Update hero selection UI with player names
            Object.keys(data.heroes).forEach(hero => {
                const heroData = data.heroes[hero];
                const card = document.querySelector(`.heroSelectCard[data-hero="${hero}"]`);
                if (card && heroData) {
                    // Always show player name for ALL selected heroes
                    const playerLabel = card.querySelector('.heroPlayerLabel');
                    if (playerLabel) {
                        playerLabel.textContent = heroData.playerName || 'Player';
                        playerLabel.style.display = 'block';
                    }
                    
                    // Check if this is my hero or someone else's
                    const isMyHero = multiplayerState.myHeroes.includes(hero);
                    
                    if (isMyHero) {
                        // My hero - highlight it, don't dim
                        card.classList.add('selected');
                        card.style.borderWidth = '5px';
                        card.style.opacity = '1';
                        card.style.cursor = 'pointer';
                    } else {
                        // Someone else's hero - show TAKEN and dim
                        card.classList.add('taken');
                        card.style.opacity = '0.7';
                        card.style.cursor = 'not-allowed';
                        const takenLabel = card.querySelector('.heroTakenLabel');
                        if (takenLabel) {
                            takenLabel.style.display = 'block';
                        }
                    }
                }
            });
            
            // Update connected players list
            updateConnectedPlayersList(data.heroes);
            
            // Update player count
            const playerCount = multiplayerState.connectedPlayers.length;
            const countDisplay = document.getElementById('playerCountDisplay');
            if (countDisplay) {
                countDisplay.textContent = `${playerCount}/4`;
            }
            
            // Update waiting message and show game start options when all 4 heroes selected
            const heroCount = Object.keys(data.heroes).length;
            const waitingMsg = document.getElementById('heroWaitingMessage');
            const gameStartOptions = document.getElementById('gameStartOptions');
            const backBtn = document.getElementById('heroSelectionBackBtn');
            
            if (heroCount === 4) {
                if (waitingMsg) waitingMsg.style.display = 'none';
                if (gameStartOptions && multiplayerState.role === 'host') {
                    gameStartOptions.style.display = 'block';
                    if (backBtn) backBtn.style.display = 'none'; // Hide standalone back button
                }
            } else {
                if (waitingMsg) {
                    waitingMsg.style.display = 'block';
                    waitingMsg.textContent = `Select heroes (${heroCount}/4 selected). Players can select multiple heroes.`;
                }
                if (gameStartOptions) gameStartOptions.style.display = 'none';
                if (backBtn) backBtn.style.display = 'flex'; // Show standalone back button
            }
            
            // Update multiplayer status indicator
            updateMultiplayerStatus();
        }
        
        function updateConnectedPlayersList(heroes) {
            const listContent = document.getElementById('playersListContent');
            if (!listContent) return;
            
            listContent.innerHTML = '';
            
            // Show all connected players
            if (multiplayerState.connectedPlayers.length === 0) {
                listContent.innerHTML = '<div style="color: #89A0B4; font-size: 12px;">No players connected</div>';
                return;
            }
            
            multiplayerState.connectedPlayers.forEach(player => {
                const playerBadge = document.createElement('div');
                playerBadge.style.cssText = 'padding: 6px 12px; background: rgba(42, 157, 143, 0.3); border: 1px solid #2A9D8F; border-radius: 5px; font-size: 12px; margin-bottom: 5px;';
                
                const heroText = player.heroes && player.heroes.length > 0 
                    ? ` â†’ ${player.heroes.map(h => h.toUpperCase()).join(', ')}` 
                    : ' â†’ (no heroes)';
                playerBadge.innerHTML = `<span style="color: #F2C94C;">${player.name}</span> <span style="color: #89A0B4;">${heroText}</span>`;
                listContent.appendChild(playerBadge);
            });
        }
        
        function updateConnectedPlayersListOnly() {
            // Update just the player list without touching hero cards
            const listContent = document.getElementById('playersListContent');
            if (!listContent) return;
            
            listContent.innerHTML = '';
            
            if (multiplayerState.connectedPlayers.length === 0) {
                listContent.innerHTML = '<div style="color: #89A0B4; font-size: 12px;">No players connected</div>';
                return;
            }
            
            multiplayerState.connectedPlayers.forEach(player => {
                const playerBadge = document.createElement('div');
                playerBadge.style.cssText = 'padding: 6px 12px; background: rgba(42, 157, 143, 0.3); border: 1px solid #2A9D8F; border-radius: 5px; font-size: 12px; margin-bottom: 5px;';
                
                const heroText = player.heroes && player.heroes.length > 0 
                    ? ` â†’ ${player.heroes.map(h => h.toUpperCase()).join(', ')}` 
                    : ' â†’ (no heroes)';
                playerBadge.innerHTML = `<span style="color: #F2C94C;">${player.name}</span> <span style="color: #89A0B4;">${heroText}</span>`;
                listContent.appendChild(playerBadge);
            });
        }
        
        function updateMultiplayerStatus() {
            const statusDiv = document.getElementById('multiplayerStatus');
            const statusText = document.getElementById('mpStatusText');
            
            if (multiplayerState.enabled && multiplayerState.roomCode) {
                statusDiv.style.display = 'block';
                const playerCount = multiplayerState.connectedPlayers.length;
                const role = multiplayerState.role === 'host' ? 'ðŸ‘‘ HOST' : 'ðŸŽ® CLIENT';
                statusText.textContent = `${role} | Room: ${multiplayerState.roomCode} | Players: ${playerCount}/4`;
            } else {
                statusDiv.style.display = 'none';
            }
        }
        
        function startMultiplayerBattle() {
            // This function is now handled by showing game start options
            // See continueGame(), loadSaveGame(), startNewAdventure()
        }
        
        // Multiplayer: Continue game from save (host only)
        function continueGameMultiplayer() {
            if (multiplayerState.role !== 'host') {
                showNotification('Only host can start the game', 'error');
                return;
            }
            
            // Ensure save exists
            let sharedSave = loadSharedSave();
            if (!sharedSave) {
                sharedSave = createDefaultSharedSave();
                saveSharedSave(sharedSave);
            }
            
            // Hide hero selection
            document.getElementById('heroSelectionModal').style.display = 'none';
            document.getElementById('musicControls').classList.remove('heroSelectionActive');
            document.getElementById('musicTicker').classList.remove('battleActive');
            
            // Center music controls for dungeon menu
            document.getElementById('musicControls').classList.add('dungeonMenuActive');
            document.getElementById('musicTicker').classList.add('dungeonMenuActive');
            
            // Show dungeon menu
            currentScreen = 'dungeonMenu';
            document.getElementById('titleScreen').style.display = 'none';
            document.getElementById('dungeonMenuScreen').style.display = 'block';
            
            // Update dungeon menu with save data (after currentScreen is set)
            updateDungeonMenuHeroes();
            updateGoldDisplay();
            
            // Get current level from save
            const currentLevel = sharedSave?.dungeonState?.currentLevel || sharedSave?.arcadeState?.level || 1;
            
            // Update level display
            const dungeonMenuLevel = document.getElementById('dungeonMenuLevel');
            if (dungeonMenuLevel) {
                dungeonMenuLevel.textContent = currentLevel;
            }
            
            // Initialize level layout for current level (BEFORE broadcasting to clients)
            initializeLevelLayout(currentLevel);
            
            // Pre-generate next encounter while in dungeon menu (host only)
            preGenerateNextEncounter();
            
            // Notify all clients to start WITH save data AND level layout
            sendWebSocketMessage({ 
                type: 'game_start', 
                screen: 'dungeonMenu', 
                mode: 'continue',
                saveData: sharedSave,
                levelLayout: currentLevelLayout,
                levelProgress: levelProgress
            });
            
            showNotification('Continuing from last save...', 'success');
        }
        
        function loadSaveGame() {
            if (multiplayerState.role !== 'host') {
                showNotification('Only host can start the game', 'error');
                return;
            }
            
            // Ensure save exists
            let sharedSave = loadSharedSave();
            if (!sharedSave) {
                sharedSave = createDefaultSharedSave();
                saveSharedSave(sharedSave);
            }
            
            // Hide hero selection
            document.getElementById('heroSelectionModal').style.display = 'none';
            document.getElementById('musicControls').classList.remove('heroSelectionActive');
            document.getElementById('musicControls').classList.add('dungeonMenuActive');
            document.getElementById('musicTicker').classList.remove('battleActive');
            document.getElementById('musicTicker').classList.add('dungeonMenuActive');
            
            // For now, just show dungeon menu - load game UI can be added later
            currentScreen = 'dungeonMenu';
            document.getElementById('titleScreen').style.display = 'none';
            document.getElementById('dungeonMenuScreen').style.display = 'block';
            
            // Update dungeon menu with save data
            updateDungeonMenuHeroes();
            updateGoldDisplay();
            
            // Notify all clients to start WITH save data
            sendWebSocketMessage({ 
                type: 'game_start', 
                screen: 'dungeonMenu', 
                mode: 'load',
                saveData: sharedSave
            });
            
            showNotification('Load game functionality - showing dungeon menu', 'info');
            
            // Get current level from save
            const currentLevel = sharedSave?.dungeonState?.currentLevel || sharedSave?.arcadeState?.level || 1;
            
            // Update level display
            const dungeonMenuLevel = document.getElementById('dungeonMenuLevel');
            if (dungeonMenuLevel) {
                dungeonMenuLevel.textContent = currentLevel;
            }
            
            // Initialize level layout for current level
            initializeLevelLayout(currentLevel);
            
            // Pre-generate next encounter while in dungeon menu (host only)
            preGenerateNextEncounter();
        }
        
        // Track if we're in roll phase
        let inRollPhase = false;
        
        // Enter roll phase - show roll buttons and wait for all rolls
        function enterRollPhase() {
            // Allow host OR single player (not enabled = single player)
            if (multiplayerState.enabled && multiplayerState.role !== 'host') {
                showNotification('Only host can start new game', 'error');
                return;
            }
            
            inRollPhase = true;
            
            // Force heroSelectionHasSave to false since we're starting a NEW game
            heroSelectionHasSave = false;
            
            // Switch to phase 2 UI
            document.getElementById('gameStartPhase1').style.display = 'none';
            document.getElementById('gameStartPhase2').style.display = 'block';
            
            // Show roll buttons for all claimed heroes
            showAllRollButtons();
            
            // Clear any previous rolled stats
            multiplayerState.rolledHeroStats = {};
            
            // Update status
            updateRollPhaseStatus();
            
            // Broadcast to clients that roll phase has started (only in multiplayer)
            if (multiplayerState.enabled) {
                sendWebSocketMessage({
                    type: 'roll_phase_start'
                });
            }
            
            showNotification('Roll phase started! Roll stats for your heroes.', 'info');
        }
        
        // Cancel roll phase and go back to phase 1
        function cancelRollPhase() {
            inRollPhase = false;
            
            // Switch back to phase 1 UI
            document.getElementById('gameStartPhase1').style.display = 'block';
            document.getElementById('gameStartPhase2').style.display = 'none';
            
            // Hide all roll buttons
            hideAllRollButtons();
            
            // Clear rolled stats
            multiplayerState.rolledHeroStats = {};
            
            // Broadcast to clients (only in multiplayer)
            if (multiplayerState.enabled) {
                sendWebSocketMessage({
                    type: 'roll_phase_cancel'
                });
            }
        }
        
        // Show roll buttons for all heroes (during roll phase)
        function showAllRollButtons() {
            const heroNames = ['zooko', 'nate', 'zancas', 'cyberaxe'];
            heroNames.forEach(heroKey => {
                const rollBtn = document.querySelector(`.heroRollButton[data-hero="${heroKey}"]`);
                if (rollBtn) {
                    // Show button only for heroes this player owns
                    if (multiplayerState.myHeroes.includes(heroKey)) {
                        rollBtn.classList.add('visible');
                    }
                }
            });
        }
        
        // Hide all roll buttons
        function hideAllRollButtons() {
            document.querySelectorAll('.heroRollButton').forEach(btn => {
                btn.classList.remove('visible');
            });
        }
        
        // Update roll phase status message
        function updateRollPhaseStatus() {
            // Get list of CLAIMED heroes (from playerHeroes which tracks all claimed heroes)
            const claimedHeroes = Object.keys(multiplayerState.playerHeroes || {});
            const totalHeroes = claimedHeroes.length;
            const rolledCount = claimedHeroes.filter(h => multiplayerState.rolledHeroStats[h]).length;
            
            // In single player OR as host, we can launch
            const canLaunch = !multiplayerState.enabled || multiplayerState.role === 'host';
            
            const statusEl = document.getElementById('rollPhaseStatus');
            const launchBtn = document.getElementById('launchGameBtn');
            
            if (statusEl) {
                if (totalHeroes === 0) {
                    statusEl.textContent = 'Waiting for heroes to be claimed...';
                    statusEl.style.color = '#89A0B4';
                } else if (rolledCount === totalHeroes) {
                    statusEl.textContent = 'âœ“ All heroes have rolled! Ready to launch.';
                    statusEl.style.color = '#27AE60';
                } else {
                    statusEl.textContent = `Rolling stats... (${rolledCount}/${totalHeroes} heroes ready)`;
                    statusEl.style.color = '#89A0B4';
                }
            }
            
            if (launchBtn) {
                if (totalHeroes > 0 && rolledCount === totalHeroes && canLaunch) {
                    launchBtn.disabled = false;
                    launchBtn.style.color = '#fff';
                    launchBtn.style.cursor = 'pointer';
                    launchBtn.style.background = 'linear-gradient(135deg, rgba(39, 174, 96, 0.5), rgba(39, 174, 96, 0.3))';
                } else {
                    launchBtn.disabled = true;
                    launchBtn.style.color = '#666';
                    launchBtn.style.cursor = 'not-allowed';
                    launchBtn.style.background = 'linear-gradient(135deg, rgba(39, 174, 96, 0.3), rgba(39, 174, 96, 0.2))';
                }
            }
        }
        
        // Launch the game with rolled stats
        function launchNewGame() {
            // Allow host OR single player
            if (multiplayerState.enabled && multiplayerState.role !== 'host') {
                showNotification('Only host can launch the game', 'error');
                return;
            }
            
            // Verify all CLAIMED heroes have rolled
            const claimedHeroes = Object.keys(multiplayerState.playerHeroes || {});
            const allRolled = claimedHeroes.every(h => multiplayerState.rolledHeroStats[h]);
            
            if (!allRolled || claimedHeroes.length === 0) {
                showNotification('Not all heroes have rolled yet!', 'error');
                return;
            }
            
            // Hide hero selection
            document.getElementById('heroSelectionModal').style.display = 'none';
            document.getElementById('musicControls').classList.remove('heroSelectionActive');
            document.getElementById('musicTicker').classList.remove('battleActive');
            
            // Restore hidden elements for single player (in case they go back)
            if (!multiplayerState.enabled) {
                const codeDisplay = document.getElementById('heroSelectionCode');
                if (codeDisplay) codeDisplay.parentElement.style.display = '';
                const playerNameInput = document.getElementById('playerNameInput');
                if (playerNameInput) playerNameInput.parentElement.style.display = '';
                const backBtn = document.getElementById('heroSelectionBackBtn');
                if (backBtn) backBtn.style.display = '';
            }
            
            // Create fresh save with rolled stats
            const newSave = createDefaultSharedSave();
            saveSharedSave(newSave);
            
            inRollPhase = false;
            currentScreen = 'dungeonMenu';
            document.getElementById('titleScreen').style.display = 'none';
            document.getElementById('dungeonMenuScreen').style.display = 'block';
            
            // Update dungeon menu with new save data (after currentScreen is set)
            updateDungeonMenuHeroes();
            updateGoldDisplay();
            
            // Center music controls
            document.getElementById('musicControls').classList.remove('heroSelectionActive');
            document.getElementById('musicControls').classList.add('dungeonMenuActive');
            document.getElementById('musicTicker').classList.remove('battleActive');
            document.getElementById('musicTicker').classList.add('dungeonMenuActive');
            
            // Initialize level layout for level 1 (new game) - BEFORE broadcasting to clients
            initializeLevelLayout(1);
            
            // Pre-generate next encounter
            preGenerateNextEncounter();
            
            // Notify all clients to start WITH save data AND level layout (only in multiplayer)
            if (multiplayerState.enabled) {
                sendWebSocketMessage({ 
                    type: 'game_start', 
                    screen: 'dungeonMenu', 
                    mode: 'new',
                    saveData: newSave,
                    levelLayout: currentLevelLayout,
                    levelProgress: levelProgress
                });
            }
            
            showNotification('Adventure begins!', 'success');
        }
        
        function startNewAdventure() {
            if (multiplayerState.role !== 'host') {
                showNotification('Only host can start the game', 'error');
                return;
            }
            
            showConfirmation(
                'START NEW ADVENTURE?',
                'This will replace your local save game. All progress will be lost.',
                (confirmed) => {
                    if (!confirmed) return;
                    
                    // Hide hero selection
                    document.getElementById('heroSelectionModal').style.display = 'none';
                    document.getElementById('musicControls').classList.remove('heroSelectionActive');
                    document.getElementById('musicTicker').classList.remove('battleActive');
                    
                    // Create fresh save FIRST
                    const newSave = createDefaultSharedSave();
                    saveSharedSave(newSave);
                    
                    currentScreen = 'dungeonMenu';
                    document.getElementById('titleScreen').style.display = 'none';
                    document.getElementById('dungeonMenuScreen').style.display = 'block';
                    
                    // Update dungeon menu with new save data (after currentScreen is set)
                    updateDungeonMenuHeroes();
                    updateGoldDisplay();
                    
                    // Center music controls
                    document.getElementById('musicControls').classList.remove('heroSelectionActive');
                    document.getElementById('musicControls').classList.add('dungeonMenuActive');
                    document.getElementById('musicTicker').classList.remove('battleActive');
                    document.getElementById('musicTicker').classList.add('dungeonMenuActive');
                    
                    // Initialize level layout for level 1 (new game) - BEFORE broadcasting to clients
                    initializeLevelLayout(1);
                    
                    // Pre-generate next encounter while in dungeon menu (host only)
                    preGenerateNextEncounter();
                    
                    // Notify all clients to start WITH save data AND level layout
                    sendWebSocketMessage({ 
                        type: 'game_start', 
                        screen: 'dungeonMenu', 
                        mode: 'new',
                        saveData: newSave,
                        levelLayout: currentLevelLayout,
                        levelProgress: levelProgress
                    });
                    
                    showNotification('Starting new adventure...', 'success');
                }
            );
        }
        
        function rejoinGame() {
            if (multiplayerState.role !== 'client') {
                showNotification('Only clients can rejoin', 'error');
                return;
            }
            
            if (multiplayerState.myHeroes.length === 0) {
                showNotification('Please select at least one hero', 'warning');
                return;
            }
            
            // Request current game state from host
            sendWebSocketMessage({ 
                type: 'request_sync',
                heroes: multiplayerState.myHeroes
            });
            
            showNotification('Rejoining game...', 'info');
            multiplayerState.isReconnecting = false;
            
            // Don't hide anything here - let game_start handler manage all screen transitions
        }
        
        function showHostControls() {
            document.getElementById('hostControlsPanel').style.display = 'block';
            updatePlayerList();
        }
        
        function closeHostControls() {
            document.getElementById('hostControlsPanel').style.display = 'none';
        }
        
        function updatePlayerList() {
            const list = document.getElementById('playerList');
            list.innerHTML = '';
            
            multiplayerState.connectedPlayers.forEach(player => {
                const div = document.createElement('div');
                div.style.cssText = 'padding: 10px; margin-bottom: 10px; background: rgba(0,0,0,0.5); border-radius: 5px; display: flex; justify-content: space-between; align-items: center;';
                div.innerHTML = `
                    <div>
                        <div style="color: #F2C94C; font-size: 14px;">${player.hero || 'No hero selected'}</div>
                        <div style="color: #89A0B4; font-size: 11px;">Player ${player.id}</div>
                    </div>
                    <div>
                        <button onclick="skipPlayerTurn(${player.id})" style="padding: 5px 10px; margin-right: 5px; background: #F39C12; border: none; border-radius: 3px; color: white; cursor: pointer;">SKIP TURN</button>
                        <button onclick="kickPlayer(${player.id})" style="padding: 5px 10px; background: #EB5757; border: none; border-radius: 3px; color: white; cursor: pointer;">KICK</button>
                    </div>
                `;
                list.appendChild(div);
            });
            
            // Update multiplayer status indicator
            updateMultiplayerStatus();
        }
        
        function kickPlayer(playerId) {
            if (confirm('Kick this player?')) {
                sendWebSocketMessage({ type: 'kick_player', player_id: playerId });
            }
        }
        
        function skipPlayerTurn(playerId) {
            sendWebSocketMessage({ type: 'skip_turn', player_id: playerId });
        }
        
        function handlePlayerDisconnect(playerId) {
            // Find disconnected player info
            const disconnectedPlayer = multiplayerState.connectedPlayers.find(p => p.id === playerId);
            
            // Find heroes controlled by this player
            const disconnectedHeroes = [];
            if (disconnectedPlayer && disconnectedPlayer.heroes) {
                disconnectedPlayer.heroes.forEach(heroName => {
                    disconnectedHeroes.push(heroName);
                    // Transfer control to host
                    const hero = battleState.heroes?.find(h => h.name.toLowerCase() === heroName.toLowerCase());
                    if (hero) {
                        hero.aiControlled = false; // Host controls it, not AI
                    }
                    // Add to host's heroes (stored lowercase)
                    const heroLower = heroName.toLowerCase();
                    if (!multiplayerState.myHeroes.includes(heroLower)) {
                        multiplayerState.myHeroes.push(heroLower);
                    }
                });
            }
            
            if (disconnectedHeroes.length > 0) {
                showNotification(`Player disconnected - you now control: ${disconnectedHeroes.join(', ')}`, 'warning');
                // Update UI to enable buttons for these heroes
                if (battleState.active && battleState.currentHeroIndex !== undefined) {
                    updateHeroTurn();
                }
            }
            
            // Remove from connected players
            multiplayerState.connectedPlayers = multiplayerState.connectedPlayers.filter(p => p.id !== playerId);
        }
        
        function processClientAction(data) {
            // Host processes action from client
            const action = data.action;
            const target = data.target;
            const heroName = data.hero;
            
            // Retreat is now host-only - clients cannot retreat individually
            if (action === 'retreat') {
                console.log('[MP] Client tried to retreat - only host can retreat the party');
                return;
            }
            
            // Find hero
            const hero = battleState.heroes.find(h => h.name.toLowerCase() === heroName.toLowerCase());
            if (!hero) return;
            
            // Execute action (existing battle logic)
            if (action === 'light' || action === 'heavy' || action === 'special') {
                const enemy = battleState.enemies[target];
                if (enemy) {
                    executeAttack(hero, enemy, action);
                }
            } else if (action === 'swap') {
                // Handle swap with target hero
                const targetHero = battleState.heroes[target];
                if (targetHero && targetHero !== hero) {
                    const tempX = hero.x;
                    const tempY = hero.y;
                    const tempPlatform = hero.platform;
                    
                    hero.x = targetHero.x;
                    hero.y = targetHero.y;
                    hero.platform = targetHero.platform;
                    
                    targetHero.x = tempX;
                    targetHero.y = tempY;
                    targetHero.platform = tempPlatform;
                    
                    showDiceRoll(`${hero.name} swapped positions with ${targetHero.name}!`);
                    advanceTurn();
                }
            } else if (action === 'defend') {
                hero.defending = true;
                showDiceRoll(`${hero.name} defends!`);
                advanceTurn();
            } else if (action === 'heal') {
                if (hero.healsRemaining > 0) {
                    const healAmount = Math.floor(hero.maxHp * 0.5);
                    hero.hp = Math.min(hero.maxHp, hero.hp + healAmount);
                    hero.healsRemaining--;
                    hero.usedHeal = true;
                    
                    // Hide a potion sprite (consume the rightmost visible one)
                    if (hero.potions) {
                        for (let i = hero.potions.length - 1; i >= 0; i--) {
                            if (hero.potions[i].visible) {
                                hero.potions[i].visible = false;
                                break;
                            }
                        }
                    }
                    
                    showDiceRoll(`${hero.name} heals for ${healAmount} HP! (1 action used)`);
                    updateBattleHeroCards();
                }
            } else if (action === 'taunt') {
                const chaModifier = calculateModifier(hero.stats?.cha || 10);
                const tauntRoll = rollD20() + chaModifier;
                const tauntDC = 12;
                
                if (tauntRoll >= tauntDC) {
                    hero.taunting = true;
                    hero.tauntTurns = 3;
                    showDiceRoll(`${hero.name} taunts! d20(${tauntRoll}) SUCCESS!`);
                } else {
                    showDiceRoll(`${hero.name} taunt fails! d20(${tauntRoll}) vs DC ${tauntDC}`);
                }
                advanceTurn();
            } else if (action === 'skip') {
                showDiceRoll(`${hero.name} skips turn.`);
                advanceTurn();
            }
            
            // Broadcast state to all clients
            broadcastGameState();
        }
        
        function broadcastGameState() {
            if (multiplayerState.role !== 'host') return;
            
            const canvas = battleState.canvas;
            
            const state = {
                turnOrder: battleState.turnOrder.map(c => ({ name: c.name, hp: c.hp })),
                heroes: battleState.heroes.map(h => ({
                    name: h.name,
                    hp: h.hp,
                    maxHp: h.maxHp,
                    xp: h.xp,
                    level: h.level,
                    healsRemaining: h.healsRemaining,
                    potionVisibility: h.potions ? h.potions.map(p => p.visible) : [true, true],
                    stats: h.stats,
                    x: h.x / canvas.width,
                    y: h.y / canvas.height,
                    platform: h.platform,
                    defending: h.defending,
                    taunting: h.taunting,
                    tauntTurns: h.tauntTurns || 0,
                    usedHeal: h.usedHeal || false,
                    facing: h.facing,
                    retreated: h.retreated || false,
                    color: h.color,
                    spritePath: h.spritePath,
                    initiative: h.initiative
                })),
                enemies: battleState.enemies.map(e => ({
                    name: e.name,
                    species: e.species,
                    hp: e.hp,
                    maxHp: e.maxHp,
                    ac: e.ac,
                    attackDamage: e.attackDamage,
                    speed: e.speed,
                    dex: e.dex,
                    hostile: e.hostile,
                    x: e.x / canvas.width,
                    y: e.y / canvas.height,
                    platform: e.platform,
                    facing: e.facing,
                    isMob: e.isMob,
                    isBoss: e.isBoss,
                    spritePath: e.spritePath,
                    backstory: e.backstory,
                    initiative: e.initiative,
                    goldDrop: e.goldDrop || 0
                })),
                // Include captive state for sync
                captiveNpc: battleState.captiveNpc ? {
                    name: battleState.captiveNpc.name,
                    rescued: battleState.captiveNpc.rescued,
                    hp: battleState.captiveNpc.hp || 1,
                    maxHp: battleState.captiveNpc.maxHp || 1,
                    goldReward: battleState.captiveNpc.goldReward || 0,
                    x: battleState.captiveNpc.x / canvas.width,
                    y: battleState.captiveNpc.y / canvas.height
                } : null,
                currentTurn: battleState.currentTurn,
                // Sync gold to clients
                gold: loadSharedSave()?.dungeonState?.gold || 0
            };
            
            sendWebSocketMessage({ type: 'state_update', state });
        }
        
        function updateGameStateFromHost(state) {
            // Client updates local state from host
            battleState.currentTurn = state.currentTurn;
            
            const canvas = battleState.canvas;
            
            // Rebuild heroes array to handle removals (retreats)
            battleState.heroes = state.heroes.map(heroData => {
                const existingHero = battleState.heroes.find(h => h.name === heroData.name);
                if (existingHero) {
                    // Update ALL fields from host state for complete sync
                    existingHero.hp = heroData.hp;
                    existingHero.maxHp = heroData.maxHp;
                    existingHero.xp = heroData.xp;
                    existingHero.level = heroData.level;
                    existingHero.healsRemaining = heroData.healsRemaining;
                    // Sync potion visibility from host
                    if (existingHero.potions && heroData.potionVisibility) {
                        heroData.potionVisibility.forEach((visible, idx) => {
                            if (existingHero.potions[idx]) {
                                existingHero.potions[idx].visible = visible;
                            }
                        });
                    }
                    existingHero.stats = heroData.stats;
                    existingHero.x = heroData.x * canvas.width;
                    existingHero.y = (heroData.y * canvas.height) - 25;
                    existingHero.platform = heroData.platform;
                    existingHero.defending = heroData.defending;
                    existingHero.taunting = heroData.taunting;
                    existingHero.tauntTurns = heroData.tauntTurns || 0;
                    existingHero.usedHeal = heroData.usedHeal || false;
                    existingHero.facing = heroData.facing;
                    existingHero.retreated = heroData.retreated || false;
                    existingHero.color = heroData.color;
                    existingHero.spritePath = heroData.spritePath;
                    existingHero.initiative = heroData.initiative;
                    return existingHero;
                } else {
                    console.warn('[MP] Received unknown hero:', heroData.name);
                    return null;
                }
            }).filter(h => h !== null);
            
            // Update enemies - rebuild array to handle removals
            battleState.enemies = state.enemies.map(enemyData => {
                const existingEnemy = battleState.enemies.find(e => e.name === enemyData.name);
                if (existingEnemy) {
                    // Update ALL enemy fields from host state for complete sync
                    existingEnemy.hp = enemyData.hp;
                    existingEnemy.maxHp = enemyData.maxHp;
                    existingEnemy.ac = enemyData.ac;
                    existingEnemy.attackDamage = enemyData.attackDamage;
                    existingEnemy.speed = enemyData.speed;
                    existingEnemy.dex = enemyData.dex;
                    existingEnemy.hostile = enemyData.hostile;
                    existingEnemy.x = enemyData.x * canvas.width;
                    existingEnemy.y = (enemyData.y * canvas.height) - 25;
                    existingEnemy.platform = enemyData.platform;
                    existingEnemy.facing = enemyData.facing;
                    existingEnemy.isMob = enemyData.isMob;
                    existingEnemy.isBoss = enemyData.isBoss;
                    existingEnemy.spritePath = enemyData.spritePath;
                    existingEnemy.backstory = enemyData.backstory;
                    existingEnemy.initiative = enemyData.initiative;
                    existingEnemy.goldDrop = enemyData.goldDrop || 0;
                    existingEnemy.species = enemyData.species;
                    return existingEnemy;
                } else {
                    // This shouldn't happen in normal gameplay, but handle it
                    console.warn('[MP] Received unknown enemy:', enemyData.name);
                    return null;
                }
            }).filter(e => e !== null);
            
            // Update captive NPC state from host
            if (state.captiveNpc && battleState.captiveNpc) {
                battleState.captiveNpc.rescued = state.captiveNpc.rescued;
                battleState.captiveNpc.hp = state.captiveNpc.hp;
                battleState.captiveNpc.maxHp = state.captiveNpc.maxHp;
                battleState.captiveNpc.goldReward = state.captiveNpc.goldReward;
                if (state.captiveNpc.x !== undefined) {
                    battleState.captiveNpc.x = state.captiveNpc.x * canvas.width;
                    battleState.captiveNpc.y = state.captiveNpc.y * canvas.height;
                }
            }
            
            // Rebuild turn order to match host
            battleState.turnOrder = state.turnOrder.map(combatantData => {
                return battleState.heroes.find(h => h.name === combatantData.name) || 
                       battleState.enemies.find(e => e.name === combatantData.name);
            }).filter(c => c);
            
            // Update client hero stats cache from host state
            if (multiplayerState.role === 'client') {
                state.heroes.forEach(heroData => {
                    const heroKey = heroData.name.toLowerCase();
                    if (multiplayerState.heroStatsCache[heroKey] !== undefined) {
                        multiplayerState.heroStatsCache[heroKey] = {
                            hp: heroData.hp,
                            maxHp: heroData.maxHp,
                            xp: heroData.xp,
                            level: heroData.level,
                            str: heroData.stats?.str,
                            dex: heroData.stats?.dex,
                            con: heroData.stats?.con,
                            int: heroData.stats?.int,
                            wis: heroData.stats?.wis,
                            cha: heroData.stats?.cha
                        };
                    }
                });
            }
            
            // Check win condition for clients - change retreat button and show notification
            if (multiplayerState.role === 'client' && battleState.enemies.length === 0 && !battleState.won) {
                battleState.won = true;
                showBattleNotification('ROOM CLEARED!');
                const retreatBtn = document.querySelector('.battleButton.retreat');
                if (retreatBtn) {
                    retreatBtn.textContent = 'ðŸšª LEAVE';
                }
            }
            
            // Update gold cache for clients
            if (state.gold !== undefined) {
                multiplayerState.goldCache = state.gold;
                updateGoldDisplay();
            }
            
            // Check if this was a resync response
            if (multiplayerState.awaitingResync) {
                multiplayerState.awaitingResync = false;
                showNotification('âœ… Resynced with host!', 'success');
            }
            
            // Re-render
            renderBattle();
            updateBattleHeroCards();
            updateBattleEnemyCards();
            updateBattleTurnInfo();
            updateChatTargets();  // Refresh chat buttons when enemies die
        }
        
        function initializeBattleFromHost(battleData) {
            // Client receives full battle initialization from host
            // Ensure canvas is initialized
            if (!battleState.canvas) {
                battleState.canvas = document.getElementById('battleCanvas');
                battleState.ctx = battleState.canvas.getContext('2d');
                battleState.canvas.width = window.innerWidth;
                battleState.canvas.height = window.innerHeight - 180;
            }
            
            const canvas = battleState.canvas;
            
            // Set background - check if host is using video
            battleState.backgroundPath = battleData.backgroundPath;
            battleState.backgroundVideoPath = battleData.backgroundVideoPath || '';
            battleState.useVideoBackground = battleData.useVideoBackground || false;
            
            if (battleState.useVideoBackground && battleData.backgroundVideoPath) {
                // Load video background (same as host)
                const videoEl = document.getElementById('battleBackgroundVideo');
                if (videoEl) {
                    videoEl.querySelector('source').src = battleData.backgroundVideoPath;
                    videoEl.load();
                    videoEl.style.display = 'block';
                    
                    videoEl.onloadeddata = () => {
                        console.log('[MP] Client video loaded:', battleData.backgroundVideoPath);
                        
                        // Capture first frame for backgroundImage (used in detection visualization)
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = videoEl.videoWidth;
                        tempCanvas.height = videoEl.videoHeight;
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCtx.drawImage(videoEl, 0, 0);
                        
                        battleState.backgroundImage = new Image();
                        battleState.backgroundImage.onload = () => renderBattle();
                        battleState.backgroundImage.src = tempCanvas.toDataURL('image/png');
                        
                        videoEl.play().catch(e => console.log('[MP] Video autoplay blocked:', e));
                    };
                    
                    videoEl.onerror = () => {
                        console.error('[MP] Client video failed, using fallback');
                        battleState.useVideoBackground = false;
                        videoEl.style.display = 'none';
                        loadClientFallbackBackground(battleData.backgroundPath);
                    };
                } else {
                    loadClientFallbackBackground(battleData.backgroundPath);
                }
            } else {
                // Use static image background
                loadClientFallbackBackground(battleData.backgroundPath);
            }
            
            // Helper function to load static background for client
            function loadClientFallbackBackground(bgPath) {
                battleState.useVideoBackground = false;
                const videoEl = document.getElementById('battleBackgroundVideo');
                if (videoEl) videoEl.style.display = 'none';
                
                battleState.backgroundImage = new Image();
                battleState.backgroundImage.onload = () => renderBattle();
                battleState.backgroundImage.onerror = () => console.error('[MP] Background failed:', bgPath);
                battleState.backgroundImage.src = bgPath;
            }
            
            // Setup heroes with host's data
            battleState.heroes = battleData.heroes.map(hData => {
                const hero = {
                    name: hData.name,
                    hp: hData.hp,
                    maxHp: hData.maxHp,
                    xp: hData.xp,
                    level: hData.level ?? 1,
                    healsRemaining: hData.healsRemaining,
                    stats: hData.stats,
                    color: hData.name === 'Zooko' ? '#F2C94C' : hData.name === 'Nate' ? '#E74C3C' : hData.name === 'Zancas' ? '#27AE60' : '#2E86DE',
                    x: hData.x * canvas.width,
                    y: (hData.y * canvas.height) - 25,
                    platform: hData.platform,
                    initiative: hData.initiative,
                    facing: 'center',
                    sprite: new Image(),
                    spritePath: hData.spritePath
                };
                hero.sprite.onload = () => {
                    renderBattle();
                };
                hero.sprite.onerror = () => {
                    console.error('[MP ERROR] Hero sprite failed:', hero.name, hero.spritePath);
                };
                hero.sprite.src = hero.spritePath + '?v=' + Date.now();
                return hero;
            });
            
            // Initialize animation controllers for heroes (so clients can receive animation_sync)
            battleState.heroes.forEach(hero => {
                const heroKey = hero.name.toLowerCase();
                let idlePath = HERO_ANIM_PATHS[heroKey]?.idle;
                // Handle array of idle variants - pick random one
                if (Array.isArray(idlePath)) {
                    idlePath = idlePath[Math.floor(Math.random() * idlePath.length)];
                }
                if (idlePath) {
                    initAnimation(hero, idlePath, 'pingpong');
                }
                
                // Initialize health potion animations for clients
                // Initialize health potion static sprites for clients
                hero.potions = [{ visible: true }, { visible: true }];
                const potionPath = 'tunnelsofprivacy/items/healing_potions_a_cropped.png';
                hero.potionSprite = new Image();
                hero.potionSprite.onload = () => renderBattle();
                hero.potionSprite.src = potionPath + '?v=' + Date.now();
                
                hero.potions.forEach((potion, idx) => {
                    potion.visible = idx < hero.healsRemaining;  // Show based on heals remaining
                });
                
                // Load backpack sprite for client
                hero.backpackSprite = new Image();
                hero.backpackPath = `tunnelsofprivacy/gear/${heroKey}_backpack.png`;
                hero.backpackSprite.onload = () => renderBattle();
                hero.backpackSprite.src = hero.backpackPath + '?v=' + Date.now();
            });
            
            // Setup enemies with host's data
            battleState.enemies = battleData.enemies.map(eData => {
                const enemy = {
                    name: eData.name,
                    species: eData.species,
                    hp: eData.hp,
                    maxHp: eData.maxHp,
                    ac: eData.ac,
                    attackDamage: eData.attackDamage,
                    speed: eData.speed,
                    dex: eData.dex,
                    hostile: eData.hostile,
                    color: eData.isMob ? '#5C3317' : '#8B45FF',
                    x: eData.x * canvas.width,
                    y: (eData.y * canvas.height) - 25,
                    platform: eData.platform,
                    initiative: eData.initiative,
                    facing: 'center',
                    sprite: new Image(),
                    spritePath: eData.spritePath,
                    isMob: eData.isMob,
                    isBoss: eData.isBoss,
                    goldDrop: eData.goldDrop || 0,
                    backstory: eData.backstory
                };
                enemy.sprite.onload = () => {
                    renderBattle();
                };
                enemy.sprite.onerror = () => {
                    console.error('[MP ERROR] Enemy sprite failed:', enemy.name, enemy.spritePath);
                };
                enemy.sprite.src = enemy.spritePath + '?v=' + Date.now();
                return enemy;
            });
            
            // Setup turn order from host
            const allCombatants = [...battleState.heroes, ...battleState.enemies];
            battleState.turnOrder = battleData.turnOrder.map(name => 
                allCombatants.find(c => c.name === name)
            ).filter(c => c); // Filter out any not found
            
            if (battleState.turnOrder.length === 0) {
                console.error('[MP ERROR] Turn order is empty after initialization!');
            }
            
            // Setup captive NPC from host's data (full mob-like entity)
            if (battleData.captiveNpc) {
                battleState.captiveNpc = {
                    name: battleData.captiveNpc.name,
                    species: battleData.captiveNpc.species,
                    backstory: battleData.captiveNpc.backstory,
                    personality: battleData.captiveNpc.personality,
                    rescueReward: battleData.captiveNpc.rescueReward,
                    goldReward: battleData.captiveNpc.goldReward || battleData.captiveNpc.rescueReward?.gold || 0,
                    dialogueOnRescue: battleData.captiveNpc.dialogueOnRescue,
                    rescued: battleData.captiveNpc.rescued,
                    hp: battleData.captiveNpc.hp || 1,
                    maxHp: battleData.captiveNpc.maxHp || 1,
                    x: battleData.captiveNpc.x * canvas.width,
                    y: battleData.captiveNpc.y * canvas.height,
                    spritePath: battleData.captiveNpc.spritePath,
                    color: battleData.captiveNpc.color || '#F2C94C',
                    sprite: new Image(),
                    isCaptive: true,
                    isMob: false,
                    canChat: true,
                    hostile: false,
                    facing: battleData.captiveNpc.facing || 'center'
                };
                // Handle sprite load with graceful fallback
                battleState.captiveNpc.sprite.onerror = () => {
                    console.log('[MP] Captive sprite not found, using fallback circle');
                };
                battleState.captiveNpc.sprite.onload = () => {
                    renderBattle();
                };
                battleState.captiveNpc.sprite.src = battleState.captiveNpc.spritePath + '?v=' + Date.now();
                console.log('[MP] Captive NPC received:', battleState.captiveNpc.name);
            } else {
                battleState.captiveNpc = null;
            }
            
            battleState.currentTurn = battleData.currentTurn;
            battleState.active = true;
            battleState.targetingMode = false;
            battleState.pendingAction = null;
            battleState.allHeroes = []; // Reset for fresh battle - will be populated on retreat/death
            
            // Check for heroes that entered battle already knocked out (0 HP)
            battleState.heroes.forEach(hero => {
                if (hero.hp <= 0) {
                    const heroKey = hero.name.toLowerCase();
                    const paths = HERO_ANIM_PATHS[heroKey];
                    if (paths && paths.knockout) {
                        setAnimationState(hero, 'knockout', 'once');
                        console.log(`[MP] ${hero.name} entered battle knocked out`);
                    }
                }
            });
            
            // Update UI
            updateBattleTurnInfo();
            updateBattleHeroCards();
            updateBattleEnemyCards();
            renderBattle();
            
            // Show captive NPC notification if present (same as host)
            if (battleState.captiveNpc) {
                setTimeout(() => {
                    showBattleNotification(`A prisoner is here: ${battleState.captiveNpc.name}!`);
                }, 2000);
            }
            
            // Start battle animation loop for continuous updates
            function battleAnimationLoop() {
                if (battleState.active) {
                    renderBattle();
                    requestAnimationFrame(battleAnimationLoop);
                }
            }
            battleAnimationLoop();
            
            // Disable retreat button for clients - only host can retreat
            const retreatBtn = document.getElementById('battleRetreatBtn');
            if (retreatBtn) {
                retreatBtn.disabled = true;
                retreatBtn.style.opacity = '0.5';
                retreatBtn.style.cursor = 'not-allowed';
                retreatBtn.title = 'Only party leader can retreat';
            }
            
            showNotification('Battle initialized!', 'success');
        }
        
        function showNotification(message, type = 'info') {
            // Simple notification system
            const color = type === 'error' ? '#EB5757' : type === 'success' ? '#27AE60' : type === 'warning' ? '#F39C12' : '#3498DB';
            showDiceRoll(message);
        }
        
        // Show dramatic boss battle announcement
        function showBossBattleAnnouncement(bossText, level) {
            // Remove existing announcement if any
            const existing = document.getElementById('bossBattleAnnouncement');
            if (existing) existing.remove();
            
            const announcement = document.createElement('div');
            announcement.id = 'bossBattleAnnouncement';
            announcement.innerHTML = `
                <div style="
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: linear-gradient(135deg, rgba(139, 69, 255, 0.95), rgba(80, 20, 150, 0.95));
                    border: 4px solid #FFD700;
                    border-radius: 16px;
                    padding: 30px 60px;
                    z-index: 10000;
                    backdrop-filter: blur(10px);
                    box-shadow: 0 0 60px rgba(139, 69, 255, 0.8), 0 0 120px rgba(255, 215, 0, 0.4);
                    text-align: center;
                    animation: bossBattleZoom 0.5s ease-out;
                ">
                    <div style="font-size: 48px; font-weight: 900; color: #FFD700; text-shadow: 0 0 20px #FFD700, 0 0 40px #8B45FF; letter-spacing: 4px; margin-bottom: 10px;">
                        âš”ï¸ ${bossText} âš”ï¸
                    </div>
                    <div style="font-size: 28px; font-weight: 700; color: #fff; text-shadow: 0 0 10px rgba(255,255,255,0.5);">
                        LEVEL ${level}
                    </div>
                </div>
            `;
            
            // Add animation keyframes if not already present
            if (!document.getElementById('bossBattleStyles')) {
                const style = document.createElement('style');
                style.id = 'bossBattleStyles';
                style.textContent = `
                    @keyframes bossBattleZoom {
                        0% { transform: translate(-50%, -50%) scale(0.3); opacity: 0; }
                        50% { transform: translate(-50%, -50%) scale(1.1); }
                        100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
                    }
                `;
                document.head.appendChild(style);
            }
            
            document.body.appendChild(announcement);
            
            // Auto-remove after 2.5 seconds with fade out
            setTimeout(() => {
                announcement.style.transition = 'opacity 0.5s ease-out';
                announcement.style.opacity = '0';
                setTimeout(() => announcement.remove(), 500);
            }, 2500);
        }
        
        // Show rate limit warning on right side of screen
        function showRateLimitWarning() {
            // Remove existing warning if any
            const existing = document.getElementById('rateLimitWarning');
            if (existing) existing.remove();
            
            const warning = document.createElement('div');
            warning.id = 'rateLimitWarning';
            warning.innerHTML = `
                <div style="
                    position: fixed;
                    top: 50%;
                    right: 20px;
                    transform: translateY(-50%);
                    background: linear-gradient(135deg, rgba(235, 87, 87, 0.95), rgba(180, 50, 50, 0.95));
                    border: 2px solid #EB5757;
                    border-radius: 12px;
                    padding: 16px 20px;
                    max-width: 280px;
                    z-index: 10000;
                    backdrop-filter: blur(10px);
                    box-shadow: 0 8px 32px rgba(235, 87, 87, 0.4);
                    animation: slideInRight 0.3s ease-out;
                ">
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                        <span style="font-size: 24px;">âš ï¸</span>
                        <span style="font-weight: 700; font-size: 14px; color: #fff;">LLM Rate Limited</span>
                    </div>
                    <div style="font-size: 12px; color: rgba(255,255,255,0.9); line-height: 1.4; margin-bottom: 12px;">
                        API request limit reached.<br>
                        <strong>Wait 30-60 seconds</strong> and retry,<br>
                        or switch to <strong>Paid Models</strong> in Settings.
                    </div>
                    <button onclick="document.getElementById('rateLimitWarning').remove()" style="
                        background: rgba(255,255,255,0.2);
                        border: 1px solid rgba(255,255,255,0.3);
                        border-radius: 6px;
                        padding: 6px 16px;
                        color: #fff;
                        font-size: 11px;
                        cursor: pointer;
                        width: 100%;
                        transition: background 0.2s;
                    " onmouseover="this.style.background='rgba(255,255,255,0.3)'" onmouseout="this.style.background='rgba(255,255,255,0.2)'">
                        DISMISS
                    </button>
                </div>
            `;
            document.body.appendChild(warning);
            
            // Auto-dismiss after 10 seconds
            setTimeout(() => {
                const el = document.getElementById('rateLimitWarning');
                if (el) el.remove();
            }, 10000);
        }
        
        // Check if error is a rate limit error and show warning
        function checkForRateLimitError(error) {
            if (error && (error.includes('429') || error.toLowerCase().includes('rate limit'))) {
                showRateLimitWarning();
                return true;
            }
            return false;
        }

        // ===== NETWORK DEBUG FUNCTIONS =====
        let debugMessageLog = [];
        const MAX_DEBUG_MESSAGES = 20;
        
        function toggleNetworkDebug() {
            const panel = document.getElementById('networkDebugPanel');
            const checkbox = document.getElementById('networkDebug');
            
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
                if (checkbox) checkbox.checked = true;
            } else {
                panel.style.display = 'none';
                if (checkbox) checkbox.checked = false;
            }
        }
        
        function logDebugMessage(type, data, direction = 'out') {
            const timestamp = new Date().toLocaleTimeString();
            const arrow = direction === 'out' ? 'â¬†ï¸' : 'â¬‡ï¸';
            const color = direction === 'out' ? '#F39C12' : '#3498DB';
            
            debugMessageLog.push({
                timestamp,
                type,
                data,
                direction,
                arrow,
                color
            });
            
            // Keep only last 20 messages
            if (debugMessageLog.length > MAX_DEBUG_MESSAGES) {
                debugMessageLog.shift();
            }
            
            updateDebugLogDisplay();
        }
        
        function updateDebugLogDisplay() {
            const logDiv = document.getElementById('debugMessageLog');
            if (!logDiv) return;
            
            logDiv.innerHTML = debugMessageLog.map(msg => `
                <div style="margin-bottom: 8px; padding: 5px; border-left: 3px solid ${msg.color}; background: rgba(0,0,0,0.3);">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 3px;">
                        <span style="color: #89A0B4; font-size: 10px;">${msg.timestamp}</span>
                        <span style="font-size: 10px;">${msg.arrow} ${msg.type}</span>
                    </div>
                    <div style="color: #E9F0F7; font-size: 10px; word-break: break-word;">${JSON.stringify(msg.data, null, 2).slice(0, 200)}</div>
                </div>
            `).join('');
            
            // Auto-scroll to bottom
            logDiv.scrollTop = logDiv.scrollHeight;
        }
        
        function clearDebugLog() {
            debugMessageLog = [];
            updateDebugLogDisplay();
        }
        
        function updateDebugStatus() {
            const connStatus = document.getElementById('debugConnStatus');
            const roomState = document.getElementById('debugRoomState');
            
            if (connStatus) {
                if (multiplayerState.ws && multiplayerState.ws.readyState === WebSocket.OPEN) {
                    connStatus.textContent = 'âœ… Connected';
                    connStatus.style.color = '#27AE60';
                } else {
                    connStatus.textContent = 'âŒ Disconnected';
                    connStatus.style.color = '#EB5757';
                }
            }
            
            if (roomState) {
                if (multiplayerState.enabled && multiplayerState.roomCode) {
                    const role = multiplayerState.role === 'host' ? 'ðŸ‘‘ HOST' : 'ðŸŽ® CLIENT';
                    const players = multiplayerState.connectedPlayers.length;
                    roomState.innerHTML = `
                        <div>${role}</div>
                        <div style="margin-top: 3px;">Code: <span style="color: #F2C94C; font-weight: bold;">${multiplayerState.roomCode}</span></div>
                        <div style="margin-top: 3px;">Players: ${players}/4</div>
                        <div style="margin-top: 3px;">My Heroes: <span style="color: #F2C94C;">${multiplayerState.myHeroes.join(', ') || 'None'}</span></div>
                    `;
                    roomState.style.color = '#2A9D8F';
                } else {
                    roomState.textContent = 'No room';
                    roomState.style.color = '#89A0B4';
                }
            }
        }
        
        // ===== END MULTIPLAYER FUNCTIONS =====
        
        function init() {
            console.log('Tunnels of Privacy - Initializing...');
            
            // Load settings
            loadSettings();
            console.log('Settings loaded:', settings);
            
            // Initialize SFX audio pool
            initSfxPool();
            
            // Add global click handler for UI button sounds
            document.addEventListener('click', (e) => {
                const target = e.target.closest('button, .menuButton, .heroSelectCard');
                if (target && sfxVolume > 0) {
                    playSfx('uiClick');
                }
            });
            
            // Initialize party inventory
            const savedLevel = parseInt(document.getElementById('dungeonLevel')?.textContent) || 1;
            initializeInventory(savedLevel);
            
            // Check TTS availability
            checkTTSAvailability();
            
            // ===== GAMEPAD SUPPORT =====
            // Handle gamepad connections
            window.addEventListener('gamepadconnected', onGamepadConnected);
            window.addEventListener('gamepaddisconnected', onGamepadDisconnected);
            // Start gamepad polling loop
            gamepadLoop();
            // ===== END GAMEPAD SUPPORT =====
            
            // Initialize achievements and bestiary system
            initAchievementsSystem();
            
            // Preload assets
            preloadAssets();
            
            // Start background animation
            startStoryIntroAnimation();
            
            // Load shared save and display hero stats
            const sharedSave = loadSharedSave();
            const heroStatsEl = document.getElementById('heroStats');
            
            if (sharedSave && sharedSave.heroes) {
                console.log('Loaded shared save with heroes:', sharedSave.heroes);
                
                // Show hero party
                if (heroStatsEl) heroStatsEl.style.display = 'block';
                
                // Update each hero's display
                updateHeroDisplay('zooko', sharedSave.heroes.zooko);
                updateHeroDisplay('nate', sharedSave.heroes.nate);
                updateHeroDisplay('zancas', sharedSave.heroes.zancas);
                updateHeroDisplay('cyberaxe', sharedSave.heroes.cyberaxe);
                
                // Update dungeon level from arcade level
                if (sharedSave.arcadeState && sharedSave.arcadeState.level) {
                    const arcadeLevel = sharedSave.arcadeState.level;
                    document.getElementById('dungeonLevel').textContent = arcadeLevel;
                    console.log('Dungeon depth set to arcade level:', arcadeLevel);
                } else {
                    console.log('No arcade level found - defaulting to level 1');
                }
            } else {
                console.log('No shared save found - hiding hero party');
                // Hide hero party when no save exists
                if (heroStatsEl) heroStatsEl.style.display = 'none';
            }
            
            // Update title screen button states
            updateTitleScreenButtons();
            
            // Initialize hackathon info tooltips
            initTooltipSystem();
            
            // Load level progress stats (total bosses defeated, current level progress)
            loadLevelProgress();
            
            console.log('Initialization complete. Portal system ready.');
        }
        
        // Run init when page loads
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
