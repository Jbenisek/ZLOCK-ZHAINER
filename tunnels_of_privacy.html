<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <title>TUNNELS OF PRIVACY - Dungeon Crawler v0.3.43</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet" media="print" onload="this.media='all'; this.onload=null;">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #0A0E12 0%, #1A1E2A 100%);
            color: #E9F0F7;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            cursor: default;
        }
        
        #gameContainer {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #titleScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 14, 18, 0.95);
            z-index: 100;
            pointer-events: none;
        }
        
        #dungeonMenuScreen {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0A0E12 0%, #1A1E2A 100%);
            z-index: 100;
        }
        
        #dungeonMenuBackground {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.25;
            background-size: 800% 1600%;
            background-position: 0% 0%;
            background-repeat: no-repeat;
            transition: opacity 1s ease-in-out;
        }
        
        #battleScreen {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a0f2e 0%, #0f0a1e 100%);
            z-index: 100;
        }
        
        #battleCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: calc(100% - 180px);
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        #battleNotification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(46, 204, 113, 0.95), rgba(39, 174, 96, 0.95));
            border: 4px solid #27AE60;
            border-radius: 12px;
            padding: 40px 60px;
            font-family: 'Inter', sans-serif;
            font-size: 48px;
            font-weight: 900;
            color: #FFFFFF;
            text-shadow: 0 4px 8px rgba(0, 0, 0, 0.6);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
            z-index: 1000;
            display: none;
            width: 700px;
            text-align: center;
            word-wrap: break-word;
            overflow-wrap: break-word;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 4px;
            animation: notificationPulse 0.5s ease-out;
        }
        
        @keyframes notificationPulse {
            0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        
        @keyframes slideInRight {
            0% { transform: translateY(-50%) translateX(100px); opacity: 0; }
            100% { transform: translateY(-50%) translateX(0); opacity: 1; }
        }
        
        #battleEnemyCards {
            position: absolute;
            top: 20px;
            left: 20px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            max-width: 170px;
            max-height: calc(100vh - 180px);
            overflow-y: auto;
            overflow-x: hidden;
            z-index: 10;
            scrollbar-width: none;  /* Firefox */
            -ms-overflow-style: none;  /* IE/Edge */
        }
        
        #battleEnemyCards::-webkit-scrollbar {
            display: none;  /* Chrome/Safari/Opera */
        }
        
        #battleEnemyCards.threeColumns {
            grid-template-columns: 1fr 1fr 1fr;
            max-width: 255px;
        }
        
        .battleEnemyCard {
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            border: 2px solid #E74C3C;
            border-radius: 6px;
            padding: 4px;
            width: 75px;
            backdrop-filter: blur(10px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
            cursor: pointer;
            transition: all 0.3s ease;
            transform-origin: top left;
        }
        
        .battleEnemyCard.enlarged {
            position: fixed;
            transform: scale(2);
            z-index: 1000;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.8);
        }
        
        .battleEnemyCard.boss {
            border-color: #8B45FF;
            box-shadow: 0 0 8px rgba(139, 69, 255, 0.4);
        }
        
        .battleEnemyCard.targetable {
            border-color: #FFD700;
            box-shadow: 0 0 12px rgba(255, 215, 0, 0.6);
            animation: cardPulse 1s infinite;
        }
        
        .battleEnemyCard:hover.targetable {
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.8);
        }
        
        @keyframes cardPulse {
            0%, 100% { box-shadow: 0 0 12px rgba(255, 215, 0, 0.6); }
            50% { box-shadow: 0 0 18px rgba(255, 215, 0, 0.9); }
        }
        
        .battleEnemyCard.dead {
            opacity: 0.4;
            cursor: not-allowed;
            filter: grayscale(100%);
        }
        
        .battleEnemyPortrait {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background-size: cover;
            background-position: center;
            border: 1px solid #E74C3C;
            margin: 0 auto 3px auto;
            box-shadow: 0 0 5px rgba(231, 76, 60, 0.4);
        }
        
        .battleEnemyCard.boss .battleEnemyPortrait {
            border-color: #8B45FF;
            box-shadow: 0 0 5px rgba(139, 69, 255, 0.4);
        }
        
        .battleEnemyName {
            font-family: 'Inter', sans-serif;
            font-size: 7px;
            font-weight: 700;
            text-align: center;
            margin-bottom: 2px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            color: #E74C3C;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .battleEnemyCard.boss .battleEnemyName {
            color: #8B45FF;
        }
        
        .battleEnemyStat {
            font-size: 6px;
            text-align: center;
            margin-bottom: 1px;
        }
        
        .battleEnemyCard.captive {
            border-color: #F2C94C;
            box-shadow: 0 0 8px rgba(242, 201, 76, 0.4);
        }
        
        .battleEnemyCard.captive .battleEnemyPortrait {
            border-color: #F2C94C;
            box-shadow: 0 0 5px rgba(242, 201, 76, 0.4);
            background-size: 250%;
            background-position: center 15%;
        }
        
        .battleEnemyCard.captive .battleEnemyName {
            color: #F2C94C;
            margin-top: -4px;
            position: relative;
            z-index: 10;
        }
        
        /* Chat Window Styles */
        #battleChatWindow {
            position: absolute;
            bottom: 10px;
            right: 20px;
            width: 350px;
            height: 600px;
            background: rgba(10, 14, 18, 0.5);
            border: 2px solid #5865F2;
            border-radius: 12px;
            display: none;
            flex-direction: column;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            z-index: 100;
            transition: height 0.3s ease;
        }
        
        #battleChatWindow.compact {
            height: 300px;
        }
        
        #battleChatWindow.compact #chatTargetSelector,
        #battleChatWindow.compact #chatModelSelector {
            display: none;
        }
        
        #chatExpandBtn {
            background: none;
            border: none;
            color: white;
            font-size: 16px;
            cursor: pointer;
            padding: 0 5px;
            margin-right: 4px;
        }
        
        #chatExpandBtn:hover {
            color: #5865F2;
        }
        
        #chatHeader {
            padding: 10px 15px;
            background: linear-gradient(135deg, #5865F2, #4752C4);
            border-radius: 10px 10px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        #chatHeader span {
            color: white;
            font-weight: 700;
            font-size: 14px;
        }
        
        #chatCloseBtn {
            background: none;
            border: none;
            color: white;
            font-size: 18px;
            cursor: pointer;
            padding: 0 5px;
        }
        
        #ttsToggleLabel {
            display: flex;
            align-items: center;
            gap: 4px;
            cursor: pointer;
            color: white;
            margin-left: auto;
            margin-right: 8px;
            padding: 2px 6px;
            border-radius: 4px;
            background: rgba(255,255,255,0.1);
        }
        
        #ttsToggleLabel:hover {
            background: rgba(255,255,255,0.2);
        }
        
        #ttsToggle {
            width: 14px;
            height: 14px;
            cursor: pointer;
        }
        
        #chatMessages {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .chatMessage {
            display: flex;
            gap: 8px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }
        
        .chatAvatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background-size: cover;
            background-position: center;
            flex-shrink: 0;
            border: 2px solid #444;
        }
        
        .chatContent {
            flex: 1;
            min-width: 0;
        }
        
        .chatName {
            font-size: 12px;
            font-weight: 700;
            margin-bottom: 2px;
        }
        
        .chatName.hostile { color: #E74C3C; }
        .chatName.questable { color: #F2C94C; }
        .chatName.friendly { color: #27AE60; }
        .chatName.player { color: #FFFFFF; }
        
        .chatText {
            font-size: 13px;
            color: #BFD1E0;
            word-wrap: break-word;
            overflow-wrap: break-word;
            white-space: pre-wrap;
        }
        
        .typingCursor {
            color: #5865F2;
            animation: cursorBlink 0.5s infinite;
        }
        
        @keyframes cursorBlink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        #chatInputArea {
            padding: 10px;
            border-top: 1px solid #333;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        #chatTargetSelector {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            max-height: 80px;
            overflow-y: auto;
            padding: 4px 0;
        }
        
        .chatTargetBtn {
            padding: 3px 8px;
            font-size: 10px;
            border: 1px solid #444;
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.5);
            color: #aaa;
            cursor: pointer;
            white-space: nowrap;
            max-width: 100px;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .chatTargetBtn:hover {
            background: rgba(88, 101, 242, 0.3);
            border-color: #5865F2;
        }
        
        .chatTargetBtn.active {
            background: #5865F2;
            color: white;
            border-color: #5865F2;
        }
        
        .chatTargetBtn.hostile {
            border-color: #E74C3C;
        }
        
        .chatTargetBtn.hostile.active {
            background: #E74C3C;
        }
        
        .chatTargetBtn.friendly {
            border-color: #F2C94C;
        }
        
        .chatTargetBtn.friendly.active {
            background: #F2C94C;
            color: #000;
        }
        
        .chatTargetBtn.boss {
            border-color: #8B45FF;
        }
        
        .chatTargetBtn.boss.active {
            background: #8B45FF;
        }
        
        .chatTargetBtn.broadcast {
            border-color: #27AE60;
        }
        
        .chatTargetBtn.broadcast.active {
            background: #27AE60;
        }
        
        #chatInputRow {
            display: flex;
            gap: 8px;
        }
        
        #chatInput {
            flex: 1;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #444;
            border-radius: 6px;
            padding: 8px 12px;
            color: white;
            font-size: 13px;
            outline: none;
        }
        
        #chatInput:focus {
            border-color: #5865F2;
        }
        
        #chatSendBtn {
            background: #5865F2;
            border: none;
            border-radius: 6px;
            padding: 8px 15px;
            color: white;
            font-weight: 600;
            cursor: pointer;
        }
        
        #chatModelSelector {
            display: flex;
            gap: 3px;
            padding: 5px 10px;
            border-bottom: 1px solid #333;
            flex-wrap: wrap;
            align-items: center;
            position: relative;
            z-index: 10;
        }
        
        #chatModelSelector span {
            pointer-events: none;
            user-select: none;
        }
        
        .modelBtn {
            width: 24px;
            height: 24px;
            border: 1px solid #444;
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.5);
            color: #aaa;
            font-size: 11px;
            cursor: pointer;
            padding: 0;
            position: relative;
            z-index: 11;
        }
        
        .modelBtn:hover {
            background: rgba(88, 101, 242, 0.3);
            border-color: #5865F2;
        }
        
        .modelBtn.active {
            background: #5865F2;
            color: white;
            border-color: #5865F2;
        }
        
        .modelBtn.exhausted {
            opacity: 0.5;
            cursor: not-allowed;
            position: relative;
        }
        
        .modelBtn.exhausted::after {
            content: 'âœ•';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #E74C3C;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 0 0 2px black;
        }
        
        #chatSendBtn:hover {
            background: #4752C4;
        }
        
        #chatSendBtn:disabled {
            background: #333;
            cursor: not-allowed;
        }
        
        .battleEnemyStat {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: #BFD1E0;
            text-align: center;
            margin: 2px 0;
        }
        
        #battleUI {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 180px;
            background: linear-gradient(180deg, rgba(10, 14, 18, 0) 0%, rgba(10, 14, 18, 0.95) 20%, rgba(10, 14, 18, 0.98) 100%);
            display: flex;
            flex-direction: row;
            align-items: flex-end;
            justify-content: center;
            padding: 15px;
            gap: 15px;
        }
        
        #battleUILeft {
            display: flex;
            flex-direction: row;
            gap: 10px;
            flex-shrink: 0;
        }
        
        #battleUICenter {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            gap: 10px;
        }
        
        #battleUIRight {
            display: flex;
            flex-direction: row;
            gap: 10px;
            flex-shrink: 0;
        }
        
        .battleHeroCard {
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            border: 2px solid #2A9D8F;
            border-radius: 8px;
            padding: 8px;
            width: 140px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
        }
        
        .battleHeroCard.active {
            border-color: #F2C94C;
            box-shadow: 0 0 20px rgba(242, 201, 76, 0.6);
        }
        
        /* Character-specific card borders */
        #battleCardZooko {
            border-color: #F2C94C;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4), 0 0 10px rgba(242, 201, 76, 0.3);
        }
        #battleCardNate {
            border-color: #E74C3C;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4), 0 0 10px rgba(231, 76, 60, 0.3);
        }
        #battleCardZancas {
            border-color: #27AE60;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4), 0 0 10px rgba(39, 174, 96, 0.3);
        }
        #battleCardCyberAxe {
            border-color: #2E86DE;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4), 0 0 10px rgba(46, 134, 222, 0.3);
        }
        
        .battleHeroPortrait {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-size: cover;
            background-position: center;
            border: 2px solid #2A9D8F;
            margin: 0 auto 6px auto;
            box-shadow: 0 0 10px rgba(42, 157, 143, 0.4);
        }
        
        .battleHeroName {
            font-family: 'Inter', sans-serif;
            font-size: 11px;
            font-weight: 700;
            text-align: center;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .battleHeroStat {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: #BFD1E0;
            text-align: center;
            margin: 2px 0;
        }
        
        #battleTurnInfo {
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            color: #F2C94C;
            text-shadow: 0 0 10px rgba(242, 201, 76, 0.5);
            margin-bottom: 5px;
        }
        
        #battleActions {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 5px;
            width: 100%;
            max-width: 700px;
        }
        
        .battleButton {
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            border: 2px solid #2A9D8F;
            color: #E9F0F7;
            font-family: 'Inter', sans-serif;
            font-size: 10px;
            font-weight: 600;
            padding: 4px 4px;
            border-radius: 6px;
            cursor: pointer;
            pointer-events: all;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .battleButton:hover:not(:disabled) {
            background: linear-gradient(135deg, rgba(42, 157, 143, 0.3), rgba(42, 157, 143, 0.2));
            border-color: #3DBAA3;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(42, 157, 143, 0.4);
        }
        
        .battleButton:active:not(:disabled) {
            transform: translateY(0px) scale(0.95);
            box-shadow: 0 2px 8px rgba(42, 157, 143, 0.6);
        }
        
        .battleButton:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        .battleButton.attack-weak { border-color: #3498DB; }
        .battleButton.attack-weak:hover:not(:disabled) { 
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.3), rgba(52, 152, 219, 0.2));
            border-color: #5DADE2;
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
        }
        
        .battleButton.attack-strong { border-color: #E74C3C; }
        .battleButton.attack-strong:hover:not(:disabled) { 
            background: linear-gradient(135deg, rgba(231, 76, 60, 0.3), rgba(231, 76, 60, 0.2));
            border-color: #EC7063;
            box-shadow: 0 6px 20px rgba(231, 76, 60, 0.4);
        }
        
        .battleButton.special { border-color: #F39C12; }
        .battleButton.special:hover:not(:disabled) { 
            background: linear-gradient(135deg, rgba(243, 156, 18, 0.3), rgba(243, 156, 18, 0.2));
            border-color: #F8C471;
            box-shadow: 0 6px 20px rgba(243, 156, 18, 0.4);
        }
        
        .battleButton.defend { border-color: #27AE60; }
        .battleButton.defend:hover:not(:disabled) { 
            background: linear-gradient(135deg, rgba(39, 174, 96, 0.3), rgba(39, 174, 96, 0.2));
            border-color: #52BE80;
            box-shadow: 0 6px 20px rgba(39, 174, 96, 0.4);
        }
        
        .battleButton.heal { border-color: #9B59B6; }
        .battleButton.heal:hover:not(:disabled) { 
            background: linear-gradient(135deg, rgba(155, 89, 182, 0.3), rgba(155, 89, 182, 0.2));
            border-color: #AF7AC5;
            box-shadow: 0 6px 20px rgba(155, 89, 182, 0.4);
        }
        
        .battleButton.swap { border-color: #3498DB; }
        .battleButton.swap:hover:not(:disabled) { 
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.3), rgba(52, 152, 219, 0.2));
            border-color: #5DADE2;
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
        }
        
        .battleButton.taunt { border-color: #E67E22; }
        .battleButton.taunt:hover:not(:disabled) { 
            background: linear-gradient(135deg, rgba(230, 126, 34, 0.3), rgba(230, 126, 34, 0.2));
            border-color: #F39C12;
            box-shadow: 0 6px 20px rgba(230, 126, 34, 0.4);
        }
        
        .battleButton.retreat { border-color: #95A5A6; }
        .battleButton.retreat:hover:not(:disabled) { 
            background: linear-gradient(135deg, rgba(149, 165, 166, 0.3), rgba(149, 165, 166, 0.2));
            border-color: #BDC3C7;
            box-shadow: 0 6px 20px rgba(149, 165, 166, 0.4);
        }
        
        #pauseScreen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 14, 18, 0.98);
            z-index: 1000;
            pointer-events: all;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        #pauseTitle {
            font-size: 72px;
            font-weight: 900;
            color: #8B45FF;
            text-shadow: 0 0 40px rgba(139, 69, 255, 0.6);
            margin-bottom: 40px;
            letter-spacing: 8px;
        }
        
        #storyIntroBackground {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.3;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            transition: opacity 2s ease-in-out;
        }
        
        #title {
            display: none;
        }
        
        #subtitle {
            display: none;
        }
        
        /* Center Column - Main Menu Buttons */
        #menuButtonsCenter {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            pointer-events: none;
        }
        
        .menuButton {
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            border: 2px solid #2A9D8F;
            color: #E9F0F7;
            font-family: 'Inter', sans-serif;
            font-size: 18px;
            font-weight: 700;
            padding: 14px 40px;
            margin: 8px;
            cursor: pointer;
            transition: all 0.2s;
            border-radius: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
            width: 380px;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: all;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
        }
        
        .menuButton:hover {
            background: linear-gradient(135deg, rgba(20, 27, 34, 0.95), rgba(42, 157, 143, 0.2));
            box-shadow: 0 6px 25px rgba(42, 157, 143, 0.4);
            transform: translateY(-2px);
            border-color: #4ECDC4;
        }
        
        .menuButton:active {
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.98), rgba(15, 19, 24, 0.95));
            transform: translateY(0px);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }
        
        .menuButton:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        /* Explore Level Button with loading bar */
        #exploreLevelBtn {
            position: relative;
            overflow: hidden;
            z-index: 1;
        }
        
        #exploreLevelBtn .loadingBar {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, rgba(42, 157, 143, 0.4), rgba(78, 205, 196, 0.5));
            transition: width 0.3s ease-out;
            z-index: -1;
            border-radius: 6px;
        }
        
        #exploreLevelBtn.ready {
            border-color: #27AE60;
            box-shadow: 0 0 15px rgba(39, 174, 96, 0.5);
        }
        
        #exploreLevelBtn.ready .loadingBar {
            background: linear-gradient(90deg, rgba(39, 174, 96, 0.4), rgba(46, 204, 113, 0.5));
        }
        
        #exploreLevelBtn .btnText {
            position: relative;
            z-index: 2;
        }
        
        /* Level Store Button - Unlocked State */
        #levelStoreBtn.unlocked {
            background: linear-gradient(135deg, rgba(39, 174, 96, 0.4), rgba(39, 174, 96, 0.3));
            border-color: #27AE60;
            box-shadow: 0 0 15px rgba(39, 174, 96, 0.5);
            cursor: pointer;
            opacity: 1;
        }
        
        #levelStoreBtn.unlocked:hover {
            background: linear-gradient(135deg, rgba(39, 174, 96, 0.6), rgba(39, 174, 96, 0.5));
            border-color: #2ECC71;
            box-shadow: 0 5px 20px rgba(39, 174, 96, 0.6);
            transform: translateY(-2px);
        }
        
        #levelStoreBtn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .portalButton {
            background: linear-gradient(135deg, rgba(139, 69, 255, 0.4), rgba(139, 69, 255, 0.3));
            border-color: #8B45FF;
        }
        
        .portalButton:hover {
            background: linear-gradient(135deg, rgba(139, 69, 255, 0.6), rgba(139, 69, 255, 0.5));
            border-color: #A45FFF;
            box-shadow: 0 5px 20px rgba(139, 69, 255, 0.5);
        }
        
        /* Left Column - Hero Stats (Title Screen) */
        #heroStats {
            position: absolute;
            left: 60px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(20, 27, 34, 0.8);
            border: 2px solid #26313B;
            border-radius: 12px;
            padding: 25px;
            width: 320px;
            pointer-events: all;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
        }
        
        /* Hero Cards in Corners (Dungeon Menu) */
        .dungeonHeroCard {
            position: absolute;
            background: linear-gradient(135deg, rgba(39, 174, 96, 0.1), rgba(39, 174, 96, 0.05));
            border: 1px solid #27AE60;
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            width: 160px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
        }
        
        #dungeonZooko { top: 20px; left: 20px; border-color: #EB5757; box-shadow: 0 0 15px rgba(235, 87, 87, 0.3); }
        #dungeonNate { bottom: 80px; left: 20px; border-color: #F2C94C; box-shadow: 0 0 15px rgba(242, 201, 76, 0.3); }
        #dungeonZancas { top: 20px; right: 20px; border-color: #27AE60; box-shadow: 0 0 15px rgba(39, 174, 96, 0.3); }
        #dungeonCyberAxe { bottom: 80px; right: 20px; border-color: #2E86DE; box-shadow: 0 0 15px rgba(46, 134, 222, 0.3); }
        
        /* Narrator Button */
        #narratorBtn {
            position: absolute;
            top: 20px;
            right: 180px;
            background: linear-gradient(135deg, rgba(139, 69, 255, 0.4), rgba(75, 0, 130, 0.4));
            border: 2px solid #8B45FF;
            border-radius: 10px;
            padding: 10px 15px;
            color: #F2C94C;
            font-family: 'Cinzel Decorative', serif;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
            box-shadow: 0 0 15px rgba(139, 69, 255, 0.3);
            z-index: 50;
        }
        #narratorBtn:hover {
            background: linear-gradient(135deg, rgba(139, 69, 255, 0.6), rgba(75, 0, 130, 0.6));
            box-shadow: 0 0 25px rgba(139, 69, 255, 0.5);
            transform: scale(1.05);
        }
        #narratorBtn.playing {
            background: linear-gradient(135deg, rgba(235, 87, 87, 0.4), rgba(150, 50, 50, 0.4));
            border-color: #EB5757;
            box-shadow: 0 0 20px rgba(235, 87, 87, 0.4);
        }
        #narratorBtn.loading {
            opacity: 0.7;
            cursor: wait;
        }
        #narratorBtn .narratorIcon {
            font-size: 18px;
        }
        
        .heroRow {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 12px;
        }
        
        .heroCard {
            background: linear-gradient(135deg, rgba(39, 174, 96, 0.1), rgba(39, 174, 96, 0.05));
            border: 1px solid #27AE60;
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            position: relative;
        }
        
        .heroPortrait {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            margin: 0 auto 8px auto;
            background-size: cover;
            background-position: center;
            border: 2px solid #27AE60;
            box-shadow: 0 0 10px rgba(39, 174, 96, 0.4);
        }
        
        .heroName {
            font-weight: 700;
            font-size: 14px;
            color: #F2C94C;
            margin-bottom: 8px;
        }
        
        .heroStat {
            font-size: 11px;
            color: #ffffff;
            margin: 2px 0;
            font-family: 'JetBrains Mono', monospace;
            font-weight: 700;
        }
        
        .heroSelectStats {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            font-family: 'JetBrains Mono', monospace;
            font-size: 16px;
            text-align: center;
        }
        
        .heroSelectStats .stat-row {
            display: block;
            margin: 4px 0;
            color: #BFD1E0;
        }
        
        .heroSelectStats .stat-label {
            color: #89A0B4;
        }
        
        .heroSelectStats .hp-row {
            color: #ff6b6b;
            font-weight: bold;
            font-size: 17px;
            display: inline;
        }
        
        .heroSelectStats .ac-row {
            color: #6bb3ff;
            font-weight: bold;
            font-size: 17px;
            display: inline;
            margin-left: 15px;
        }
        
        .heroSelectStats .hp-ac-row {
            margin: 4px 0;
        }
        
        .heroSelectStats .xp-row {
            color: #F2C94C;
            font-size: 17px;
        }
        
        .heroSelectCard {
            position: relative;
        }
        
        .heroSelectCard .heroTakenLabel {
            position: absolute;
            left: -5px;
            top: 55px;
            transform: translateY(-50%) rotate(-90deg);
            transform-origin: center center;
            font-size: 16px;
            font-weight: bold;
            letter-spacing: 2px;
            z-index: 10;
        }
        
        .heroSelectCard .heroPlayerLabel {
            position: absolute;
            right: -5px;
            top: 55px;
            transform: translateY(-50%) rotate(90deg);
            transform-origin: center center;
            font-size: 14px;
            font-weight: bold;
            white-space: nowrap;
            z-index: 10;
        }
        
        /* Dice Rolling System */
        .heroRollButton {
            display: none;
            margin-top: 8px;
            padding: 6px 12px;
            background: linear-gradient(135deg, rgba(242, 201, 76, 0.4), rgba(242, 201, 76, 0.2));
            border: 2px solid #F2C94C;
            border-radius: 6px;
            color: #F2C94C;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .heroRollButton:hover {
            background: linear-gradient(135deg, rgba(242, 201, 76, 0.6), rgba(242, 201, 76, 0.4));
            transform: scale(1.05);
        }
        
        .heroRollButton.visible {
            display: inline-block;
        }
        
        #diceRollModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 400;
            justify-content: center;
            align-items: center;
        }
        
        #diceRollModal.visible {
            display: flex;
        }
        
        .diceRollContainer {
            background: linear-gradient(135deg, #1a1f25, #0d1117);
            border: 3px solid #F2C94C;
            border-radius: 16px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            text-align: center;
        }
        
        .diceRollTitle {
            color: #F2C94C;
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 20px;
            font-family: 'Inter', sans-serif;
        }
        
        .diceStatRow {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }
        
        .diceStatName {
            color: #89A0B4;
            font-size: 16px;
            font-weight: bold;
            width: 50px;
            text-align: left;
        }
        
        .diceGroup {
            display: flex;
            gap: 8px;
        }
        
        .die {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #fff, #ddd);
            border: 2px solid #333;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            font-weight: bold;
            color: #111;
            font-family: 'JetBrains Mono', monospace;
            box-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .die.rolling {
            animation: diceRoll 0.1s infinite;
        }
        
        @keyframes diceRoll {
            0% { transform: rotate(0deg) scale(1); }
            25% { transform: rotate(10deg) scale(1.1); }
            50% { transform: rotate(0deg) scale(1); }
            75% { transform: rotate(-10deg) scale(1.1); }
            100% { transform: rotate(0deg) scale(1); }
        }
        
        .diceStatTotal {
            color: #F2C94C;
            font-size: 20px;
            font-weight: bold;
            width: 40px;
            text-align: right;
        }
        
        .diceRollActions {
            margin-top: 25px;
            display: flex;
            gap: 15px;
            justify-content: center;
        }
        
        .diceRollBtn {
            padding: 12px 30px;
            border-radius: 8px;
            font-family: 'Inter', sans-serif;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .diceRollBtn.roll {
            background: linear-gradient(135deg, rgba(242, 201, 76, 0.5), rgba(242, 201, 76, 0.3));
            border: 2px solid #F2C94C;
            color: #F2C94C;
        }
        
        .diceRollBtn.roll:hover {
            background: linear-gradient(135deg, rgba(242, 201, 76, 0.7), rgba(242, 201, 76, 0.5));
            transform: scale(1.05);
        }
        
        .diceRollBtn.accept {
            background: linear-gradient(135deg, rgba(39, 174, 96, 0.5), rgba(39, 174, 96, 0.3));
            border: 2px solid #27AE60;
            color: #27AE60;
        }
        
        .diceRollBtn.accept:hover {
            background: linear-gradient(135deg, rgba(39, 174, 96, 0.7), rgba(39, 174, 96, 0.5));
            transform: scale(1.05);
        }
        
        .diceRollBtn.cancel {
            background: linear-gradient(135deg, rgba(235, 87, 87, 0.5), rgba(235, 87, 87, 0.3));
            border: 2px solid #EB5757;
            color: #EB5757;
        }
        
        .diceRollBtn.cancel:hover {
            background: linear-gradient(135deg, rgba(235, 87, 87, 0.7), rgba(235, 87, 87, 0.5));
            transform: scale(1.05);
        }
        
        .derivedStats {
            margin-top: 15px;
            padding: 12px;
            background: rgba(242, 201, 76, 0.1);
            border: 1px solid rgba(242, 201, 76, 0.3);
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
        }
        
        .derivedStats span {
            font-size: 16px;
        }
        
        .derivedStats .hp-value {
            color: #ff6b6b;
            font-weight: bold;
        }
        
        .derivedStats .ac-value {
            color: #6bb3ff;
            font-weight: bold;
        }
        
        #versionDisplay {
            position: absolute;
            bottom: 20px;
            right: 20px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: #5A7A8F;
        }
        
        .comingSoon {
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            border-color: #EB5757;
            color: #EB5757;
        }
        
        .comingSoon:hover {
            background: linear-gradient(135deg, rgba(235, 87, 87, 0.2), rgba(235, 87, 87, 0.1));
            box-shadow: 0 6px 25px rgba(235, 87, 87, 0.4);
            transform: translateY(-2px);
            border-color: #FF6B6B;
        }
        
        /* Center Column - Level Display (at top of center buttons) */
        #dungeonLevelDisplay {
            text-align: center;
            padding: 15px;
            background: linear-gradient(135deg, rgba(139, 69, 255, 0.2), rgba(75, 0, 130, 0.2));
            border: 2px solid #8B45FF;
            border-radius: 10px;
            width: 380px;
            pointer-events: auto;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            margin-bottom: 20px;
            cursor: help;
        }
        
        #dungeonLevelDisplay:hover {
            border-color: #F2C94C;
            box-shadow: 0 0 20px rgba(242, 201, 76, 0.3);
        }
        
        .levelStatsGrid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 12px;
            text-align: left;
        }
        
        .levelStatItem {
            display: flex;
            justify-content: space-between;
            padding: 4px 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            font-size: 11px;
        }
        
        .levelStatLabel {
            color: #89A0B4;
        }
        
        .levelStatValue {
            color: #F2C94C;
            font-weight: bold;
            font-family: 'JetBrains Mono', monospace;
        }
        
        /* Music Ticker */
        #musicTicker {
            position: fixed;
            bottom: 10px;
            left: 10px;
            transform: translateX(0);
            background: rgba(42, 157, 143, 0.3);
            border: 2px solid #2A9D8F;
            border-radius: 8px;
            overflow: hidden;
            width: 400px;
            max-width: 25%;
            z-index: 500;
            pointer-events: auto;
            transition: left 0.3s ease, transform 0.3s ease;
        }
        
        /* Center ticker on dungeon menu */
        #musicTicker.dungeonMenuActive {
            left: 50%;
            transform: translateX(-50%);
        }
        
        /* Move ticker to bottom left during battle */
        #musicTicker.battleActive {
            left: 10px;
            transform: translateX(0);
        }
        
        #musicTickerWrapper {
            display: flex;
            width: fit-content;
            animation: scrollTicker 30s linear infinite;
        }
        
        #musicTicker:hover #musicTickerWrapper {
            animation-duration: 60s;
        }
        
        .tickerText {
            color: #F2C94C;
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            font-weight: 700;
            white-space: nowrap;
            padding-right: 100px;
        }
        
        @keyframes scrollTicker {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }
        
        /* Music Control Panel - Bottom of Screen Above Ticker */
        #musicControls {
            position: fixed;
            bottom: 65px;
            left: 10px;
            transform: translateX(0);
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            border: 2px solid #2A9D8F;
            border-radius: 8px;
            padding: 12px;
            min-width: 240px;
            max-width: 25%;
            pointer-events: auto;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8);
            z-index: 500;
            transition: left 0.3s ease, transform 0.3s ease;
        }
        
        /* Center controls on dungeon menu */
        #musicControls.dungeonMenuActive {
            left: 50%;
            transform: translateX(-50%);
        }
        
        /* Move controls to bottom left during battle or hero selection */
        #musicControls.battleActive,
        #musicControls.heroSelectionActive {
            left: 10px;
            transform: translateX(0);
        }
        
        .musicControlTitle {
            margin: 0 0 10px 0;
            color: #2A9D8F;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            text-align: center;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .musicButton {
            padding: 8px 16px;
            background: linear-gradient(135deg, rgba(42, 157, 143, 0.4), rgba(42, 157, 143, 0.3));
            border: 2px solid #2A9D8F;
            color: #F2C94C;
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            font-weight: bold;
            margin: 3px 0;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 6px;
            width: 100%;
            text-align: center;
        }
        
        .musicButton:hover {
            background: linear-gradient(135deg, rgba(42, 157, 143, 0.6), rgba(42, 157, 143, 0.5));
            border-color: #2ECC71;
        }
        
        .musicButton:active {
            transform: translateY(1px);
        }
        
        .volumeControl {
            margin: 10px 0 0 0;
        }
        
        .volumeLabel {
            color: #BFD1E0;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            display: block;
            margin-bottom: 4px;
        }
        
        .volumeSlider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(139, 69, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }
        
        .volumeSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #8B45FF;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(139, 69, 255, 0.5);
        }
        
        .volumeSlider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #8B45FF;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 5px rgba(139, 69, 255, 0.5);
        }
        
        #overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 14, 18, 0.9);
            z-index: 150;
            pointer-events: all;
        }
        
        #settingsPanel {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            border: 2px solid #2A9D8F;
            border-radius: 12px;
            padding: 25px;
            max-width: 450px;
            width: auto;
            z-index: 1100;
            pointer-events: all;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
        }
        
        .panelTitle {
            font-size: 28px;
            font-weight: 900;
            color: #2A9D8F;
            margin-bottom: 20px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .settingRow {
            margin: 20px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .settingLabel {
            font-size: 18px;
            color: #E9F0F7;
        }
        
        input[type="range"] {
            width: 200px;
        }
        
        /* Loading Screen Styles */
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }
        
        @keyframes slowBlink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        /* ===== HACKATHON INFO TOOLTIPS ===== */
        #infoTooltip {
            position: fixed;
            max-width: 380px;
            background: linear-gradient(135deg, rgba(15, 10, 35, 0.98), rgba(30, 20, 50, 0.98));
            border: 2px solid #F2C94C;
            border-radius: 12px;
            padding: 15px 18px;
            z-index: 99999;
            pointer-events: none;
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.3s ease, transform 0.3s ease;
            box-shadow: 0 8px 32px rgba(242, 201, 76, 0.3), 0 0 60px rgba(139, 69, 255, 0.2);
            backdrop-filter: blur(10px);
        }
        
        #infoTooltip.visible {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }
        
        #infoTooltip .tooltip-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(242, 201, 76, 0.3);
        }
        
        #infoTooltip .tooltip-icon {
            font-size: 24px;
        }
        
        #infoTooltip .tooltip-title {
            color: #F2C94C;
            font-size: 16px;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        #infoTooltip .tooltip-body {
            color: #E0E0E0;
            font-size: 13px;
            line-height: 1.6;
        }
        
        #infoTooltip .tooltip-tag {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 700;
            margin-right: 5px;
            margin-top: 8px;
            text-transform: uppercase;
        }
        
        #infoTooltip .tag-ai { background: rgba(139, 69, 255, 0.4); color: #D4BBFF; border: 1px solid #8B45FF; }
        #infoTooltip .tag-free { background: rgba(46, 204, 113, 0.4); color: #A8F0C8; border: 1px solid #2ECC71; }
        #infoTooltip .tag-paid { background: rgba(231, 76, 60, 0.4); color: #F5A8A0; border: 1px solid #E74C3C; }
        #infoTooltip .tag-local { background: rgba(52, 152, 219, 0.4); color: #A8D4F0; border: 1px solid #3498DB; }
        #infoTooltip .tag-zcash { background: rgba(242, 201, 76, 0.4); color: #FFF4C8; border: 1px solid #F2C94C; }
        #infoTooltip .tag-multiplayer { background: rgba(155, 89, 182, 0.4); color: #E0C8F0; border: 1px solid #9B59B6; }
        
        #infoTooltip .tooltip-footer {
            margin-top: 10px;
            padding-top: 8px;
            border-top: 1px solid rgba(242, 201, 76, 0.2);
            font-size: 10px;
            color: #89A0B4;
            font-style: italic;
        }
        
        /* Slideshow dots */
        #infoTooltip .tooltip-dots {
            display: flex;
            gap: 6px;
            margin-left: auto;
        }
        
        #infoTooltip .tooltip-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(242, 201, 76, 0.3);
            border: 1px solid rgba(242, 201, 76, 0.5);
            cursor: pointer;
            pointer-events: auto;
            transition: all 0.2s ease;
        }
        
        #infoTooltip .tooltip-dot:hover {
            background: rgba(242, 201, 76, 0.6);
            transform: scale(1.2);
        }
        
        #infoTooltip .tooltip-dot.active {
            background: #F2C94C;
            box-shadow: 0 0 8px rgba(242, 201, 76, 0.8);
        }
        
        [data-tooltip] {
            position: relative;
        }
        /* ===== END HACKATHON INFO TOOLTIPS ===== */
    </style>
</head>
<body>
    <!-- Hackathon Info Tooltip -->
    <div id="infoTooltip"></div>
    
    <!-- Loading Modal -->
    <div id="loadingModal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.95); display: flex; align-items: center; justify-content: center; z-index: 10000;">
        <div style="background: linear-gradient(135deg, #1a2332 0%, #0d1218 100%); padding: 40px 60px; border-radius: 15px; border: 2px solid #8B45FF; box-shadow: 0 10px 50px rgba(139, 69, 255, 0.5); text-align: center; min-width: 500px;">
            <div style="font-size: 48px; margin-bottom: 20px; animation: pulse 1.5s ease-in-out infinite;">ðŸ°</div>
            <div style="font-size: 24px; font-weight: bold; color: #8B45FF; margin-bottom: 10px;">TUNNELS OF PRIVACY</div>
            <div style="font-size: 14px; color: #F2C94C; margin-bottom: 15px; font-style: italic;">A Dungeon Crawler Adventure</div>
            <div id="loadingNote" style="font-size: 12px; color: #BFD1E0; margin-bottom: 20px; line-height: 1.5;">Loading assets... This may take a moment on first visit</div>
            
            <!-- Category breakdown -->
            <div style="margin-bottom: 15px; text-align: left; font-size: 13px; color: #BFD1E0;">
                <div id="loadingArt" style="margin-bottom: 5px;">ðŸŽ¨ Art: <span style="color: #8B45FF; font-weight: bold;">0/0</span></div>
                <div id="loadingSound" style="margin-bottom: 5px;">ðŸ”Š Sound: <span style="color: #8B45FF; font-weight: bold;">0/0</span></div>
            </div>
            
            <!-- Overall progress -->
            <div id="loadingIndicator" style="font-size: 18px; color: #2ECC71; margin-bottom: 20px; font-weight: bold;">0%</div>
            
            <div style="width: 100%; height: 30px; background: rgba(139, 69, 255, 0.2); border-radius: 15px; overflow: hidden; border: 1px solid #8B45FF;">
                <div id="loadingBar" style="height: 100%; width: 0%; background: linear-gradient(90deg, #8B45FF, #2ECC71); transition: width 0.3s ease; border-radius: 15px; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 14px;"></div>
            </div>
            
            <!-- Click to Play prompt (hidden until ready) -->
            <div id="clickToPlayPrompt" style="display: none; margin-top: 30px; font-size: 24px; color: #2ECC71; font-weight: bold; animation: slowBlink 2s ease-in-out infinite; cursor: pointer;">
                <div style="margin-bottom: 10px;">ðŸŽ® CLICK TO ENTER ðŸŽ®</div>
                <div style="font-size: 14px; color: #89A0B4;">
                    <span style="display: inline-block; padding: 5px 10px; background: rgba(52, 152, 219, 0.3); border-radius: 5px; margin-right: 5px;">MOUSE</span>
                    or
                    <span style="display: inline-block; padding: 5px 10px; background: rgba(46, 204, 113, 0.3); border-radius: 5px; margin-left: 5px;">ðŸŽ® A</span>
                </div>
            </div>
        </div>
    </div>
    
    <div id="gameContainer">
        <!-- Dungeon Menu Screen -->
        <div id="dungeonMenuScreen">
            <!-- Story Background Animation -->
            <div id="dungeonMenuBackground"></div>
            
            <!-- Narrator Button (Top Right) -->
            <button id="narratorBtn" onclick="toggleNarrator()" title="Listen to level narration">
                <span class="narratorIcon">ðŸŽ­</span>
                <span id="narratorBtnText">NARRATE</span>
            </button>
            
            <!-- Hero Cards in Corners -->
            <div class="dungeonHeroCard" id="dungeonZooko">
                <div class="heroPortrait" style="background-image: url('people/zooko_a_head_compressed.png'); border-color: #EB5757; box-shadow: 0 0 10px rgba(235, 87, 87, 0.4);"></div>
                <div class="heroName" style="color: #EB5757;">ZOOKO</div>
                <div class="heroStat" style="color: #ff6b6b; font-size: 12px; margin: 4px 0;">HP: <span id="dzooko-hp">0</span>/<span id="dzooko-maxhp">0</span></div>
                <div class="heroStat" style="color: #F2C94C; font-size: 11px; margin: 2px 0;">XP: <span id="dzooko-xp">0</span></div>
                <div class="heroStat">STR: <span id="dzooko-str">0</span>  INT: <span id="dzooko-int">0</span></div>
                <div class="heroStat">DEX: <span id="dzooko-dex">0</span>  WIS: <span id="dzooko-wis">0</span></div>
                <div class="heroStat">CON: <span id="dzooko-con">0</span>  CHA: <span id="dzooko-cha">0</span></div>
            </div>
            
            <div class="dungeonHeroCard" id="dungeonNate">
                <div class="heroPortrait" style="background-image: url('people/Nate_a_head_compressed.png'); border-color: #F2C94C; box-shadow: 0 0 10px rgba(242, 201, 76, 0.4);"></div>
                <div class="heroName" style="color: #F2C94C;">NATE</div>
                <div class="heroStat" style="color: #ff6b6b; font-size: 12px; margin: 4px 0;">HP: <span id="dnate-hp">0</span>/<span id="dnate-maxhp">0</span></div>
                <div class="heroStat" style="color: #F2C94C; font-size: 11px; margin: 2px 0;">XP: <span id="dnate-xp">0</span></div>
                <div class="heroStat">STR: <span id="dnate-str">0</span>  INT: <span id="dnate-int">0</span></div>
                <div class="heroStat">DEX: <span id="dnate-dex">0</span>  WIS: <span id="dnate-wis">0</span></div>
                <div class="heroStat">CON: <span id="dnate-con">0</span>  CHA: <span id="dnate-cha">0</span></div>
            </div>
            
            <div class="dungeonHeroCard" id="dungeonZancas">
                <div class="heroPortrait" style="background-image: url('people/Zancas_a_head_compressed.png'); border-color: #27AE60; box-shadow: 0 0 10px rgba(39, 174, 96, 0.4);"></div>
                <div class="heroName" style="color: #27AE60;">ZANCAS</div>
                <div class="heroStat" style="color: #ff6b6b; font-size: 12px; margin: 4px 0;">HP: <span id="dzancas-hp">0</span>/<span id="dzancas-maxhp">0</span></div>
                <div class="heroStat" style="color: #F2C94C; font-size: 11px; margin: 2px 0;">XP: <span id="dzancas-xp">0</span></div>
                <div class="heroStat">STR: <span id="dzancas-str">0</span>  INT: <span id="dzancas-int">0</span></div>
                <div class="heroStat">DEX: <span id="dzancas-dex">0</span>  WIS: <span id="dzancas-wis">0</span></div>
                <div class="heroStat">CON: <span id="dzancas-con">0</span>  CHA: <span id="dzancas-cha">0</span></div>
            </div>
            
            <div class="dungeonHeroCard" id="dungeonCyberAxe">
                <div class="heroPortrait" style="background-image: url('people/cyberaxe_a_head_compressed.png'); border-color: #2E86DE; box-shadow: 0 0 10px rgba(46, 134, 222, 0.4);"></div>
                <div class="heroName" style="color: #2E86DE;">CYBERAXE</div>
                <div class="heroStat" style="color: #ff6b6b; font-size: 12px; margin: 4px 0;">HP: <span id="dcyberaxe-hp">0</span>/<span id="dcyberaxe-maxhp">0</span></div>
                <div class="heroStat" style="color: #F2C94C; font-size: 11px; margin: 2px 0;">XP: <span id="dcyberaxe-xp">0</span></div>
                <div class="heroStat">STR: <span id="dcyberaxe-str">0</span>  INT: <span id="dcyberaxe-int">0</span></div>
                <div class="heroStat">DEX: <span id="dcyberaxe-dex">0</span>  WIS: <span id="dcyberaxe-wis">0</span></div>
                <div class="heroStat">CON: <span id="dcyberaxe-con">0</span>  CHA: <span id="dcyberaxe-cha">0</span></div>
            </div>
            
            <!-- Center Menu -->
            <div style="position: absolute; top: 42%; left: 50%; transform: translate(-50%, -50%); display: flex; flex-direction: column; align-items: center; gap: 12px;">
                <div style="text-align: center; padding: 15px; background: linear-gradient(135deg, rgba(139, 69, 255, 0.2), rgba(75, 0, 130, 0.2)); border: 2px solid #8B45FF; border-radius: 10px; width: 380px; backdrop-filter: blur(10px); box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4); margin-bottom: 10px;">
                    <div style="color: #BFD1E0; font-size: 14px; margin-bottom: 5px;">Dungeon Menu</div>
                    <div style="color: #F2C94C; font-size: 28px; font-weight: 900; text-shadow: 0 0 20px rgba(242, 201, 76, 0.5);">LEVEL <span id="dungeonMenuLevel">1</span></div>
                    <div style="color: #FFD700; font-size: 16px; font-weight: 700; margin-top: 5px;">ðŸ’° <span id="dungeonMenuGold">0</span> Gold</div>
                    <div class="levelStatsGrid" style="margin-top: 10px;">
                        <div class="levelStatItem">
                            <span class="levelStatLabel">Rooms</span>
                            <span class="levelStatValue"><span id="dmRoomsExplored">0</span>/<span id="dmRoomsMax">?</span></span>
                        </div>
                        <div class="levelStatItem">
                            <span class="levelStatLabel">Boss</span>
                            <span class="levelStatValue"><span id="dmBossDefeated">0</span>/1</span>
                        </div>
                        <div class="levelStatItem">
                            <span class="levelStatLabel">Store</span>
                            <span class="levelStatValue"><span id="dmStoreVisited">0</span>/1</span>
                        </div>
                        <div class="levelStatItem">
                            <span class="levelStatLabel">Captives</span>
                            <span class="levelStatValue" id="dmCaptivesFreed">0</span>
                        </div>
                    </div>
                    <div style="margin-top: 8px; font-size: 10px; color: #89A0B4; border-top: 1px solid rgba(139, 69, 255, 0.3); padding-top: 6px;">
                        <span style="color: #8B45FF;">ðŸ‘¹</span> Bosses Defeated: <span id="dmTotalBossesDefeated" style="color: #F2C94C; font-weight: bold;">0</span>
                    </div>
                </div>
                
                <!-- Next Room Preview -->
                <div id="nextRoomPreview" style="background: rgba(0,0,0,0.4); border: 2px solid rgba(139, 69, 255, 0.5); border-radius: 10px; padding: 10px; margin-bottom: 15px; text-align: center;">
                    <div style="font-size: 10px; color: #89A0B4; margin-bottom: 4px; text-transform: uppercase; letter-spacing: 1px;">Next Room</div>
                    <div id="nextRoomType" style="font-size: 16px; font-weight: bold; color: #F2C94C;">âš”ï¸ Combat</div>
                </div>
                
                <button class="menuButton" id="exploreLevelBtn" onclick="startBattle()">
                    <div class="loadingBar" id="exploreLoadingBar"></div>
                    <span class="btnText">EXPLORE LEVEL</span>
                </button>
                <button class="menuButton" id="levelStoreBtn" onclick="enterLevelStore()" disabled>
                    <span id="levelStoreBtnText">ENTER LEVEL STORE<br><span style="font-size: 12px; font-weight: 400;">(Not Found)</span></span>
                </button>
                <button class="menuButton">INVENTORY</button>
                <button class="menuButton" id="campBtn" onclick="openCampPanel()">ðŸ•ï¸ CAMP</button>
                <button class="menuButton" id="dungeonMastersBtn" onclick="toggleDungeonMasters()" style="background: linear-gradient(135deg, rgba(139, 69, 255, 0.4), rgba(75, 0, 130, 0.4));">ðŸŽ² DUNGEON MASTERS</button>
            </div>
            
            <!-- Camp Panel (Right Side) -->
            <div id="campPanel" style="display: none; position: absolute; top: 50%; right: 20px; transform: translateY(-50%); background: linear-gradient(135deg, rgba(20, 10, 40, 0.95), rgba(40, 20, 60, 0.95)); border: 3px solid #27AE60; border-radius: 15px; padding: 20px; backdrop-filter: blur(15px); box-shadow: 0 0 30px rgba(39, 174, 96, 0.4), inset 0 0 20px rgba(39, 174, 96, 0.1); min-width: 320px; z-index: 100;">
                <div style="text-align: center; margin-bottom: 15px;">
                    <div style="color: #27AE60; font-size: 20px; font-weight: 900; text-shadow: 0 0 15px rgba(39, 174, 96, 0.5);">ðŸ•ï¸ CAMP</div>
                    <button onclick="closeCampPanel()" style="position: absolute; top: 10px; right: 10px; background: rgba(255,100,100,0.3); border: 2px solid #ff6b6b; border-radius: 50%; width: 28px; height: 28px; color: #ff6b6b; font-size: 16px; cursor: pointer; font-weight: bold;">âœ•</button>
                </div>
                
                <!-- Rest Duration Selection -->
                <div style="text-align: center; margin-bottom: 15px;">
                    <div style="color: #BFD1E0; font-size: 14px; font-weight: 700; margin-bottom: 8px;">REST DURATION</div>
                    <div style="display: flex; gap: 8px; justify-content: center; align-items: center; flex-wrap: wrap;">
                        <button class="campDurationBtn" onclick="setCampDuration(1)" data-hours="1" style="padding: 8px 12px; background: rgba(39, 174, 96, 0.3); border: 2px solid #27AE60; border-radius: 8px; color: #27AE60; font-weight: bold; cursor: pointer;">1 Hr</button>
                        <button class="campDurationBtn" onclick="setCampDuration(2)" data-hours="2" style="padding: 8px 12px; background: rgba(39, 174, 96, 0.3); border: 2px solid #27AE60; border-radius: 8px; color: #27AE60; font-weight: bold; cursor: pointer;">2 Hrs</button>
                        <button class="campDurationBtn" onclick="setCampDuration(4)" data-hours="4" style="padding: 8px 12px; background: rgba(39, 174, 96, 0.3); border: 2px solid #27AE60; border-radius: 8px; color: #27AE60; font-weight: bold; cursor: pointer;">4 Hrs</button>
                        <button class="campDurationBtn active" onclick="setCampDuration(8)" data-hours="8" style="padding: 8px 12px; background: rgba(39, 174, 96, 0.6); border: 2px solid #27AE60; border-radius: 8px; color: white; font-weight: bold; cursor: pointer;">8 Hrs</button>
                    </div>
                </div>
                
                <!-- Health Regen Preview -->
                <div style="background: rgba(0,0,0,0.3); border-radius: 10px; padding: 12px; margin-bottom: 15px;">
                    <div style="color: #F2C94C; font-size: 14px; font-weight: 700; text-align: center; margin-bottom: 8px;">â¤ï¸ HEALTH RESTORED</div>
                    <div style="display: flex; justify-content: space-around; font-size: 12px;">
                        <div style="text-align: center;">
                            <div style="color: #E74C3C; font-weight: bold;" id="campHealZooko">+16 HP</div>
                            <div style="color: #89A0B4;">Zooko</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="color: #E74C3C; font-weight: bold;" id="campHealNate">+16 HP</div>
                            <div style="color: #89A0B4;">Nate</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="color: #E74C3C; font-weight: bold;" id="campHealZancas">+16 HP</div>
                            <div style="color: #89A0B4;">Zancas</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="color: #E74C3C; font-weight: bold;" id="campHealCyberAxe">+16 HP</div>
                            <div style="color: #89A0B4;">CyberAxe</div>
                        </div>
                    </div>
                    <div style="text-align: center; margin-top: 8px; font-size: 11px; color: #27AE60;">
                        Base Regen: 2 HP per hour
                    </div>
                </div>
                
                <!-- Warning Note -->
                <div style="background: rgba(242, 201, 76, 0.15); border: 1px solid rgba(242, 201, 76, 0.4); border-radius: 8px; padding: 10px; margin-bottom: 15px;">
                    <div style="color: #F2C94C; font-size: 11px; text-align: center;">
                        âš ï¸ <strong>Warning:</strong> Longer rest periods have higher odds of encounters - good or bad!
                    </div>
                </div>
                
                <!-- Camp Button -->
                <button id="startCampBtn" class="menuButton" onclick="startCamping()" style="width: 100%; padding: 12px; font-size: 16px; background: linear-gradient(135deg, rgba(39, 174, 96, 0.5), rgba(39, 174, 96, 0.3));">
                    ðŸ”¥ MAKE CAMP
                </button>
            </div>
            
            <!-- Dungeon Masters Panel (Right Side) -->
            <div id="dungeonMastersPanel" style="display: none; position: absolute; top: 50%; right: 20px; transform: translateY(-50%); background: linear-gradient(135deg, rgba(20, 10, 40, 0.95), rgba(40, 20, 60, 0.95)); border: 3px solid #8B45FF; border-radius: 15px; padding: 20px; backdrop-filter: blur(15px); box-shadow: 0 0 30px rgba(139, 69, 255, 0.4), inset 0 0 20px rgba(139, 69, 255, 0.1); min-width: 280px;">
                <div style="text-align: center; margin-bottom: 15px;">
                    <div style="color: #F2C94C; font-size: 18px; font-weight: 900; text-shadow: 0 0 15px rgba(242, 201, 76, 0.5);">ðŸŽ² DUNGEON MASTERS</div>
                    <button onclick="toggleDungeonMasters()" style="position: absolute; top: 10px; right: 10px; background: rgba(255,100,100,0.3); border: 2px solid #ff6b6b; border-radius: 50%; width: 28px; height: 28px; color: #ff6b6b; font-size: 16px; cursor: pointer; font-weight: bold;">âœ•</button>
                </div>
                
                <!-- Stairs Section -->
                <div style="text-align: center; margin-bottom: 15px;">
                    <div style="color: #BFD1E0; font-size: 14px; font-weight: 700; margin-bottom: 8px; text-shadow: 0 0 10px rgba(139, 69, 255, 0.5);">STAIRS</div>
                    <div style="display: flex; gap: 10px; justify-content: center;">
                        <button id="stairsUpBtn" class="menuButton" onclick="changeLevel(-1)" style="width: 110px; padding: 10px 12px; font-size: 13px;">â¬†ï¸ UP</button>
                        <button id="stairsDownBtn" class="menuButton" onclick="changeLevel(1)" style="width: 110px; padding: 10px 12px; font-size: 13px;">â¬‡ï¸ DOWN</button>
                    </div>
                </div>
                
                <!-- Fast Travel -->
                <div style="text-align: center; margin-bottom: 15px;">
                    <div style="color: #BFD1E0; font-size: 14px; font-weight: 700; margin-bottom: 8px; text-shadow: 0 0 10px rgba(139, 69, 255, 0.5);">FAST TRAVEL</div>
                    <div style="display: flex; gap: 8px; justify-content: center; align-items: center;">
                        <input type="number" id="fastTravelLevel" min="1" value="1" style="width: 60px; padding: 8px; font-size: 14px; text-align: center; background: rgba(0,0,0,0.5); border: 2px solid #8B45FF; border-radius: 5px; color: #F2C94C; font-family: 'JetBrains Mono', monospace;">
                        <button id="fastTravelBtn" class="menuButton" onclick="fastTravel()" style="width: 100px; padding: 10px 12px; font-size: 13px;">ðŸš€ GO</button>
                    </div>
                </div>
                
                <!-- Difficulty Section -->
                <div style="text-align: center;">
                    <div style="color: #BFD1E0; font-size: 14px; font-weight: 700; margin-bottom: 8px; text-shadow: 0 0 10px rgba(139, 69, 255, 0.5);">DIFFICULTY</div>
                    <div style="display: flex; flex-direction: column; gap: 8px; align-items: center;">
                        <button id="diffCasualBtn" class="menuButton" onclick="setDifficulty('casual')" style="width: 200px; padding: 8px 10px; font-size: 12px;">ðŸŒ¼ CASUAL</button>
                        <button id="diffNormalBtn" class="menuButton" onclick="setDifficulty('normal')" style="width: 200px; padding: 8px 10px; font-size: 12px;">âš”ï¸ NORMAL</button>
                        <button id="diffExpertBtn" class="menuButton" onclick="setDifficulty('expert')" style="width: 200px; padding: 8px 10px; font-size: 12px;">ðŸ’€ EXPERT</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Camping Screen -->
        <div id="campingScreen" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 500; background: #000;">
            <!-- Video Background -->
            <video id="campVideo" loop playsinline style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: 1;">
                <source src="" type="video/mp4">
            </video>
            
            <!-- Dark Overlay -->
            <div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.4); z-index: 2;"></div>
            
            <!-- Camp UI Overlay -->
            <div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 3; display: flex; flex-direction: column; align-items: center; justify-content: center;">
                <!-- Camp Title -->
                <div style="color: #F2C94C; font-size: 36px; font-weight: 900; text-shadow: 0 0 30px rgba(242, 201, 76, 0.8), 2px 2px 4px rgba(0,0,0,0.8); margin-bottom: 20px;">
                    ðŸ•ï¸ RESTING AT CAMP
                </div>
                
                <!-- Progress Info -->
                <div style="background: rgba(0,0,0,0.7); border: 2px solid #27AE60; border-radius: 15px; padding: 30px 50px; text-align: center; backdrop-filter: blur(10px);">
                    <div style="color: #27AE60; font-size: 24px; font-weight: bold; margin-bottom: 15px;">
                        <span id="campTimeRemaining">8</span> Hours Remaining
                    </div>
                    
                    <!-- Progress Bar -->
                    <div style="width: 300px; height: 20px; background: rgba(0,0,0,0.5); border-radius: 10px; overflow: hidden; margin-bottom: 20px;">
                        <div id="campProgressBar" style="width: 0%; height: 100%; background: linear-gradient(90deg, #27AE60, #2ECC71); transition: width 0.5s ease;"></div>
                    </div>
                    
                    <!-- Health Regen Status -->
                    <div style="color: #E74C3C; font-size: 18px; margin-bottom: 15px;">
                        â¤ï¸ +<span id="campHealedSoFar">0</span> HP Restored
                    </div>
                    
                    <!-- Cancel Button -->
                    <button onclick="cancelCamping()" style="padding: 12px 30px; background: rgba(231, 76, 60, 0.3); border: 2px solid #E74C3C; border-radius: 8px; color: #E74C3C; font-size: 14px; font-weight: bold; cursor: pointer;">
                        âŒ BREAK CAMP EARLY
                    </button>
                </div>
                
                <!-- Event Log -->
                <div id="campEventLog" style="margin-top: 20px; max-width: 500px; max-height: 150px; overflow-y: auto; background: rgba(0,0,0,0.6); border-radius: 10px; padding: 15px;">
                    <div style="color: #89A0B4; font-size: 12px; text-align: center;">The campfire crackles softly...</div>
                </div>
            </div>
        </div>
        
        <!-- Battle Screen -->
        <div id="battleScreen">
            <!-- Video Background (behind canvas) -->
            <video id="battleBackgroundVideo" loop muted playsinline style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: 0; display: none;">
                <source src="" type="video/mp4">
            </video>
            <canvas id="battleCanvas"></canvas>
            
            <!-- Battle Notification Banner -->
            <div id="battleNotification">ROOM CLEARED!</div>
            
            <!-- Gold Display (Top Center) -->
            <div id="battleGoldDisplay" style="position: absolute; top: 10px; left: 50%; transform: translateX(-50%); background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(30, 30, 30, 0.8)); border: 2px solid #FFD700; border-radius: 8px; padding: 8px 20px; z-index: 100; display: flex; align-items: center; gap: 8px;">
                <span style="font-size: 20px;">ðŸ’°</span>
                <span id="battleGold" style="color: #FFD700; font-size: 18px; font-weight: 700; font-family: 'JetBrains Mono', monospace;">0</span>
            </div>
            
            <!-- Enemy Cards (Left Side) -->
            <div id="battleEnemyCards">
                <!-- Populated dynamically by updateBattleEnemyCards() -->
            </div>
            
            <div id="battleUI">
                <!-- Left Hero Cards: Zooko & Nate -->
                <div id="battleUILeft">
                    <div class="battleHeroCard" id="battleCardZooko">
                        <div class="battleHeroPortrait" style="background-image: url('people/zooko_a_head_compressed.png'); border-color: #F2C94C;"></div>
                        <div class="battleHeroName" style="color: #F2C94C;">ZOOKO</div>
                        <div class="battleHeroStat" style="color: #ff6b6b;">HP: <span id="bzooko-hp">30</span>/<span id="bzooko-maxhp">30</span></div>
                        <div class="battleHeroStat">AC: <span id="bzooko-ac">12</span></div>
                        <div class="battleHeroStat" style="color: #FFD700;">XP: <span id="bzooko-xp">0</span></div>
                        <div class="battleHeroStat" style="color: #ff1744; font-size: 14px;" id="bzooko-heals">â¤ï¸ â¤ï¸</div>
                    </div>
                    <div class="battleHeroCard" id="battleCardNate">
                        <div class="battleHeroPortrait" style="background-image: url('people/Nate_a_head_compressed.png'); border-color: #E74C3C;"></div>
                        <div class="battleHeroName" style="color: #E74C3C;">NATE</div>
                        <div class="battleHeroStat" style="color: #ff6b6b;">HP: <span id="bnate-hp">28</span>/<span id="bnate-maxhp">30</span></div>
                        <div class="battleHeroStat">AC: <span id="bnate-ac">14</span></div>
                        <div class="battleHeroStat" style="color: #FFD700;">XP: <span id="bnate-xp">0</span></div>
                        <div class="battleHeroStat" style="color: #ff1744; font-size: 14px;" id="bnate-heals">â¤ï¸ â¤ï¸</div>
                    </div>
                </div>
                
                <!-- Center Action Bar -->
                <div id="battleUICenter">
                    <div id="battleTurnInfo">ZOOKO'S TURN</div>
                    <div id="multiplayerStatus" style="display: none; background: rgba(42, 157, 143, 0.3); border: 2px solid #2A9D8F; border-radius: 5px; padding: 5px 10px; font-size: 11px; color: #2A9D8F; margin-bottom: 8px; text-align: center;">
                        ðŸŽ® <span id="mpStatusText">Multiplayer</span>
                    </div>
                    <div id="diceRollDisplay" style="display: block; background: linear-gradient(135deg, rgba(0,0,0,0.95), rgba(20,20,40,0.95)); color: #E0E0E0; padding: 12px 20px; border-radius: 12px; font-size: 14px; font-weight: bold; text-align: center; margin-bottom: 10px; border: 2px solid #7A8B9C; width: 500px; box-shadow: 0 0 20px rgba(122, 139, 156, 0.2), inset 0 0 20px rgba(122, 139, 156, 0.05); text-shadow: 0 0 10px rgba(224, 224, 224, 0.5), 0 0 20px rgba(224, 224, 224, 0.2); letter-spacing: 1px;">â³ Waiting to Roll...</div>
                    <div id="battleActions">
                        <button class="battleButton attack-weak" onclick="battleAction('light')">âš” LIGHT</button>
                        <button class="battleButton attack-strong" id="battleHeavyBtn" onclick="battleAction('heavy')">âš¡ HEAVY</button>
                        <button class="battleButton special" id="battleSpecialBtn" onclick="battleAction('special')">âœ¨ SPECIAL</button>
                        <button class="battleButton defend" onclick="battleAction('defend')">ðŸ›¡ DEFEND</button>
                        <button class="battleButton swap" onclick="battleAction('swap')">ðŸ”„ SWAP</button>
                        <button class="battleButton taunt" onclick="battleAction('taunt')">ðŸ—£ TAUNT</button>
                        <button class="battleButton heal" onclick="battleAction('heal')">ðŸ’š HEAL</button>
                        <button class="battleButton" id="battleSkipBtn" onclick="battleAction('skip')">â­ SKIP</button>
                        <button class="battleButton" id="battleTalkBtn" onclick="battleAction('talk')">ðŸ’¬ TALK</button>
                        <button class="battleButton retreat" onclick="battleAction('retreat')">ðŸƒ RETREAT</button>
                    </div>
                </div>
                
                <!-- Right Hero Cards: Zancas & CyberAxe -->
                <div id="battleUIRight">
                    <div class="battleHeroCard" id="battleCardZancas">
                        <div class="battleHeroPortrait" style="background-image: url('people/Zancas_a_head_compressed.png'); border-color: #27AE60;"></div>
                        <div class="battleHeroName" style="color: #27AE60;">ZANCAS</div>
                        <div class="battleHeroStat" style="color: #ff6b6b;">HP: <span id="bzancas-hp">24</span>/<span id="bzancas-maxhp">26</span></div>
                        <div class="battleHeroStat">AC: <span id="bzancas-ac">15</span></div>
                        <div class="battleHeroStat" style="color: #FFD700;">XP: <span id="bzancas-xp">0</span></div>
                        <div class="battleHeroStat" style="color: #ff1744; font-size: 14px;" id="bzancas-heals">â¤ï¸ â¤ï¸</div>
                    </div>
                    <div class="battleHeroCard" id="battleCardCyberAxe">
                        <div class="battleHeroPortrait" style="background-image: url('people/cyberaxe_a_head_compressed.png'); border-color: #2E86DE;"></div>
                        <div class="battleHeroName" style="color: #2E86DE;">CYBERAXE</div>
                        <div class="battleHeroStat" style="color: #ff6b6b;">HP: <span id="bcyberaxe-hp">32</span>/<span id="bcyberaxe-maxhp">35</span></div>
                        <div class="battleHeroStat">AC: <span id="bcyberaxe-ac">15</span></div>
                        <div class="battleHeroStat" style="color: #FFD700;">XP: <span id="bcyberaxe-xp">0</span></div>
                        <div class="battleHeroStat" style="color: #ff1744; font-size: 14px;" id="bcyberaxe-heals">â¤ï¸ â¤ï¸</div>
                    </div>
                    </div>
                </div>
            </div>
            
            <!-- Chat Window -->
            <div id="battleChatWindow">
                <div id="chatHeader">
                    <span>ðŸ’¬ Battle Chat</span>
                    <span id="chatStatus" style="font-size: 11px; color: #aaa;"></span>
                    <label id="ttsToggleLabel" title="Enable text-to-speech for NPC responses">
                        <input type="checkbox" id="ttsToggle" checked onchange="toggleTTS()">
                        <span style="font-size: 11px;">ðŸ”Š</span>
                    </label>
                    <button id="chatExpandBtn" onclick="toggleChatExpand()" title="Expand/Shrink">â‡•</button>
                    <button id="chatCloseBtn" onclick="toggleChatWindow()">âœ•</button>
                </div>
                <div id="chatModelSelector">
                    <span style="font-size: 10px; color: #888; margin-right: 4px;">Free:</span>
                    <button class="modelBtn active" onclick="selectChatModel(2)" title="Groq Llama 3.1 8B (FREE)">2</button>
                    <button class="modelBtn" onclick="selectChatModel(4)" title="Groq Gemma 2 9B (FREE)">4</button>
                    <button class="modelBtn" onclick="selectChatModel(5)" title="Groq Mixtral 8x7B (FREE)">5</button>
                    <span style="font-size: 10px; color: #F39C12; margin-left: 6px; margin-right: 4px;">Paid:</span>
                    <button class="modelBtn" onclick="selectChatModel(1)" title="OpenRouter Mistral Nemo ($)" style="border-color: #F39C12;">1</button>
                    <button class="modelBtn" onclick="selectChatModel(3)" title="Groq Llama 3.3 70B ($)" style="border-color: #F39C12;">3</button>
                    <button class="modelBtn" onclick="selectChatModel(6)" title="OpenRouter Llama 3.1 8B ($)" style="border-color: #F39C12;">6</button>
                    <button class="modelBtn" onclick="selectChatModel(7)" title="OpenRouter Gemma 2 9B ($)" style="border-color: #F39C12;">7</button>
                    <button class="modelBtn" onclick="selectChatModel(8)" title="OpenRouter Qwen 2.5 7B ($)" style="border-color: #F39C12;">8</button>
                    <button class="modelBtn" onclick="selectChatModel(9)" title="OpenRouter L3 Lunaris 8B ($)" style="border-color: #F39C12;">9</button>
                    <span id="chatCostDisplay" style="margin-left: 8px; font-size: 11px; color: #4CAF50;">$0.000000 | 0 tok</span>
                </div>
                <div id="chatMessages"></div>
                <div id="chatInputArea">
                    <div id="chatTargetSelector">
                        <button class="chatTargetBtn broadcast active" onclick="selectChatTarget(null)" title="Speak to everyone">ðŸ“¢ ALL</button>
                        <!-- Entity buttons populated dynamically -->
                    </div>
                    <div id="chatInputRow">
                        <input type="text" id="chatInput" placeholder="Say something..." onkeypress="if(event.key==='Enter')sendChatMessage()">
                        <button id="chatSendBtn" onclick="sendChatMessage()">Send</button>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="titleScreen">
            <!-- Story Intro Background Animation -->
            <div id="storyIntroBackground" data-tooltip-id="titleBackground"></div>
            
            <div id="title">TUNNELS OF PRIVACY</div>
            <div id="subtitle">A Dungeon Crawler Adventure</div>
            
            <!-- Center Column - Menu Buttons, Music Controls -->
            <div id="menuButtonsCenter">
                <button id="startAdventureBtn" class="menuButton" onclick="startAdventure()">START ADVENTURE<span style="display: inline-block; width: 26px; height: 26px; background: #27AE60; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">A</span></button>
                <button id="continueBtn" class="menuButton comingSoon" disabled onclick="continueGame()">CONTINUE<span style="display: inline-block; width: 26px; height: 26px; background: #EB5757; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">A</span></button>
                <button class="menuButton" onclick="showLoadSave()">LOAD SAVE FILE<span style="display: inline-block; width: 26px; height: 26px; background: #3498DB; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">B</span></button>
                <button class="menuButton" onclick="showSettings()">SETTINGS<span style="display: inline-block; width: 26px; height: 26px; background: #2A9D8F; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">Y</span></button>
                <button id="enterArcadeBtn" class="menuButton portalButton" onclick="exitPortal()">
                    <div style="display: flex; align-items: center; justify-content: space-between; width: 100%;">
                        <div style="text-align: left;">
                            <div style="font-size: 18px; font-weight: 700;">ENTER ARCADE</div>
                            <div style="font-size: 10px; font-weight: 400; margin-top: 2px;">(ZLOCK ZHAINER)</div>
                        </div>
                        <span style="display: inline-block; padding: 4px 10px; background: #8B45FF; border-radius: 5px; font-weight: bold; color: white; font-size: 12px;">BACK</span>
                    </div>
                </button>
            </div>
            
            <div id="versionDisplay">Tunnels of Privacy v0.3.43 â€¢ Portal System Active</div>
            
            <!-- About/Donate Button (Bottom Right) -->
            <div id="aboutDonateBtn" style="
                position: absolute;
                bottom: 20px;
                right: 20px;
                width: 200px;
                background: rgba(10, 14, 18, 0.8);
                border: 2px solid #2D9CDB;
                border-radius: 10px;
                padding: 12px;
                backdrop-filter: blur(10px);
                cursor: pointer;
                transition: all 0.3s ease;
                text-align: center;
                pointer-events: all;
                z-index: 100;
            " onclick="showAbout()" onmouseenter="this.style.borderColor='#F2C94C'; this.style.boxShadow='0 0 15px rgba(242, 201, 76, 0.4)';" onmouseleave="this.style.borderColor='#2D9CDB'; this.style.boxShadow='none';">
                <div style="font-size: 14px; font-weight: 700; color: #F2C94C; margin-bottom: 3px;">ABOUT / DONATE</div>
                <div style="font-size: 11px; color: #89A0B4;">Support Development</div>
            </div>
            
            <!-- Multiplayer Controls (Top Left) -->
            <div style="position: absolute; top: 20px; left: 20px; display: flex; flex-direction: column; gap: 10px; align-items: flex-start; pointer-events: all; z-index: 100;">
                <!-- Create Room Button -->
                <button class="menuButton" onclick="createMultiplayerRoom()" style="padding: 10px 20px; font-size: 14px; margin: 0; pointer-events: all; background: linear-gradient(135deg, rgba(42, 157, 143, 0.4), rgba(42, 157, 143, 0.3)); border-color: #2A9D8F; white-space: nowrap; width: 250px;">ðŸŽ® CREATE ROOM</button>
                
                <!-- Room Code Input and Join Button -->
                <div style="display: flex; gap: 10px; align-items: stretch;">
                    <input type="text" id="titleJoinCode" placeholder="CODE" maxlength="6" onkeypress="if(event.key==='Enter') quickJoinRoom()" style="width: 90px; padding: 10px; background: rgba(0,0,0,0.7); border: 2px solid #2A9D8F; border-radius: 5px; color: #F2C94C; font-size: 14px; text-align: center; letter-spacing: 2px; font-family: 'JetBrains Mono', monospace; text-transform: uppercase; pointer-events: all;">
                    <button class="menuButton" onclick="quickJoinRoom()" style="padding: 10px 15px; font-size: 14px; margin: 0; pointer-events: all; white-space: nowrap; width: 150px;">JOIN</button>
                </div>
                
                <!-- Player Name Input -->
                <div style="display: flex; flex-direction: column; gap: 5px; align-items: flex-start;">
                    <input type="text" id="multiplayerPlayerName" placeholder="Enter your Player Name" maxlength="20" style="width: 250px; padding: 10px; background: rgba(0,0,0,0.7); border: 2px solid #2A9D8F; border-radius: 5px; color: #E9F0F7; font-size: 14px; font-family: 'Inter', sans-serif; pointer-events: all;">
                    <div style="color: #F2C94C; font-size: 10px; font-style: italic; margin-top: -2px;">Changing will Reset Join in Progress</div>
                </div>
            </div>
        </div>
        
        <!-- Network Debug Panel -->
        <div id="networkDebugPanel" style="display: none; position: fixed; top: 10px; right: 10px; width: 400px; max-height: 500px; overflow-y: auto; background: rgba(10, 14, 18, 0.95); border: 2px solid #2A9D8F; border-radius: 8px; padding: 15px; z-index: 150; font-family: 'JetBrains Mono', monospace; font-size: 11px;">
            <div style="font-size: 14px; font-weight: bold; color: #2A9D8F; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center;">
                <span>ðŸŒ NETWORK DEBUG</span>
                <button onclick="toggleNetworkDebug()" style="background: #EB5757; border: none; border-radius: 3px; color: white; padding: 3px 8px; cursor: pointer; font-size: 10px;">âœ•</button>
            </div>
            
            <div style="margin-bottom: 10px; padding: 8px; background: rgba(0,0,0,0.5); border-radius: 5px;">
                <div style="color: #89A0B4; margin-bottom: 5px;">Connection Status:</div>
                <div id="debugConnStatus" style="color: #F2C94C; font-weight: bold;">Disconnected</div>
            </div>
            
            <div style="margin-bottom: 10px; padding: 8px; background: rgba(0,0,0,0.5); border-radius: 5px;">
                <div style="color: #89A0B4; margin-bottom: 5px;">Room State:</div>
                <div id="debugRoomState" style="color: #2A9D8F;">No room</div>
            </div>
            
            <div style="margin-bottom: 10px;">
                <div style="color: #89A0B4; margin-bottom: 5px; display: flex; justify-content: space-between;">
                    <span>Message Log (Last 20):</span>
                    <button onclick="clearDebugLog()" style="background: #E74C3C; border: none; border-radius: 3px; color: white; padding: 2px 6px; cursor: pointer; font-size: 9px;">CLEAR</button>
                </div>
                <div id="debugMessageLog" style="max-height: 300px; overflow-y: auto; background: rgba(0,0,0,0.7); border: 1px solid #2A9D8F; border-radius: 5px; padding: 8px;"></div>
            </div>
        </div>
        
        <!-- Music Control Panel - Bottom Above Ticker (OUTSIDE titleScreen so always visible) -->
        <div id="musicControls">
            <h3 class="musicControlTitle">ðŸŽµ Music Controls</h3>
            
            <!-- Playback Controls -->
            <div style="display: flex; gap: 6px; justify-content: center; margin-bottom: 12px;">
                <button onclick="musicPrevious()" class="musicButton" style="padding: 8px 12px; width: auto;">â®</button>
                <button id="musicPlayPauseBtn" onclick="musicPlayPause()" class="musicButton" style="padding: 8px 16px; border-color: #F2C94C; width: auto;">â–¶</button>
                <button onclick="musicNext()" class="musicButton" style="padding: 8px 12px; width: auto;">â­</button>
            </div>
            
            <!-- Volume Control -->
            <div style="margin-bottom: 12px;">
                <label style="color: #BFD1E0; font-family: 'JetBrains Mono', monospace; font-size: 10px; display: block; margin-bottom: 4px; text-align: center;">Volume:</label>
                <div style="display: flex; align-items: center; gap: 8px; justify-content: center;">
                    <input type="range" class="volumeSlider" id="volumeSlider" min="1" max="150" value="75" oninput="updateVolume()" style="flex: 1; max-width: 200px;">
                    <span id="volumeSliderValue" style="color: #2D9CDB; font-family: 'JetBrains Mono', monospace; font-size: 10px; font-weight: bold; min-width: 30px; text-align: right;">75</span>
                </div>
            </div>
        </div>
        
        <!-- Music Ticker (OUTSIDE titleScreen so always visible) -->
        <div id="musicTicker">
            <div id="musicTickerWrapper">
                <span class="tickerText" id="musicTickerText1">â™« Theme Song â™«</span>
                <span class="tickerText" id="musicTickerText2">â™« Theme Song â™«</span>
            </div>
        </div>
    </div>
    
    <!-- Pause Screen -->
    <div id="pauseScreen">
        <div id="pauseTitle">PAUSED</div>
        <button class="menuButton" onclick="resumeGame()">RESUME<span style="display: inline-block; width: 26px; height: 26px; background: #E74C3C; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">B</span></button>
        <button class="menuButton" onclick="saveGameFromPause()" style="background: linear-gradient(135deg, rgba(46, 134, 222, 0.4), rgba(46, 134, 222, 0.3)); border-color: #3498DB;">SAVE GAME<span style="display: inline-block; width: 26px; height: 26px; background: #3498DB; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">ðŸ’¾</span></button>
        <button class="menuButton" onclick="downloadSaveFile()" style="background: linear-gradient(135deg, rgba(39, 174, 96, 0.4), rgba(39, 174, 96, 0.3)); border-color: #27AE60;">SAVE GAME FILE<span style="display: inline-block; width: 26px; height: 26px; background: #27AE60; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">â¬‡</span></button>
        <button class="menuButton" onclick="showSettingsFromPause()">SETTINGS<span style="display: inline-block; width: 26px; height: 26px; background: #F39C12; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">Y</span></button>
        <button class="menuButton" id="resyncBtn" onclick="requestResync()" style="display: none; background: linear-gradient(135deg, rgba(155, 89, 182, 0.4), rgba(155, 89, 182, 0.3)); border-color: #9B59B6;">ðŸ”„ RESYNC FROM HOST<span style="display: inline-block; width: 26px; height: 26px; background: #9B59B6; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">â†»</span></button>
        <button class="menuButton" id="hostControlsBtn" onclick="showHostControls()" style="display: none; background: linear-gradient(135deg, rgba(42, 157, 143, 0.4), rgba(42, 157, 143, 0.3)); border-color: #2A9D8F;">HOST CONTROLS<span style="display: inline-block; width: 26px; height: 26px; background: #2A9D8F; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">ðŸŽ®</span></button>
        <button class="menuButton" onclick="quitToMenu()">QUIT TO MENU<span style="display: inline-block; padding: 4px 10px; background: #555; border-radius: 5px; margin-left: 10px; font-weight: bold; color: white; font-size: 12px;">â—€</span></button>
    </div>
    
    <!-- Non-Combat Room Screen (Store, NPC, Secret, Exploration) -->
    <div id="nonCombatRoomScreen" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(135deg, #0a0a1a 0%, #1a1a2e 50%, #16213e 100%); z-index: 50;">
        <!-- Room Background -->
        <div id="nonCombatBackground" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-size: cover; background-position: center; opacity: 0.3;"></div>
        
        <!-- Room Content Container -->
        <div style="position: relative; z-index: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; padding: 40px;">
            
            <!-- Room Type Header -->
            <div id="nonCombatRoomHeader" style="text-align: center; margin-bottom: 30px;">
                <div id="nonCombatRoomIcon" style="font-size: 64px; margin-bottom: 10px;">ðŸª</div>
                <div id="nonCombatRoomTitle" style="color: #F2C94C; font-size: 32px; font-weight: 900; text-shadow: 0 0 20px rgba(242, 201, 76, 0.5);">STORE</div>
                <div id="nonCombatRoomSubtitle" style="color: #89A0B4; font-size: 16px; margin-top: 5px;">A merchant awaits...</div>
            </div>
            
            <!-- Room Content Area -->
            <div id="nonCombatRoomContent" style="background: rgba(0,0,0,0.7); border: 3px solid #8B45FF; border-radius: 15px; padding: 30px; max-width: 800px; width: 90%; max-height: 50vh; overflow-y: auto; backdrop-filter: blur(10px);">
                <!-- Content populated dynamically based on room type -->
                <div id="storeContent" style="display: none;">
                    <div id="merchantGreeting" style="color: #F2C94C; font-size: 18px; text-align: center; margin-bottom: 20px; font-style: italic;">"Welcome, traveler!"</div>
                    <div id="storeItems" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                        <!-- Store items populated dynamically -->
                    </div>
                </div>
                
                <div id="npcContent" style="display: none;">
                    <div id="npcName" style="color: #3498DB; font-size: 24px; font-weight: bold; text-align: center; margin-bottom: 10px;">NPC Name</div>
                    <div id="npcDialogue" style="color: #E0E0E0; font-size: 16px; text-align: center; margin-bottom: 20px; line-height: 1.6;">"Hello there!"</div>
                    <div id="npcService" style="text-align: center;">
                        <button class="menuButton" id="npcServiceBtn" onclick="useNPCService()" style="background: linear-gradient(135deg, rgba(52, 152, 219, 0.4), rgba(52, 152, 219, 0.3)); border-color: #3498DB;">Accept Service</button>
                    </div>
                </div>
                
                <div id="secretContent" style="display: none;">
                    <div id="secretDescription" style="color: #F1C40F; font-size: 18px; text-align: center; margin-bottom: 20px;">You found something!</div>
                    <div id="secretReward" style="text-align: center; padding: 20px; background: rgba(241, 196, 15, 0.2); border-radius: 10px; border: 2px solid #F1C40F;">
                        <div style="font-size: 48px; margin-bottom: 10px;">âœ¨</div>
                        <div id="secretRewardText" style="color: #F1C40F; font-size: 20px; font-weight: bold;">Reward!</div>
                    </div>
                </div>
                
                <div id="explorationContent" style="display: none;">
                    <div id="explorationDescription" style="color: #9B59B6; font-size: 18px; text-align: center; margin-bottom: 20px;">An interesting discovery...</div>
                    <div id="explorationChallenge" style="text-align: center; padding: 20px; background: rgba(155, 89, 182, 0.2); border-radius: 10px; border: 2px solid #9B59B6;">
                        <div id="explorationChallengeText" style="color: #E0E0E0; font-size: 16px;">Complete the challenge!</div>
                        <button class="menuButton" id="explorationActionBtn" onclick="completeExploration()" style="margin-top: 15px; background: linear-gradient(135deg, rgba(155, 89, 182, 0.4), rgba(155, 89, 182, 0.3)); border-color: #9B59B6;">Attempt</button>
                    </div>
                </div>
            </div>
            
            <!-- Leave Button -->
            <div style="margin-top: 30px;">
                <button class="menuButton" id="nonCombatLeaveBtn" onclick="leaveNonCombatRoom()" style="background: linear-gradient(135deg, rgba(231, 76, 60, 0.4), rgba(231, 76, 60, 0.3)); border-color: #E74C3C; font-size: 18px; padding: 15px 40px;">
                    ðŸšª LEAVE ROOM
                </button>
                <div id="nonCombatWaitingMsg" style="display: none; color: #F39C12; font-size: 14px; margin-top: 10px; text-align: center;">
                    â³ Waiting for host to leave...
                </div>
            </div>
        </div>
    </div>
    
    <!-- Hero Selection Modal (Multiplayer) -->
    <div id="heroSelectionModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.95); z-index: 300; pointer-events: all;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; max-width: 1000px; width: 95%;">
            <div id="heroSelectionTitle" style="color: #2A9D8F; font-size: 32px; font-weight: 900; margin-bottom: 15px; text-shadow: 0 0 20px rgba(42, 157, 143, 0.5);">SELECT YOUR HERO</div>
            
            <!-- Player Name Input -->
            <div style="margin-bottom: 15px;">
                <input type="text" id="playerNameInput" placeholder="Enter your name..." maxlength="20" style="width: 300px; padding: 10px 15px; background: rgba(0,0,0,0.7); border: 2px solid #2A9D8F; border-radius: 5px; color: #F2C94C; font-size: 16px; text-align: center; font-family: 'JetBrains Mono', monospace;" oninput="updatePlayerName()">
            </div>
            
            <!-- Room Info Bar -->
            <div style="margin-bottom: 20px; display: flex; justify-content: center; align-items: center; gap: 20px; flex-wrap: wrap;">
                <div style="background: rgba(42, 157, 143, 0.2); padding: 8px 16px; border-radius: 8px; border: 2px solid #2A9D8F;">
                    <span style="color: #89A0B4; font-size: 11px; margin-right: 8px;">ROOM:</span>
                    <span id="heroSelectionCode" style="color: #F2C94C; font-size: 18px; font-weight: bold; letter-spacing: 3px; font-family: 'JetBrains Mono', monospace;">------</span>
                    <button onclick="toggleRoomCodeVisibility()" style="background: none; border: none; color: #2A9D8F; cursor: pointer; font-size: 14px; margin-left: 8px; padding: 0;">ðŸ‘</button>
                </div>
                <div id="playerCountBox" style="background: rgba(42, 157, 143, 0.2); padding: 8px 16px; border-radius: 8px; border: 2px solid #2A9D8F;">
                    <span style="color: #89A0B4; font-size: 11px; margin-right: 8px;">PLAYERS:</span>
                    <span id="playerCountDisplay" style="color: #F2C94C; font-size: 18px; font-weight: bold;">1/4</span>
                </div>
                <div style="background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 215, 0, 0.1)); padding: 8px 16px; border-radius: 8px; border: 2px solid #FFD700;">
                    <span style="color: #89A0B4; font-size: 11px; margin-right: 8px;">ðŸ’° GOLD:</span>
                    <span id="sel-party-gold-top" style="color: #FFD700; font-size: 18px; font-weight: bold;">0</span>
                </div>
            </div>
            
            <!-- Connected Players List -->
            <div id="connectedPlayersList" style="margin-bottom: 20px; padding: 15px; background: rgba(0,0,0,0.5); border-radius: 8px; border: 2px solid #2A9D8F; max-height: 120px; overflow-y: auto;">
                <div style="color: #89A0B4; font-size: 12px; margin-bottom: 10px; text-transform: uppercase;">Connected Players:</div>
                <div id="playersListContent" style="display: flex; flex-wrap: wrap; gap: 10px; justify-content: center;">
                    <!-- Dynamically populated -->
                </div>
            </div>
            
            <div id="heroSelectionGrid" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; margin-bottom: 20px;">
                <!-- Zooko -->
                <div class="heroSelectCard" data-hero="zooko" onclick="selectHero('zooko')" style="cursor: pointer; padding: 15px; background: linear-gradient(135deg, rgba(242, 201, 76, 0.2), rgba(242, 201, 76, 0.1)); border: 3px solid #F2C94C; border-radius: 12px; transition: all 0.3s;">
                    <div style="width: 80px; height: 80px; margin: 0 auto 10px; background-image: url('people/zooko_a_head_compressed.png'); background-size: cover; background-position: center; border-radius: 50%; border: 3px solid #F2C94C;"></div>
                    <div style="color: #F2C94C; font-size: 16px; font-weight: bold;">ZOOKO</div>
                    <div class="heroPlayerLabel" style="display: none; color: #2A9D8F;"></div>
                    <div class="heroTakenLabel" style="display: none; color: #EB5757;">TAKEN</div>
                    <div class="heroSelectStats">
                        <div class="stat-row hp-ac-row"><span class="hp-row">HP: <span id="sel-zooko-hp">22</span>/<span id="sel-zooko-maxhp">25</span></span><span class="ac-row">AC: <span id="sel-zooko-ac">12</span></span></div>
                        <div class="stat-row xp-row">XP: <span id="sel-zooko-xp">0</span> (Lv<span id="sel-zooko-level">1</span>)</div>
                        <div class="stat-row"><span class="stat-label">STR:</span><span id="sel-zooko-str">8</span> <span class="stat-label">INT:</span><span id="sel-zooko-int">15</span></div>
                        <div class="stat-row"><span class="stat-label">DEX:</span><span id="sel-zooko-dex">11</span> <span class="stat-label">WIS:</span><span id="sel-zooko-wis">13</span></div>
                        <div class="stat-row"><span class="stat-label">CON:</span><span id="sel-zooko-con">10</span> <span class="stat-label">CHA:</span><span id="sel-zooko-cha">9</span></div>
                        <button class="heroRollButton" data-hero="zooko" onclick="event.stopPropagation(); openDiceRollModal('zooko')">ðŸŽ² ROLL STATS</button>
                    </div>
                </div>
                <!-- Nate -->
                <div class="heroSelectCard" data-hero="nate" onclick="selectHero('nate')" style="cursor: pointer; padding: 15px; background: linear-gradient(135deg, rgba(231, 76, 60, 0.2), rgba(231, 76, 60, 0.1)); border: 3px solid #E74C3C; border-radius: 12px; transition: all 0.3s;">
                    <div style="width: 80px; height: 80px; margin: 0 auto 10px; background-image: url('people/Nate_a_head_compressed.png'); background-size: cover; background-position: center; border-radius: 50%; border: 3px solid #E74C3C;"></div>
                    <div style="color: #E74C3C; font-size: 16px; font-weight: bold;">NATE</div>
                    <div class="heroPlayerLabel" style="display: none; color: #2A9D8F;"></div>
                    <div class="heroTakenLabel" style="display: none; color: #EB5757;">TAKEN</div>
                    <div class="heroSelectStats">
                        <div class="stat-row hp-ac-row"><span class="hp-row">HP: <span id="sel-nate-hp">28</span>/<span id="sel-nate-maxhp">30</span></span><span class="ac-row">AC: <span id="sel-nate-ac">14</span></span></div>
                        <div class="stat-row xp-row">XP: <span id="sel-nate-xp">0</span> (Lv<span id="sel-nate-level">1</span>)</div>
                        <div class="stat-row"><span class="stat-label">STR:</span><span id="sel-nate-str">14</span> <span class="stat-label">INT:</span><span id="sel-nate-int">10</span></div>
                        <div class="stat-row"><span class="stat-label">DEX:</span><span id="sel-nate-dex">12</span> <span class="stat-label">WIS:</span><span id="sel-nate-wis">9</span></div>
                        <div class="stat-row"><span class="stat-label">CON:</span><span id="sel-nate-con">13</span> <span class="stat-label">CHA:</span><span id="sel-nate-cha">11</span></div>
                        <button class="heroRollButton" data-hero="nate" onclick="event.stopPropagation(); openDiceRollModal('nate')">ðŸŽ² ROLL STATS</button>
                    </div>
                </div>
                <!-- Zancas -->
                <div class="heroSelectCard" data-hero="zancas" onclick="selectHero('zancas')" style="cursor: pointer; padding: 15px; background: linear-gradient(135deg, rgba(39, 174, 96, 0.2), rgba(39, 174, 96, 0.1)); border: 3px solid #27AE60; border-radius: 12px; transition: all 0.3s;">
                    <div style="width: 80px; height: 80px; margin: 0 auto 10px; background-image: url('people/Zancas_a_head_compressed.png'); background-size: cover; background-position: center; border-radius: 50%; border: 3px solid #27AE60;"></div>
                    <div style="color: #27AE60; font-size: 16px; font-weight: bold;">ZANCAS</div>
                    <div class="heroPlayerLabel" style="display: none; color: #2A9D8F;"></div>
                    <div class="heroTakenLabel" style="display: none; color: #EB5757;">TAKEN</div>
                    <div class="heroSelectStats">
                        <div class="stat-row hp-ac-row"><span class="hp-row">HP: <span id="sel-zancas-hp">24</span>/<span id="sel-zancas-maxhp">26</span></span><span class="ac-row">AC: <span id="sel-zancas-ac">13</span></span></div>
                        <div class="stat-row xp-row">XP: <span id="sel-zancas-xp">0</span> (Lv<span id="sel-zancas-level">1</span>)</div>
                        <div class="stat-row"><span class="stat-label">STR:</span><span id="sel-zancas-str">10</span> <span class="stat-label">INT:</span><span id="sel-zancas-int">12</span></div>
                        <div class="stat-row"><span class="stat-label">DEX:</span><span id="sel-zancas-dex">15</span> <span class="stat-label">WIS:</span><span id="sel-zancas-wis">14</span></div>
                        <div class="stat-row"><span class="stat-label">CON:</span><span id="sel-zancas-con">11</span> <span class="stat-label">CHA:</span><span id="sel-zancas-cha">8</span></div>
                        <button class="heroRollButton" data-hero="zancas" onclick="event.stopPropagation(); openDiceRollModal('zancas')">ðŸŽ² ROLL STATS</button>
                    </div>
                </div>
                <!-- CyberAxe -->
                <div class="heroSelectCard" data-hero="cyberaxe" onclick="selectHero('cyberaxe')" style="cursor: pointer; padding: 15px; background: linear-gradient(135deg, rgba(46, 134, 222, 0.2), rgba(46, 134, 222, 0.1)); border: 3px solid #2E86DE; border-radius: 12px; transition: all 0.3s;">
                    <div style="width: 80px; height: 80px; margin: 0 auto 10px; background-image: url('people/cyberaxe_a_head_compressed.png'); background-size: cover; background-position: center; border-radius: 50%; border: 3px solid #2E86DE;"></div>
                    <div style="color: #2E86DE; font-size: 16px; font-weight: bold;">CYBERAXE</div>
                    <div class="heroPlayerLabel" style="display: none; color: #2A9D8F;"></div>
                    <div class="heroTakenLabel" style="display: none; color: #EB5757;">TAKEN</div>
                    <div class="heroSelectStats">
                        <div class="stat-row hp-ac-row"><span class="hp-row">HP: <span id="sel-cyberaxe-hp">32</span>/<span id="sel-cyberaxe-maxhp">35</span></span><span class="ac-row">AC: <span id="sel-cyberaxe-ac">15</span></span></div>
                        <div class="stat-row xp-row">XP: <span id="sel-cyberaxe-xp">0</span> (Lv<span id="sel-cyberaxe-level">1</span>)</div>
                        <div class="stat-row"><span class="stat-label">STR:</span><span id="sel-cyberaxe-str">16</span> <span class="stat-label">INT:</span><span id="sel-cyberaxe-int">8</span></div>
                        <div class="stat-row"><span class="stat-label">DEX:</span><span id="sel-cyberaxe-dex">10</span> <span class="stat-label">WIS:</span><span id="sel-cyberaxe-wis">11</span></div>
                        <div class="stat-row"><span class="stat-label">CON:</span><span id="sel-cyberaxe-con">14</span> <span class="stat-label">CHA:</span><span id="sel-cyberaxe-cha">10</span></div>
                        <button class="heroRollButton" data-hero="cyberaxe" onclick="event.stopPropagation(); openDiceRollModal('cyberaxe')">ðŸŽ² ROLL STATS</button>
                    </div>
                </div>
            </div>
            <div id="heroWaitingMessage" style="color: #89A0B4; font-size: 14px; margin-bottom: 15px;">Click heroes to select. Players can select multiple heroes.</div>
            <div id="reconnectOptions" style="display: none; margin-bottom: 15px;">
                <div style="color: #2A9D8F; font-size: 16px; margin-bottom: 15px; font-weight: bold;">ðŸ”„ Reconnecting to Game in Progress</div>
                <div style="display: flex; flex-direction: column; gap: 10px; max-width: 400px; margin: 0 auto;">
                    <button class="menuButton" onclick="rejoinGame()" style="padding: 15px; font-size: 14px; background: linear-gradient(135deg, rgba(42, 157, 143, 0.4), rgba(42, 157, 143, 0.3)); border-color: #2A9D8F;">REJOIN GAME</button>
                    <div style="color: #89A0B4; font-size: 12px; font-style: italic; margin-top: 5px;">Select your heroes above, then click to rejoin</div>
                </div>
            </div>
            <div id="gameStartOptions" style="display: none; margin-bottom: 15px;">
                <div id="gameStartPhase1" style="display: block;">
                    <div style="color: #F2C94C; font-size: 14px; margin-bottom: 10px; font-weight: bold;">All heroes selected!</div>
                    <div style="display: flex; gap: 8px; justify-content: center;">
                        <button onclick="cancelHeroSelection()" style="width: 110px; padding: 10px 0; font-size: 12px; background: linear-gradient(135deg, rgba(235, 87, 87, 0.5), rgba(235, 87, 87, 0.3)); border: 2px solid #EB5757; border-radius: 6px; color: #fff; cursor: pointer; font-family: 'Inter', sans-serif; font-weight: 600;">BACK</button>
                        <button onclick="continueGame()" style="width: 110px; padding: 10px 0; font-size: 12px; background: linear-gradient(135deg, rgba(42, 157, 143, 0.5), rgba(42, 157, 143, 0.3)); border: 2px solid #2A9D8F; border-radius: 6px; color: #fff; cursor: pointer; font-family: 'Inter', sans-serif; font-weight: 600;">CONTINUE</button>
                        <button onclick="loadSaveGame()" style="width: 110px; padding: 10px 0; font-size: 12px; background: linear-gradient(135deg, rgba(46, 134, 222, 0.5), rgba(46, 134, 222, 0.3)); border: 2px solid #2E86DE; border-radius: 6px; color: #fff; cursor: pointer; font-family: 'Inter', sans-serif; font-weight: 600;">LOAD SAVE</button>
                        <button onclick="enterRollPhase()" style="width: 110px; padding: 10px 0; font-size: 12px; background: linear-gradient(135deg, rgba(242, 201, 76, 0.5), rgba(242, 201, 76, 0.3)); border: 2px solid #F2C94C; border-radius: 6px; color: #fff; cursor: pointer; font-family: 'Inter', sans-serif; font-weight: 600;">NEW GAME</button>
                    </div>
                    <div style="color: #EB5757; font-size: 10px; font-style: italic; margin-top: 6px;">âš  NEW GAME replaces local save</div>
                </div>
                <div id="gameStartPhase2" style="display: none;">
                    <div style="color: #F2C94C; font-size: 14px; margin-bottom: 6px; font-weight: bold;">ðŸŽ² ROLL YOUR STATS!</div>
                    <div id="rollPhaseStatus" style="color: #89A0B4; font-size: 12px; margin-bottom: 10px;">Waiting for all players to roll stats...</div>
                    <div style="display: flex; gap: 8px; justify-content: center;">
                        <button onclick="cancelRollPhase()" style="width: 110px; padding: 10px 0; font-size: 12px; background: linear-gradient(135deg, rgba(235, 87, 87, 0.5), rgba(235, 87, 87, 0.3)); border: 2px solid #EB5757; border-radius: 6px; color: #fff; cursor: pointer; font-family: 'Inter', sans-serif; font-weight: 600;">BACK</button>
                        <button id="launchGameBtn" onclick="launchNewGame()" disabled style="width: 130px; padding: 10px 0; font-size: 12px; background: linear-gradient(135deg, rgba(39, 174, 96, 0.3), rgba(39, 174, 96, 0.2)); border: 2px solid #27AE60; border-radius: 6px; color: #666; cursor: not-allowed; font-family: 'Inter', sans-serif; font-weight: 600;">ðŸš€ LAUNCH GAME</button>
                    </div>
                </div>
            </div>
            <div id="heroSelectionBackBtn" style="display: flex; gap: 15px; justify-content: center;">
                <button onclick="cancelHeroSelection()" style="width: 110px; padding: 10px 0; font-size: 12px; background: linear-gradient(135deg, rgba(235, 87, 87, 0.5), rgba(235, 87, 87, 0.3)); border: 2px solid #EB5757; border-radius: 6px; color: #fff; cursor: pointer; font-family: 'Inter', sans-serif; font-weight: 600;">BACK</button>
            </div>
        </div>
    </div>
    
    <!-- Dice Roll Modal -->
    <div id="diceRollModal">
        <div class="diceRollContainer">
            <div class="diceRollTitle">ðŸŽ² ROLL STATS FOR <span id="diceRollHeroName">HERO</span></div>
            
            <div id="diceStatRows">
                <!-- STR -->
                <div class="diceStatRow" data-stat="str">
                    <div class="diceStatName">STR</div>
                    <div class="diceGroup">
                        <div class="die" data-die="1">-</div>
                        <div class="die" data-die="2">-</div>
                        <div class="die" data-die="3">-</div>
                    </div>
                    <div class="diceStatTotal">-</div>
                </div>
                <!-- DEX -->
                <div class="diceStatRow" data-stat="dex">
                    <div class="diceStatName">DEX</div>
                    <div class="diceGroup">
                        <div class="die" data-die="1">-</div>
                        <div class="die" data-die="2">-</div>
                        <div class="die" data-die="3">-</div>
                    </div>
                    <div class="diceStatTotal">-</div>
                </div>
                <!-- CON -->
                <div class="diceStatRow" data-stat="con">
                    <div class="diceStatName">CON</div>
                    <div class="diceGroup">
                        <div class="die" data-die="1">-</div>
                        <div class="die" data-die="2">-</div>
                        <div class="die" data-die="3">-</div>
                    </div>
                    <div class="diceStatTotal">-</div>
                </div>
                <!-- INT -->
                <div class="diceStatRow" data-stat="int">
                    <div class="diceStatName">INT</div>
                    <div class="diceGroup">
                        <div class="die" data-die="1">-</div>
                        <div class="die" data-die="2">-</div>
                        <div class="die" data-die="3">-</div>
                    </div>
                    <div class="diceStatTotal">-</div>
                </div>
                <!-- WIS -->
                <div class="diceStatRow" data-stat="wis">
                    <div class="diceStatName">WIS</div>
                    <div class="diceGroup">
                        <div class="die" data-die="1">-</div>
                        <div class="die" data-die="2">-</div>
                        <div class="die" data-die="3">-</div>
                    </div>
                    <div class="diceStatTotal">-</div>
                </div>
                <!-- CHA -->
                <div class="diceStatRow" data-stat="cha">
                    <div class="diceStatName">CHA</div>
                    <div class="diceGroup">
                        <div class="die" data-die="1">-</div>
                        <div class="die" data-die="2">-</div>
                        <div class="die" data-die="3">-</div>
                    </div>
                    <div class="diceStatTotal">-</div>
                </div>
            </div>
            
            <div class="derivedStats">
                <span><span class="hp-value">HP: <span id="diceRollHP">-</span></span></span>
                <span><span class="ac-value">AC: <span id="diceRollAC">-</span></span></span>
                <span style="color: #F2C94C; font-weight: bold;">TOTAL: <span id="diceRollTotal">-</span>/108</span>
            </div>
            
            <div class="diceRollActions">
                <button class="diceRollBtn cancel" onclick="closeDiceRollModal()">CANCEL</button>
                <button class="diceRollBtn roll" onclick="rollAllDice()">ðŸŽ² ROLL</button>
                <button class="diceRollBtn accept" onclick="acceptRolledStats()">âœ“ ACCEPT</button>
            </div>
        </div>
    </div>
    
    <!-- Host Controls Panel -->
    <div id="hostControlsPanel" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9)); border: 2px solid #2A9D8F; border-radius: 12px; padding: 25px; max-width: 500px; width: 85vw; z-index: 300; pointer-events: all; box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8); backdrop-filter: blur(10px);">
        <div class="panelTitle" style="color: #2A9D8F;">ðŸŽ® HOST CONTROLS</div>
        <div id="playerList" style="margin: 20px 0; max-height: 300px; overflow-y: auto;">
            <!-- Dynamically populated -->
        </div>
        <div style="display: flex; gap: 10px; margin-top: 20px;">
            <button class="menuButton" onclick="changeRoomCodeFromPanel()" style="flex: 1; padding: 10px; font-size: 13px;">CHANGE CODE</button>
            <button class="menuButton" onclick="closeHostControls()" style="flex: 1; padding: 10px; font-size: 13px; background: linear-gradient(135deg, rgba(235, 87, 87, 0.4), rgba(235, 87, 87, 0.3)); border-color: #EB5757;">CLOSE</button>
        </div>
    </div>
    
    <!-- Confirmation Modal -->
    <div id="confirmationModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); z-index: 400; pointer-events: all;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; background: linear-gradient(135deg, rgba(26, 26, 46, 0.95), rgba(13, 13, 26, 0.95)); border: 3px solid #F2C94C; border-radius: 15px; padding: 40px 60px; box-shadow: 0 10px 50px rgba(0, 0, 0, 0.9);">
            <div id="confirmationTitle" style="color: #F2C94C; font-size: 28px; font-weight: 900; margin-bottom: 20px; text-shadow: 0 0 15px rgba(242, 201, 76, 0.5); text-transform: uppercase; letter-spacing: 2px;">CONFIRM ACTION</div>
            <div id="confirmationMessage" style="color: #89A0B4; font-size: 16px; margin-bottom: 30px; line-height: 1.5;">Are you sure?</div>
            <div style="display: flex; gap: 20px; justify-content: center;">
                <button onclick="confirmModalAction(false)" style="padding: 12px 30px; font-size: 16px; font-weight: bold; background: linear-gradient(135deg, rgba(231, 76, 60, 0.4), rgba(192, 57, 43, 0.4)); border: 2px solid #E74C3C; border-radius: 8px; color: #FFFFFF; cursor: pointer; text-transform: uppercase; letter-spacing: 1px; transition: all 0.2s;">CANCEL</button>
                <button onclick="confirmModalAction(true)" style="padding: 12px 30px; font-size: 16px; font-weight: bold; background: linear-gradient(135deg, rgba(46, 204, 113, 0.4), rgba(39, 174, 96, 0.4)); border: 2px solid #27AE60; border-radius: 8px; color: #FFFFFF; cursor: pointer; text-transform: uppercase; letter-spacing: 1px; transition: all 0.2s;">YES</button>
            </div>
        </div>
    </div>
    
    <!-- Overlay for modal panels -->
    <div id="overlay" onclick="closeAllPanels()"></div>
    
    <!-- Settings Panel -->
    <div id="settingsPanel">
        <div class="panelTitle">SETTINGS</div>
        
        <!-- Music Controls -->
        <div class="settingRow" style="margin-bottom: 10px;">
            <span class="settingLabel" style="font-size: 16px;">Music Enabled</span>
            <input type="checkbox" id="musicEnabled" checked onchange="updateSettings()">
        </div>
        
        <div class="settingRow" style="margin-bottom: 15px;">
            <span class="settingLabel" style="font-size: 16px;">Music Volume</span>
            <input type="range" id="musicVolume" min="1" max="150" value="75" oninput="updateSettings()" style="width: 150px;">
            <span id="musicVolumeValue" style="margin-left: 8px; font-weight: bold; color: #2D9CDB; font-size: 14px;">75</span>
        </div>
        
        <!-- Theme/Zone Music Toggles -->
        <div class="settingRow" style="margin-bottom: 10px;">
            <span class="settingLabel" style="font-size: 16px;">Theme Songs</span>
            <input type="checkbox" id="themeMusicEnabled" checked onchange="updateSettings()">
            <span style="font-size: 10px; color: #89A0B4; margin-left: 8px;">Zcash themes</span>
        </div>
        
        <div class="settingRow" style="margin-bottom: 15px;">
            <span class="settingLabel" style="font-size: 16px;">Zone Music</span>
            <input type="checkbox" id="zoneMusicEnabled" checked onchange="updateSettings()">
            <span style="font-size: 10px; color: #89A0B4; margin-left: 8px;">Changes per dungeon zone</span>
        </div>
        
        <!-- Hitbox Toggle -->
        <div class="settingRow" style="margin-bottom: 15px;">
            <span class="settingLabel" style="font-size: 16px;">Show Hitboxes</span>
            <input type="checkbox" id="showHitboxes" onchange="updateSettings()">
        </div>
        
        <!-- Network Debug Toggle -->
        <div class="settingRow" style="margin-bottom: 15px;">
            <span class="settingLabel" style="font-size: 16px;">Network Debug</span>
            <input type="checkbox" id="networkDebug" onchange="toggleNetworkDebug()">
        </div>
        
        <!-- LLM Settings Section -->
        <div style="margin: 15px 0 10px 0; padding-top: 15px; border-top: 1px solid rgba(255, 255, 255, 0.1);">
            <span style="font-size: 14px; font-weight: bold; color: #2D9CDB;">ðŸ¤– AI Settings</span>
        </div>
        
        <!-- LLM Free Will Toggle -->
        <div class="settingRow" style="margin-bottom: 15px;">
            <span class="settingLabel" style="font-size: 16px;">NPC Free Will Chat</span>
            <input type="checkbox" id="llmFreeWill" onchange="updateSettings()">
            <span style="font-size: 10px; color: #89A0B4; margin-left: 8px;">NPCs chat on their own</span>
        </div>
        
        <!-- LLM Free vs Paid Toggle -->
        <div class="settingRow" style="margin-bottom: 15px;">
            <span class="settingLabel" style="font-size: 16px;">Use Paid LLM Models</span>
            <input type="checkbox" id="llmUsePaid" onchange="updateSettings()">
            <span style="font-size: 10px; color: #89A0B4; margin-left: 8px;">Better quality, costs $</span>
        </div>
        
        <!-- RP Mode Toggle -->
        <div class="settingRow" style="margin-bottom: 15px;">
            <span class="settingLabel" style="font-size: 16px;">Roleplay Mode</span>
            <input type="checkbox" id="rpMode" onchange="updateSettings()" checked>
            <span style="font-size: 10px; color: #89A0B4; margin-left: 8px;">*dramatic emotes* vs normal speech</span>
        </div>
        
        <!-- Diagnostic Mode Toggle -->
        <div class="settingRow" style="margin-bottom: 15px;">
            <span class="settingLabel" style="font-size: 16px;">Diag Mode (5 HP)</span>
            <input type="checkbox" id="diagMode" onchange="updateSettings()">
            <span style="font-size: 10px; color: #EB5757; margin-left: 8px;">Enemies have 5 HP for testing</span>
        </div>
        
        <div style="margin: 10px 0; padding: 10px; background: rgba(42, 157, 143, 0.1); border-radius: 5px; font-size: 11px; color: #89A0B4;">
            ðŸ’¡ Settings are saved independently for Tunnels of Privacy
        </div>
        
        <button class="menuButton" onclick="clearCache()" style="margin-top: 15px; width: 100%; padding: 12px; font-size: 14px; background: linear-gradient(135deg, rgba(235, 87, 87, 0.4), rgba(235, 87, 87, 0.3)); border-color: #EB5757;">CLEAR CACHE<span style="display: inline-block; width: 26px; height: 26px; background: #EB5757; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">X</span></button>
        <button class="menuButton" onclick="closeAllPanels()" style="margin-top: 15px; width: 100%; padding: 12px; font-size: 14px;">CLOSE<span style="display: inline-block; width: 26px; height: 26px; background: #E74C3C; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">B</span></button>
        
        <div style="display: block; width: 100%; margin-top: 15px; padding: 10px 0; text-align: center; font-family: 'JetBrains Mono', monospace; font-size: 11px; color: #5A7A8F; border-top: 1px solid rgba(255, 255, 255, 0.1);">
            Tunnels of Privacy v0.3.43
        </div>
    </div>
    
    <!-- About/Donate Panel -->
    <div id="aboutPanel" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9)); border: 2px solid #2D9CDB; border-radius: 12px; padding: 25px; max-width: 500px; width: 85vw; z-index: 200; pointer-events: all; box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8); backdrop-filter: blur(10px);">
        <div class="panelTitle">ABOUT / DONATE</div>
        <div style="font-family: 'Inter', sans-serif; color: #D4E3F0; line-height: 1.8; text-align: center;">
            <div style="margin-bottom: 25px;">
                <div style="font-size: 18px; font-weight: 700; color: #F2C94C; margin-bottom: 10px;">Created by CyberAxe</div>
                <div style="font-size: 16px; margin-bottom: 5px;">
                    <a href="https://www.OutlandishlyCrafted.com" target="_blank" style="color: #2D9CDB; text-decoration: none; font-weight: 600;">www.OutlandishlyCrafted.com</a>
                </div>
            </div>
            
            <div style="margin-bottom: 25px; padding-top: 20px; border-top: 2px solid #26313B;">
                <div style="font-size: 16px; font-weight: 700; color: #27AE60; margin-bottom: 10px;">Report Bugs & Get Support</div>
                <div style="font-size: 14px;">
                    <a href="https://github.com/Jbenisek/ZLOCK-ZHAINER" target="_blank" style="color: #2D9CDB; text-decoration: none; font-weight: 600;">github.com/Jbenisek/ZLOCK-ZHAINER</a>
                </div>
            </div>
            
            <div style="margin-bottom: 20px; padding-top: 20px; border-top: 2px solid #26313B;">
                <div style="font-size: 18px; font-weight: 700; color: #EB5757; margin-bottom: 15px;">Donate and Support</div>
                <div style="font-size: 11px; font-family: 'JetBrains Mono', monospace; background: rgba(0, 0, 0, 0.3); padding: 12px; border-radius: 8px; word-break: break-all; color: #F2C94C; margin-bottom: 15px;">
                    u1gvnthgukm0ecnan3tgj3h6pdhrmmv8zyqx8ayup9yg9er4t5l7nesas6leavc4x3rsj98n65nn2w3ekzur9yejadlmv7k4vjgu8kp58q
                </div>
                <div>
                    <img src="items/CyberAxeZcashWalletQR.PNG" alt="Zcash Donation QR Code" style="max-width: 200px; border: 2px solid #26313B; border-radius: 8px; background: white; padding: 10px;">
                </div>
            </div>
        </div>
        <button class="menuButton" onclick="closeAllPanels()" style="width: 100%; margin-top: 20px;">CLOSE<span style="display: inline-block; width: 26px; height: 26px; background: #E74C3C; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">B</span></button>
    </div>
    
    <!-- Confirmation Dialog Panel -->
    <div id="confirmDialog" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, rgba(10, 14, 18, 0.98), rgba(20, 27, 34, 0.95)); border: 3px solid #EB5757; border-radius: 12px; padding: 30px; max-width: 450px; width: 85vw; z-index: 1200; pointer-events: all; box-shadow: 0 10px 50px rgba(0, 0, 0, 0.9), 0 0 30px rgba(235, 87, 87, 0.3); backdrop-filter: blur(15px);">
        <div style="text-align: center;">
            <div style="font-size: 48px; margin-bottom: 15px;">âš ï¸</div>
            <div class="panelTitle" style="color: #EB5757; margin-bottom: 15px;" id="confirmDialogTitle">CONFIRM ACTION</div>
            <div style="font-family: 'Inter', sans-serif; color: #D4E3F0; font-size: 16px; line-height: 1.6; margin-bottom: 25px;" id="confirmDialogMessage">
                Are you sure you want to proceed?
            </div>
            <div style="display: flex; gap: 15px; justify-content: center;">
                <button class="menuButton" id="confirmDialogYes" style="flex: 1; background: linear-gradient(135deg, rgba(235, 87, 87, 0.4), rgba(180, 60, 60, 0.4)); border-color: #EB5757;">
                    YES, DELETE
                </button>
                <button class="menuButton" id="confirmDialogNo" style="flex: 1; background: linear-gradient(135deg, rgba(39, 174, 96, 0.4), rgba(30, 130, 70, 0.4)); border-color: #27AE60;">
                    CANCEL
                </button>
            </div>
        </div>
    </div>
    
    <!-- Info Dialog Panel (replaces alert) -->
    <div id="infoDialog" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, rgba(10, 14, 18, 0.98), rgba(20, 27, 34, 0.95)); border: 3px solid #27AE60; border-radius: 12px; padding: 30px; max-width: 450px; width: 85vw; z-index: 1200; pointer-events: all; box-shadow: 0 10px 50px rgba(0, 0, 0, 0.9), 0 0 30px rgba(39, 174, 96, 0.3); backdrop-filter: blur(15px);">
        <div style="text-align: center;">
            <div style="font-size: 48px; margin-bottom: 15px;" id="infoDialogIcon">âœ…</div>
            <div class="panelTitle" style="color: #27AE60; margin-bottom: 15px;" id="infoDialogTitle">SUCCESS</div>
            <div style="font-family: 'Inter', sans-serif; color: #D4E3F0; font-size: 16px; line-height: 1.6; margin-bottom: 25px;" id="infoDialogMessage">
                Operation completed successfully.
            </div>
            <button class="menuButton" id="infoDialogOk" style="width: 100%;">
                OK
            </button>
        </div>
    </div>
    
    <!-- Load Save Panel -->
    <div id="loadSavePanel" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9)); border: 2px solid #3498DB; border-radius: 12px; padding: 25px; max-width: 600px; width: 85vw; z-index: 200; pointer-events: all; box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8); backdrop-filter: blur(10px);">
        <div class="panelTitle" style="color: #3498DB;">LOAD SAVE FILE</div>
        
        <div style="margin: 15px 0; padding: 15px; background: rgba(52, 152, 219, 0.1); border-radius: 8px; border: 1px solid rgba(52, 152, 219, 0.3);">
            <div style="color: #BFD1E0; font-family: 'JetBrains Mono', monospace; font-size: 12px; margin-bottom: 10px;">
                ðŸ“¥ Import save file from arcade game or previous dungeon run
            </div>
            <input type="file" id="saveFileInput" accept=".json" style="display: block; width: 100%; padding: 10px; background: rgba(10, 14, 18, 0.8); border: 2px solid #3498DB; border-radius: 6px; color: #E9F0F7; font-family: 'JetBrains Mono', monospace; font-size: 12px; cursor: pointer; margin-bottom: 10px;">
            <button class="menuButton" onclick="loadSaveFile()" style="width: 100%; margin: 0;">LOAD FILE<span style="display: inline-block; width: 26px; height: 26px; background: #27AE60; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">A</span></button>
        </div>
        
        <div style="margin: 15px 0; padding: 10px; background: rgba(241, 196, 15, 0.1); border-radius: 5px; font-size: 11px; color: #89A0B4;">
            ðŸ’¡ You can export save files from the arcade game's settings menu. This allows you to continue your adventure with the same hero stats and progress.
        </div>
        
        <button class="menuButton" onclick="closeAllPanels()" style="margin-top: 15px; width: 100%; padding: 12px; font-size: 14px;">CLOSE<span style="display: inline-block; width: 26px; height: 26px; background: #E74C3C; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">B</span></button>
    </div>

    <script>
        // Portal System - localStorage keys with "top_" prefix
        const STORAGE_KEYS = {
            SETTINGS: 'top_tunnels_settings',
            SHARED_SAVE: 'top_shared_save'
        };
        
        const GAME_VERSION = 'v0.3.43';
        
        // ===== HACKATHON INFO TOOLTIP SYSTEM =====
        const TOOLTIP_DELAY = 800; // ms before tooltip appears
        const TOOLTIP_SLIDE_INTERVAL = 6000; // ms between slides
        let tooltipTimeout = null;
        let tooltipSlideInterval = null;
        let currentTooltipElement = null;
        let currentTooltipId = null;
        let currentSlideIndex = 0;
        
        // Tooltip definitions - each tooltip has multiple slides (Zcash/Lore first, then AI/Tech)
        const TOOLTIP_DATA = {
            // Battle Actions
            'exploreLevelBtn': {
                slides: [
                    {
                        icon: 'ðŸ’›',
                        title: 'Privacy-First Exploration',
                        body: 'The <strong>Tunnels of Privacy</strong> are ancient passages where personal data is protected. Each level represents the fight against surveillance and data harvesting in a world where privacy is treasure.',
                        tags: ['zcash'],
                        footer: 'Zcash: Privacy is a human right'
                    },
                    {
                        icon: 'ðŸ¤–',
                        title: 'AI-Powered Encounters',
                        body: 'Uses <strong>LLM (Large Language Model)</strong> to pre-generate unique encounters. Boss names, stats, personalities, and dialogue are all AI-created in real-time.<br><br>ðŸ”Œ <strong>API:</strong> OpenRouter + Groq<br>ðŸŽ¯ <strong>9 Models</strong> to choose from',
                        tags: ['ai', 'paid'],
                        footer: 'OpenRouter & Groq APIs â€¢ 9 models available'
                    }
                ]
            },
            'battleTalkBtn': {
                slides: [
                    {
                        icon: 'ðŸ’›',
                        title: 'Negotiate for Privacy',
                        body: 'Some enemies can be <strong>reasoned with or bribed</strong>. In the Zcash universe, not every conflict requires violence - sometimes privacy can be bought, traded, or persuaded.',
                        tags: ['zcash'],
                        footer: 'Diplomacy: A tool for the wise adventurer'
                    },
                    {
                        icon: 'ðŸ—£ï¸',
                        title: 'Local Text-to-Speech',
                        body: 'Uses <strong>Piper TTS</strong> - a completely FREE, locally-hosted neural text-to-speech engine. No cloud API needed! Voices run 100% on your machine.',
                        tags: ['ai', 'free', 'local'],
                        footer: 'Free feature: Piper TTS auto-installs on first use'
                    }
                ]
            },
            'battleHeavyBtn': {
                slides: [
                    {
                        icon: 'âš”ï¸',
                        title: 'Fight for Freedom',
                        body: 'Heavy attacks represent the <strong>direct action</strong> needed to protect privacy. Sometimes you must fight surveillance head-on with overwhelming force.',
                        tags: ['free'],
                        footer: 'Privacy worth fighting for'
                    },
                    {
                        icon: 'ðŸŽ²',
                        title: 'D&D Combat System',
                        body: 'Full <strong>D&D 5e-style</strong> dice rolling: d20 for attack rolls vs AC, damage dice (1d6/2d6/3d6), stat modifiers. All combat math follows tabletop RPG rules.',
                        tags: ['free'],
                        footer: 'Real dice mechanics with critical hits and misses'
                    }
                ]
            },
            'battleSpecialBtn': {
                slides: [
                    {
                        icon: 'ðŸ’›',
                        title: 'Zero-Knowledge Powers',
                        body: 'Each hero\'s special ability is inspired by <strong>cryptographic concepts</strong>. Zooko\'s shield (encryption), Nate\'s fury (brute force), Zancas\'s precision (targeted proofs), CyberAxe\'s storm (distributed attack).',
                        tags: ['zcash'],
                        footer: 'Crypto-powered heroes!'
                    },
                    {
                        icon: 'âœ¨',
                        title: 'AI Particle Effects',
                        body: 'Each hero has unique special attacks with <strong>AI-generated particle effects</strong> created using a custom particle editor tool.',
                        tags: ['ai', 'free'],
                        footer: 'Effects created with particle_editor.html'
                    }
                ]
            },
            // Dungeon Menu
            'dungeonMastersBtn': {
                slides: [
                    {
                        icon: 'ðŸŽ²',
                        title: 'Dungeon Master',
                        body: 'Like a tabletop RPG <strong>Game Master</strong>, the host controls the adventure. Choose difficulty, navigate levels, and guide your party through the Tunnels of Privacy.',
                        tags: ['free'],
                        footer: 'Host = Dungeon Master'
                    },
                    {
                        icon: 'ðŸ‘¥',
                        title: 'WebSocket Multiplayer',
                        body: 'Host-only panel for <strong>level navigation</strong> and <strong>difficulty settings</strong>. Clients see updates in real-time via WebSocket sync.',
                        tags: ['multiplayer', 'free'],
                        footer: 'Real-time sync for all players'
                    }
                ]
            },
            'diffCasualBtn': {
                slides: [
                    {
                        icon: 'ðŸŒ¼',
                        title: 'Casual Mode',
                        body: 'For those new to privacy advocacy - <strong>easier enemies</strong> let you learn the ropes while enjoying the story and Zcash lore.',
                        tags: ['free'],
                        footer: 'Everyone deserves privacy education'
                    },
                    {
                        icon: 'ðŸ“Š',
                        title: 'Dynamic Difficulty',
                        body: 'Loads different <strong>boss stat JSON files</strong> based on difficulty. Casual has lower boss HP, damage, and ability modifiers.',
                        tags: ['free'],
                        footer: 'Boss data: bosses_data_easy.json'
                    }
                ]
            },
            'diffNormalBtn': {
                slides: [
                    {
                        icon: 'âš”ï¸',
                        title: 'Normal Mode',
                        body: 'The standard challenge - <strong>balanced difficulty</strong> for experienced privacy advocates ready to defend their data.',
                        tags: ['free'],
                        footer: 'The intended experience'
                    },
                    {
                        icon: 'ðŸ“Š',
                        title: 'Dynamic Difficulty',
                        body: 'Loads different <strong>boss stat JSON files</strong> based on difficulty. Normal has balanced boss stats.',
                        tags: ['free'],
                        footer: 'Boss data: bosses_data_normal.json'
                    }
                ]
            },
            'diffExpertBtn': {
                slides: [
                    {
                        icon: 'ðŸ’€',
                        title: 'Expert Mode',
                        body: 'For hardened cypherpunks only - <strong>brutal enemies</strong> that test your strategic thinking and party coordination.',
                        tags: ['free'],
                        footer: 'Privacy is worth the struggle'
                    },
                    {
                        icon: 'ðŸ“Š',
                        title: 'Dynamic Difficulty',
                        body: 'Loads different <strong>boss stat JSON files</strong> based on difficulty. Expert has higher boss HP, damage, and abilities.',
                        tags: ['free'],
                        footer: 'Boss data: bosses_data_hard.json'
                    }
                ]
            },
            // Music & Audio
            'musicTicker': {
                slides: [
                    {
                        icon: 'ðŸ’›',
                        title: 'Learn About Zcash',
                        body: 'The ticker displays <strong>real Zcash ecosystem facts</strong>! Learn about shielded transactions, zero-knowledge proofs, the Zcash Foundation, and privacy technology while you play.',
                        tags: ['zcash', 'free'],
                        footer: 'Education through entertainment'
                    },
                    {
                        icon: 'ðŸ“š',
                        title: 'Dynamic Fact System',
                        body: 'Facts loaded from <strong>ticker_facts.json</strong> - a curated database of Zcash knowledge. New facts appear with each song change.',
                        tags: ['free'],
                        footer: 'Facts rotate with each track'
                    }
                ]
            },
            'musicControls': {
                slides: [
                    {
                        icon: 'ðŸŽµ',
                        title: 'Tunnels of Doom Tribute',
                        body: 'Music inspired by <strong>Hank Mishkoff\'s</strong> iconic theme song for the TI-99/4A classic <strong>Tunnels of Doom</strong> (1982). The original drew from D&D, Infocom Adventures, and Wizardry.',
                        tags: ['free'],
                        footer: 'Remixed with permission from Hank Mishkoff'
                    },
                    {
                        icon: 'ðŸ¤–',
                        title: 'AI-Remixed Music',
                        body: 'All 10 theme tracks were <strong>AI-remixed</strong> using AiVideo.com, reimagining the classic Tunnels of Doom sound for a modern cyberpunk-fantasy atmosphere.',
                        tags: ['ai', 'paid'],
                        footer: 'Music: AiVideo.com â€¢ Original: Hank Mishkoff'
                    }
                ]
            },
            // Story & Visuals
            'dungeonMenuBackground': {
                slides: [
                    {
                        icon: 'ðŸ“–',
                        title: 'The Zcash Story',
                        body: 'The story follows heroes fighting to protect <strong>financial privacy</strong> in a world where personal data has become currency. Privacy is treasure, and those who steal it become corrupted.',
                        tags: ['zcash'],
                        footer: 'Privacy: The ultimate treasure'
                    },
                    {
                        icon: 'ðŸŽ¬',
                        title: 'AI Story Animations',
                        body: '<strong>Sprite atlas animations</strong> (8Ã—16 = 128 frames at 16fps) play as backgrounds. All sequences were AI-generated as video, then converted to sprite sheets.<br><br>ðŸŽ¥ <strong>Video:</strong> AiVideo.com<br>ðŸ“– <strong>Story:</strong> ChatGPT',
                        tags: ['ai', 'paid'],
                        footer: 'Video by AiVideo.com â€¢ Story by ChatGPT'
                    }
                ]
            },
            // Heroes - with proper Zcash bios
            'dungeonZooko': {
                slides: [
                    {
                        icon: 'ðŸ’›',
                        title: 'Zooko Wilcox-O\'Hearn',
                        body: '<strong>Named after the founder of Zcash</strong>. The real Zooko is a cryptographer and cypherpunk who created Zcash to give everyone access to private, digital money. In-game, Zooko is the party\'s wise protector.',
                        tags: ['zcash'],
                        footer: 'Role: Guardian â€¢ Shield abilities'
                    },
                    {
                        icon: 'ðŸŽ¨',
                        title: 'AI-Generated Hero Art',
                        body: 'All character portraits, sprites, and animations were <strong>AI-generated</strong> using licensed assets and image generation tools from Envato.com.',
                        tags: ['ai', 'paid'],
                        footer: 'Art: Envato.com'
                    }
                ]
            },
            'dungeonNate': {
                slides: [
                    {
                        icon: 'ðŸ’›',
                        title: 'Nathan Wilcox',
                        body: '<strong>Named after Zcash\'s former CTO</strong>. Nathan helped build the technical foundation of Zcash and led engineering efforts. In-game, Nate is the fierce warrior who charges into battle.',
                        tags: ['zcash'],
                        footer: 'Role: Warrior â€¢ Heavy damage dealer'
                    },
                    {
                        icon: 'ðŸŽ¨',
                        title: 'AI-Generated Hero Art',
                        body: 'All character portraits, sprites, and animations were <strong>AI-generated</strong> using licensed assets and image generation tools from Envato.com.',
                        tags: ['ai', 'paid'],
                        footer: 'Art: Envato.com'
                    }
                ]
            },
            'dungeonZancas': {
                slides: [
                    {
                        icon: 'ðŸ’›',
                        title: 'Josh "Zancas" Wilcox',
                        body: '<strong>Named after Zcash developer Josh Wilcox (zancas)</strong>. Josh created Zingo Wallet and contributed to numerous Zcash projects. In-game, Zancas represents precision, innovation, and relentless dedication to privacy tools.',
                        tags: ['zcash'],
                        footer: 'Role: Rogue â€¢ Precision striker'
                    },
                    {
                        icon: 'ðŸŽ¨',
                        title: 'AI-Generated Hero Art',
                        body: 'All character portraits, sprites, and animations were <strong>AI-generated</strong> using licensed assets and image generation tools from Envato.com.',
                        tags: ['ai', 'paid'],
                        footer: 'Art: Envato.com'
                    }
                ]
            },
            'dungeonCyberAxe': {
                slides: [
                    {
                        icon: 'ðŸ’›',
                        title: 'Community Champion',
                        body: '<strong>CyberAxe represents the Zcash community</strong> - the developers, advocates, and users who power the network. Electric abilities symbolize the distributed, unstoppable nature of decentralized privacy.',
                        tags: ['zcash'],
                        footer: 'Role: Mage â€¢ Electric storm attacks'
                    },
                    {
                        icon: 'ðŸŽ¨',
                        title: 'AI-Generated Hero Art',
                        body: 'All character portraits, sprites, and animations were <strong>AI-generated</strong> using licensed assets and image generation tools from Envato.com.',
                        tags: ['ai', 'paid'],
                        footer: 'Art: Envato.com'
                    }
                ]
            },
            // Version/Credits
            'versionDisplay': {
                slides: [
                    {
                        icon: 'ðŸ’›',
                        title: 'Zcash Hackathon 2025',
                        body: 'Built to showcase <strong>Zcash values</strong>: privacy, freedom, and the right to transact without surveillance. The game teaches crypto concepts through gameplay and story.',
                        tags: ['zcash'],
                        footer: 'Privacy is normal. Privacy is freedom.'
                    },
                    {
                        icon: 'ðŸ¤–',
                        title: '100% AI-Developed Game',
                        body: '<strong>EVERYTHING</strong> in this game was AI-generated:<br>â€¢ Code: GitHub Copilot (Claude)<br>â€¢ Art: AI image generation<br>â€¢ Music: Suno AI<br>â€¢ Story: ChatGPT<br>â€¢ Video: AiVideo.com<br>â€¢ Sound FX: AI audio tools',
                        tags: ['ai'],
                        footer: 'Built for Zcash Hackathon 2025'
                    }
                ]
            },
            // Multiplayer
            'heroSelectionCode': {
                slides: [
                    {
                        icon: 'ðŸ‘¥',
                        title: 'Party Up!',
                        body: 'Join forces with up to <strong>4 players</strong> to explore the Tunnels together. Each player controls one hero - coordinate your attacks and protect each other!',
                        tags: ['multiplayer', 'free'],
                        footer: 'Stronger together'
                    },
                    {
                        icon: 'ðŸŒ',
                        title: 'WebSocket Multiplayer',
                        body: 'Real-time <strong>4-player co-op</strong> using WebSocket connections. Host creates room, clients join with 6-character code. Turn-based combat with live state sync.',
                        tags: ['multiplayer', 'free'],
                        footer: 'Python WebSocket server on port 8765'
                    }
                ]
            },
            // ===== TITLE SCREEN TOOLTIPS =====
            'dungeonLevelDisplay': {
                slides: [
                    {
                        icon: 'ðŸ°',
                        title: 'Dungeon Depth',
                        body: 'Your current <strong>depth in the Tunnels of Privacy</strong>. Deeper levels have stronger enemies but better rewards. Each level has rooms to explore, a boss to defeat, and captives to rescue.',
                        tags: ['zcash', 'free'],
                        footer: 'Descend deeper to find greater treasures'
                    },
                    {
                        icon: 'ðŸ“Š',
                        title: 'Level Progress',
                        body: '<strong>Track your exploration:</strong><br>â€¢ Rooms: Encounters completed<br>â€¢ Boss: Level guardian status<br>â€¢ Store: Merchant visited<br>â€¢ Captives: NPCs rescued<br>â€¢ Total Bosses: Career defeats',
                        tags: ['free'],
                        footer: 'Clear the boss to descend deeper'
                    }
                ]
            },
            'startAdventureBtn': {
                slides: [
                    {
                        icon: 'âš”ï¸',
                        title: 'Begin Your Quest',
                        body: 'Enter the <strong>Tunnels of Privacy</strong> - ancient passages where financial freedom is defended. Lead your party of heroes against surveillance, data harvesters, and corrupted entities.',
                        tags: ['zcash', 'free'],
                        footer: 'Protect the right to privacy!'
                    },
                    {
                        icon: 'ðŸŽ®',
                        title: 'Dungeon Crawler RPG',
                        body: '<strong>Turn-based combat</strong> with D&D mechanics, AI-generated encounters, procedural levels, and persistent hero progression. Single player or 4-player co-op!',
                        tags: ['ai', 'multiplayer', 'free'],
                        footer: 'Progress saves automatically'
                    }
                ]
            },
            'enterArcadeBtn': {
                slides: [
                    {
                        icon: 'ðŸŽ¯',
                        title: 'ZLOCK CONSENSUS',
                        body: 'The <strong>other half of this universe</strong>! ZLOCK CONSENSUS is a 3D puzzle arcade game where the same heroes solve block puzzles. Your hero stats carry between both games!',
                        tags: ['zcash', 'free'],
                        footer: 'Portal System: Shared heroes & progress'
                    },
                    {
                        icon: 'ðŸ•¹ï¸',
                        title: '3D Puzzle Game',
                        body: '<strong>Three.js-powered</strong> arcade puzzler with falling blocks, combos, and special abilities. Same 4 heroes, different gameplay. XP earned in either game levels up your characters!',
                        tags: ['ai', 'free'],
                        footer: 'Built with Three.js â€¢ WebGL renderer'
                    }
                ]
            },
            'aboutDonateBtn': {
                slides: [
                    {
                        icon: 'ðŸ’›',
                        title: 'Support Zcash',
                        body: 'This game was created to <strong>spread awareness about Zcash</strong> and financial privacy. Donations help fund continued development and more educational content.',
                        tags: ['zcash'],
                        footer: 'Every ZEC helps!'
                    },
                    {
                        icon: 'ðŸ™',
                        title: 'About This Project',
                        body: 'A <strong>Zcash Hackathon 2025</strong> entry demonstrating how AI can create complete games. 100% AI-developed: code, art, music, story, and more. Open source and free to play!',
                        tags: ['ai', 'free'],
                        footer: 'Made with â¤ï¸ for the Zcash community'
                    }
                ]
            },
            'titleBackground': {
                slides: [
                    {
                        icon: 'ðŸ“–',
                        title: 'The Story',
                        body: 'In a world where <strong>personal data became currency</strong>, privacy itself is treasure. The Tunnels are ancient passages where defenders of financial freedom fight back against surveillance.',
                        tags: ['zcash'],
                        footer: 'A tale of privacy vs surveillance'
                    },
                    {
                        icon: 'ðŸŽ¬',
                        title: 'AI Story Animations',
                        body: '<strong>Sprite atlas animations</strong> (8Ã—16 = 128 frames) created by converting AI-generated video to sprite sheets. Background tells the story while you play!',
                        tags: ['ai', 'paid'],
                        footer: 'Video: AiVideo.com â€¢ Story: ChatGPT'
                    }
                ]
            }
        };
        
        // Initialize tooltip system
        function initTooltipSystem() {
            const tooltip = document.getElementById('infoTooltip');
            if (!tooltip) return;
            
            // Add wheel event listener to tooltip for slide navigation
            tooltip.addEventListener('wheel', handleTooltipWheel, { passive: false });
            
            // Add event listeners to all elements with tooltip data
            Object.keys(TOOLTIP_DATA).forEach(elementId => {
                const element = document.getElementById(elementId);
                if (element) {
                    element.addEventListener('mouseenter', (e) => showTooltipDelayed(e, elementId));
                    element.addEventListener('mouseleave', hideTooltip);
                    element.addEventListener('mousemove', updateTooltipPosition);
                }
            });
            
            // Also handle elements by class
            document.querySelectorAll('[data-tooltip-id]').forEach(element => {
                const tooltipId = element.getAttribute('data-tooltip-id');
                if (TOOLTIP_DATA[tooltipId]) {
                    element.addEventListener('mouseenter', (e) => showTooltipDelayed(e, tooltipId));
                    element.addEventListener('mouseleave', hideTooltip);
                    element.addEventListener('mousemove', updateTooltipPosition);
                }
            });
        }
        
        function showTooltipDelayed(event, tooltipId) {
            clearTimeout(tooltipTimeout);
            clearInterval(tooltipSlideInterval);
            currentTooltipElement = event.target;
            currentTooltipId = tooltipId;
            currentSlideIndex = 0;
            
            tooltipTimeout = setTimeout(() => {
                showTooltip(event, tooltipId);
            }, TOOLTIP_DELAY);
        }
        
        function showTooltip(event, tooltipId) {
            const tooltip = document.getElementById('infoTooltip');
            const data = TOOLTIP_DATA[tooltipId];
            if (!tooltip || !data || !data.slides) return;
            
            currentSlideIndex = 0;
            renderTooltipSlide(tooltip, data, currentSlideIndex);
            
            updateTooltipPosition(event);
            tooltip.classList.add('visible');
            
            // Start slideshow if multiple slides
            if (data.slides.length > 1) {
                clearInterval(tooltipSlideInterval);
                tooltipSlideInterval = setInterval(() => {
                    currentSlideIndex = (currentSlideIndex + 1) % data.slides.length;
                    renderTooltipSlide(tooltip, data, currentSlideIndex);
                }, TOOLTIP_SLIDE_INTERVAL);
            }
        }
        
        function renderTooltipSlide(tooltip, data, slideIndex) {
            const slide = data.slides[slideIndex];
            if (!slide) return;
            
            // Build tags HTML
            let tagsHtml = '';
            if (slide.tags) {
                slide.tags.forEach(tag => {
                    const tagLabels = {
                        'ai': 'ðŸ¤– AI-Generated',
                        'free': 'âœ… Free',
                        'paid': 'ðŸ’³ Paid API',
                        'local': 'ðŸ’» Local',
                        'zcash': 'ðŸ’› Zcash',
                        'multiplayer': 'ðŸ‘¥ Multiplayer'
                    };
                    tagsHtml += `<span class="tooltip-tag tag-${tag}">${tagLabels[tag] || tag}</span>`;
                });
            }
            
            // Build slide dots HTML
            let dotsHtml = '';
            if (data.slides.length > 1) {
                dotsHtml = '<div class="tooltip-dots">';
                for (let i = 0; i < data.slides.length; i++) {
                    dotsHtml += `<span class="tooltip-dot ${i === slideIndex ? 'active' : ''}" onclick="goToTooltipSlide(${i})"></span>`;
                }
                dotsHtml += '</div>';
            }
            
            tooltip.innerHTML = `
                <div class="tooltip-header">
                    <span class="tooltip-icon">${slide.icon}</span>
                    <span class="tooltip-title">${slide.title}</span>
                    ${dotsHtml}
                </div>
                <div class="tooltip-body">
                    ${slide.body}
                    <div style="margin-top: 8px;">${tagsHtml}</div>
                </div>
                ${slide.footer ? `<div class="tooltip-footer">â„¹ï¸ ${slide.footer}</div>` : ''}
            `;
        }
        
        function goToTooltipSlide(index) {
            const tooltip = document.getElementById('infoTooltip');
            const data = TOOLTIP_DATA[currentTooltipId];
            if (!tooltip || !data || !data.slides) return;
            
            currentSlideIndex = index;
            renderTooltipSlide(tooltip, data, currentSlideIndex);
            
            // Reset the interval timer
            if (data.slides.length > 1) {
                clearInterval(tooltipSlideInterval);
                tooltipSlideInterval = setInterval(() => {
                    currentSlideIndex = (currentSlideIndex + 1) % data.slides.length;
                    renderTooltipSlide(tooltip, data, currentSlideIndex);
                }, TOOLTIP_SLIDE_INTERVAL);
            }
        }
        
        function handleTooltipWheel(event) {
            const data = TOOLTIP_DATA[currentTooltipId];
            if (!data || !data.slides || data.slides.length <= 1) return;
            
            event.preventDefault();
            
            // Scroll down = next slide, scroll up = previous slide
            if (event.deltaY > 0) {
                currentSlideIndex = (currentSlideIndex + 1) % data.slides.length;
            } else {
                currentSlideIndex = (currentSlideIndex - 1 + data.slides.length) % data.slides.length;
            }
            
            const tooltip = document.getElementById('infoTooltip');
            renderTooltipSlide(tooltip, data, currentSlideIndex);
            
            // Reset the interval timer
            clearInterval(tooltipSlideInterval);
            tooltipSlideInterval = setInterval(() => {
                currentSlideIndex = (currentSlideIndex + 1) % data.slides.length;
                renderTooltipSlide(tooltip, data, currentSlideIndex);
            }, TOOLTIP_SLIDE_INTERVAL);
        }
        
        function updateTooltipPosition(event) {
            const tooltip = document.getElementById('infoTooltip');
            if (!tooltip) return;
            
            const padding = 15;
            let x = event.clientX + padding;
            let y = event.clientY + padding;
            
            // Keep tooltip on screen
            const rect = tooltip.getBoundingClientRect();
            if (x + rect.width > window.innerWidth - padding) {
                x = event.clientX - rect.width - padding;
            }
            if (y + rect.height > window.innerHeight - padding) {
                y = event.clientY - rect.height - padding;
            }
            
            tooltip.style.left = `${x}px`;
            tooltip.style.top = `${y}px`;
        }
        
        function hideTooltip() {
            clearTimeout(tooltipTimeout);
            clearInterval(tooltipSlideInterval);
            const tooltip = document.getElementById('infoTooltip');
            if (tooltip) {
                tooltip.classList.remove('visible');
            }
            currentTooltipElement = null;
            currentTooltipId = null;
            currentSlideIndex = 0;
        }
        // ===== END HACKATHON INFO TOOLTIP SYSTEM =====
        
        // ===== LEVEL PROGRESS TRACKING =====
        let levelProgress = {
            roomsExplored: 0,
            roomsMax: '?',
            bossDefeated: false,
            storeVisited: false,
            captivesFreed: 0,
            totalBossesDefeated: 0
        };
        
        function resetLevelProgress() {
            levelProgress.roomsExplored = 0;
            levelProgress.roomsMax = '?';
            levelProgress.bossDefeated = false;
            levelProgress.storeVisited = false;
            levelProgress.captivesFreed = 0;
            updateLevelProgressDisplay();
            saveLevelProgress();
            broadcastLevelProgress();
        }
        
        function updateLevelProgressDisplay() {
            // Update the level stats in the dungeon level display (title screen)
            const roomsExploredEl = document.getElementById('levelRoomsExplored');
            const roomsMaxEl = document.getElementById('levelRoomsMax');
            const bossDefeatedEl = document.getElementById('levelBossDefeated');
            const storeVisitedEl = document.getElementById('levelStoreVisited');
            const captivesFreedEl = document.getElementById('levelCaptivesFreed');
            const totalBossesEl = document.getElementById('totalBossesDefeated');
            
            if (roomsExploredEl) roomsExploredEl.textContent = levelProgress.roomsExplored;
            if (roomsMaxEl) roomsMaxEl.textContent = levelProgress.roomsMax;
            if (bossDefeatedEl) bossDefeatedEl.textContent = levelProgress.bossDefeated ? '1' : '0';
            if (storeVisitedEl) storeVisitedEl.textContent = levelProgress.storeVisited ? '1' : '0';
            if (captivesFreedEl) captivesFreedEl.textContent = levelProgress.captivesFreed;
            if (totalBossesEl) totalBossesEl.textContent = levelProgress.totalBossesDefeated;
            
            // Update the level stats in the dungeon menu (dm = dungeon menu)
            const dmRoomsExploredEl = document.getElementById('dmRoomsExplored');
            const dmRoomsMaxEl = document.getElementById('dmRoomsMax');
            const dmBossDefeatedEl = document.getElementById('dmBossDefeated');
            const dmStoreVisitedEl = document.getElementById('dmStoreVisited');
            const dmCaptivesFreedEl = document.getElementById('dmCaptivesFreed');
            const dmTotalBossesEl = document.getElementById('dmTotalBossesDefeated');
            
            if (dmRoomsExploredEl) dmRoomsExploredEl.textContent = levelProgress.roomsExplored;
            if (dmRoomsMaxEl) dmRoomsMaxEl.textContent = levelProgress.roomsMax;
            if (dmBossDefeatedEl) dmBossDefeatedEl.textContent = levelProgress.bossDefeated ? '1' : '0';
            if (dmStoreVisitedEl) dmStoreVisitedEl.textContent = levelProgress.storeVisited ? '1' : '0';
            if (dmCaptivesFreedEl) dmCaptivesFreedEl.textContent = levelProgress.captivesFreed;
            if (dmTotalBossesEl) dmTotalBossesEl.textContent = levelProgress.totalBossesDefeated;
        }
        
        function incrementRoomsExplored() {
            levelProgress.roomsExplored++;
            updateLevelProgressDisplay();
            saveLevelProgress();
            broadcastLevelProgress();
        }
        
        function markBossDefeated() {
            levelProgress.bossDefeated = true;
            levelProgress.totalBossesDefeated++;
            updateLevelProgressDisplay();
            saveLevelProgress();
            broadcastLevelProgress();
            
            // Also save to sharedSave bossesDefeated array
            try {
                const sharedSave = loadSharedSave();
                if (sharedSave && sharedSave.dungeonState && sharedSave.dungeonState.questProgress) {
                    const currentLevel = parseInt(document.getElementById('dungeonLevel')?.textContent || document.getElementById('dungeonMenuLevel')?.textContent) || 1;
                    if (!sharedSave.dungeonState.questProgress.bossesDefeated.includes(currentLevel)) {
                        sharedSave.dungeonState.questProgress.bossesDefeated.push(currentLevel);
                        saveSharedSave(sharedSave);
                    }
                }
            } catch (e) {
                console.error('[LevelProgress] Error saving boss defeat:', e);
            }
        }
        
        function markStoreVisited() {
            levelProgress.storeVisited = true;
            updateLevelProgressDisplay();
            saveLevelProgress();
            broadcastLevelProgress();
        }
        
        function incrementCaptivesFreed() {
            levelProgress.captivesFreed++;
            updateLevelProgressDisplay();
            saveLevelProgress();
            broadcastLevelProgress();
        }
        
        function loadTotalBossesDefeated() {
            try {
                const sharedSave = loadSharedSave();
                if (sharedSave && sharedSave.dungeonState && sharedSave.dungeonState.questProgress) {
                    levelProgress.totalBossesDefeated = sharedSave.dungeonState.questProgress.bossesDefeated.length || 0;
                }
            } catch (e) {
                console.error('[LevelProgress] Error loading boss count:', e);
            }
            updateLevelProgressDisplay();
        }
        
        // Save current level progress to sharedSave
        function saveLevelProgress() {
            // Only host saves in multiplayer
            if (multiplayerState.enabled && multiplayerState.role === 'client') return;
            
            try {
                const sharedSave = loadSharedSave();
                if (sharedSave && sharedSave.dungeonState) {
                    const currentLevel = parseInt(document.getElementById('dungeonLevel')?.textContent || document.getElementById('dungeonMenuLevel')?.textContent) || 1;
                    
                    // Initialize levelProgress storage if not exists
                    if (!sharedSave.dungeonState.levelProgress) {
                        sharedSave.dungeonState.levelProgress = {};
                    }
                    
                    // Save current level's progress
                    sharedSave.dungeonState.levelProgress[currentLevel] = {
                        roomsExplored: levelProgress.roomsExplored,
                        bossDefeated: levelProgress.bossDefeated,
                        storeVisited: levelProgress.storeVisited,
                        captivesFreed: levelProgress.captivesFreed
                    };
                    
                    saveSharedSave(sharedSave);
                }
            } catch (e) {
                console.error('[LevelProgress] Error saving level progress:', e);
            }
        }
        
        // Load level progress for current level from sharedSave
        function loadLevelProgress() {
            try {
                const sharedSave = loadSharedSave();
                const currentLevel = parseInt(document.getElementById('dungeonLevel')?.textContent || document.getElementById('dungeonMenuLevel')?.textContent) || 1;
                
                // Load total bosses defeated
                if (sharedSave && sharedSave.dungeonState && sharedSave.dungeonState.questProgress) {
                    levelProgress.totalBossesDefeated = sharedSave.dungeonState.questProgress.bossesDefeated.length || 0;
                }
                
                // Load this level's progress if exists
                if (sharedSave && sharedSave.dungeonState && sharedSave.dungeonState.levelProgress && sharedSave.dungeonState.levelProgress[currentLevel]) {
                    const saved = sharedSave.dungeonState.levelProgress[currentLevel];
                    levelProgress.roomsExplored = saved.roomsExplored || 0;
                    levelProgress.bossDefeated = saved.bossDefeated || false;
                    levelProgress.storeVisited = saved.storeVisited || false;
                    levelProgress.captivesFreed = saved.captivesFreed || 0;
                } else {
                    // No saved progress for this level - reset
                    levelProgress.roomsExplored = 0;
                    levelProgress.bossDefeated = false;
                    levelProgress.storeVisited = false;
                    levelProgress.captivesFreed = 0;
                }
                
                updateLevelProgressDisplay();
            } catch (e) {
                console.error('[LevelProgress] Error loading level progress:', e);
            }
        }
        
        // Broadcast level progress to all clients (host only)
        function broadcastLevelProgress() {
            if (!multiplayerState.enabled || multiplayerState.role !== 'host') return;
            
            sendWebSocketMessage({
                type: 'level_progress_update',
                progress: {
                    roomsExplored: levelProgress.roomsExplored,
                    roomsMax: levelProgress.roomsMax,
                    bossDefeated: levelProgress.bossDefeated,
                    storeVisited: levelProgress.storeVisited,
                    captivesFreed: levelProgress.captivesFreed,
                    totalBossesDefeated: levelProgress.totalBossesDefeated
                }
            });
        }
        
        // Client receives level progress from host
        function updateLevelProgressFromHost(progress) {
            levelProgress.roomsExplored = progress.roomsExplored || 0;
            levelProgress.roomsMax = progress.roomsMax || '?';
            levelProgress.bossDefeated = progress.bossDefeated || false;
            levelProgress.storeVisited = progress.storeVisited || false;
            levelProgress.captivesFreed = progress.captivesFreed || 0;
            levelProgress.totalBossesDefeated = progress.totalBossesDefeated || 0;
            updateLevelProgressDisplay();
        }
        // ===== END LEVEL PROGRESS TRACKING =====
        
        // ===== LEVEL LAYOUT SYSTEM =====
        // Defines the structure of each dungeon level - rooms, encounters, stores, etc.
        let currentLevelLayout = null;
        
        // Room types for level generation
        const ROOM_TYPES = {
            COMBAT: 'combat',           // Standard combat room with mobs
            BOSS: 'boss',               // Level boss room
            MINI_BOSS: 'miniBoss',      // Mini-boss encounter
            STORE: 'store',             // Shop/merchant room
            NPC: 'npc',                 // Non-combat NPC interaction
            EXPLORATION: 'exploration', // Exploration/puzzle room
            SECRET: 'secret',           // Hidden room (requires discovery)
            CAPTIVE: 'captive'          // Room with captive NPC to rescue
        };
        
        // Generate level layout based on dungeon level
        function generateLevelLayout(level) {
            // Base room counts that scale with level
            const baseRooms = 4 + Math.floor(level / 3); // 4 rooms at level 1, increases every 3 levels
            const maxRooms = Math.min(baseRooms, 12); // Cap at 12 rooms per level
            
            // Calculate room distribution
            const combatRooms = Math.max(2, Math.floor(maxRooms * 0.4)); // 40% combat
            const miniBossRooms = level >= 3 ? Math.min(Math.floor(level / 5), 2) : 0; // Mini-bosses start at level 3
            const npcRooms = Math.max(1, Math.floor(maxRooms * 0.15)); // 15% NPC
            const explorationRooms = Math.max(1, Math.floor(maxRooms * 0.15)); // 15% exploration
            const secretRooms = Math.random() < 0.3 + (level * 0.02) ? 1 : 0; // 30%+ chance of secret room
            const hasStore = Math.random() < 0.6 + (level * 0.02); // 60%+ chance of store
            const captiveRooms = Math.random() < 0.4 ? 1 : 0; // 40% chance of captive
            
            // Build rooms array
            const rooms = [];
            let roomId = 1;
            
            // Always add the boss room (last room to be encountered)
            rooms.push({
                id: roomId++,
                type: ROOM_TYPES.BOSS,
                explored: false,
                accessible: false, // Boss unlocks after other rooms explored
                data: null // Will be populated by LLM
            });
            
            // Add mini-boss rooms
            for (let i = 0; i < miniBossRooms; i++) {
                rooms.push({
                    id: roomId++,
                    type: ROOM_TYPES.MINI_BOSS,
                    explored: false,
                    accessible: true,
                    data: null
                });
            }
            
            // Add combat rooms
            for (let i = 0; i < combatRooms; i++) {
                rooms.push({
                    id: roomId++,
                    type: ROOM_TYPES.COMBAT,
                    explored: false,
                    accessible: true,
                    data: null
                });
            }
            
            // Add store if present
            if (hasStore) {
                rooms.push({
                    id: roomId++,
                    type: ROOM_TYPES.STORE,
                    explored: false,
                    accessible: true,
                    data: null
                });
            }
            
            // Add NPC rooms
            for (let i = 0; i < npcRooms; i++) {
                rooms.push({
                    id: roomId++,
                    type: ROOM_TYPES.NPC,
                    explored: false,
                    accessible: true,
                    data: null
                });
            }
            
            // Add exploration rooms
            for (let i = 0; i < explorationRooms; i++) {
                rooms.push({
                    id: roomId++,
                    type: ROOM_TYPES.EXPLORATION,
                    explored: false,
                    accessible: true,
                    data: null
                });
            }
            
            // Add captive room if present
            if (captiveRooms > 0) {
                rooms.push({
                    id: roomId++,
                    type: ROOM_TYPES.CAPTIVE,
                    explored: false,
                    accessible: true,
                    data: null
                });
            }
            
            // Add secret rooms (not initially accessible)
            for (let i = 0; i < secretRooms; i++) {
                rooms.push({
                    id: roomId++,
                    type: ROOM_TYPES.SECRET,
                    explored: false,
                    accessible: false, // Must be discovered
                    discoveryHint: generateSecretRoomHint(),
                    data: null
                });
            }
            
            // Shuffle non-boss rooms to randomize encounter order
            const bossRoom = rooms.find(r => r.type === ROOM_TYPES.BOSS);
            const otherRooms = rooms.filter(r => r.type !== ROOM_TYPES.BOSS);
            shuffleArray(otherRooms);
            
            const layout = {
                level: level,
                totalRooms: rooms.length,
                accessibleRooms: rooms.filter(r => r.accessible).length,
                rooms: otherRooms, // Boss is separate
                bossRoom: bossRoom,
                hasStore: hasStore,
                storeFound: false,
                secretRoomsTotal: secretRooms,
                secretRoomsFound: 0,
                roomQueue: [...otherRooms.filter(r => r.accessible)], // Queue of accessible unexplored rooms
                generatedAt: Date.now()
            };
            
            return layout;
        }
        
        // Generate hint for finding secret rooms
        function generateSecretRoomHint() {
            const hints = [
                'A draft of cold air seeps through a crack in the wall...',
                'Strange markings on the floor point toward a shadowy corner...',
                'The echo of your footsteps sounds hollow near one wall...',
                'A faint glow emanates from behind loose stones...',
                'Dust patterns suggest something has moved here recently...'
            ];
            return hints[Math.floor(Math.random() * hints.length)];
        }
        
        // Shuffle array in place (Fisher-Yates)
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }
        
        // Get the next room to explore based on level layout
        function getNextRoomFromLayout() {
            if (!currentLevelLayout) return null;
            
            // Get unexplored accessible rooms
            const availableRooms = currentLevelLayout.rooms.filter(r => !r.explored && r.accessible);
            
            // Check if boss room should be accessible
            const nonBossRoomsExplored = currentLevelLayout.rooms.filter(r => r.explored && r.type !== ROOM_TYPES.SECRET).length;
            const requiredForBoss = Math.floor(currentLevelLayout.accessibleRooms * 0.7); // Need 70% explored for boss
            
            if (nonBossRoomsExplored >= requiredForBoss && !currentLevelLayout.bossRoom.explored) {
                currentLevelLayout.bossRoom.accessible = true;
            }
            
            // If no regular rooms left, check boss
            if (availableRooms.length === 0) {
                if (currentLevelLayout.bossRoom.accessible && !currentLevelLayout.bossRoom.explored) {
                    return currentLevelLayout.bossRoom;
                }
                return null; // Level complete
            }
            
            // Calculate room selection weights based on what's been found
            // If store hasn't been found and few rooms left, increase store odds
            const roomWeights = availableRooms.map(room => {
                let weight = 1;
                
                if (room.type === ROOM_TYPES.STORE && !currentLevelLayout.storeFound) {
                    // Increase store weight as fewer rooms remain
                    const remainingRatio = availableRooms.length / currentLevelLayout.accessibleRooms;
                    weight = remainingRatio < 0.3 ? 5 : (remainingRatio < 0.5 ? 3 : 1);
                }
                
                return { room, weight };
            });
            
            // Weighted random selection
            const totalWeight = roomWeights.reduce((sum, rw) => sum + rw.weight, 0);
            let random = Math.random() * totalWeight;
            
            for (const rw of roomWeights) {
                random -= rw.weight;
                if (random <= 0) {
                    return rw.room;
                }
            }
            
            // Fallback to first available
            return availableRooms[0];
        }
        
        // Get the next room TYPE as a string for encounter generation
        // This is used by preGenerateNextEncounter() to determine what kind of content to generate
        function getNextRoomType() {
            // Get the next room from the layout
            const nextRoom = getNextRoomFromLayout();
            
            // If no room or no layout, default to combat
            if (!nextRoom) {
                return 'combat';
            }
            
            // Map internal room types to the encounter generation types
            const typeMapping = {
                [ROOM_TYPES.COMBAT]: 'combat',
                [ROOM_TYPES.BOSS]: 'boss',
                [ROOM_TYPES.MINI_BOSS]: 'mini_boss',
                [ROOM_TYPES.STORE]: 'store',
                [ROOM_TYPES.NPC]: 'npc',
                [ROOM_TYPES.EXPLORATION]: 'exploration',
                [ROOM_TYPES.SECRET]: 'secret',
                [ROOM_TYPES.CAPTIVE]: 'combat' // Captive rooms have combat + captive
            };
            
            return typeMapping[nextRoom.type] || 'combat';
        }
        
        // Mark a room as explored
        function markRoomExplored(roomId) {
            if (!currentLevelLayout) return;
            
            const room = currentLevelLayout.rooms.find(r => r.id === roomId);
            if (room) {
                room.explored = true;
                
                // Update store found flag
                if (room.type === ROOM_TYPES.STORE) {
                    currentLevelLayout.storeFound = true;
                }
                
                // Update secret room count
                if (room.type === ROOM_TYPES.SECRET) {
                    currentLevelLayout.secretRoomsFound++;
                }
            }
            
            // Check boss room
            if (currentLevelLayout.bossRoom && currentLevelLayout.bossRoom.id === roomId) {
                currentLevelLayout.bossRoom.explored = true;
            }
            
            // Save layout
            saveLevelLayout();
        }
        
        // Save level layout to sharedSave
        function saveLevelLayout() {
            if (multiplayerState.enabled && multiplayerState.role === 'client') return;
            
            try {
                const sharedSave = loadSharedSave();
                if (sharedSave && sharedSave.dungeonState) {
                    if (!sharedSave.dungeonState.levelLayouts) {
                        sharedSave.dungeonState.levelLayouts = {};
                    }
                    sharedSave.dungeonState.levelLayouts[currentLevelLayout.level] = currentLevelLayout;
                    saveSharedSave(sharedSave);
                }
            } catch (e) {
                console.error('[LevelLayout] Error saving:', e);
            }
        }
        
        // Load level layout from sharedSave or generate new
        function loadOrGenerateLevelLayout(level) {
            try {
                const sharedSave = loadSharedSave();
                
                // Check if layout exists for this level
                if (sharedSave?.dungeonState?.levelLayouts?.[level]) {
                    currentLevelLayout = sharedSave.dungeonState.levelLayouts[level];
                    console.log(`[LevelLayout] Loaded existing layout for level ${level}:`, currentLevelLayout.totalRooms, 'rooms');
                } else {
                    // Generate new layout
                    currentLevelLayout = generateLevelLayout(level);
                    console.log(`[LevelLayout] Generated new layout for level ${level}:`, currentLevelLayout.totalRooms, 'rooms');
                    saveLevelLayout();
                }
                
                // Update level progress max rooms display
                levelProgress.roomsMax = currentLevelLayout.totalRooms;
                updateLevelProgressDisplay();
                
                // Update store button state based on whether store is found
                updateStoreButtonState();
                
            } catch (e) {
                console.error('[LevelLayout] Error loading/generating:', e);
                currentLevelLayout = generateLevelLayout(level);
            }
        }
        
        // Alias for initializeLevelLayout - used by stairs and game start
        function initializeLevelLayout(level) {
            loadOrGenerateLevelLayout(level);
        }
        
        // Get room type display name
        function getRoomTypeName(type) {
            const names = {
                [ROOM_TYPES.COMBAT]: 'Combat Room',
                [ROOM_TYPES.BOSS]: 'Boss Chamber',
                [ROOM_TYPES.MINI_BOSS]: 'Mini-Boss Lair',
                [ROOM_TYPES.STORE]: 'Merchant\'s Den',
                [ROOM_TYPES.NPC]: 'Meeting Hall',
                [ROOM_TYPES.EXPLORATION]: 'Mysterious Chamber',
                [ROOM_TYPES.SECRET]: 'Hidden Room',
                [ROOM_TYPES.CAPTIVE]: 'Prison Cell'
            };
            return names[type] || 'Unknown Room';
        }
        
        // Check if level is complete (all non-secret rooms explored + boss defeated)
        function isLevelComplete() {
            if (!currentLevelLayout) return false;
            
            const requiredRooms = currentLevelLayout.rooms.filter(r => r.type !== ROOM_TYPES.SECRET);
            const allExplored = requiredRooms.every(r => r.explored);
            const bossDefeated = currentLevelLayout.bossRoom.explored;
            
            return allExplored && bossDefeated;
        }
        // ===== END LEVEL LAYOUT SYSTEM =====
        
        // ===== RANDOM PLAYER NAME GENERATOR =====
        const PLAYER_FIRST_NAMES = ['Crypto', 'Shadow', 'Pixel', 'Neon', 'Quantum', 'Cyber', 'Nova', 'Phoenix', 'Storm', 'Blaze'];
        const PLAYER_LAST_NAMES = ['Wolf', 'Hawk', 'Dragon', 'Knight', 'Hunter', 'Blade', 'Rider', 'Walker', 'Guard', 'Seeker'];
        
        function generateRandomPlayerName() {
            const first = PLAYER_FIRST_NAMES[Math.floor(Math.random() * PLAYER_FIRST_NAMES.length)];
            const last = PLAYER_LAST_NAMES[Math.floor(Math.random() * PLAYER_LAST_NAMES.length)];
            return `${first}${last}`;
        }
        
        // ===== MULTIPLAYER STATE =====
        let multiplayerState = {
            enabled: false,
            role: null, // 'host' or 'client'
            roomCode: null,
            ws: null,
            myHeroes: [], // Array of hero names this player controls
            myPlayerId: null,
            playerName: generateRandomPlayerName(),
            playerHeroes: {}, // { hero_name: { playerId, playerName } }
            connectedPlayers: [], // [ { id, hero, name } ]
            isReconnecting: false,
            // Client-only: Cache of hero stats from host broadcasts
            heroStatsCache: {
                zooko: null,
                nate: null,
                zancas: null,
                cyberaxe: null
            },
            // Client-only: Cache of gold from host
            goldCache: 0,
            // Rolled hero stats from dice rolling (new game only)
            rolledHeroStats: {}
        };
        
        // ===== GAMEPAD SUPPORT =====
        let gamepadConnected = false;
        let gamepadIndex = null;
        let gamepadButtonStates = {};
        let gamepadAxisDeadzone = 0.25;
        let lastGamepadUpdate = 0;
        const gamepadUpdateInterval = 16; // ~60Hz polling
        
        // Button mapping (standard gamepad layout)
        const GamepadButtons = {
            A: 0,           // Bottom face button (A on Xbox, X on PlayStation)
            B: 1,           // Right face button (B on Xbox, Circle on PlayStation)
            X: 2,           // Left face button (X on Xbox, Square on PlayStation)
            Y: 3,           // Top face button (Y on Xbox, Triangle on PlayStation)
            LB: 4,          // Left bumper
            RB: 5,          // Right bumper
            LT: 6,          // Left trigger
            RT: 7,          // Right trigger
            SELECT: 8,      // Select/Back/Share
            START: 9,       // Start/Menu/Options
            L3: 10,         // Left stick button
            R3: 11,         // Right stick button
            DPAD_UP: 12,
            DPAD_DOWN: 13,
            DPAD_LEFT: 14,
            DPAD_RIGHT: 15
        };
        
        // Axis mapping
        const GamepadAxes = {
            LEFT_X: 0,
            LEFT_Y: 1,
            RIGHT_X: 2,
            RIGHT_Y: 3
        };
        // ===== END GAMEPAD SUPPORT =====
        
        // Music System
        let currentMusic = null;
        let musicEnabled = true;
        let musicVolume = 75; // Music volume (1-150)
        let musicStarted = false;
        let currentTrackIndex = 0;
        let mainThemePlayed = false; // Track if main theme has played
        let zoneMusicEnabled = true; // Zone tracks toggle
        let themeMusicEnabled = true; // Theme songs toggle
        let musicAnimationFrameId = null;
        let currentMusicZone = -1; // Track current zone for music switching
        let userPausedMusic = false; // Track if user manually paused
        
        // Asset loading tracking
        let assetsToLoad = 0;
        let assetsLoaded = 0;
        let artTotal = 0;
        let artLoaded = 0;
        let audioTotal = 0;
        let audioLoaded = 0;
        let allAssetsReady = false;
        
        // Ticker facts system
        let tickerFacts = [];
        let currentTickerFact = '';
        
        // Game state
        let isPaused = false;
        let currentScreen = 'title'; // 'title', 'dungeonMenu', 'exploration'
        
        // Load ticker facts from JSON file
        fetch('ticker_facts.json')
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                tickerFacts = data.facts;
                
                // Pick initial random fact
                if (tickerFacts.length > 0) {
                    currentTickerFact = tickerFacts[Math.floor(Math.random() * tickerFacts.length)];
                }
            })
            .catch(err => {});
        
        // ===== STORY INTRO BACKGROUND ANIMATION =====
        // intro_a.png is 8x16 atlas (128 frames) at 16fps
        let storyIntroCurrentFrame = 0;
        let storyIntroDirection = 1; // 1 = forward, -1 = backward (ping-pong)
        let storyIntroIntervalId = null;
        const INTRO_COLS = 8;
        const INTRO_ROWS = 16;
        const INTRO_TOTAL_FRAMES = 128;
        const INTRO_FPS = 16;
        
        function startStoryIntroAnimation() {
            const bgElement = document.getElementById('storyIntroBackground');
            if (!bgElement) return;
            
            // Use dungeon intro animation
            const imageFile = 'story/intro/intro_a.png';
            
            // Set intro_a atlas as background
            bgElement.style.backgroundImage = `url('${imageFile}')`;
            bgElement.style.backgroundSize = `${INTRO_COLS * 100}% ${INTRO_ROWS * 100}%`;
            bgElement.style.opacity = '1';
            
            // Start frame animation at 16fps
            const frameInterval = 1000 / INTRO_FPS; // ~62.5ms per frame
            storyIntroIntervalId = window.setInterval(() => {
                // Calculate current frame position in atlas
                const col = storyIntroCurrentFrame % INTRO_COLS;
                const row = Math.floor(storyIntroCurrentFrame / INTRO_COLS);
                
                // Set background position to show current frame
                const xPercent = (col / (INTRO_COLS - 1)) * 100;
                const yPercent = (row / (INTRO_ROWS - 1)) * 100;
                bgElement.style.backgroundPosition = `${xPercent}% ${yPercent}%`;
                
                // Advance frame with ping-pong
                storyIntroCurrentFrame += storyIntroDirection;
                
                // Reverse at boundaries (ping-pong mode)
                if (storyIntroCurrentFrame >= INTRO_TOTAL_FRAMES - 1) {
                    storyIntroCurrentFrame = INTRO_TOTAL_FRAMES - 1;
                    storyIntroDirection = -1;
                } else if (storyIntroCurrentFrame <= 0) {
                    storyIntroCurrentFrame = 0;
                    storyIntroDirection = 1;
                }
            }, frameInterval);
        }
        
        function stopStoryIntroAnimation() {
            if (storyIntroIntervalId) {
                window.clearInterval(storyIntroIntervalId);
                storyIntroIntervalId = null;
            }
        }
        // ===== END STORY INTRO BACKGROUND ANIMATION =====
        
        // ===== SPRITE SHEET ANIMATION SYSTEM =====
        // Supports 9x9 atlas (81 frames), 16fps, ping-pong/loop/once modes
        // Used for heroes, mobs, bosses in battle
        
        const ANIM_GRID_SIZE = 9; // 9x9 grid
        const ANIM_TOTAL_FRAMES = 81;
        const ANIM_DEFAULT_FPS = 16;
        
        // Animation state paths for heroes
        // States can be a single path (string) or array of variants for random selection
        const HERO_ANIM_PATHS = {
            zooko: { 
                idle: [
                    'tunnelsofprivacy/heros/zooko_idle.png',
                    'tunnelsofprivacy/heros/zooko_idle_a.png',
                    'tunnelsofprivacy/heros/zooko_idle_b.png'
                ],
                light_attack: 'tunnelsofprivacy/heros/zooko_light_attack.png',
                heavy_attack: 'tunnelsofprivacy/heros/zooko_heavy_attack.png',
                special_attack: 'tunnelsofprivacy/heros/zooko_special_attack.png',
                knockout: 'tunnelsofprivacy/heros/zooko_knockout.png',
                hit: 'tunnelsofprivacy/heros/zooko_hit.png',
                defend: 'tunnelsofprivacy/heros/zooko_def.png'
            },
            nate: { 
                idle: [
                    'tunnelsofprivacy/heros/nate_idle.png',
                    'tunnelsofprivacy/heros/nate_idle_a.png',
                    'tunnelsofprivacy/heros/nate_idle_b.png',
                    'tunnelsofprivacy/heros/nate_idle_c.png'
                ],
                light_attack: 'tunnelsofprivacy/heros/nate_light_attack.png',
                heavy_attack: 'tunnelsofprivacy/heros/nate_heavy_attack.png',
                special_attack: [
                    'tunnelsofprivacy/heros/nate_special_attack.png',
                    'tunnelsofprivacy/heros/nate_special_attack_a.png'
                ],
                knockout: 'tunnelsofprivacy/heros/nate_knockout.png',
                hit: 'tunnelsofprivacy/heros/nate_hit.png',
                defend: 'tunnelsofprivacy/heros/nate_def.png',
                heal: 'tunnelsofprivacy/heros/nate_heal.png',
                taunt: 'tunnelsofprivacy/heros/nate_taunt.png',
                myturn: 'tunnelsofprivacy/heros/nate_myturn.png'
            },
            zancas: { 
                idle: [
                    'tunnelsofprivacy/heros/zancas_idle.png',
                    'tunnelsofprivacy/heros/zancas_idle_a.png',
                    'tunnelsofprivacy/heros/zancas_idle_b.png'
                ],
                light_attack: 'tunnelsofprivacy/heros/zancas_light_attack.png',
                heavy_attack: 'tunnelsofprivacy/heros/zancas_heavy_attack.png',
                special_attack: 'tunnelsofprivacy/heros/zancas_special_attack.png',
                knockout: 'tunnelsofprivacy/heros/zancas_knockout.png',
                hit: 'tunnelsofprivacy/heros/zancas_hit.png',
                defend: 'tunnelsofprivacy/heros/zancas_def.png',
                heal: 'tunnelsofprivacy/heros/zancas_heal.png'
            },
            cyberaxe: { 
                idle: [
                    'tunnelsofprivacy/heros/cyberaxe_idle.png',
                    'tunnelsofprivacy/heros/cyberaxe_idle_a.png',
                    'tunnelsofprivacy/heros/cyberaxe_idle_b.png'
                ],
                light_attack: 'tunnelsofprivacy/heros/cyberaxe_light_attack.png',
                heavy_attack: 'tunnelsofprivacy/heros/cyberaxe_heavy_attack.png',
                special_attack: 'tunnelsofprivacy/heros/cyberaxe_special_attack.png',
                knockout: 'tunnelsofprivacy/heros/cyberaxe_knockout.png',
                hit: 'tunnelsofprivacy/heros/cyberaxe_hit.png',
                defend: 'tunnelsofprivacy/heros/cyberaxe_def.png'
            }
        };
        
        // Cache for loaded sprite sheets
        const spriteSheetCache = {};
        
        // Load a sprite sheet (lazy load with caching)
        function loadSpriteSheet(path) {
            if (spriteSheetCache[path]) {
                return Promise.resolve(spriteSheetCache[path]);
            }
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    spriteSheetCache[path] = img;
                    resolve(img);
                };
                img.onerror = reject;
                img.src = path + '?v=' + Date.now();
            });
        }
        
        // Initialize animation controller for a combatant
        function initAnimation(combatant, sheetPath, playMode = 'pingpong') {
            combatant.anim = {
                sheet: null,
                sheetPath: sheetPath,
                frameSize: 0,       // Auto-calculated from sheet.width / 9
                frame: 0,           // Current frame 0-80
                fps: ANIM_DEFAULT_FPS,
                lastTime: 0,        // Last frame update timestamp
                direction: 1,       // 1 = forward, -1 = reverse
                playMode: playMode, // 'pingpong', 'loop', 'once'
                state: 'idle',
                playing: true,
                onComplete: null    // Callback when animation completes (for 'once' mode)
            };
            
            // Load the sprite sheet
            loadSpriteSheet(sheetPath).then(sheet => {
                combatant.anim.sheet = sheet;
                combatant.anim.frameSize = sheet.width / ANIM_GRID_SIZE;
            }).catch(err => {
                console.error('Failed to load sprite sheet:', sheetPath, err);
            });
        }
        
        // Update animation frame based on elapsed time
        function updateAnimation(combatant, currentTime) {
            const anim = combatant.anim;
            if (!anim || !anim.sheet || !anim.playing) return;
            
            // Initialize lastTime on first call
            if (anim.lastTime === 0) {
                anim.lastTime = currentTime;
                return;
            }
            
            const frameInterval = 1000 / anim.fps;
            const elapsed = currentTime - anim.lastTime;
            
            if (elapsed >= frameInterval) {
                anim.lastTime = currentTime - (elapsed % frameInterval);
                
                // Advance frame
                anim.frame += anim.direction;
                
                // Handle boundaries based on play mode
                if (anim.playMode === 'pingpong') {
                    if (anim.frame >= ANIM_TOTAL_FRAMES - 1) {
                        anim.frame = ANIM_TOTAL_FRAMES - 1;
                        anim.direction = -1;
                    } else if (anim.frame <= 0) {
                        anim.frame = 0;
                        const wasReversing = anim.direction === -1;
                        anim.direction = 1;
                        // Cycle complete (just finished reversing) - pick new random variant
                        if (wasReversing && anim.state === 'idle') {
                            pickNextIdleVariant(combatant);
                        }
                    }
                } else if (anim.playMode === 'loop') {
                    if (anim.frame >= ANIM_TOTAL_FRAMES) {
                        anim.frame = 0;
                    }
                } else if (anim.playMode === 'once') {
                    if (anim.frame >= ANIM_TOTAL_FRAMES - 1) {
                        anim.frame = ANIM_TOTAL_FRAMES - 1;
                        anim.playing = false;
                        if (anim.onComplete) anim.onComplete();
                    }
                }
            }
        }
        
        // Pick next idle variant for combatants with multiple idles
        function pickNextIdleVariant(combatant) {
            const anim = combatant.anim;
            if (!anim) return;
            
            const heroKey = combatant.name.toLowerCase();
            const paths = HERO_ANIM_PATHS[heroKey];
            if (!paths || !Array.isArray(paths.idle) || paths.idle.length <= 1) return;
            
            // Pick a different variant than current
            const otherPaths = paths.idle.filter(p => p !== anim.sheetPath);
            if (otherPaths.length === 0) return;
            
            const newPath = otherPaths[Math.floor(Math.random() * otherPaths.length)];
            anim.sheetPath = newPath;
            
            // Check if already cached (instant swap)
            if (spriteSheetCache[newPath]) {
                anim.sheet = spriteSheetCache[newPath];
                anim.frameSize = anim.sheet.width / ANIM_GRID_SIZE;
                anim.frame = 0; // Reset to start of new animation
            } else {
                // Load and swap when ready
                loadSpriteSheet(newPath).then(sheet => {
                    anim.sheet = sheet;
                    anim.frameSize = sheet.width / ANIM_GRID_SIZE;
                    anim.frame = 0; // Reset to start of new animation
                });
            }
        }
        
        // Preload all idle variants for a hero (call on battle start)
        function preloadIdleVariants(heroKey) {
            const paths = HERO_ANIM_PATHS[heroKey];
            if (paths && Array.isArray(paths.idle)) {
                paths.idle.forEach(path => loadSpriteSheet(path));
            }
        }
        
        // Draw animated sprite from atlas
        function drawAnimatedSprite(ctx, combatant, destX, destY, destWidth, destHeight, flipX = false) {
            const anim = combatant.anim;
            if (!anim || !anim.sheet || !anim.sheet.complete) {
                // Fallback: draw static sprite if available
                if (combatant.sprite && combatant.sprite.complete && combatant.sprite.naturalHeight !== 0) {
                    ctx.save();
                    if (flipX) {
                        ctx.translate(destX + destWidth / 2, destY + destHeight / 2);
                        ctx.scale(-1, 1);
                        ctx.translate(-(destX + destWidth / 2), -(destY + destHeight / 2));
                    }
                    ctx.drawImage(combatant.sprite, destX, destY, destWidth, destHeight);
                    ctx.restore();
                }
                return;
            }
            
            // Calculate source rectangle from 9x9 grid
            const col = anim.frame % ANIM_GRID_SIZE;
            const row = Math.floor(anim.frame / ANIM_GRID_SIZE);
            const srcX = col * anim.frameSize;
            const srcY = row * anim.frameSize;
            const srcSize = anim.frameSize;
            
            ctx.save();
            if (flipX) {
                ctx.translate(destX + destWidth / 2, destY + destHeight / 2);
                ctx.scale(-1, 1);
                ctx.translate(-(destX + destWidth / 2), -(destY + destHeight / 2));
            }
            ctx.drawImage(
                anim.sheet,
                srcX, srcY, srcSize, srcSize,  // Source rectangle
                destX, destY, destWidth, destHeight  // Destination rectangle
            );
            ctx.restore();
        }
        
        // Change animation state (e.g., idle -> attack -> idle)
        function setAnimationState(combatant, newState, playMode = 'pingpong', onComplete = null, broadcastToClients = true) {
            const anim = combatant.anim;
            if (!anim) return;
            
            // Get the path for this combatant's new state
            const heroKey = combatant.name.toLowerCase();
            const paths = HERO_ANIM_PATHS[heroKey];
            if (!paths || !paths[newState]) {
                console.warn('No animation path for:', heroKey, newState);
                return;
            }
            
            // Broadcast animation to clients (only if host and broadcastToClients is true)
            if (broadcastToClients && multiplayerState.enabled && multiplayerState.role === 'host') {
                sendWebSocketMessage({
                    type: 'animation_sync',
                    combatantName: combatant.name,
                    animState: newState,
                    playMode: playMode
                });
            }
            
            // Handle array of variants (random selection)
            let newPath = paths[newState];
            if (Array.isArray(newPath)) {
                newPath = newPath[Math.floor(Math.random() * newPath.length)];
            }
            
            // If same path and already playing, don't restart (but allow different variant)
            if (anim.sheetPath === newPath && anim.playing) {
                return;
            }
            
            anim.state = newState;
            anim.sheetPath = newPath;
            anim.frame = 0;
            anim.direction = 1;
            anim.playMode = playMode;
            anim.playing = true;
            anim.onComplete = onComplete;
            anim.lastTime = 0;
            
            // Load new sprite sheet
            loadSpriteSheet(newPath).then(sheet => {
                anim.sheet = sheet;
                anim.frameSize = sheet.width / ANIM_GRID_SIZE;
            });
        }
        // ===== END SPRITE SHEET ANIMATION SYSTEM =====
        
        const themeTracks = [
            { file: 'music/main_theme.webm', name: 'Tunnels of Privacy Theme' },
            { file: 'music/theme_a.webm', name: 'Electric Coin Company' },
            { file: 'music/theme_b.webm', name: 'Zcash Foundation' },
            { file: 'music/theme_c_boss.webm', name: 'Proof of Work Battle' },
            { file: 'music/theme_d.webm', name: 'ZecWallet Lite' },
            { file: 'music/theme_e.webm', name: 'Private by Default' },
            { file: 'music/theme_f.webm', name: 'Halo Arc Dreams' },
            { file: 'music/theme_g.webm', name: 'Mining the Future' },
            { file: 'music/theme_h.webm', name: 'zkSNARK Symphony' },
            { file: 'music/theme_i.webm', name: 'Trusted Setup Ceremony' },
            { file: 'music/theme_j.webm', name: 'Shielded Sunset' }
        ];
        
        // Zone music tracks - mapped to dungeon zones from level_data.json
        // Descent Arc (Levels 1-100)
        const zoneMusicTracks = [
            { file: 'music/level_1.webm', minLevel: 1, maxLevel: 5, name: 'Entry Crypts' },
            { file: 'music/level_2.webm', minLevel: 6, maxLevel: 15, name: 'Forgotten Mines' },
            { file: 'music/level_3.webm', minLevel: 16, maxLevel: 25, name: 'Fungal Gardens' },
            { file: 'music/level_4.webm', minLevel: 26, maxLevel: 35, name: 'Underground River' },
            { file: 'music/level_5.webm', minLevel: 36, maxLevel: 45, name: 'Crystal Caverns' },
            { file: 'music/level_6.webm', minLevel: 46, maxLevel: 55, name: 'Bone Pits' },
            { file: 'music/level_7.webm', minLevel: 56, maxLevel: 65, name: 'Infernal Depths' },
            { file: 'music/level_8.webm', minLevel: 66, maxLevel: 75, name: 'Shadow Realm' },
            { file: 'music/level_9.webm', minLevel: 76, maxLevel: 90, name: 'Abyssal Trenches' },
            { file: 'music/level_10.webm', minLevel: 91, maxLevel: 100, name: 'Core of Darkness' },
            // Ascent Arc (Levels 101-1000)
            { file: 'music/up_1.webm', minLevel: 101, maxLevel: 200, name: 'Sanctuary Ruins' },
            { file: 'music/up_2.webm', minLevel: 201, maxLevel: 400, name: 'Ember Wastes' },
            { file: 'music/up_3.webm', minLevel: 401, maxLevel: 700, name: 'Celestial Spire' },
            { file: 'music/up_4.webm', minLevel: 701, maxLevel: 999, name: 'Void Threshold' },
            { file: 'music/up_5.webm', minLevel: 1000, maxLevel: 999999, name: 'Beyond the Veil' }
        ];
        
        // Get appropriate zone music track for current dungeon level
        function getMusicForZone(level) {
            for (let i = 0; i < zoneMusicTracks.length; i++) {
                const track = zoneMusicTracks[i];
                if (level >= track.minLevel && level <= track.maxLevel) {
                    return track;
                }
            }
            return zoneMusicTracks[0]; // Default to first track
        }
        
        function loadMusic(trackData) {
            if (!musicEnabled) return;
            
            // Check if zone or theme music is disabled - skip to alternate type
            const isTheme = trackData.minLevel === undefined;
            if (isTheme && !themeMusicEnabled) {
                // Theme disabled, play zone track instead
                if (zoneMusicEnabled) {
                    const currentLevel = parseInt(document.getElementById('dungeonLevel')?.textContent) || 1;
                    const zoneTrack = getMusicForZone(currentLevel);
                    loadMusic(zoneTrack);
                }
                return;
            }
            if (!isTheme && !zoneMusicEnabled) {
                // Zone disabled, play theme instead
                if (themeMusicEnabled) {
                    const randomTheme = themeTracks[Math.floor(Math.random() * themeTracks.length)];
                    loadMusic(randomTheme);
                }
                return;
            }
            
            // Check if we're already playing this track
            if (currentMusic && currentMusic.src.endsWith(trackData.file)) {
                return; // Don't restart the same track
            }
            
            // Update music ticker with track name
            const tickerText1 = document.getElementById('musicTickerText1');
            const tickerText2 = document.getElementById('musicTickerText2');
            if (tickerText1 && tickerText2 && trackData.name) {
                // Pick a new random fact each time track changes
                if (tickerFacts.length > 0) {
                    currentTickerFact = tickerFacts[Math.floor(Math.random() * tickerFacts.length)];
                }
                
                // Check if this is a zone track or theme track
                let musicInfo = '';
                if (trackData.minLevel !== undefined) {
                    // Zone track - show level range
                    const levelRange = trackData.maxLevel === 999999 ? `${trackData.minLevel}+` : `${trackData.minLevel}-${trackData.maxLevel}`;
                    musicInfo = `â™« Zone Track: ${trackData.name} (Levels ${levelRange}) â™«`;
                } else {
                    // Theme track
                    musicInfo = `â™« Theme Song: ${trackData.name} â™«`;
                }
                
                // Combine music info with fun fact
                const finalText = currentTickerFact ? `${musicInfo}  â€¢  ${currentTickerFact}` : musicInfo;
                tickerText1.textContent = finalText;
                tickerText2.textContent = finalText;
            }
            
            // Use musicVolume divided by 100 (1-150 scale), clamped to max 1.0
            const volumeScale = Math.min(1.0, musicVolume / 100);
            
            // Create new audio element
            const newMusic = new Audio(trackData.file);
            newMusic.loop = false;
            newMusic.volume = 0; // Start silent
            
            // Fade in new track
            newMusic.play().then(() => {
                fadeMusic(newMusic, 0, volumeScale, 1000);
                musicStarted = true;
                updateMusicButton();
                
                // When song ends, maybe play a theme, then resume zone track
                newMusic.addEventListener('ended', () => {
                    // Don't auto-play next track if user manually paused
                    if (userPausedMusic || !musicEnabled) return;
                    
                    mainThemePlayed = true;
                    const shouldPlayTheme = Math.random() < 0.5; // 50% chance
                    
                    if (shouldPlayTheme && themeMusicEnabled) {
                        // Pick random theme
                        const randomTheme = themeTracks[Math.floor(Math.random() * themeTracks.length)];
                        loadMusic(randomTheme);
                    } else if (zoneMusicEnabled) {
                        // Loop the zone track again
                        const currentLevel = parseInt(document.getElementById('dungeonLevel')?.textContent) || 1;
                        const zoneTrack = getMusicForZone(currentLevel);
                        loadMusic(zoneTrack);
                    } else if (themeMusicEnabled) {
                        // Fall back to theme if zone disabled
                        const randomTheme = themeTracks[Math.floor(Math.random() * themeTracks.length)];
                        loadMusic(randomTheme);
                    }
                });
            }).catch(err => {
                console.log('Music autoplay blocked:', err);
            });
            
            // Fade out old track
            if (currentMusic) {
                const oldMusic = currentMusic;
                fadeMusic(oldMusic, oldMusic.volume, 0, 1000, () => {
                    oldMusic.pause();
                    oldMusic.src = '';
                });
            }
            
            currentMusic = newMusic;
        }
        
        function fadeMusic(audioElement, startVol, endVol, duration, callback) {
            const steps = 20;
            const stepTime = duration / steps;
            const volStep = (endVol - startVol) / steps;
            let currentStep = 0;
            
            const fadeInterval = setInterval(() => {
                currentStep++;
                const newVol = startVol + (volStep * currentStep);
                audioElement.volume = Math.max(0, Math.min(1, newVol));
                
                if (currentStep >= steps) {
                    clearInterval(fadeInterval);
                    audioElement.volume = Math.max(0, Math.min(1.5, endVol));
                    if (callback) callback();
                }
            }, stepTime);
        }
        
        // Music Control Functions
        function musicPlayPause() {
            const btn = document.getElementById('musicPlayPauseBtn');
            
            if (!currentMusic) {
                // No music loaded yet, start music system
                musicEnabled = true;
                userPausedMusic = false;
                startMusicSystem();
                if (btn) btn.textContent = 'â¸';
                return;
            }
            
            if (currentMusic.paused) {
                currentMusic.play().catch(err => console.log('Play error:', err));
                musicEnabled = true;
                userPausedMusic = false;
                if (btn) btn.textContent = 'â¸';
            } else {
                currentMusic.pause();
                userPausedMusic = true;
                if (btn) btn.textContent = 'â–¶';
            }
        }
        
        function musicPrevious() {
            if (currentMusic) {
                currentMusic.pause();
            }
            
            musicEnabled = true;
            userPausedMusic = false;
            mainThemePlayed = true;
            
            // If zone music enabled, play zone track; otherwise theme
            if (zoneMusicEnabled) {
                const currentLevel = parseInt(document.getElementById('dungeonLevel')?.textContent) || 1;
                const zoneTrack = getMusicForZone(currentLevel);
                loadMusic(zoneTrack);
            } else if (themeMusicEnabled) {
                const randomIndex = Math.floor(Math.random() * (themeTracks.length - 1)) + 1;
                const randomTrack = themeTracks[randomIndex];
                loadMusic(randomTrack);
            }
        }
        
        function musicNext() {
            if (currentMusic) {
                currentMusic.pause();
            }
            
            musicEnabled = true;
            userPausedMusic = false;
            mainThemePlayed = true;
            
            // Alternate between zone and theme tracks
            const isCurrentlyZone = currentMusic && zoneMusicTracks.some(t => currentMusic.src.endsWith(t.file));
            
            if (isCurrentlyZone && themeMusicEnabled) {
                // Currently zone, play random theme
                const randomIndex = Math.floor(Math.random() * themeTracks.length);
                loadMusic(themeTracks[randomIndex]);
            } else if (zoneMusicEnabled) {
                // Play zone track for current level
                const currentLevel = parseInt(document.getElementById('dungeonLevel')?.textContent) || 1;
                const zoneTrack = getMusicForZone(currentLevel);
                loadMusic(zoneTrack);
            } else if (themeMusicEnabled) {
                // Fall back to theme
                const randomIndex = Math.floor(Math.random() * themeTracks.length);
                loadMusic(themeTracks[randomIndex]);
            }
        }
        
        function updateMusicButton() {
            const btn = document.getElementById('musicPlayPauseBtn');
            if (btn) {
                if (currentMusic && !currentMusic.paused) {
                    btn.textContent = 'â¸';
                } else {
                    btn.textContent = 'â–¶';
                }
            }
        }
        
        // SEPARATE animation loop for music system - monitors zone changes
        function animateMusicSystem() {
            if (!musicEnabled) {
                musicAnimationFrameId = null;
                return;
            }
            
            musicAnimationFrameId = requestAnimationFrame(animateMusicSystem);
            
            // Get current dungeon level
            const currentLevel = parseInt(document.getElementById('dungeonLevel')?.textContent) || 1;
            
            // Check if zone changed and we need a different track
            if (currentLevel !== currentMusicZone && zoneMusicEnabled) {
                const oldTrack = getMusicForZone(currentMusicZone);
                const newTrack = getMusicForZone(currentLevel);
                
                // Only switch if track file is different (zone changed)
                if (oldTrack.file !== newTrack.file) {
                    console.log(`[Music] Zone changed: Level ${currentMusicZone} -> ${currentLevel}, switching to "${newTrack.name}"`);
                    loadMusic(newTrack);
                }
                
                currentMusicZone = currentLevel;
            }
            
            // Update volume dynamically based on musicVolume (1-150 range)
            if (currentMusic) {
                const volumeScale = Math.min(1.0, musicVolume / 100);
                currentMusic.volume = volumeScale;
            }
        }
        
        // Start the music system with proper initialization
        function startMusicSystem() {
            if (musicEnabled && !musicAnimationFrameId) {
                const currentLevel = parseInt(document.getElementById('dungeonLevel')?.textContent) || 1;
                currentMusicZone = currentLevel;
                
                // Start with a random theme song for variety, then zone music takes over
                if (themeMusicEnabled && !mainThemePlayed) {
                    // First time: play main theme
                    loadMusic(themeTracks[0]);
                    mainThemePlayed = true;
                } else if (themeMusicEnabled) {
                    // After first time: random theme
                    const randomTheme = themeTracks[Math.floor(Math.random() * themeTracks.length)];
                    loadMusic(randomTheme);
                } else if (zoneMusicEnabled) {
                    // Themes disabled: play zone track
                    const zoneTrack = getMusicForZone(currentLevel);
                    loadMusic(zoneTrack);
                }
                
                // Start the monitoring loop
                animateMusicSystem();
            }
        }
        
        function updateVolume() {
            const slider = document.getElementById('volumeSlider');
            if (!slider) return;
            
            musicVolume = parseInt(slider.value);
            
            // Update settings object
            settings.musicVolume = musicVolume;
            
            // Update volume display
            const volumeDisplay = document.getElementById('volumeSliderValue');
            if (volumeDisplay) {
                volumeDisplay.textContent = musicVolume;
            }
            
            // Update settings panel slider if open
            const settingsSlider = document.getElementById('musicVolume');
            if (settingsSlider) {
                settingsSlider.value = musicVolume;
            }
            const settingsVolumeDisplay = document.getElementById('musicVolumeValue');
            if (settingsVolumeDisplay) {
                settingsVolumeDisplay.textContent = musicVolume;
            }
            
            if (currentMusic) {
                currentMusic.volume = Math.min(1.0, musicVolume / 100);
            }
            
            // Save to localStorage
            saveSettings();
        }
        
        // Settings System
        let settings = {
            musicEnabled: true,
            musicVolume: 75,
            themeMusicEnabled: true,  // Theme songs toggle
            zoneMusicEnabled: true,   // Zone music toggle
            showHitboxes: false,
            playerName: '',
            llmFreeWill: true,       // NPCs chat autonomously
            llmUsePaid: false,       // Use paid LLM models
            rpMode: false,           // RP emotes/dramatic speech vs normal 2025 talk
            diagMode: false,         // Diagnostic mode - enemies have 5 HP
            difficulty: 'normal'     // Game difficulty: 'casual', 'normal', 'expert'
        };
        
        function showSettings() {
            document.getElementById('overlay').style.display = 'block';
            document.getElementById('settingsPanel').style.display = 'block';
            
            // Load current settings into UI
            document.getElementById('musicEnabled').checked = settings.musicEnabled;
            document.getElementById('musicVolume').value = settings.musicVolume;
            document.getElementById('musicVolumeValue').textContent = settings.musicVolume;
            document.getElementById('themeMusicEnabled').checked = settings.themeMusicEnabled !== false;
            document.getElementById('zoneMusicEnabled').checked = settings.zoneMusicEnabled !== false;
            document.getElementById('showHitboxes').checked = settings.showHitboxes;
            document.getElementById('llmFreeWill').checked = settings.llmFreeWill;
            document.getElementById('llmUsePaid').checked = settings.llmUsePaid;
            document.getElementById('rpMode').checked = settings.rpMode !== false; // Default true
            document.getElementById('diagMode').checked = settings.diagMode === true;
        }
        
        function showAbout() {
            document.getElementById('overlay').style.display = 'block';
            document.getElementById('aboutPanel').style.display = 'block';
        }
        
        function updateSettings() {
            // Read values from UI
            settings.musicEnabled = document.getElementById('musicEnabled').checked;
            settings.musicVolume = parseInt(document.getElementById('musicVolume').value);
            settings.showHitboxes = document.getElementById('showHitboxes').checked;
            settings.llmFreeWill = document.getElementById('llmFreeWill').checked;
            settings.llmUsePaid = document.getElementById('llmUsePaid').checked;
            settings.rpMode = document.getElementById('rpMode').checked;
            settings.diagMode = document.getElementById('diagMode').checked;
            
            // Update display
            document.getElementById('musicVolumeValue').textContent = settings.musicVolume;
            
            // Read theme/zone music toggles
            const themeCheckbox = document.getElementById('themeMusicEnabled');
            const zoneCheckbox = document.getElementById('zoneMusicEnabled');
            if (themeCheckbox) settings.themeMusicEnabled = themeCheckbox.checked;
            if (zoneCheckbox) settings.zoneMusicEnabled = zoneCheckbox.checked;
            
            // Prevent both being disabled - at least one must be on
            if (!settings.themeMusicEnabled && !settings.zoneMusicEnabled) {
                // Re-enable the one that was just disabled
                if (!themeCheckbox.checked) {
                    settings.zoneMusicEnabled = true;
                    if (zoneCheckbox) zoneCheckbox.checked = true;
                } else {
                    settings.themeMusicEnabled = true;
                    if (themeCheckbox) themeCheckbox.checked = true;
                }
            }
            
            // Apply to game state
            musicEnabled = settings.musicEnabled;
            musicVolume = settings.musicVolume;
            themeMusicEnabled = settings.themeMusicEnabled;
            zoneMusicEnabled = settings.zoneMusicEnabled;
            
            // Re-render battle if active to show/hide hitboxes
            if (battleState.active) {
                renderBattle();
            }
            
            // Handle music enable/disable
            if (currentMusic) {
                if (musicEnabled) {
                    // Enable: Resume if paused
                    if (currentMusic.paused) {
                        currentMusic.play().catch(err => console.log('Play error:', err));
                    }
                    currentMusic.volume = Math.min(1.0, musicVolume / 100);
                } else {
                    // Disable: Pause music
                    currentMusic.pause();
                }
            }
            
            // Update volume slider in main controls
            const mainSlider = document.getElementById('volumeSlider');
            if (mainSlider) {
                mainSlider.value = musicVolume;
            }
            
            // Update play/pause button
            updateMusicButton();
            
            // Save to localStorage
            saveSettings();
        }
        
        function closeAllPanels() {
            document.getElementById('overlay').style.display = 'none';
            document.getElementById('settingsPanel').style.display = 'none';
            document.getElementById('aboutPanel').style.display = 'none';
            const loadSavePanel = document.getElementById('loadSavePanel');
            if (loadSavePanel) {
                loadSavePanel.style.display = 'none';
            }
        }
        
        function showLoadSave() {
            document.getElementById('overlay').style.display = 'block';
            const loadSavePanel = document.getElementById('loadSavePanel');
            if (loadSavePanel) {
                loadSavePanel.style.display = 'block';
            }
        }
        
        function loadSaveFile() {
            const fileInput = document.getElementById('saveFileInput');
            const file = fileInput.files[0];
            
            if (!file) {
                alert('Please select a save file first!');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const saveData = JSON.parse(e.target.result);
                    
                    // Validate save data structure
                    if (!saveData || !saveData.heroes) {
                        alert('Invalid save file format! Missing hero data.');
                        return;
                    }
                    
                    // Save to localStorage
                    if (saveSharedSave(saveData)) {
                        alert('Save file loaded successfully!');
                        
                        // Refresh hero displays
                        if (saveData.heroes.zooko) updateHeroDisplay('zooko', saveData.heroes.zooko);
                        if (saveData.heroes.nate) updateHeroDisplay('nate', saveData.heroes.nate);
                        if (saveData.heroes.zancas) updateHeroDisplay('zancas', saveData.heroes.zancas);
                        if (saveData.heroes.cyberaxe) updateHeroDisplay('cyberaxe', saveData.heroes.cyberaxe);
                        
                        // Update gold display
                        updateGoldDisplay();
                        
                        // Update dungeon level if arcade state exists
                        if (saveData.arcadeState && saveData.arcadeState.level) {
                            document.getElementById('dungeonLevel').textContent = saveData.arcadeState.level;
                        }
                        
                        // Update title screen buttons
                        updateTitleScreenButtons();
                        
                        // Close panel
                        closeAllPanels();
                        
                        // Clear file input
                        fileInput.value = '';
                    } else {
                        alert('Failed to save the loaded data to localStorage.');
                    }
                } catch (error) {
                    alert('Error reading save file: ' + error.message);
                    console.error('Save file load error:', error);
                }
            };
            
            reader.onerror = function() {
                alert('Error reading file!');
            };
            
            reader.readAsText(file);
        }
        
        function saveSettings() {
            try {
                localStorage.setItem(STORAGE_KEYS.SETTINGS, JSON.stringify(settings));
            } catch (e) {
                console.error('Failed to save settings:', e);
            }
        }
        
        function loadSettings() {
            try {
                const saved = localStorage.getItem(STORAGE_KEYS.SETTINGS);
                if (saved) {
                    const loaded = JSON.parse(saved);
                    settings = { ...settings, ...loaded };
                    
                    // Apply to game state
                    musicEnabled = settings.musicEnabled;
                    musicVolume = settings.musicVolume;
                    themeMusicEnabled = settings.themeMusicEnabled !== false;
                    zoneMusicEnabled = settings.zoneMusicEnabled !== false;
                    
                    // Update main volume slider and display
                    const mainSlider = document.getElementById('volumeSlider');
                    if (mainSlider) {
                        mainSlider.value = musicVolume;
                    }
                    const volumeDisplay = document.getElementById('volumeSliderValue');
                    if (volumeDisplay) {
                        volumeDisplay.textContent = musicVolume;
                    }
                    
                    // Populate player name input field
                    const playerNameInput = document.getElementById('multiplayerPlayerName');
                    if (playerNameInput) {
                        if (settings.playerName) {
                            playerNameInput.value = settings.playerName;
                            multiplayerState.playerName = settings.playerName;
                        } else {
                            // Use random name as default
                            playerNameInput.value = multiplayerState.playerName;
                        }
                    }
                }
            } catch (e) {
                console.error('Failed to load settings:', e);
            }
            
            // Ensure player name input has a value even if settings load failed
            const playerNameInput = document.getElementById('multiplayerPlayerName');
            if (playerNameInput && !playerNameInput.value) {
                playerNameInput.value = multiplayerState.playerName;
            }
        }
        
        // Load shared save and populate hero stats
        function loadSharedSave() {
            try {
                const saved = localStorage.getItem(STORAGE_KEYS.SHARED_SAVE);
                if (!saved) return null;
                
                const sharedSave = JSON.parse(saved);
                return migrateSharedSave(sharedSave);
            } catch (e) {
                console.error('Failed to load shared save:', e);
                return null;
            }
        }
        
        // Save shared save to localStorage
        function saveSharedSave(sharedSave) {
            try {
                const jsonString = JSON.stringify(sharedSave);
                localStorage.setItem(STORAGE_KEYS.SHARED_SAVE, jsonString);
                console.log('Shared save written. Size:', jsonString.length, 'bytes');
                return true;
            } catch (e) {
                console.error('Failed to save shared save:', e);
                return false;
            }
        }
        
        // Migrate shared save between versions
        function migrateSharedSave(sharedSave) {
            // Currently at version 1, no migrations needed yet
            return sharedSave;
        }
        
        // Creates default shared save with initial hero stats
        function createDefaultSharedSave() {
            // Get rolled stats if any were set during hero selection
            const rolledStats = multiplayerState.rolledHeroStats || {};
            
            // Helper to merge rolled stats with defaults
            function getHeroStats(heroKey, defaultStats) {
                if (rolledStats[heroKey]) {
                    return {
                        name: defaultStats.name,
                        str: rolledStats[heroKey].str,
                        dex: rolledStats[heroKey].dex,
                        con: rolledStats[heroKey].con,
                        int: rolledStats[heroKey].int,
                        wis: rolledStats[heroKey].wis,
                        cha: rolledStats[heroKey].cha,
                        hp: rolledStats[heroKey].hp,
                        maxHp: rolledStats[heroKey].maxHp,
                        ac: rolledStats[heroKey].ac,
                        xp: 0,
                        level: 1
                    };
                }
                return defaultStats;
            }
            
            return {
                saveVersion: 1,
                lastPlayed: Date.now(),
                arcadeState: null,
                dungeonState: {
                    currentLevel: 1,
                    inventory: [],
                    gold: 0,
                    questProgress: {
                        hasScepter: false,
                        hasReturned: false,
                        bossesDefeated: []
                    }
                },
                heroes: {
                    zooko: getHeroStats('zooko', {
                        name: 'Zooko',
                        str: 8, dex: 11, con: 10, int: 15, wis: 13, cha: 9,
                        hp: 22, maxHp: 25, ac: 12, xp: 0, level: 1
                    }),
                    nate: getHeroStats('nate', {
                        name: 'Nate',
                        str: 14, dex: 12, con: 13, int: 10, wis: 9, cha: 11,
                        hp: 28, maxHp: 30, ac: 14, xp: 0, level: 1
                    }),
                    zancas: getHeroStats('zancas', {
                        name: 'Zancas',
                        str: 10, dex: 15, con: 11, int: 12, wis: 14, cha: 8,
                        hp: 24, maxHp: 26, ac: 13, xp: 0, level: 1
                    }),
                    cyberaxe: getHeroStats('cyberaxe', {
                        name: 'CyberAxe',
                        str: 16, dex: 10, con: 14, int: 8, wis: 11, cha: 10,
                        hp: 32, maxHp: 35, ac: 15, xp: 0, level: 1
                    })
                }
            };
        }
        
        // Custom dialog system (replaces browser confirm/alert)
        function showConfirmDialog(title, message, onConfirm, onCancel) {
            const dialog = document.getElementById('confirmDialog');
            const overlay = document.getElementById('overlay');
            const titleEl = document.getElementById('confirmDialogTitle');
            const messageEl = document.getElementById('confirmDialogMessage');
            const yesBtn = document.getElementById('confirmDialogYes');
            const noBtn = document.getElementById('confirmDialogNo');
            
            titleEl.textContent = title;
            messageEl.textContent = message;
            
            // Clear previous handlers
            yesBtn.onclick = null;
            noBtn.onclick = null;
            
            yesBtn.onclick = () => {
                dialog.style.display = 'none';
                overlay.style.zIndex = '150'; // Reset overlay z-index
                if (onConfirm) onConfirm();
            };
            
            noBtn.onclick = () => {
                dialog.style.display = 'none';
                overlay.style.zIndex = '150'; // Reset overlay z-index
                if (onCancel) onCancel();
            };
            
            overlay.style.zIndex = '1150'; // Above settings (1100) but below dialogs (1200)
            overlay.style.display = 'block';
            dialog.style.display = 'block';
        }
        
        function showInfoDialog(title, message, icon, onOk) {
            const dialog = document.getElementById('infoDialog');
            const overlay = document.getElementById('overlay');
            const titleEl = document.getElementById('infoDialogTitle');
            const messageEl = document.getElementById('infoDialogMessage');
            const iconEl = document.getElementById('infoDialogIcon');
            const okBtn = document.getElementById('infoDialogOk');
            
            titleEl.textContent = title;
            messageEl.textContent = message;
            iconEl.textContent = icon || 'âœ…';
            
            // Set border color based on icon
            if (icon === 'âŒ' || icon === 'âš ï¸') {
                dialog.style.borderColor = '#EB5757';
                titleEl.style.color = '#EB5757';
            } else {
                dialog.style.borderColor = '#27AE60';
                titleEl.style.color = '#27AE60';
            }
            
            okBtn.onclick = () => {
                dialog.style.display = 'none';
                overlay.style.zIndex = '150'; // Reset overlay z-index
                if (onOk) onOk();
            };
            
            overlay.style.zIndex = '1150'; // Above settings (1100) but below dialogs (1200)
            overlay.style.display = 'block';
            dialog.style.display = 'block';
        }
        
        // Clear cache - deletes all localStorage data and forces hard reload
        function clearCache() {
            showConfirmDialog(
                'CLEAR ALL DATA',
                'This will delete ALL saved data including your hero progress, settings, and game state. This cannot be undone. Are you sure?',
                () => {
                    // User confirmed - clear everything
                    try {
                        localStorage.removeItem(STORAGE_KEYS.SETTINGS);
                        localStorage.removeItem(STORAGE_KEYS.SHARED_SAVE);
                        
                        // Clear browser cache for images and assets
                        if ('caches' in window) {
                            caches.keys().then(function(names) {
                                for (let name of names) caches.delete(name);
                            });
                        }
                        
                        showInfoDialog(
                            'CACHE CLEARED',
                            'All data has been deleted. The page will now reload with fresh assets.',
                            'âœ…',
                            () => {
                                // Force hard reload (bypass cache)
                                location.reload(true);
                            }
                        );
                    } catch (e) {
                        console.error('Clear cache error:', e);
                        showInfoDialog('ERROR', 'Error clearing cache: ' + e.message, 'âŒ');
                    }
                },
                null // Cancel does nothing
            );
        }
        
        // Update title screen button states based on save existence
        function updateTitleScreenButtons() {
            const sharedSave = loadSharedSave();
            const continueBtn = document.getElementById('continueBtn');
            
            if (sharedSave && (sharedSave.arcadeState || sharedSave.dungeonState)) {
                // Has save - enable CONTINUE
                continueBtn.disabled = false;
                continueBtn.classList.remove('comingSoon');
            } else {
                // No save - disable CONTINUE
                continueBtn.disabled = true;
                continueBtn.classList.add('comingSoon');
            }
        }
        
        // Continue game - load from save
        // Single-player: Continue game from save
        function continueGameSinglePlayer() {
            const sharedSave = loadSharedSave();
            if (!sharedSave) {
                alert('No save game found! Start a new adventure first.');
                return;
            }
            
            // Hide hero selection modal if open (for single player flow)
            document.getElementById('heroSelectionModal').style.display = 'none';
            document.getElementById('musicControls').classList.remove('heroSelectionActive');
            document.getElementById('musicTicker').classList.remove('battleActive');
            
            // Restore hidden elements (in case coming from single player hero selection)
            const codeDisplay = document.getElementById('heroSelectionCode');
            if (codeDisplay) codeDisplay.parentElement.style.display = '';
            const playerNameInput = document.getElementById('playerNameInput');
            if (playerNameInput) playerNameInput.parentElement.style.display = '';
            const backBtn = document.getElementById('heroSelectionBackBtn');
            if (backBtn) backBtn.style.display = '';
            
            // Center music controls for dungeon menu
            document.getElementById('musicControls').classList.add('dungeonMenuActive');
            document.getElementById('musicTicker').classList.add('dungeonMenuActive');
            
            // Show dungeon menu with existing save (no warning needed)
            document.getElementById('titleScreen').style.display = 'none';
            document.getElementById('dungeonMenuScreen').style.display = 'block';
            currentScreen = 'dungeonMenu';
            
            // Update dungeon menu with save data
            updateDungeonMenuHeroes();
            updateGoldDisplay();
            updateDifficultyButtons();
            
            // Apply client UI restrictions
            applyClientUIRestrictions();
            
            // Pre-generate next encounter while player is in dungeon menu
            preGenerateNextEncounter();
        }
        
        // Router: Determine which continue function to call
        function continueGame() {
            if (multiplayerState.enabled) {
                continueGameMultiplayer();
            } else {
                continueGameSinglePlayer();
            }
        }
        
        // ===== BATTLE SYSTEM =====
        
        // Battle state
        let battleState = {
            active: false,
            won: false,
            hadBoss: false, // Track if this battle had a boss (for level progress)
            currentTurn: 0,
            turnOrder: [],
            heroes: [],
            allHeroes: [], // All heroes including dead/retreated ones (for saving stats)
            enemies: [],
            platforms: [],
            canvas: null,
            ctx: null,
            backgroundImage: null,
            backgroundPath: '',
            backgroundVideo: null,
            backgroundVideoPath: '',
            useVideoBackground: false,
            detectedPlatforms: [],
            targetingMode: false,
            pendingAction: null,
            swapTargetingMode: false,
            swapInitiator: null
        };
        
        // Room video backgrounds (68 videos)
        const roomVideos = [];
        for (let i = 1; i <= 68; i++) {
            roomVideos.push(`tunnelsofprivacy/levels/rooms/rooms (${i}).mp4`);
        }
        
        // Get random room video
        function getRandomRoomVideo() {
            return roomVideos[Math.floor(Math.random() * roomVideos.length)];
        }
        
        // Stop and hide battle background video
        function stopBattleVideo() {
            const videoEl = document.getElementById('battleBackgroundVideo');
            if (videoEl) {
                videoEl.pause();
                videoEl.style.display = 'none';
            }
            battleState.useVideoBackground = false;
        }
        
        // Calculate number of mobs to spawn based on dungeon level
        // Scales from 2 mobs at level 1 up to max 9 mobs at higher levels
        function getMobCountForLevel(level) {
            // Level 1: 2 mobs (intro)
            // Level 2-4: 2 mobs
            // Level 5-9: 3 mobs
            // Level 10-14: 4 mobs
            // Level 15-19: 5 mobs
            // Level 20-29: 6 mobs
            // Level 30-39: 7 mobs
            // Level 40-49: 8 mobs
            // Level 50+: 9 mobs (max)
            if (level < 5) return 2;
            if (level < 10) return 3;
            if (level < 15) return 4;
            if (level < 20) return 5;
            if (level < 30) return 6;
            if (level < 40) return 7;
            if (level < 50) return 8;
            return 9; // Max mobs
        }
        
        // Get boss data file based on difficulty setting
        function getBossDifficultyFile() {
            const difficultyMap = {
                'casual': 'tunnelsofprivacy/bosses/bosses_data_easy.json',
                'normal': 'tunnelsofprivacy/bosses/bosses_data_normal.json',
                'expert': 'tunnelsofprivacy/bosses/bosses_data_hard.json'
            };
            return difficultyMap[settings.difficulty] || difficultyMap['normal'];
        }
        
        // ===== CAMP SYSTEM =====
        
        // Camp state
        let campState = {
            active: false,
            selectedHours: 8,
            hoursRemaining: 0,
            healPerHour: 2,
            startTime: null,
            intervalId: null,
            videoPlaying: false
        };
        
        // Camp video files organized by level ranges
        const campVideos = {
            // Early levels (1-20) - general camp videos
            early: [
                'tunnelsofprivacy/levels/camps/camp_lvl1_var1.mp4',
                'tunnelsofprivacy/levels/camps/camp_lvl1_var2.mp4',
                'tunnelsofprivacy/levels/camps/camp_lvl1_var3.mp4',
                'tunnelsofprivacy/levels/camps/camp_lvl1_var4.mp4'
            ],
            // Mid levels (21-60) - counterfeit vaults area
            mid: [
                'tunnelsofprivacy/levels/camps/camp_lvl5x-6x_counterfeit_vaults_var1.mp4',
                'tunnelsofprivacy/levels/camps/camp_lvl5x-6x_counterfeit_vaults_var2.mp4'
            ],
            // Deep levels (61-90) - descent to core
            deep: [
                'tunnelsofprivacy/levels/camps/camp_lvl9x_descent_to_core_var1.mp4',
                'tunnelsofprivacy/levels/camps/camp_lvl9x_descent_to_core_var2.mp4'
            ],
            // Zone-specific camps
            forkedMaze: ['tunnelsofprivacy/levels/camps/camp_forked_maze_var1.mp4'],
            fungibilityLabyrinth: ['tunnelsofprivacy/levels/camps/camp_fungibility_labyrinth_var1.mp4'],
            haloSpiral: ['tunnelsofprivacy/levels/camps/camp_halo_spiral_var1.mp4'],
            identityDepths: [
                'tunnelsofprivacy/levels/camps/camp_identity_depths_var1.mp4',
                'tunnelsofprivacy/levels/camps/camp_identity_depths_var2.mp4'
            ],
            orchardSanctum: ['tunnelsofprivacy/levels/camps/camp_orchard_sanctum_var1.mp4'],
            // Generic camps
            generic: [
                'tunnelsofprivacy/levels/camps/camps_bitgold_bazaar_var1.mp4',
                'tunnelsofprivacy/levels/camps/camps_collapsed_gallery_var1.mp4',
                'tunnelsofprivacy/levels/camps/camps_crossroads_village_var1.mp4',
                'tunnelsofprivacy/levels/camps/camps_refugee_village_var1.mp4',
                'tunnelsofprivacy/levels/camps/camps_river_tavern_var1.mp4',
                'tunnelsofprivacy/levels/camps/camps_tunnel_inn_var1.mp4'
            ]
        };
        
        // Get appropriate camp video based on current dungeon level
        function getCampVideoForLevel(level) {
            let videoPool = [];
            
            if (level <= 20) {
                videoPool = [...campVideos.early, ...campVideos.generic];
            } else if (level <= 60) {
                videoPool = [...campVideos.mid, ...campVideos.generic];
            } else if (level <= 90) {
                videoPool = [...campVideos.deep, ...campVideos.generic];
            } else {
                // High levels - use zone-specific or generic
                videoPool = [
                    ...campVideos.identityDepths,
                    ...campVideos.orchardSanctum,
                    ...campVideos.haloSpiral,
                    ...campVideos.generic
                ];
            }
            
            // Random selection
            return videoPool[Math.floor(Math.random() * videoPool.length)];
        }
        
        // Open the camp panel
        function openCampPanel() {
            // Host-only check in multiplayer
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                showNotification('Only the party leader can set up camp', 'warning');
                return;
            }
            
            // Close other panels
            const dungeonMastersPanel = document.getElementById('dungeonMastersPanel');
            if (dungeonMastersPanel) dungeonMastersPanel.style.display = 'none';
            
            // Show camp panel
            const campPanel = document.getElementById('campPanel');
            if (campPanel) {
                campPanel.style.display = 'block';
                
                // Update heal preview based on selected hours
                updateCampHealPreview();
                
                // Highlight camp button
                const campBtn = document.getElementById('campBtn');
                if (campBtn) {
                    campBtn.style.background = 'linear-gradient(135deg, rgba(39, 174, 96, 0.7), rgba(39, 174, 96, 0.5))';
                    campBtn.style.borderColor = '#27AE60';
                }
            }
        }
        
        // Close the camp panel
        function closeCampPanel() {
            const campPanel = document.getElementById('campPanel');
            if (campPanel) {
                campPanel.style.display = 'none';
                
                // Reset camp button style
                const campBtn = document.getElementById('campBtn');
                if (campBtn) {
                    campBtn.style.background = '';
                    campBtn.style.borderColor = '';
                }
            }
        }
        
        // Set camp duration
        function setCampDuration(hours) {
            campState.selectedHours = hours;
            
            // Update button states
            const buttons = document.querySelectorAll('.campDurationBtn');
            buttons.forEach(btn => {
                const btnHours = parseInt(btn.dataset.hours);
                if (btnHours === hours) {
                    btn.style.background = 'rgba(39, 174, 96, 0.6)';
                    btn.style.color = 'white';
                    btn.classList.add('active');
                } else {
                    btn.style.background = 'rgba(39, 174, 96, 0.3)';
                    btn.style.color = '#27AE60';
                    btn.classList.remove('active');
                }
            });
            
            // Update heal preview
            updateCampHealPreview();
        }
        
        // Update the heal preview in camp panel
        function updateCampHealPreview() {
            const hours = campState.selectedHours;
            const healAmount = hours * campState.healPerHour;
            
            // Update each hero's heal preview
            const heroes = ['Zooko', 'Nate', 'Zancas', 'CyberAxe'];
            heroes.forEach(hero => {
                const el = document.getElementById(`campHeal${hero}`);
                if (el) {
                    // Calculate actual heal (can't exceed max HP)
                    const heroData = battleState.heroes.find(h => h.name === hero) || 
                                     { hp: 100, maxHp: 100 };
                    const actualHeal = Math.min(healAmount, heroData.maxHp - heroData.hp);
                    el.textContent = actualHeal > 0 ? `+${actualHeal} HP` : 'FULL';
                    el.style.color = actualHeal > 0 ? '#E74C3C' : '#27AE60';
                }
            });
        }
        
        // Start camping
        function startCamping() {
            // Host-only check
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                showNotification('Only the party leader can start camping', 'warning');
                return;
            }
            
            // Set camp state
            campState.active = true;
            campState.hoursRemaining = campState.selectedHours;
            campState.startTime = Date.now();
            
            // Hide dungeon menu
            document.getElementById('dungeonMenuScreen').style.display = 'none';
            closeCampPanel();
            
            // Show camping screen
            const campingScreen = document.getElementById('campingScreen');
            if (campingScreen) {
                campingScreen.style.display = 'block';
            }
            
            // Load and play camp video
            const currentLevel = parseInt(document.getElementById('dungeonMenuLevel')?.textContent) || 1;
            const videoSrc = getCampVideoForLevel(currentLevel);
            const videoEl = document.getElementById('campVideo');
            if (videoEl) {
                videoEl.querySelector('source').src = videoSrc;
                videoEl.load();
                videoEl.volume = 0.05; // 5% volume for ambient camp sounds
                videoEl.play().catch(e => console.log('[Camp] Video autoplay blocked:', e));
                campState.videoPlaying = true;
            }
            
            // Update UI
            document.getElementById('campTimeRemaining').textContent = campState.hoursRemaining;
            document.getElementById('campProgressBar').style.width = '0%';
            document.getElementById('campHealedSoFar').textContent = '0';
            document.getElementById('campEventLog').innerHTML = '<div style="color: #89A0B4; font-size: 12px; text-align: center;">The campfire crackles softly...</div>';
            
            // Start camping timer (1 second = 1 hour in-game for faster gameplay)
            const totalDuration = campState.selectedHours * 1000; // 1 second per hour
            let elapsed = 0;
            let healedSoFar = 0;
            
            campState.intervalId = setInterval(() => {
                elapsed += 100;
                const progress = (elapsed / totalDuration) * 100;
                const hoursElapsed = Math.floor(elapsed / 1000);
                const hoursRemaining = campState.selectedHours - hoursElapsed;
                
                // Update UI
                document.getElementById('campProgressBar').style.width = `${progress}%`;
                document.getElementById('campTimeRemaining').textContent = Math.max(0, hoursRemaining);
                
                // Broadcast progress to clients every 500ms
                if (multiplayerState.enabled && multiplayerState.role === 'host' && elapsed % 500 === 0) {
                    sendWebSocketMessage({
                        type: 'camp_progress',
                        progress: progress,
                        hoursRemaining: Math.max(0, hoursRemaining),
                        healedSoFar: healedSoFar
                    });
                }
                
                // Heal every "hour" (every 1000ms)
                if (hoursElapsed > healedSoFar / campState.healPerHour) {
                    healedSoFar += campState.healPerHour;
                    document.getElementById('campHealedSoFar').textContent = healedSoFar;
                    
                    // Actually heal heroes
                    applyHealToHeroes(campState.healPerHour);
                    
                    // Random camp events (longer rest = more events)
                    if (Math.random() < 0.15 * campState.selectedHours / 8) {
                        triggerCampEvent();
                    }
                }
                
                // Check if camping is complete
                if (elapsed >= totalDuration) {
                    completeCamping();
                }
            }, 100);
            
            // Log start
            addCampEvent('You set up camp and rest by the fire...');
            
            // Broadcast to clients in multiplayer
            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                sendWebSocketMessage({
                    type: 'camp_started',
                    hours: campState.selectedHours,
                    videoSrc: videoSrc
                });
            }
            
            console.log('[Camp] Started camping for', campState.selectedHours, 'hours');
        }
        
        // Apply healing to all heroes - directly updates save file
        function applyHealToHeroes(amount) {
            const sharedSave = loadSharedSave();
            if (!sharedSave || !sharedSave.heroes) return;
            
            // Heal each hero directly in the save (ALL heroes, including knocked out at 0 HP)
            ['zooko', 'nate', 'zancas', 'cyberaxe'].forEach(heroKey => {
                const hero = sharedSave.heroes[heroKey];
                if (hero) {
                    hero.hp = Math.min(hero.hp + amount, hero.maxHp);
                }
            });
            
            saveSharedSave(sharedSave);
            updateDungeonMenuHeroes();
        }
        
        // Add event to camp log
        function addCampEvent(message) {
            const log = document.getElementById('campEventLog');
            if (log) {
                const entry = document.createElement('div');
                entry.style.cssText = 'color: #F2C94C; font-size: 12px; padding: 4px 0; border-bottom: 1px solid rgba(255,255,255,0.1);';
                entry.textContent = `ðŸŒ™ ${message}`;
                log.appendChild(entry);
                log.scrollTop = log.scrollHeight;
            }
        }
        
        // Trigger a random camp event
        function triggerCampEvent() {
            const goodEvents = [
                { text: 'A friendly traveler shares supplies with your party!', effect: 'heal', value: 5 },
                { text: 'The stars align, granting mystical energy!', effect: 'heal', value: 3 },
                { text: 'You find a hidden cache of gold nearby!', effect: 'gold', value: 10 },
                { text: 'A wandering merchant offers a fair trade.', effect: 'gold', value: 5 },
                { text: 'The peaceful rest rejuvenates your spirit.', effect: 'heal', value: 2 }
            ];
            
            const badEvents = [
                { text: 'Bandits steal some of your gold in the night!', effect: 'gold', value: -5 },
                { text: 'A strange noise disturbs your rest...', effect: 'none' },
                { text: 'Wild animals rummage through your supplies.', effect: 'gold', value: -3 },
                { text: 'The cold night air makes sleeping difficult.', effect: 'none' }
            ];
            
            // 70% good, 30% bad events
            const events = Math.random() < 0.7 ? goodEvents : badEvents;
            const event = events[Math.floor(Math.random() * events.length)];
            
            addCampEvent(event.text);
            
            // Broadcast event to clients
            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                sendWebSocketMessage({
                    type: 'camp_event',
                    text: event.text
                });
            }
            
            // Apply event effect
            if (event.effect === 'heal' && event.value > 0) {
                applyHealToHeroes(event.value);
            } else if (event.effect === 'gold') {
                // Update gold in sharedSave (host only)
                if (!multiplayerState.enabled || multiplayerState.role === 'host') {
                    const sharedSave = loadSharedSave();
                    if (sharedSave) {
                        if (!sharedSave.dungeonState) sharedSave.dungeonState = {};
                        sharedSave.dungeonState.gold = Math.max(0, (sharedSave.dungeonState.gold || 0) + event.value);
                        saveSharedSave(sharedSave);
                    }
                }
                updateGoldDisplay();
            }
        }
        
        // Cancel camping early
        function cancelCamping() {
            if (!campState.active) return;
            
            addCampEvent('You break camp early and prepare to move on.');
            
            // Clear interval
            if (campState.intervalId) {
                clearInterval(campState.intervalId);
                campState.intervalId = null;
            }
            
            // Stop video
            const videoEl = document.getElementById('campVideo');
            if (videoEl) {
                videoEl.pause();
                campState.videoPlaying = false;
            }
            
            campState.active = false;
            
            // Save hero states (host only in multiplayer)
            if (!multiplayerState.enabled || multiplayerState.role === 'host') {
                const sharedSave = loadSharedSave();
                if (sharedSave && sharedSave.heroes) {
                    battleState.heroes.forEach(hero => {
                        const heroKey = hero.name.toLowerCase();
                        if (sharedSave.heroes[heroKey]) {
                            sharedSave.heroes[heroKey].hp = hero.hp;
                            sharedSave.heroes[heroKey].maxHp = hero.maxHp;
                        }
                    });
                    sharedSave.lastPlayed = Date.now();
                    saveSharedSave(sharedSave);
                }
            }
            
            // Return to dungeon menu
            document.getElementById('campingScreen').style.display = 'none';
            document.getElementById('dungeonMenuScreen').style.display = 'block';
            
            showNotification('Camp broken early', 'info');
        }
        
        // Complete camping
        function completeCamping() {
            // Clear interval
            if (campState.intervalId) {
                clearInterval(campState.intervalId);
                campState.intervalId = null;
            }
            
            // Final heal summary
            const totalHealed = campState.selectedHours * campState.healPerHour;
            addCampEvent(`Well rested! Total healing: ${totalHealed} HP per hero.`);
            
            // Stop video
            const videoEl = document.getElementById('campVideo');
            if (videoEl) {
                videoEl.pause();
                campState.videoPlaying = false;
            }
            
            campState.active = false;
            
            // Brief delay before returning to menu
            setTimeout(() => {
                document.getElementById('campingScreen').style.display = 'none';
                document.getElementById('dungeonMenuScreen').style.display = 'block';
                updateDungeonMenuHeroes();
                
                showNotification(`Party rested for ${campState.selectedHours} hours! +${totalHealed} HP healed.`, 'success');
                
                // Broadcast completion in multiplayer
                if (multiplayerState.enabled && multiplayerState.role === 'host') {
                    const sharedSave = loadSharedSave();
                    sendWebSocketMessage({
                        type: 'camp_completed',
                        hoursRested: campState.selectedHours,
                        healedAmount: totalHealed,
                        heroes: sharedSave ? [
                            { name: 'Zooko', hp: sharedSave.heroes.zooko?.hp, maxHp: sharedSave.heroes.zooko?.maxHp },
                            { name: 'Nate', hp: sharedSave.heroes.nate?.hp, maxHp: sharedSave.heroes.nate?.maxHp },
                            { name: 'Zancas', hp: sharedSave.heroes.zancas?.hp, maxHp: sharedSave.heroes.zancas?.maxHp },
                            { name: 'CyberAxe', hp: sharedSave.heroes.cyberaxe?.hp, maxHp: sharedSave.heroes.cyberaxe?.maxHp }
                        ] : []
                    });
                }
            }, 1500);
            
            console.log('[Camp] Camping complete');
        }
        
        // Toggle Dungeon Masters panel visibility
        function toggleDungeonMasters() {
            // Close camp panel if open
            closeCampPanel();
            
            const panel = document.getElementById('dungeonMastersPanel');
            const btn = document.getElementById('dungeonMastersBtn');
            if (panel) {
                const isVisible = panel.style.display !== 'none';
                panel.style.display = isVisible ? 'none' : 'block';
                
                // Update button style to show active state
                if (btn) {
                    if (isVisible) {
                        btn.style.background = 'linear-gradient(135deg, rgba(139, 69, 255, 0.4), rgba(75, 0, 130, 0.4))';
                        btn.style.borderColor = '';
                    } else {
                        btn.style.background = 'linear-gradient(135deg, rgba(139, 69, 255, 0.7), rgba(75, 0, 130, 0.7))';
                        btn.style.borderColor = '#F2C94C';
                    }
                }
            }
        }
        
        // Set game difficulty and regenerate encounter
        function setDifficulty(difficulty) {
            // In multiplayer, only host can change difficulty
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                showNotification('Only the party leader can change difficulty', 'warning');
                return;
            }
            
            // Don't do anything if same difficulty
            if (settings.difficulty === difficulty) {
                return;
            }
            
            settings.difficulty = difficulty;
            saveSettings();
            
            // Update button highlights
            updateDifficultyButtons();
            
            // Reset and regenerate the queued encounter
            preGeneratedEncounter = {
                ready: false,
                generating: false,
                boss: null,
                mobs: [],
                captive: null,
                background: null,
                roomLevel: preGeneratedEncounter.roomLevel || 1
            };
            updateExploreLoadingBar(0);
            
            // Start regenerating
            preGenerateNextEncounter();
            
            const difficultyNames = { 'casual': 'Casual', 'normal': 'Normal', 'expert': 'Expert' };
            showNotification(`Difficulty set to ${difficultyNames[difficulty]}`, 'info');
            console.log('[Difficulty] Changed to:', difficulty);
            
            // In multiplayer, broadcast difficulty change to clients
            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                sendWebSocketMessage({
                    type: 'difficulty_change',
                    difficulty: difficulty
                });
            }
        }
        
        // Update difficulty button visual states
        function updateDifficultyButtons() {
            const buttons = {
                'casual': document.getElementById('diffCasualBtn'),
                'normal': document.getElementById('diffNormalBtn'),
                'expert': document.getElementById('diffExpertBtn')
            };
            
            // Reset all buttons
            Object.values(buttons).forEach(btn => {
                if (btn) {
                    btn.style.background = '';
                    btn.style.borderColor = '';
                    btn.style.boxShadow = '';
                }
            });
            
            // Highlight selected difficulty
            const selectedBtn = buttons[settings.difficulty];
            if (selectedBtn) {
                const colors = {
                    'casual': { bg: 'rgba(39, 174, 96, 0.4)', border: '#27AE60', shadow: '0 0 15px rgba(39, 174, 96, 0.5)' },
                    'normal': { bg: 'rgba(242, 201, 76, 0.4)', border: '#F2C94C', shadow: '0 0 15px rgba(242, 201, 76, 0.5)' },
                    'expert': { bg: 'rgba(235, 87, 87, 0.4)', border: '#EB5757', shadow: '0 0 15px rgba(235, 87, 87, 0.5)' }
                };
                const c = colors[settings.difficulty];
                selectedBtn.style.background = `linear-gradient(135deg, ${c.bg}, ${c.bg})`;
                selectedBtn.style.borderColor = c.border;
                selectedBtn.style.boxShadow = c.shadow;
            }
        }
        
        // ===== DUNGEON MENU STORY BACKGROUND ANIMATION =====
        // Sprite atlas format: 8 cols x 16 rows = 128 frames at 16fps
        const STORY_COLS = 8;
        const STORY_ROWS = 16;
        const STORY_TOTAL_FRAMES = 128;
        const STORY_FPS = 16;
        
        let storyBackgroundFrame = 0;
        let storyBackgroundDirection = 1; // 1 = forward, -1 = backward (ping-pong)
        let storyBackgroundIntervalId = null;
        let currentStoryAnimation = null;
        
        // Story animations based on dungeon level
        const dungeonStoryLoops = [
            { file: 'story/intro/intro_a.png', minLevel: 1, maxLevel: 2, pingpong: true },
            { file: 'story/intro/intro_b.png', minLevel: 3, maxLevel: 4, pingpong: true },
            { file: 'story/intro/intro_c.png', minLevel: 5, maxLevel: 5, pingpong: true },
            { file: 'story/intro/intro_d.png', minLevel: 6, maxLevel: 7, pingpong: true },
            { file: 'story/intro/intro_e.png', minLevel: 8, maxLevel: 9, pingpong: true },
            { file: 'story/lvl1/story_lvl_1.png', minLevel: 10, maxLevel: 12, pingpong: true },
            { file: 'story/lvl1/story_lvl_1_loop.png', minLevel: 13, maxLevel: 19, pingpong: false },
            { file: 'story/lvl2/story_lvl_2.png', minLevel: 20, maxLevel: 22, pingpong: true },
            { file: 'story/lvl2/story_lvl_2_idle.png', minLevel: 23, maxLevel: 29, pingpong: false },
            { file: 'story/lvl3/story_lvl_3.png', minLevel: 30, maxLevel: 32, pingpong: true },
            { file: 'story/lvl3/story_lvl_3_idle.png', minLevel: 33, maxLevel: 39, pingpong: false },
            { file: 'story/lvl4/story_lvl_4.png', minLevel: 40, maxLevel: 42, pingpong: true },
            { file: 'story/lvl4/story_lvl_4_idle.png', minLevel: 43, maxLevel: 49, pingpong: false },
            { file: 'story/lvl5/story_lvl_5.png', minLevel: 50, maxLevel: 52, pingpong: true },
            { file: 'story/lvl5/story_lvl_5_idle.png', minLevel: 53, maxLevel: 59, pingpong: false },
            { file: 'story/lvl6/story_lvl_6.png', minLevel: 60, maxLevel: 62, pingpong: true },
            { file: 'story/lvl6/story_lvl_6_idle.png', minLevel: 63, maxLevel: 69, pingpong: false },
            { file: 'story/lvl7/story_lvl_7.png', minLevel: 70, maxLevel: 72, pingpong: true },
            { file: 'story/lvl7/story_lvl_7_idle.png', minLevel: 73, maxLevel: 79, pingpong: false },
            { file: 'story/lvl8/story_lvl_8.png', minLevel: 80, maxLevel: 82, pingpong: true },
            { file: 'story/lvl8/story_lvl_8_idle.png', minLevel: 83, maxLevel: 89, pingpong: false },
            { file: 'story/lvl9/story_lvl_9.png', minLevel: 90, maxLevel: 92, pingpong: true },
            { file: 'story/lvl9/story_lvl_9_idle.png', minLevel: 93, maxLevel: 99, pingpong: false },
            { file: 'story/lvl10/story_lvl_10.png', minLevel: 100, maxLevel: 102, pingpong: true },
            { file: 'story/lvl10/story_lvl_10_idle.png', minLevel: 103, maxLevel: 199, pingpong: false },
            { file: 'story/up_1/story_up_1.png', minLevel: 200, maxLevel: 210, pingpong: true },
            { file: 'story/up_1/story_up_1_idle.png', minLevel: 211, maxLevel: 399, pingpong: false },
            { file: 'story/up_2/story_up_2.png', minLevel: 400, maxLevel: 410, pingpong: true },
            { file: 'story/up_2/story_up_2_idle.png', minLevel: 411, maxLevel: 599, pingpong: false },
            { file: 'story/up_3/story_up_3.png', minLevel: 600, maxLevel: 610, pingpong: true },
            { file: 'story/up_3/story_up_3_idle.png', minLevel: 611, maxLevel: 799, pingpong: false },
            { file: 'story/up_4/story_up_4.png', minLevel: 800, maxLevel: 810, pingpong: true },
            { file: 'story/up_4/story_up_4_idle.png', minLevel: 811, maxLevel: 999, pingpong: false },
            { file: 'story/up_5/story_up_5.png', minLevel: 1000, maxLevel: 1005, pingpong: true },
            { file: 'story/up_5/story_up_5_idle.png', minLevel: 1006, maxLevel: 9999, pingpong: false },
            { file: 'story/end/end.png', minLevel: 10000, maxLevel: 999999, pingpong: true }
        ];
        
        // Get story animation for current level
        function getDungeonStoryAnimation(level) {
            for (const loop of dungeonStoryLoops) {
                if (level >= loop.minLevel && level <= loop.maxLevel) {
                    return loop;
                }
            }
            // Default to first animation
            return dungeonStoryLoops[0];
        }
        
        // Start dungeon menu background animation
        function startDungeonMenuAnimation() {
            const bgElement = document.getElementById('dungeonMenuBackground');
            if (!bgElement) return;
            
            // Get current dungeon level
            const dungeonLevelEl = document.getElementById('dungeonMenuLevel');
            const currentLevel = parseInt(dungeonLevelEl?.textContent) || 1;
            
            // Get appropriate animation for this level
            const animData = getDungeonStoryAnimation(currentLevel);
            
            // Only reload if animation changed
            if (currentStoryAnimation !== animData.file) {
                currentStoryAnimation = animData.file;
                storyBackgroundFrame = 0;
                storyBackgroundDirection = 1;
                
                // Set sprite atlas as background
                bgElement.style.backgroundImage = `url('${animData.file}')`;
                bgElement.style.backgroundSize = `${STORY_COLS * 100}% ${STORY_ROWS * 100}%`;
                bgElement.style.opacity = '0.25';
                
                console.log('[StoryBG] Loaded animation:', animData.file, 'for level', currentLevel);
            }
            
            // Stop existing animation if running
            if (storyBackgroundIntervalId) {
                clearInterval(storyBackgroundIntervalId);
            }
            
            // Start frame animation at 16fps
            const frameInterval = 1000 / STORY_FPS;
            const isPingPong = animData.pingpong;
            
            storyBackgroundIntervalId = setInterval(() => {
                // Calculate current frame position in atlas
                const col = storyBackgroundFrame % STORY_COLS;
                const row = Math.floor(storyBackgroundFrame / STORY_COLS);
                
                // Set background position to show current frame
                const xPercent = (col / (STORY_COLS - 1)) * 100;
                const yPercent = (row / (STORY_ROWS - 1)) * 100;
                bgElement.style.backgroundPosition = `${xPercent}% ${yPercent}%`;
                
                // Advance frame
                if (isPingPong) {
                    // Ping-pong mode: forward then backward
                    storyBackgroundFrame += storyBackgroundDirection;
                    
                    if (storyBackgroundFrame >= STORY_TOTAL_FRAMES - 1) {
                        storyBackgroundFrame = STORY_TOTAL_FRAMES - 1;
                        storyBackgroundDirection = -1;
                    } else if (storyBackgroundFrame <= 0) {
                        storyBackgroundFrame = 0;
                        storyBackgroundDirection = 1;
                    }
                } else {
                    // Loop mode: restart at beginning
                    storyBackgroundFrame++;
                    if (storyBackgroundFrame >= STORY_TOTAL_FRAMES) {
                        storyBackgroundFrame = 0;
                    }
                }
            }, frameInterval);
        }
        
        // Stop dungeon menu background animation
        function stopDungeonMenuAnimation() {
            if (storyBackgroundIntervalId) {
                clearInterval(storyBackgroundIntervalId);
                storyBackgroundIntervalId = null;
            }
        }
        
        // Update story background when level changes
        function updateDungeonMenuBackground() {
            // Only update if dungeon menu is visible
            if (currentScreen === 'dungeonMenu') {
                startDungeonMenuAnimation();
            }
        }
        // ===== END DUNGEON MENU STORY BACKGROUND ANIMATION =====
        
        // Pre-generated encounter data (prepared while in dungeon menu)
        let preGeneratedEncounter = {
            ready: false,
            generating: false,
            boss: null,
            mobs: [],
            captive: null,
            background: null,
            roomLevel: 2,
            roomType: 'combat',   // Room type from level layout
            storeData: null,      // Store room merchant/items
            secretData: null,     // Secret room rewards
            npcData: null,        // NPC room data
            explorationData: null // Exploration event data
        };
        
        // Pre-generate the next encounter while player is in dungeon menu
        async function preGenerateNextEncounter() {
            // Don't regenerate if already ready or currently generating
            if (preGeneratedEncounter.ready || preGeneratedEncounter.generating) {
                return;
            }
            
            // Only host generates encounters
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                return;
            }
            
            preGeneratedEncounter.generating = true;
            
            // Reset loading bar
            updateExploreLoadingBar(0);
            
            try {
                const roomLevel = preGeneratedEncounter.roomLevel;
                
                // Get room type from level layout (or default to combat)
                const roomType = getNextRoomType();
                preGeneratedEncounter.roomType = roomType;
                console.log(`[PreGen] Generating ${roomType} room for level ${roomLevel}`);
                
                // Load enemy data based on difficulty setting (needed for combat/boss rooms)
                let bossesData = [];
                let mobsData = [];
                if (roomType === 'combat' || roomType === 'boss' || roomType === 'mini_boss') {
                    try {
                        const difficultyFile = getBossDifficultyFile();
                        const bossResponse = await fetch(difficultyFile);
                        bossesData = await bossResponse.json();
                        const mobResponse = await fetch('tunnelsofprivacy/mobs/mobs_data.json');
                        const mobObj = await mobResponse.json();
                        mobsData = mobObj.mobs || [];
                    } catch(e) {
                        console.error('[PreGen] Failed to load enemy data:', e);
                        preGeneratedEncounter.generating = false;
                        updateExploreLoadingBar(0);
                        return;
                    }
                }
                updateExploreLoadingBar(10);  // Data loaded
                
                // Generate content based on room type
                switch (roomType) {
                    case 'boss':
                        // Boss room - always has the level boss
                        await generateBossRoomContent(bossesData, roomLevel);
                        break;
                    
                    case 'mini_boss':
                        // Mini-boss room - tougher than normal, but not the main boss
                        await generateMiniBossRoomContent(bossesData, mobsData, roomLevel);
                        break;
                    
                    case 'store':
                        // Store room - merchant with items to buy
                        await generateStoreRoomContent(roomLevel);
                        break;
                    
                    case 'secret':
                        // Secret room - special treasure/event
                        await generateSecretRoomContent(roomLevel);
                        break;
                    
                    case 'npc':
                        // NPC room - friendly character interaction
                        await generateNPCRoomContent(roomLevel);
                        break;
                    
                    case 'exploration':
                        // Exploration event - puzzle/trap/discovery
                        await generateExplorationRoomContent(roomLevel);
                        break;
                    
                    case 'combat':
                    default:
                        // Standard combat room
                        await generateCombatRoomContent(bossesData, mobsData, roomLevel);
                        break;
                }
                
                // Pre-select background (all room types get a background)
                const backgroundOptions = [
                    'backgrounds_lvl1 (8).png',
                    'backgrounds_lvl1 (10).png',
                    'backgrounds_lvl1 (12).png',
                    'backgrounds_lvl1 (14).png',
                    'backgrounds_lvl1 (15).png',
                    'backgrounds_lvl1 (16).png'
                ];
                preGeneratedEncounter.background = backgroundOptions[Math.floor(Math.random() * backgroundOptions.length)];
                
                preGeneratedEncounter.ready = true;
                preGeneratedEncounter.generating = false;
                updateExploreLoadingBar(100);  // Complete!
                
                // Update the Next Room Preview UI
                updateNextRoomPreview();
                updateLevelLayoutDisplay();
                
            } catch (error) {
                console.error('[PreGen] Error during pre-generation:', error);
                preGeneratedEncounter.generating = false;
                updateExploreLoadingBar(0);
            }
        }
        
        // ===== ROOM TYPE GENERATION FUNCTIONS =====
        
        // Generate standard combat room content
        async function generateCombatRoomContent(bossesData, mobsData, roomLevel) {
            // Standard combat has no boss, just mobs
            preGeneratedEncounter.boss = null;
            preGeneratedEncounter.mobs = [];
            
            const hostileMobs = mobsData.filter(m => m.behavior?.hostile && (m.minLevel === undefined || m.minLevel <= roomLevel));
            const mobCount = getMobCountForLevel(roomLevel);
            const mobProgressPerMob = 60 / mobCount; // Distribute 60% progress across all mobs
            
            for (let i = 0; i < mobCount && i < hostileMobs.length; i++) {
                const mob = hostileMobs[Math.floor(Math.random() * hostileMobs.length)];
                const generatedMob = await generateEncounter('mob', mob, roomLevel);
                preGeneratedEncounter.mobs.push({
                    baseData: mob,
                    generated: generatedMob
                });
                updateExploreLoadingBar(10 + Math.round((i + 1) * mobProgressPerMob));
                await new Promise(r => setTimeout(r, 300));
            }
            
            // Generate captive (50% chance)
            preGeneratedEncounter.captive = null;
            if (Math.random() > 0.5) {
                const captiveData = await generateEncounter('captive', {}, roomLevel);
                const captiveSpriteNum = Math.floor(Math.random() * 12) + 1;
                preGeneratedEncounter.captive = {
                    generated: captiveData,
                    spriteNum: captiveSpriteNum
                };
            }
            updateExploreLoadingBar(90);
        }
        
        // Generate boss room content (level boss)
        async function generateBossRoomContent(bossesData, roomLevel) {
            preGeneratedEncounter.mobs = [];
            preGeneratedEncounter.captive = null;
            
            // Level 1 has no boss (casual intro level)
            if (roomLevel < 2) {
                preGeneratedEncounter.boss = null;
                updateExploreLoadingBar(90);
                return;
            }
            
            let boss = bossesData.find(b => b.mainLevel === roomLevel);
            
            // Fallback for levels without exact boss match
            if (!boss) {
                if (roomLevel > 100) {
                    boss = bossesData[Math.floor(Math.random() * bossesData.length)];
                } else {
                    console.warn(`[PreGen] No boss found for level ${roomLevel}, finding nearest...`);
                    const sortedBosses = [...bossesData].sort((a, b) => 
                        Math.abs(a.mainLevel - roomLevel) - Math.abs(b.mainLevel - roomLevel)
                    );
                    boss = sortedBosses[0];
                }
            }
            
            if (boss) {
                const generatedBoss = await generateEncounter('boss', boss, roomLevel);
                preGeneratedEncounter.boss = {
                    baseData: boss,
                    generated: generatedBoss
                };
            }
            updateExploreLoadingBar(90);
        }
        
        // Generate mini-boss room content
        async function generateMiniBossRoomContent(bossesData, mobsData, roomLevel) {
            // Mini-boss: pick a boss from lower levels or a tougher mob
            preGeneratedEncounter.mobs = [];
            preGeneratedEncounter.captive = null;
            
            // Try to find a boss from earlier levels
            const lowerLevelBosses = bossesData.filter(b => b.mainLevel < roomLevel && b.mainLevel >= Math.max(1, roomLevel - 10));
            
            let miniBoss = null;
            if (lowerLevelBosses.length > 0) {
                miniBoss = lowerLevelBosses[Math.floor(Math.random() * lowerLevelBosses.length)];
            } else if (bossesData.length > 0) {
                // Use any random boss
                miniBoss = bossesData[Math.floor(Math.random() * bossesData.length)];
            }
            
            if (miniBoss) {
                const generatedBoss = await generateEncounter('boss', miniBoss, roomLevel);
                preGeneratedEncounter.boss = {
                    baseData: miniBoss,
                    generated: generatedBoss,
                    isMiniBoss: true
                };
            }
            updateExploreLoadingBar(90);
        }
        
        // Generate store room content
        async function generateStoreRoomContent(roomLevel) {
            preGeneratedEncounter.boss = null;
            preGeneratedEncounter.mobs = [];
            preGeneratedEncounter.captive = null;
            
            // Store data - items available for purchase
            preGeneratedEncounter.storeData = {
                merchantName: getRandomMerchantName(),
                items: generateStoreItems(roomLevel),
                greeting: getRandomMerchantGreeting()
            };
            
            console.log('[PreGen] Generated store with', preGeneratedEncounter.storeData.items.length, 'items');
            updateExploreLoadingBar(90);
        }
        
        // Generate secret room content
        async function generateSecretRoomContent(roomLevel) {
            preGeneratedEncounter.boss = null;
            preGeneratedEncounter.mobs = [];
            preGeneratedEncounter.captive = null;
            
            // Secret room rewards
            const secretTypes = ['treasure', 'artifact', 'shrine', 'knowledge'];
            const secretType = secretTypes[Math.floor(Math.random() * secretTypes.length)];
            
            preGeneratedEncounter.secretData = {
                type: secretType,
                reward: generateSecretReward(secretType, roomLevel),
                description: getSecretDescription(secretType)
            };
            
            console.log('[PreGen] Generated secret room:', secretType);
            updateExploreLoadingBar(90);
        }
        
        // Generate NPC room content
        async function generateNPCRoomContent(roomLevel) {
            preGeneratedEncounter.boss = null;
            preGeneratedEncounter.mobs = [];
            preGeneratedEncounter.captive = null;
            
            // NPC encounter - friendly character
            const npcTypes = ['adventurer', 'scholar', 'healer', 'guide'];
            const npcType = npcTypes[Math.floor(Math.random() * npcTypes.length)];
            
            preGeneratedEncounter.npcData = {
                type: npcType,
                name: getRandomNPCName(npcType),
                dialogue: getNPCDialogue(npcType, roomLevel),
                service: getNPCService(npcType, roomLevel)
            };
            
            console.log('[PreGen] Generated NPC room:', npcType);
            updateExploreLoadingBar(90);
        }
        
        // Generate exploration event room content
        async function generateExplorationRoomContent(roomLevel) {
            preGeneratedEncounter.boss = null;
            preGeneratedEncounter.mobs = [];
            preGeneratedEncounter.captive = null;
            
            // Exploration events
            const eventTypes = ['puzzle', 'trap', 'discovery', 'environmental'];
            const eventType = eventTypes[Math.floor(Math.random() * eventTypes.length)];
            
            preGeneratedEncounter.explorationData = {
                type: eventType,
                challenge: generateExplorationChallenge(eventType, roomLevel),
                reward: generateExplorationReward(eventType, roomLevel)
            };
            
            console.log('[PreGen] Generated exploration event:', eventType);
            updateExploreLoadingBar(90);
        }
        
        // ===== STORE HELPERS =====
        function getRandomMerchantName() {
            const names = ['Zashop the Vendor', 'Cryptkeeper\'s Cache', 'The Shield Merchant', 'Thornwick\'s Treasures', 'Dusty Dale\'s Goods'];
            return names[Math.floor(Math.random() * names.length)];
        }
        
        function getRandomMerchantGreeting() {
            const greetings = [
                'Welcome, brave adventurer! Take a look at my wares.',
                'Ah, customers! Please, browse to your heart\'s content.',
                'Looking for something special? I might have just the thing.',
                'My prices are fair, my goods are... mostly legitimate.',
                'Heroes! Perfect timing. I have new stock from the upper levels.'
            ];
            return greetings[Math.floor(Math.random() * greetings.length)];
        }
        
        function generateStoreItems(roomLevel) {
            const items = [];
            const itemCount = 3 + Math.floor(roomLevel / 10); // More items at deeper levels
            
            const itemTypes = [
                { name: 'Health Potion', type: 'consumable', effect: 'heal', value: 25, basePrice: 50 },
                { name: 'Mana Elixir', type: 'consumable', effect: 'mana', value: 20, basePrice: 40 },
                { name: 'Strength Tonic', type: 'consumable', effect: 'buff_str', value: 2, basePrice: 75 },
                { name: 'Shield Charm', type: 'consumable', effect: 'buff_ac', value: 2, basePrice: 60 },
                { name: 'Speed Potion', type: 'consumable', effect: 'buff_dex', value: 2, basePrice: 65 },
                { name: 'Antidote', type: 'consumable', effect: 'cure_poison', value: 1, basePrice: 30 },
                { name: 'Scroll of Insight', type: 'consumable', effect: 'reveal', value: 1, basePrice: 100 }
            ];
            
            for (let i = 0; i < Math.min(itemCount, 7); i++) {
                const baseItem = itemTypes[Math.floor(Math.random() * itemTypes.length)];
                items.push({
                    ...baseItem,
                    price: Math.floor(baseItem.basePrice * (1 + roomLevel * 0.1)),
                    quantity: 1 + Math.floor(Math.random() * 3)
                });
            }
            
            return items;
        }
        
        // ===== SECRET ROOM HELPERS =====
        function generateSecretReward(secretType, roomLevel) {
            const baseXP = 50 * roomLevel;
            const baseGold = 100 * roomLevel;
            
            switch (secretType) {
                case 'treasure':
                    return { gold: baseGold * 2, xp: baseXP };
                case 'artifact':
                    return { item: 'Mysterious Artifact', xp: baseXP * 2 };
                case 'shrine':
                    return { blessing: 'temporary_buff', xp: baseXP, duration: 3 };
                case 'knowledge':
                    return { xp: baseXP * 3, lore: 'Ancient Zcash Knowledge' };
                default:
                    return { xp: baseXP };
            }
        }
        
        function getSecretDescription(secretType) {
            const descriptions = {
                'treasure': 'You discover a hidden cache of valuables!',
                'artifact': 'A strange artifact glows with mysterious energy...',
                'shrine': 'An ancient shrine radiates peaceful power.',
                'knowledge': 'Cryptic writings cover the walls of this hidden chamber.'
            };
            return descriptions[secretType] || 'You found something interesting...';
        }
        
        // ===== NPC HELPERS =====
        function getRandomNPCName(npcType) {
            const names = {
                'adventurer': ['Marcus the Bold', 'Elena Swift', 'Gruff Ironfoot', 'Lily Shadowstep'],
                'scholar': ['Professor Zook', 'Sage Whisperwind', 'Archivist Dusty', 'Lorekeeper Nyx'],
                'healer': ['Sister Mercy', 'Brother Calm', 'Herbalist Fern', 'Medic Kane'],
                'guide': ['Old Map Murphy', 'Scout Keen-Eye', 'Pathfinder Rosa', 'Tunnel Tom']
            };
            const typeNames = names[npcType] || names['adventurer'];
            return typeNames[Math.floor(Math.random() * typeNames.length)];
        }
        
        function getNPCDialogue(npcType, roomLevel) {
            const dialogues = {
                'adventurer': `I've been exploring these tunnels for days. Level ${roomLevel} is treacherous - stay alert!`,
                'scholar': `Fascinating! The cryptographic inscriptions here suggest ancient Zcash knowledge...`,
                'healer': `You look weary, travelers. Let me tend to your wounds.`,
                'guide': `I know these passages well. The boss room is nearby - I can feel it.`
            };
            return dialogues[npcType] || 'Hello there, traveler.';
        }
        
        function getNPCService(npcType, roomLevel) {
            const services = {
                'adventurer': { type: 'hint', description: 'Share combat tips' },
                'scholar': { type: 'lore', description: 'Reveal level secrets' },
                'healer': { type: 'heal', description: 'Restore HP', value: 25 + roomLevel * 5 },
                'guide': { type: 'reveal', description: 'Show remaining rooms' }
            };
            return services[npcType] || { type: 'chat', description: 'Friendly conversation' };
        }
        
        // ===== EXPLORATION HELPERS =====
        function generateExplorationChallenge(eventType, roomLevel) {
            const challenges = {
                'puzzle': { type: 'riddle', difficulty: roomLevel, description: 'Solve the ancient puzzle' },
                'trap': { type: 'avoid', difficulty: roomLevel, description: 'Navigate the trapped corridor' },
                'discovery': { type: 'search', difficulty: roomLevel, description: 'Investigate the strange markings' },
                'environmental': { type: 'survive', difficulty: roomLevel, description: 'Deal with hazardous conditions' }
            };
            return challenges[eventType] || challenges['discovery'];
        }
        
        function generateExplorationReward(eventType, roomLevel) {
            const baseXP = 30 * roomLevel;
            return {
                xp: baseXP,
                bonus: eventType === 'puzzle' ? 'intelligence_boost' : eventType === 'trap' ? 'dexterity_boost' : null
            };
        }
        
        // ===== END ROOM TYPE GENERATION FUNCTIONS =====
        
        // ===== NON-COMBAT ROOM SYSTEM =====
        
        // State for non-combat rooms
        let nonCombatRoomState = {
            active: false,
            roomType: null,
            data: null
        };
        
        // Enter a non-combat room (store, NPC, secret, exploration)
        function enterNonCombatRoom(roomType) {
            console.log('[NonCombat] Entering room type:', roomType);
            
            nonCombatRoomState.active = true;
            nonCombatRoomState.roomType = roomType;
            nonCombatRoomState.data = preGeneratedEncounter;
            
            // Stop dungeon menu animation
            stopDungeonMenuAnimation();
            
            // Hide dungeon menu, show non-combat room
            currentScreen = 'nonCombatRoom';
            document.getElementById('dungeonMenuScreen').style.display = 'none';
            document.getElementById('nonCombatRoomScreen').style.display = 'block';
            
            // Move music controls
            document.getElementById('musicControls').classList.add('battleActive');
            document.getElementById('musicTicker').classList.add('battleActive');
            
            // Set background
            if (preGeneratedEncounter.background) {
                document.getElementById('nonCombatBackground').style.backgroundImage = 
                    `url('tunnelsofprivacy/backgrounds/${preGeneratedEncounter.background}')`;
            }
            
            // Configure room display based on type
            const roomConfigs = {
                'store': { icon: 'ðŸª', title: 'MERCHANT\'S SHOP', subtitle: 'Browse the wares...', color: '#27AE60' },
                'npc': { icon: 'ðŸ‘¤', title: 'FRIENDLY ENCOUNTER', subtitle: 'Someone approaches...', color: '#3498DB' },
                'secret': { icon: 'âœ¨', title: 'SECRET ROOM', subtitle: 'You found something hidden!', color: '#F1C40F' },
                'exploration': { icon: 'ðŸ”', title: 'EXPLORATION', subtitle: 'An interesting discovery...', color: '#9B59B6' }
            };
            
            const config = roomConfigs[roomType] || roomConfigs['exploration'];
            document.getElementById('nonCombatRoomIcon').textContent = config.icon;
            document.getElementById('nonCombatRoomTitle').textContent = config.title;
            document.getElementById('nonCombatRoomTitle').style.color = config.color;
            document.getElementById('nonCombatRoomSubtitle').textContent = config.subtitle;
            
            // Hide all content sections first
            document.getElementById('storeContent').style.display = 'none';
            document.getElementById('npcContent').style.display = 'none';
            document.getElementById('secretContent').style.display = 'none';
            document.getElementById('explorationContent').style.display = 'none';
            
            // Show appropriate content
            switch (roomType) {
                case 'store':
                    populateStoreContent();
                    document.getElementById('storeContent').style.display = 'block';
                    break;
                case 'npc':
                    populateNPCContent();
                    document.getElementById('npcContent').style.display = 'block';
                    break;
                case 'secret':
                    populateSecretContent();
                    document.getElementById('secretContent').style.display = 'block';
                    break;
                case 'exploration':
                    populateExplorationContent();
                    document.getElementById('explorationContent').style.display = 'block';
                    break;
            }
            
            // Handle multiplayer - client sees waiting message if not host
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                document.getElementById('nonCombatLeaveBtn').style.opacity = '0.5';
            } else {
                document.getElementById('nonCombatLeaveBtn').style.opacity = '1';
            }
            document.getElementById('nonCombatWaitingMsg').style.display = 'none';
            
            // Broadcast to clients in multiplayer
            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                sendWebSocketMessage({
                    type: 'non_combat_room',
                    action: 'enter',
                    roomType: roomType,
                    data: {
                        storeData: preGeneratedEncounter.storeData,
                        npcData: preGeneratedEncounter.npcData,
                        secretData: preGeneratedEncounter.secretData,
                        explorationData: preGeneratedEncounter.explorationData,
                        background: preGeneratedEncounter.background
                    }
                });
            }
        }
        
        // Populate store content
        function populateStoreContent() {
            const storeData = preGeneratedEncounter.storeData;
            if (!storeData) return;
            
            document.getElementById('merchantGreeting').textContent = `"${storeData.greeting}"`;
            
            const itemsContainer = document.getElementById('storeItems');
            itemsContainer.innerHTML = '';
            
            storeData.items.forEach((item, index) => {
                const itemEl = document.createElement('div');
                itemEl.style.cssText = 'background: rgba(39, 174, 96, 0.2); border: 2px solid #27AE60; border-radius: 10px; padding: 15px; text-align: center;';
                itemEl.innerHTML = `
                    <div style="font-size: 24px; margin-bottom: 5px;">ðŸ§ª</div>
                    <div style="color: #27AE60; font-weight: bold; font-size: 14px;">${item.name}</div>
                    <div style="color: #FFD700; font-size: 16px; margin: 5px 0;">ðŸ’° ${item.price}</div>
                    <div style="color: #89A0B4; font-size: 12px;">Qty: ${item.quantity}</div>
                    <button onclick="buyItem(${index})" style="margin-top: 10px; padding: 5px 15px; background: #27AE60; border: none; border-radius: 5px; color: white; cursor: pointer; font-weight: bold;">BUY</button>
                `;
                itemsContainer.appendChild(itemEl);
            });
        }
        
        // Populate NPC content
        function populateNPCContent() {
            const npcData = preGeneratedEncounter.npcData;
            if (!npcData) return;
            
            document.getElementById('npcName').textContent = npcData.name;
            document.getElementById('npcDialogue').textContent = `"${npcData.dialogue}"`;
            
            const serviceBtn = document.getElementById('npcServiceBtn');
            serviceBtn.textContent = npcData.service?.description || 'Talk';
        }
        
        // Populate secret room content
        function populateSecretContent() {
            const secretData = preGeneratedEncounter.secretData;
            if (!secretData) return;
            
            document.getElementById('secretDescription').textContent = secretData.description;
            
            let rewardText = '';
            if (secretData.reward.gold) rewardText += `ðŸ’° ${secretData.reward.gold} Gold\n`;
            if (secretData.reward.xp) rewardText += `â­ ${secretData.reward.xp} XP\n`;
            if (secretData.reward.item) rewardText += `ðŸŽ ${secretData.reward.item}\n`;
            if (secretData.reward.lore) rewardText += `ðŸ“œ ${secretData.reward.lore}`;
            
            document.getElementById('secretRewardText').textContent = rewardText || 'Mystery reward!';
        }
        
        // Populate exploration content
        function populateExplorationContent() {
            const explorationData = preGeneratedEncounter.explorationData;
            if (!explorationData) return;
            
            document.getElementById('explorationDescription').textContent = explorationData.challenge?.description || 'An interesting discovery...';
            document.getElementById('explorationChallengeText').textContent = 
                `Difficulty: ${explorationData.challenge?.difficulty || 1}`;
        }
        
        // Buy an item from the store
        function buyItem(itemIndex) {
            const storeData = preGeneratedEncounter.storeData;
            if (!storeData || !storeData.items[itemIndex]) return;
            
            const item = storeData.items[itemIndex];
            const sharedSave = loadSharedSave();
            
            if (!sharedSave.dungeonState) sharedSave.dungeonState = {};
            const currentGold = sharedSave.dungeonState.gold || 0;
            
            if (currentGold < item.price) {
                showNotification('Not enough gold!', 'error');
                return;
            }
            
            // Deduct gold
            sharedSave.dungeonState.gold = currentGold - item.price;
            
            // Add to inventory (simplified - just track consumables)
            if (!sharedSave.dungeonState.inventory) sharedSave.dungeonState.inventory = [];
            sharedSave.dungeonState.inventory.push({ ...item, quantity: 1 });
            
            saveSharedSave(sharedSave);
            updateGoldDisplay();
            
            // Reduce item quantity
            item.quantity--;
            if (item.quantity <= 0) {
                storeData.items.splice(itemIndex, 1);
            }
            
            // Refresh display
            populateStoreContent();
            showNotification(`Bought ${item.name}!`, 'success');
        }
        
        // Use NPC service
        function useNPCService() {
            const npcData = preGeneratedEncounter.npcData;
            if (!npcData || !npcData.service) return;
            
            const sharedSave = loadSharedSave();
            
            switch (npcData.service.type) {
                case 'heal':
                    // Heal all heroes
                    const healAmount = npcData.service.value || 25;
                    ['zooko', 'nate', 'zancas', 'cyberaxe'].forEach(heroKey => {
                        if (sharedSave.heroes[heroKey]) {
                            sharedSave.heroes[heroKey].hp = Math.min(
                                sharedSave.heroes[heroKey].maxHp,
                                sharedSave.heroes[heroKey].hp + healAmount
                            );
                        }
                    });
                    showNotification(`Healed all heroes for ${healAmount} HP!`, 'success');
                    break;
                case 'hint':
                    showNotification('The NPC shares valuable combat tips!', 'info');
                    break;
                case 'lore':
                    showNotification('The NPC reveals ancient secrets...', 'info');
                    break;
                case 'reveal':
                    showNotification('The NPC shows you the way forward!', 'info');
                    break;
                default:
                    showNotification('Thanks for chatting!', 'info');
            }
            
            saveSharedSave(sharedSave);
            
            // Disable button after use
            document.getElementById('npcServiceBtn').disabled = true;
            document.getElementById('npcServiceBtn').style.opacity = '0.5';
        }
        
        // Complete exploration challenge
        function completeExploration() {
            const explorationData = preGeneratedEncounter.explorationData;
            if (!explorationData) return;
            
            const sharedSave = loadSharedSave();
            
            // Award XP
            const xpReward = explorationData.reward?.xp || 50;
            ['zooko', 'nate', 'zancas', 'cyberaxe'].forEach(heroKey => {
                if (sharedSave.heroes[heroKey]) {
                    sharedSave.heroes[heroKey].xp += Math.floor(xpReward / 4);
                }
            });
            
            saveSharedSave(sharedSave);
            showNotification(`Exploration complete! Gained ${xpReward} XP!`, 'success');
            
            // Disable button after completion
            document.getElementById('explorationActionBtn').disabled = true;
            document.getElementById('explorationActionBtn').style.opacity = '0.5';
        }
        
        // Leave non-combat room
        function leaveNonCombatRoom() {
            console.log('[NonCombat] Leaving room');
            
            // In multiplayer, clients wait for host
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                document.getElementById('nonCombatWaitingMsg').style.display = 'block';
                return;
            }
            
            // Host or single player - actually leave
            executeLeaveNonCombatRoom();
            
            // Broadcast to clients in multiplayer
            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                sendWebSocketMessage({
                    type: 'non_combat_room',
                    action: 'leave'
                });
            }
        }
        
        // Actually execute leaving the non-combat room
        function executeLeaveNonCombatRoom() {
            // If leaving a store, mark it as found and save store data for revisiting
            if (nonCombatRoomState.roomType === 'store' && currentLevelLayout) {
                if (!currentLevelLayout.storeFound) {
                    currentLevelLayout.storeFound = true;
                    // Save the store data so player can revisit
                    currentLevelLayout.discoveredStoreData = {
                        merchantName: nonCombatRoomState.data?.storeData?.merchantName,
                        items: nonCombatRoomState.data?.storeData?.items || [],
                        greeting: nonCombatRoomState.data?.storeData?.greeting
                    };
                    saveLevelLayout();
                    console.log('[Store] Store discovered and saved for level', currentLevelLayout.level);
                }
                // Update the store button on dungeon menu
                updateStoreButtonState();
            }
            
            // Save game state
            const sharedSave = loadSharedSave();
            if (sharedSave) {
                sharedSave.lastPlayed = Date.now();
                saveSharedSave(sharedSave);
            }
            
            // Reset state
            nonCombatRoomState.active = false;
            nonCombatRoomState.roomType = null;
            nonCombatRoomState.data = null;
            
            // Switch screens
            currentScreen = 'dungeonMenu';
            document.getElementById('nonCombatRoomScreen').style.display = 'none';
            document.getElementById('dungeonMenuScreen').style.display = 'block';
            
            // Move music controls back
            document.getElementById('musicControls').classList.remove('battleActive');
            document.getElementById('musicControls').classList.add('dungeonMenuActive');
            document.getElementById('musicTicker').classList.remove('battleActive');
            document.getElementById('musicTicker').classList.add('dungeonMenuActive');
            
            // Update dungeon menu displays
            updateDungeonMenuHeroes();
            updateGoldDisplay();
            
            // Hide waiting message
            document.getElementById('nonCombatWaitingMsg').style.display = 'none';
            
            // Reset pre-generated encounter and start generating next
            resetPreGeneratedEncounter();
            preGenerateNextEncounter();
            
            // Update level progress
            levelProgress.roomsExplored++;
            updateLevelProgressDisplay();
            saveLevelProgress();
        }
        
        // Client enters non-combat room (from host message)
        function clientEnterNonCombatRoom(roomType, data) {
            console.log('[NonCombat] Client entering room:', roomType);
            
            // Set up the encounter data from host
            preGeneratedEncounter.roomType = roomType;
            preGeneratedEncounter.storeData = data.storeData;
            preGeneratedEncounter.npcData = data.npcData;
            preGeneratedEncounter.secretData = data.secretData;
            preGeneratedEncounter.explorationData = data.explorationData;
            preGeneratedEncounter.background = data.background;
            
            // Enter the room
            enterNonCombatRoom(roomType);
        }
        
        // ===== END NON-COMBAT ROOM SYSTEM =====
        
        // ===== LEVEL STORE SYSTEM =====
        
        // Enter the level store from dungeon menu (revisiting a discovered store)
        function enterLevelStore() {
            // Check if store was actually found
            if (!currentLevelLayout || !currentLevelLayout.storeFound) {
                showNotification('Store not yet discovered on this level!', 'error');
                return;
            }
            
            // Check if we have saved store data
            if (!currentLevelLayout.discoveredStoreData) {
                showNotification('Store data not available!', 'error');
                return;
            }
            
            console.log('[Store] Revisiting level store');
            
            // Set up the preGeneratedEncounter with saved store data
            preGeneratedEncounter.roomType = 'store';
            preGeneratedEncounter.storeData = currentLevelLayout.discoveredStoreData;
            preGeneratedEncounter.background = 'store_bg.jpg'; // Default store background
            
            // Enter the store room (enterNonCombatRoom handles multiplayer broadcast)
            enterNonCombatRoom('store');
        }
        
        // Update the store button state based on whether store is found
        function updateStoreButtonState() {
            const storeBtn = document.getElementById('levelStoreBtn');
            const storeBtnText = document.getElementById('levelStoreBtnText');
            
            if (!storeBtn || !storeBtnText) return;
            
            if (currentLevelLayout && currentLevelLayout.storeFound && currentLevelLayout.discoveredStoreData) {
                // Store was found - enable button
                storeBtn.disabled = false;
                storeBtn.classList.add('unlocked');
                storeBtnText.innerHTML = 'ENTER LEVEL STORE<br><span style="font-size: 12px; font-weight: 400;">ðŸ›’ Store Available!</span>';
            } else if (currentLevelLayout && currentLevelLayout.hasStore && !currentLevelLayout.storeFound) {
                // Level has a store but not found yet
                storeBtn.disabled = true;
                storeBtn.classList.remove('unlocked');
                storeBtnText.innerHTML = 'ENTER LEVEL STORE<br><span style="font-size: 12px; font-weight: 400;">(Not Found)</span>';
            } else {
                // No store on this level or no layout
                storeBtn.disabled = true;
                storeBtn.classList.remove('unlocked');
                storeBtnText.innerHTML = 'ENTER LEVEL STORE<br><span style="font-size: 12px; font-weight: 400;">(None on Level)</span>';
            }
        }
        
        // ===== END LEVEL STORE SYSTEM =====
        
        // Update the Next Room Preview UI
        function updateNextRoomPreview() {
            const nextRoomTypeEl = document.getElementById('nextRoomType');
            if (!nextRoomTypeEl) return;
            
            const roomType = preGeneratedEncounter.roomType || 'combat';
            
            // Map room types to display text and icons
            const roomTypeDisplay = {
                'combat': { icon: 'âš”ï¸', text: 'Combat', color: '#E74C3C' },
                'boss': { icon: 'ðŸ‘¹', text: 'BOSS BATTLE', color: '#8B45FF' },
                'mini_boss': { icon: 'ðŸ’€', text: 'Mini-Boss', color: '#E67E22' },
                'store': { icon: 'ðŸ›’', text: 'Store', color: '#27AE60' },
                'secret': { icon: 'âœ¨', text: 'Secret Room', color: '#F1C40F' },
                'npc': { icon: 'ðŸ‘¤', text: 'NPC Encounter', color: '#3498DB' },
                'exploration': { icon: 'ðŸ”', text: 'Exploration', color: '#9B59B6' }
            };
            
            const display = roomTypeDisplay[roomType] || roomTypeDisplay['combat'];
            nextRoomTypeEl.innerHTML = `${display.icon} ${display.text}`;
            nextRoomTypeEl.style.color = display.color;
            
            // Add glow effect for special rooms
            if (roomType === 'boss' || roomType === 'secret' || roomType === 'store') {
                nextRoomTypeEl.style.textShadow = `0 0 15px ${display.color}`;
            } else {
                nextRoomTypeEl.style.textShadow = 'none';
            }
        }
        
        // Update level layout display (rooms remaining by type)
        function updateLevelLayoutDisplay() {
            // Update the Rooms display to show actual room count from layout
            const roomsMaxEl = document.getElementById('dmRoomsMax');
            if (roomsMaxEl && currentLevelLayout && currentLevelLayout.generated) {
                roomsMaxEl.textContent = currentLevelLayout.totalRooms;
            }
        }
        
        // Update the Explore Level button loading bar
        function updateExploreLoadingBar(percent) {
            const loadingBar = document.getElementById('exploreLoadingBar');
            const exploreBtn = document.getElementById('exploreLevelBtn');
            const btnText = exploreBtn?.querySelector('.btnText');
            
            if (loadingBar) {
                loadingBar.style.width = percent + '%';
            }
            
            if (exploreBtn) {
                if (percent >= 100) {
                    exploreBtn.classList.add('ready');
                    if (btnText) btnText.textContent = 'âš”ï¸ EXPLORE LEVEL';
                } else if (percent > 0) {
                    exploreBtn.classList.remove('ready');
                    if (btnText) btnText.textContent = `PREPARING... ${percent}%`;
                } else {
                    exploreBtn.classList.remove('ready');
                    if (btnText) btnText.textContent = 'EXPLORE LEVEL';
                }
            }
        }
        
        // Reset pre-generated encounter (call after battle ends)
        function resetPreGeneratedEncounter() {
            // Get current level from UI
            const dungeonLevelEl = document.getElementById('dungeonMenuLevel');
            const currentLevel = parseInt(dungeonLevelEl?.textContent) || 1;
            
            preGeneratedEncounter = {
                ready: false,
                generating: false,
                boss: null,
                mobs: [],
                captive: null,
                background: null,
                roomLevel: currentLevel,
                roomType: 'combat', // Will be set by preGenerateNextEncounter
                storeData: null,
                secretData: null,
                npcData: null,
                explorationData: null
            };
            // Reset loading bar UI
            updateExploreLoadingBar(0);
        }
        
        // Change dungeon level (stairs up/down)
        function changeLevel(direction) {
            // In multiplayer, only host can change levels
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                console.log('[Stairs] Clients cannot change levels - waiting for host');
                showNotification('Only the party leader can use stairs', 'warning');
                return;
            }
            
            // Get current level from UI
            const dungeonLevelEl = document.getElementById('dungeonMenuLevel');
            let currentLevel = parseInt(dungeonLevelEl?.textContent) || 1;
            
            // Calculate new level (minimum 1)
            const newLevel = Math.max(1, currentLevel + direction);
            
            // Don't do anything if level didn't change
            if (newLevel === currentLevel) {
                console.log('[Stairs] Already at minimum level');
                return;
            }
            
            console.log(`[Stairs] Moving from level ${currentLevel} to level ${newLevel}`);
            
            // Update UI
            if (dungeonLevelEl) {
                dungeonLevelEl.textContent = newLevel;
            }
            
            // Update story background for new level
            updateDungeonMenuBackground();
            
            // Save to shared save (host only saves in multiplayer)
            if (!multiplayerState.enabled || multiplayerState.role === 'host') {
                const sharedSave = loadSharedSave();
                if (sharedSave) {
                    if (!sharedSave.dungeonState) {
                        sharedSave.dungeonState = {};
                    }
                    sharedSave.dungeonState.currentLevel = newLevel;
                    sharedSave.lastPlayed = Date.now();
                    saveSharedSave(sharedSave);
                    console.log('[Stairs] Game saved at level', newLevel);
                }
            }
            
            // Reset and regenerate encounter for new level
            preGeneratedEncounter = {
                ready: false,
                generating: false,
                boss: null,
                mobs: [],
                captive: null,
                background: null,
                roomLevel: newLevel,
                roomType: 'combat' // Will be set by preGenerateNextEncounter
            };
            updateExploreLoadingBar(0);
            
            // Load level progress for new level (or reset if no saved progress)
            loadLevelProgress();
            
            // Initialize level layout for new level
            initializeLevelLayout(newLevel);
            
            // Start generating the new encounter
            preGenerateNextEncounter();
            
            // In multiplayer, host broadcasts level change to all clients
            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                sendWebSocketMessage({
                    type: 'level_change',
                    newLevel: newLevel
                });
                console.log('[MP] Broadcast level change to clients:', newLevel);
                // Also broadcast level progress
                broadcastLevelProgress();
            }
        }
        
        // Fast travel to a specific level (diag feature)
        function fastTravel() {
            // In multiplayer, only host can fast travel
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                console.log('[FastTravel] Clients cannot fast travel - waiting for host');
                showNotification('Only the party leader can fast travel', 'warning');
                return;
            }
            
            const input = document.getElementById('fastTravelLevel');
            const targetLevel = parseInt(input?.value) || 1;
            
            // Minimum level 1
            const newLevel = Math.max(1, targetLevel);
            
            // Get current level
            const dungeonLevelEl = document.getElementById('dungeonMenuLevel');
            const currentLevel = parseInt(dungeonLevelEl?.textContent) || 1;
            
            // Don't do anything if already at target level
            if (newLevel === currentLevel) {
                console.log('[FastTravel] Already at level', newLevel);
                return;
            }
            
            console.log(`[FastTravel] Traveling from level ${currentLevel} to level ${newLevel}`);
            
            // Update UI
            if (dungeonLevelEl) {
                dungeonLevelEl.textContent = newLevel;
            }
            
            // Update story background for new level
            updateDungeonMenuBackground();
            
            // Save to shared save (host only saves in multiplayer)
            if (!multiplayerState.enabled || multiplayerState.role === 'host') {
                const sharedSave = loadSharedSave();
                if (sharedSave) {
                    if (!sharedSave.dungeonState) {
                        sharedSave.dungeonState = {};
                    }
                    sharedSave.dungeonState.currentLevel = newLevel;
                    sharedSave.lastPlayed = Date.now();
                    saveSharedSave(sharedSave);
                    console.log('[FastTravel] Game saved at level', newLevel);
                }
            }
            
            // Reset and regenerate encounter for new level
            preGeneratedEncounter = {
                ready: false,
                generating: false,
                boss: null,
                mobs: [],
                captive: null,
                background: null,
                roomLevel: newLevel,
                roomType: 'combat' // Will be set by preGenerateNextEncounter
            };
            updateExploreLoadingBar(0);
            
            // Load level progress for new level (or reset if no saved progress)
            loadLevelProgress();
            
            // Initialize level layout for new level
            initializeLevelLayout(newLevel);
            
            // Start generating the new encounter
            preGenerateNextEncounter();
            
            // In multiplayer, host broadcasts level change to all clients
            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                sendWebSocketMessage({
                    type: 'level_change',
                    newLevel: newLevel
                });
                console.log('[MP] Broadcast level change to clients:', newLevel);
                // Also broadcast level progress
                broadcastLevelProgress();
            }
        }
        
        // Chat state for battle
        let chatState = {
            visible: false,
            messages: [],  // { id, senderName, senderType, senderAvatar, text, timestamp }
            targetNpc: null,  // Currently selected NPC to chat with (deprecated - use targetEntity)
            targetEntity: null,  // Current chat target: null = broadcast, or { type, index, name }
            selectedModel: 2,  // Model ID 1-10 (default to free model 2)
            exhaustedModels: [],  // Track rate-limited models
            totalCost: 0,      // Running cost tally in dollars
            totalTokens: 0,    // Running token count
            ttsEnabled: true,  // TTS on by default
            ttsAvailable: false // Set by server check
        };
        
        // TTS audio queue and current audio
        let ttsAudioQueue = [];
        let ttsCurrentAudio = null;
        
        // Toggle TTS on/off
        function toggleTTS() {
            const checkbox = document.getElementById('ttsToggle');
            chatState.ttsEnabled = checkbox?.checked ?? false;
            console.log('[TTS] Enabled:', chatState.ttsEnabled);
        }
        
        // Check TTS availability on page load
        async function checkTTSAvailability() {
            try {
                const response = await fetch('/api/tts-status', { method: 'POST' });
                const data = await response.json();
                chatState.ttsAvailable = data.enabled;
                console.log('[TTS] Server availability:', data.enabled);
                
                // Update UI if TTS not available
                if (!data.enabled) {
                    const toggle = document.getElementById('ttsToggle');
                    const label = document.getElementById('ttsToggleLabel');
                    if (toggle) toggle.disabled = true;
                    if (label) label.title = 'TTS not available - piper-tts not installed on server';
                }
            } catch (e) {
                console.log('[TTS] Server check failed:', e);
                chatState.ttsAvailable = false;
            }
        }
        
        // Get voice type based on entity
        function getTTSVoiceType(senderType, senderName, entityVoiceType) {
            // If entity has LLM-assigned voice type, use that first
            if (entityVoiceType) {
                return entityVoiceType;
            }
            
            // Check if it's a hero name
            const heroNames = ['zooko', 'nate', 'zancas', 'cyberaxe'];
            const lowerName = (senderName || '').toLowerCase();
            if (heroNames.includes(lowerName)) {
                return lowerName;
            }
            
            // Map sender types to voice types (fallback)
            switch (senderType) {
                case 'boss': return 'boss';
                case 'mob': case 'enemy': return 'mob';
                case 'captive': return 'captive';
                case 'npc': return 'npc';
                case 'narrator': case 'system': return 'narrator';
                default: return 'default';
            }
        }
        
        // Play TTS for a message
        async function playTTS(text, senderType, senderName, entityVoiceType, entityPersonality, entityId = null) {
            if (!chatState.ttsEnabled || !chatState.ttsAvailable) return;
            
            // Skip empty or very short text
            if (!text || text.length < 2) return;
            
            // Skip action-only messages like *silence* or *growls*
            if (text.trim().startsWith('*') && text.trim().endsWith('*') && text.length < 30) {
                return;
            }
            
            try {
                const voiceType = getTTSVoiceType(senderType, senderName, entityVoiceType);
                console.log(`[TTS] Generating audio for "${text.substring(0, 30)}..." with voice: ${voiceType}, personality: ${entityPersonality || 'none'}, entityId: ${entityId || 'none'}`);
                
                const response = await fetch('/api/tts', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        text, 
                        voiceType, 
                        personality: entityPersonality || '',
                        entityId: entityId || null  // For consistent voice per entity
                    })
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    console.error('[TTS] Error:', error);
                    return;
                }
                
                // Get audio blob and play it
                const audioBlob = await response.blob();
                const audioUrl = URL.createObjectURL(audioBlob);
                
                // Queue audio playback
                ttsAudioQueue.push({ url: audioUrl, text: text.substring(0, 30) });
                playNextTTSAudio();
                
            } catch (e) {
                console.error('[TTS] Playback error:', e);
            }
        }
        
        // Play next audio in queue
        function playNextTTSAudio() {
            if (ttsCurrentAudio || ttsAudioQueue.length === 0) return;
            
            const { url, text } = ttsAudioQueue.shift();
            console.log(`[TTS] Playing: "${text}..."`);
            
            ttsCurrentAudio = new Audio(url);
            ttsCurrentAudio.volume = 0.8;
            
            ttsCurrentAudio.onended = () => {
                URL.revokeObjectURL(url);
                ttsCurrentAudio = null;
                playNextTTSAudio(); // Play next in queue
            };
            
            ttsCurrentAudio.onerror = (e) => {
                console.error('[TTS] Audio playback error:', e);
                URL.revokeObjectURL(url);
                ttsCurrentAudio = null;
                playNextTTSAudio();
            };
            
            ttsCurrentAudio.play().catch(e => {
                console.log('[TTS] Autoplay blocked, user interaction needed');
                ttsCurrentAudio = null;
            });
        }
        
        // ============ NARRATOR SYSTEM ============
        let narratorState = {
            levelData: null,
            isPlaying: false,
            isLoading: false,
            currentAudio: null,
            cachedNarrations: {} // Cache narrations per level
        };
        
        // Load level data JSON
        async function loadLevelData() {
            if (narratorState.levelData) return narratorState.levelData;
            
            try {
                const response = await fetch('tunnelsofprivacy/levels/level_data.json');
                narratorState.levelData = await response.json();
                console.log('[Narrator] Level data loaded:', narratorState.levelData.zones.length, 'zones');
                return narratorState.levelData;
            } catch (e) {
                console.error('[Narrator] Failed to load level data:', e);
                return null;
            }
        }
        
        // Get zone info for current level
        function getZoneForLevel(level) {
            if (!narratorState.levelData) return null;
            
            for (const zone of narratorState.levelData.zones) {
                if (level >= zone.levelRange[0] && level <= zone.levelRange[1]) {
                    return zone;
                }
            }
            return null;
        }
        
        // Generate narrator text via LLM
        async function generateNarration(level, zone) {
            const cacheKey = `level_${level}`;
            if (narratorState.cachedNarrations[cacheKey]) {
                console.log('[Narrator] Using cached narration for level', level);
                return narratorState.cachedNarrations[cacheKey];
            }
            
            // Build context for LLM
            const arcInfo = narratorState.levelData.arcs[zone.arc];
            const enemyList = zone.enemies?.join(', ') || 'unknown threats';
            const miniboss = zone.miniboss ? `The miniboss ${zone.miniboss} lurks here.` : '';
            const boss = zone.boss ? `The boss ${zone.boss.name} - ${zone.boss.title} awaits.` : '';
            
            const prompt = `You are the narrator for "Tunnels of Privacy", a dungeon crawler RPG about protecting financial privacy in a world where personal data has become currency. The heroes fight to defend Zcash values: privacy, freedom, and the right to transact without surveillance.

CURRENT LEVEL: ${level}
ZONE: ${zone.name}
ARC: ${arcInfo.name} - ${arcInfo.description}
ZONE DESCRIPTION: ${zone.description}
ZONE LORE: ${zone.lore}
ENEMIES: ${enemyList}
${miniboss}
${boss}

Write a dramatic 2-3 sentence narration describing this level as the heroes enter. Be atmospheric and evocative. Reference the zone's theme and dangers. Keep it under 50 words. Do not use quotation marks. Speak as an omniscient narrator.`;

            try {
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        npcName: 'Narrator',
                        backstory: 'The omniscient narrator of the Tunnels of Privacy',
                        npcType: 'narrator',
                        conversation: [],
                        message: prompt,
                        playerName: 'Heroes',
                        modelId: chatState.selectedModel || 'groq/llama-3.3-70b-versatile',
                        rpMode: settings.rpMode !== false  // Honor user's RP mode setting
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    narratorState.cachedNarrations[cacheKey] = result.response;
                    return result.response;
                } else {
                    console.error('[Narrator] LLM error:', result.error);
                    checkForRateLimitError(result.error);
                    return `Level ${level}. ${zone.name}. ${zone.description}.`;
                }
            } catch (e) {
                console.error('[Narrator] API error:', e);
                checkForRateLimitError(e.message || String(e));
                return `Level ${level}. ${zone.name}. ${zone.description}.`;
            }
        }
        
        // Toggle narrator play/stop
        async function toggleNarrator() {
            const btn = document.getElementById('narratorBtn');
            const btnText = document.getElementById('narratorBtnText');
            
            // If playing, stop
            if (narratorState.isPlaying) {
                stopNarrator();
                return;
            }
            
            // If loading, ignore
            if (narratorState.isLoading) return;
            
            // Start loading
            narratorState.isLoading = true;
            btn.classList.add('loading');
            btnText.textContent = 'LOADING...';
            
            try {
                // Load level data if needed
                await loadLevelData();
                if (!narratorState.levelData) {
                    throw new Error('Failed to load level data');
                }
                
                // Get current level from DOM (same pattern used elsewhere in codebase)
                const currentLevel = parseInt(document.getElementById('dungeonMenuLevel')?.textContent || document.getElementById('dungeonLevel')?.textContent) || 1;
                const zone = getZoneForLevel(currentLevel);
                
                if (!zone) {
                    throw new Error('No zone found for level ' + currentLevel);
                }
                
                // Generate narration
                btnText.textContent = 'GENERATING...';
                const narrationText = await generateNarration(currentLevel, zone);
                
                // Play TTS
                btnText.textContent = 'SPEAKING...';
                await playNarratorTTS(narrationText);
                
                // Update UI to playing state
                narratorState.isPlaying = true;
                narratorState.isLoading = false;
                btn.classList.remove('loading');
                btn.classList.add('playing');
                btnText.textContent = 'STOP';
                
            } catch (e) {
                console.error('[Narrator] Error:', e);
                narratorState.isLoading = false;
                btn.classList.remove('loading');
                btnText.textContent = 'NARRATE';
            }
        }
        
        // Play narrator TTS
        async function playNarratorTTS(text) {
            if (!chatState.ttsAvailable) {
                console.log('[Narrator] TTS not available, showing text only');
                // Could show text in UI instead
                return;
            }
            
            try {
                const response = await fetch('/api/tts', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        text: text, 
                        voiceType: 'narrator',
                        personality: 'dramatic, wise, omniscient'
                    })
                });
                
                if (!response.ok) {
                    throw new Error('TTS request failed');
                }
                
                const audioBlob = await response.blob();
                const audioUrl = URL.createObjectURL(audioBlob);
                
                narratorState.currentAudio = new Audio(audioUrl);
                narratorState.currentAudio.volume = 0.9;
                
                narratorState.currentAudio.onended = () => {
                    URL.revokeObjectURL(audioUrl);
                    narratorState.currentAudio = null;
                    narratorState.isPlaying = false;
                    
                    const btn = document.getElementById('narratorBtn');
                    const btnText = document.getElementById('narratorBtnText');
                    if (btn) btn.classList.remove('playing');
                    if (btnText) btnText.textContent = 'NARRATE';
                };
                
                narratorState.currentAudio.onerror = (e) => {
                    console.error('[Narrator] Audio error:', e);
                    URL.revokeObjectURL(audioUrl);
                    stopNarrator();
                };
                
                await narratorState.currentAudio.play();
                
            } catch (e) {
                console.error('[Narrator] TTS error:', e);
                throw e;
            }
        }
        
        // Stop narrator
        function stopNarrator() {
            if (narratorState.currentAudio) {
                narratorState.currentAudio.pause();
                narratorState.currentAudio = null;
            }
            
            narratorState.isPlaying = false;
            narratorState.isLoading = false;
            
            const btn = document.getElementById('narratorBtn');
            const btnText = document.getElementById('narratorBtnText');
            if (btn) {
                btn.classList.remove('playing', 'loading');
            }
            if (btnText) {
                btnText.textContent = 'NARRATE';
            }
        }
        
        // Select chat target entity
        function selectChatTarget(entity) {
            chatState.targetEntity = entity;
            
            // Update button visuals
            document.querySelectorAll('.chatTargetBtn').forEach(btn => {
                const isActive = entity === null ? 
                    btn.classList.contains('broadcast') : 
                    btn.dataset.entityType === entity?.type && btn.dataset.entityIndex === String(entity?.index);
                btn.classList.toggle('active', isActive);
            });
            
            // Update input placeholder
            const input = document.getElementById('chatInput');
            if (input) {
                if (entity === null) {
                    input.placeholder = 'Say something to everyone...';
                } else {
                    input.placeholder = `Say something to ${entity.name}...`;
                }
            }
            
            console.log('[Chat] Target:', entity ? entity.name : 'BROADCAST');
        }
        
        // Update chat target buttons based on current entities
        function updateChatTargets() {
            const container = document.getElementById('chatTargetSelector');
            if (!container) return;
            
            // Clear existing buttons (except broadcast)
            container.innerHTML = '<button class="chatTargetBtn broadcast' + (chatState.targetEntity === null ? ' active' : '') + '" onclick="selectChatTarget(null)" title="Speak to everyone">ðŸ“¢ ALL</button>';
            
            // Add boss/enemy buttons
            battleState.enemies.forEach((enemy, index) => {
                if (enemy.hp > 0) {
                    const btnClass = enemy.isMob ? 'hostile' : 'boss';
                    const isActive = chatState.targetEntity?.type === 'enemy' && chatState.targetEntity?.index === index;
                    const shortName = enemy.name.length > 10 ? enemy.name.substring(0, 9) + 'â€¦' : enemy.name;
                    const btn = document.createElement('button');
                    btn.className = `chatTargetBtn ${btnClass}${isActive ? ' active' : ''}`;
                    btn.dataset.entityType = 'enemy';
                    btn.dataset.entityIndex = index;
                    btn.onclick = () => selectChatTarget({ type: 'enemy', index, name: enemy.name, entity: enemy });
                    btn.title = enemy.name;
                    btn.textContent = `âš”ï¸ ${shortName}`;
                    container.appendChild(btn);
                }
            });
            
            // Add captive button if present
            if (battleState.captiveNpc && !battleState.captiveNpc.rescued) {
                const captive = battleState.captiveNpc;
                const isActive = chatState.targetEntity?.type === 'captive';
                const shortName = captive.name.length > 10 ? captive.name.substring(0, 9) + 'â€¦' : captive.name;
                const btn = document.createElement('button');
                btn.className = `chatTargetBtn friendly${isActive ? ' active' : ''}`;
                btn.dataset.entityType = 'captive';
                btn.dataset.entityIndex = '0';
                btn.onclick = () => selectChatTarget({ type: 'captive', index: 0, name: captive.name, entity: captive });
                btn.title = captive.name + ' (Captive)';
                btn.textContent = `â›“ï¸ ${shortName}`;
                container.appendChild(btn);
            }
        }
        
        // Select chat model (1-10)
        function selectChatModel(modelId) {
            // Don't allow selecting exhausted models
            if (chatState.exhaustedModels.includes(modelId)) {
                console.log(`[Chat] Model ${modelId} is exhausted (rate limited)`);
                return;
            }
            
            chatState.selectedModel = modelId;
            // Update button visuals - use onclick attribute to match model ID
            document.querySelectorAll('.modelBtn').forEach(btn => {
                // Extract model ID from onclick attribute: onclick="selectChatModel(X)"
                const onclickAttr = btn.getAttribute('onclick') || '';
                const match = onclickAttr.match(/selectChatModel\((\d+)\)/);
                const btnModelId = match ? parseInt(match[1]) : 0;
                btn.classList.toggle('active', btnModelId === modelId);
            });
            console.log(`[Chat] Selected model ${modelId}`);
        }
        
        // Mark a model as exhausted (rate limited)
        function markModelExhausted(modelId) {
            if (!chatState.exhaustedModels.includes(modelId)) {
                chatState.exhaustedModels.push(modelId);
                // Update button visual
                document.querySelectorAll('.modelBtn').forEach(btn => {
                    const onclickAttr = btn.getAttribute('onclick') || '';
                    const match = onclickAttr.match(/selectChatModel\((\d+)\)/);
                    const btnModelId = match ? parseInt(match[1]) : 0;
                    if (btnModelId === modelId) {
                        btn.classList.add('exhausted');
                        btn.title = btn.title + ' (RATE LIMITED)';
                    }
                });
                console.log(`[Chat] Model ${modelId} marked as exhausted`);
                
                // If current model is exhausted, switch to another free model
                if (chatState.selectedModel === modelId) {
                    const freeModels = [2, 4, 5];
                    const availableFree = freeModels.filter(m => !chatState.exhaustedModels.includes(m));
                    if (availableFree.length > 0) {
                        selectChatModel(availableFree[0]);
                    }
                }
            }
        }
        
        // Toggle chat window visibility
        function toggleChatWindow() {
            chatState.visible = !chatState.visible;
            const chatWindow = document.getElementById('battleChatWindow');
            if (chatWindow) {
                chatWindow.style.display = chatState.visible ? 'flex' : 'none';
                if (chatState.visible) {
                    document.getElementById('chatInput').focus();
                    updateChatTargets();  // Refresh entity buttons when opening
                }
            }
        }
        
        // Toggle chat window expand/shrink
        function toggleChatExpand() {
            const chatWindow = document.getElementById('battleChatWindow');
            const expandBtn = document.getElementById('chatExpandBtn');
            if (chatWindow) {
                chatWindow.classList.toggle('compact');
                const isCompact = chatWindow.classList.contains('compact');
                if (expandBtn) {
                    expandBtn.textContent = isCompact ? 'â‡•' : 'â‡•';
                    expandBtn.title = isCompact ? 'Expand' : 'Shrink';
                }
            }
        }
        
        // Typewriter effect for NPC messages
        function typewriterEffect(messageId, fullText, charIndex = 0) {
            const container = document.getElementById('chatMessages');
            if (!container) return;
            
            // Find the message element by data-id
            const msgElement = container.querySelector(`[data-msg-id="${messageId}"] .chatText`);
            if (!msgElement) return;
            
            // Also update the stored message text for consistency
            const msg = chatState.messages.find(m => m.id === messageId);
            if (msg) {
                msg.displayText = fullText.substring(0, charIndex);
            }
            
            // Update displayed text with cursor
            const displayText = fullText.substring(0, charIndex);
            msgElement.innerHTML = formatChatText(displayText) + (charIndex < fullText.length ? '<span class="typingCursor">â–Œ</span>' : '');
            
            // Continue typing if not done
            if (charIndex < fullText.length) {
                // Variable speed: faster for spaces, slower for punctuation
                const char = fullText[charIndex];
                let delay = 25; // Base speed (ms per char)
                if (char === ' ') delay = 15;
                else if ('.!?'.includes(char)) delay = 150;
                else if (',;:'.includes(char)) delay = 80;
                
                setTimeout(() => typewriterEffect(messageId, fullText, charIndex + 1), delay);
            } else {
                // Done typing - remove cursor
                msgElement.innerHTML = formatChatText(fullText);
                if (msg) msg.displayText = fullText;
            }
        }
        
        // Add message to chat
        function addChatMessage(senderName, senderType, senderAvatar, text, isNpc = false, voiceType = null, personality = null, entityId = null) {
            const message = {
                id: Date.now(),
                senderName,
                senderType,  // 'hostile', 'questable', 'friendly', 'player', 'boss', 'mob', 'captive'
                senderAvatar,
                text,
                displayText: isNpc ? '' : text,  // For typewriter effect
                isNpc,
                voiceType,  // LLM-assigned voice type
                personality,  // For TTS emotional adjustment
                entityId,  // Unique ID for consistent TTS voice
                timestamp: new Date().toLocaleTimeString()
            };
            
            // Add to front (newest first)
            chatState.messages.unshift(message);
            
            // Keep last 50 messages
            if (chatState.messages.length > 50) {
                chatState.messages.pop();
            }
            
            renderChatMessages();
            
            // Start typewriter effect for NPC messages
            if (isNpc && text.length > 0) {
                setTimeout(() => typewriterEffect(message.id, text, 0), 100);
                
                // Play TTS for NPC responses (pass entity's voiceType, personality, and ID)
                playTTS(text, senderType, senderName, voiceType, personality, entityId);
            }
            
            // Broadcast to other players if host (send full text, clients show instantly)
            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                sendWebSocketMessage({
                    type: 'chat_message',
                    message: { ...message, displayText: text }  // Send full text to clients
                });
            }
        }
        
        // Format chat text - convert *text* to italics, escape HTML
        function formatChatText(text) {
            // First escape HTML to prevent XSS
            const escaped = text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;');
            // Convert *text* to italics (common roleplay notation)
            return escaped.replace(/\*([^*]+)\*/g, '<em>$1</em>');
        }
        
        // Render chat messages
        function renderChatMessages() {
            const container = document.getElementById('chatMessages');
            if (!container) return;
            
            container.innerHTML = chatState.messages.map(msg => `
                <div class="chatMessage" data-msg-id="${msg.id}">
                    <div class="chatAvatar" style="background-image: url('${msg.senderAvatar}');"></div>
                    <div class="chatContent">
                        <div class="chatName ${msg.senderType}">${msg.senderName}</div>
                        <div class="chatText">${formatChatText(msg.displayText !== undefined ? msg.displayText : msg.text)}</div>
                    </div>
                </div>
            `).join('');
        }
        
        // Send chat message from player
        async function sendChatMessage() {
            const input = document.getElementById('chatInput');
            const sendBtn = document.getElementById('chatSendBtn');
            const statusEl = document.getElementById('chatStatus');
            const message = input.value.trim();
            
            if (!message) return;
            
            // Get player name
            const playerName = multiplayerState.enabled ? 
                (multiplayerState.playerName || 'Player') : 'Player';
            
            // Get current hero avatar (use first alive hero)
            const currentHero = battleState.heroes.find(h => h.hp > 0);
            const heroAvatar = currentHero ? 
                `people/${currentHero.name.toLowerCase()}_a_head_compressed.png` : 
                'people/zooko_a_head_compressed.png';
            
            // Add player message to chat
            addChatMessage(playerName, 'player', heroAvatar, message, false);
            
            // Clear input
            input.value = '';
            
            // In multiplayer, only host calls LLM
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                // Send to host for LLM processing, including target selection
                if (statusEl) statusEl.textContent = 'Sending to host...';
                sendWebSocketMessage({
                    type: 'chat_request',
                    playerName: playerName,
                    message: message,
                    targetEntity: chatState.targetEntity  // Include client's selected target
                });
                setTimeout(() => { if (statusEl) statusEl.textContent = ''; }, 2000);
                return;
            }
            
            // Get NPC to respond based on selected target
            let respondingNpc = null;
            
            // If a specific target is selected, use that
            if (chatState.targetEntity) {
                if (chatState.targetEntity.type === 'captive') {
                    respondingNpc = battleState.captiveNpc;
                } else if (chatState.targetEntity.type === 'enemy') {
                    respondingNpc = battleState.enemies[chatState.targetEntity.index];
                }
                
                // Validate the target is still valid
                if (respondingNpc && (respondingNpc.hp <= 0 || respondingNpc.rescued)) {
                    respondingNpc = null;
                    selectChatTarget(null);  // Reset to broadcast
                }
            }
            
            // If broadcast mode (ALL), give all NPCs a chance to respond via free will
            if (!chatState.targetEntity) {
                const allNpcs = [];
                
                // Add captive if present and can chat
                if (battleState.captiveNpc && !battleState.captiveNpc.rescued && battleState.captiveNpc.canChat) {
                    allNpcs.push(battleState.captiveNpc);
                }
                
                // Add all alive enemies with backstory
                battleState.enemies.forEach(enemy => {
                    if (enemy.hp > 0 && enemy.backstory) {
                        allNpcs.push(enemy);
                    }
                });
                
                if (allNpcs.length === 0) {
                    if (statusEl) statusEl.textContent = 'No one can talk';
                    addChatMessage('System', 'friendly', 'people/zooko_a_head_compressed.png', 
                        '*No one responds...*', true);
                    setTimeout(() => { if (statusEl) statusEl.textContent = ''; }, 2000);
                    return;
                }
                
                // Give each NPC a chance to respond (free will style)
                if (statusEl) statusEl.textContent = 'NPCs considering response...';
                for (const npc of allNpcs) {
                    triggerFreeWillChatResponse(npc, playerName, message);
                }
                setTimeout(() => { if (statusEl) statusEl.textContent = ''; }, 3000);
                return;
            }
            
            if (!respondingNpc) {
                // No NPC can respond
                if (statusEl) statusEl.textContent = 'No one can talk';
                addChatMessage('System', 'friendly', 'people/zooko_a_head_compressed.png', 
                    '*No one responds...*', true);
                setTimeout(() => { if (statusEl) statusEl.textContent = ''; }, 2000);
                return;
            }
            
            // Determine NPC type for the API
            const npcType = respondingNpc.isCaptive ? 'captive' : (respondingNpc.isBoss ? 'boss' : 'mob');
            
            // Disable send while waiting
            sendBtn.disabled = true;
            sendBtn.textContent = '...';
            
            // Start response timer
            const startTime = performance.now();
            let timerInterval = setInterval(() => {
                const elapsed = ((performance.now() - startTime) / 1000).toFixed(1);
                if (statusEl) statusEl.textContent = `Model ${chatState.selectedModel} - ${elapsed}s...`;
            }, 100);
            
            try {
                // Call server LLM API
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        npcName: respondingNpc.name,
                        backstory: respondingNpc.backstory || 'A mysterious creature.',
                        npcType: npcType,
                        conversation: chatState.messages.slice(0, 10).reverse(),
                        message: message,
                        playerName: playerName,
                        modelId: chatState.selectedModel,
                        rpMode: settings.rpMode !== false  // Default true for RP style
                    })
                });
                
                // Stop timer
                clearInterval(timerInterval);
                const totalTime = ((performance.now() - startTime) / 1000).toFixed(2);
                
                const result = await response.json();
                
                if (result.success) {
                    if (statusEl) statusEl.textContent = `Model ${chatState.selectedModel}: ${totalTime}s`;
                    // Clear status after 5 seconds
                    setTimeout(() => { if (statusEl && statusEl.textContent.includes(totalTime)) statusEl.textContent = ''; }, 5000);
                    
                    // Update cost tracking
                    if (result.usage) {
                        chatState.totalCost += result.usage.cost || 0;
                        chatState.totalTokens += (result.usage.promptTokens || 0) + (result.usage.completionTokens || 0);
                        const costDisplay = document.getElementById('chatCostDisplay');
                        if (costDisplay) {
                            costDisplay.textContent = `$${chatState.totalCost.toFixed(6)} | ${chatState.totalTokens} tok`;
                        }
                    }
                    
                    // Determine NPC type for color (captive = friendly, hostile enemy = hostile, etc)
                    const chatNpcType = respondingNpc.isCaptive ? 'friendly' :
                        (respondingNpc.hostile ? 'hostile' : 
                        (respondingNpc.questable ? 'questable' : 'friendly'));
                    
                    // Add NPC response (include LLM-assigned voiceType and personality)
                    addChatMessage(
                        respondingNpc.name,
                        chatNpcType,
                        respondingNpc.spritePath || 'people/zooko_a_head_compressed.png',
                        result.response,
                        true,
                        respondingNpc.voiceType,  // Pass entity's voice type
                        respondingNpc.personality  // Pass entity's personality for TTS
                    );
                    
                    // Process negotiation outcomes (betrayal, retreat, rage)
                    processNegotiation(respondingNpc, message, result.response);
                } else {
                    // Check for rate limit error
                    const errorMsg = result.error || 'Unknown';
                    const isRateLimit = errorMsg.toLowerCase().includes('rate') || 
                                       errorMsg.toLowerCase().includes('limit') ||
                                       errorMsg.toLowerCase().includes('quota') ||
                                       errorMsg.toLowerCase().includes('429') ||
                                       errorMsg.toLowerCase().includes('exceeded');
                    
                    if (isRateLimit) {
                        // Mark current model as exhausted
                        markModelExhausted(chatState.selectedModel);
                        if (statusEl) statusEl.textContent = `Model ${chatState.selectedModel} rate limited!`;
                        addChatMessage('System', 'friendly', 'people/zooko_a_head_compressed.png', 
                            `*Model ${chatState.selectedModel} is rate limited. Try another model.*`, true);
                        showRateLimitWarning();  // Show popup
                    } else {
                        if (statusEl) statusEl.textContent = `Error (${totalTime}s): ` + errorMsg;
                    }
                    console.error('Chat API error:', result.error);
                }
            } catch (error) {
                clearInterval(timerInterval);
                if (statusEl) statusEl.textContent = 'Connection error';
                console.error('Chat fetch error:', error);
            }
            
            sendBtn.disabled = false;
            sendBtn.textContent = 'Send';
        }
        
        // Clear chat when battle ends
        function clearBattleChat() {
            chatState.messages = [];
            chatState.visible = false;
            chatState.targetNpc = null;
            const chatWindow = document.getElementById('battleChatWindow');
            if (chatWindow) chatWindow.style.display = 'none';
            renderChatMessages();
        }
        
        // ============================================
        // NEGOTIATION SYSTEM - Mob Betrayal & Boss Retreat
        // ============================================
        
        // Initialize negotiation state for an enemy
        function initNegotiationState(enemy) {
            if (!enemy.negotiationState) {
                enemy.negotiationState = {
                    // Mob betrayal tracking
                    goldOffered: 0,           // Total gold offered so far
                    betrayalThreshold: enemy.isBoss ? 999999 : (50 + Math.floor(Math.random() * 150)),  // 50-200 gold for mobs
                    lowOfferCount: 0,         // Number of insultingly low offers
                    rageStacks: 0,            // Rage buildup (each stack = +10% HP)
                    
                    // Boss morale tracking
                    morale: 100,              // Boss morale (0-100)
                    insultCount: 0,           // Times insulted/threatened
                    failedAttacks: 0,         // Consecutive missed attacks
                    
                    // State flags
                    betrayed: false,          // Mob switched sides
                    retreated: false,         // Boss fled
                    enraged: false            // Currently enraged (double attack)
                };
            }
            return enemy.negotiationState;
        }
        
        // Process negotiation after each chat exchange
        function processNegotiation(npc, playerMessage, npcResponse) {
            if (!npc || npc.hp <= 0) return;
            
            const state = initNegotiationState(npc);
            const msgLower = playerMessage.toLowerCase();
            const responseLower = npcResponse.toLowerCase();
            
            // === MOB BETRAYAL LOGIC ===
            if (!npc.isBoss && npc.hostile) {
                // Check for gold offers in player message
                const goldMatch = msgLower.match(/(\d+)\s*(gold|coins?|gp|money)/i);
                if (goldMatch) {
                    const offeredGold = parseInt(goldMatch[1]);
                    
                    // Check if player actually HAS this gold
                    const sharedSave = loadSharedSave();
                    const currentGold = sharedSave?.dungeonState?.gold || 0;
                    
                    if (offeredGold > currentGold) {
                        // Player tried to offer gold they don't have - instant rage!
                        addChatMessage('System', 'system', null, `âŒ You only have ${currentGold} gold! ${npc.name} sees through your empty promise!`, false);
                        triggerRage(npc, 'Your LIES have enraged');
                        return;
                    }
                    
                    state.goldOffered += offeredGold;
                    state.lastOfferAmount = offeredGold;  // Track last offer for deduction on success
                    
                    // Check if offer is insulting (less than 10% of threshold)
                    if (offeredGold < state.betrayalThreshold * 0.1) {
                        state.lowOfferCount++;
                        
                        // After 3 low offers, mob gets enraged
                        if (state.lowOfferCount >= 3 && !state.enraged) {
                            triggerRage(npc, 'Your pathetic offers have enraged');
                        }
                    }
                    
                    // Check for betrayal - roll with modifier based on offer
                    const offerRatio = state.goldOffered / state.betrayalThreshold;
                    if (offerRatio >= 0.5) {  // At least 50% of threshold to have a chance
                        const betrayalRoll = rollD20();
                        const dc = Math.max(5, 20 - Math.floor(offerRatio * 15));  // DC 5-20 based on offer
                        
                        console.log(`[Negotiation] ${npc.name} betrayal check: d20(${betrayalRoll}) vs DC ${dc}, offer ratio: ${(offerRatio * 100).toFixed(0)}%`);
                        
                        if (betrayalRoll >= dc || state.goldOffered >= state.betrayalThreshold) {
                            triggerBetrayal(npc, state.goldOffered);
                            return;
                        } else if (betrayalRoll <= 3) {
                            // Critical fail - mob gets angry
                            triggerRage(npc, 'Your bribe attempt has angered');
                        }
                    }
                    
                    // Show offer progress
                    const progress = Math.min(100, (state.goldOffered / state.betrayalThreshold) * 100);
                    showDiceRoll(`ðŸ’° ${npc.name} considers your offer... (${progress.toFixed(0)}% convinced)`);
                }
                
                // Check for threats/insults making mob angry
                if (msgLower.match(/threat|kill|destroy|die|weak|pathetic|coward/i)) {
                    state.lowOfferCount++;
                    if (state.lowOfferCount >= 2 && !state.enraged) {
                        triggerRage(npc, 'Your threats have enraged');
                    }
                }
            }
            
            // === BOSS RETREAT/RAGE LOGIC ===
            if (npc.isBoss) {
                // Check for insults/threats
                if (msgLower.match(/weak|pathetic|coward|afraid|scared|flee|run away|give up/i)) {
                    state.insultCount++;
                    state.morale -= 10;
                    console.log(`[Negotiation] ${npc.name} morale: ${state.morale} (insulted)`);
                }
                
                // Check for intimidation in NPC response (they're worried)
                if (responseLower.match(/perhaps|maybe.*wrong|reconsider|mercy|spare|retreat|flee/i)) {
                    state.morale -= 5;
                }
                
                // Check morale + HP for retreat/rage
                const hpPercent = (npc.hp / npc.maxHp) * 100;
                if (hpPercent < 30 && state.morale < 50) {
                    // Boss is low HP and demoralized - roll for retreat or rage
                    const retreatRoll = rollD20();
                    console.log(`[Negotiation] ${npc.name} retreat check: d20(${retreatRoll}), HP: ${hpPercent.toFixed(0)}%, Morale: ${state.morale}`);
                    
                    if (retreatRoll <= 8) {
                        // Boss retreats!
                        triggerBossRetreat(npc);
                    } else if (retreatRoll >= 17 && !state.enraged) {
                        // Boss gets enraged instead!
                        triggerRage(npc, 'Cornered and desperate,');
                        state.enraged = true;
                    }
                }
            }
        }
        
        // Trigger mob betrayal - switch sides!
        function triggerBetrayal(mob, goldPaid) {
            const state = mob.negotiationState;
            state.betrayed = true;
            mob.hostile = false;
            
            // Deduct gold from player
            if (goldPaid > 0) {
                const sharedSave = JSON.parse(localStorage.getItem('top_shared_save') || '{}');
                if (!sharedSave.dungeonState) sharedSave.dungeonState = {};
                sharedSave.dungeonState.gold = Math.max(0, (sharedSave.dungeonState.gold || 0) - goldPaid);
                localStorage.setItem('top_shared_save', JSON.stringify(sharedSave));
                
                addChatMessage('System', 'system', null, `ðŸ’¸ Paid ${goldPaid} gold to ${mob.name}!`, false);
                updateGoldDisplay();
            }
            
            // Visual/audio feedback
            showDiceRoll(`âš”ï¸âž¡ï¸ðŸ¤ ${mob.name} BETRAYS THE BOSS!`);
            showBattleNotification(`${mob.name} switches sides!`);
            
            // Add chat message
            addChatMessage(mob.name, 'friendly', mob.spritePath, 
                `*${mob.name} turns against their former master!* "You've convinced me. Let's take down that tyrant together!"`, 
                true, mob.voiceType);
            
            // Change color to friendly
            mob.color = '#00FF00';
            
            renderBattle();
            updateBattleEnemyCards();
            
            console.log(`[Negotiation] ${mob.name} has betrayed the boss!`);
        }
        
        // Trigger boss retreat - they flee!
        function triggerBossRetreat(boss) {
            const state = boss.negotiationState;
            state.retreated = true;
            
            // Visual/audio feedback
            showDiceRoll(`ðŸƒ ${boss.name} RETREATS!`);
            showBattleNotification(`${boss.name} flees in terror!`);
            
            // Add chat message
            addChatMessage(boss.name, 'hostile', boss.spritePath,
                `*${boss.name} staggers back, fear in their eyes* "This isn't over! I'll return stronger!" *vanishes into the shadows*`,
                true, boss.voiceType);
            
            // Remove boss from battle (set HP to 0 but mark as retreated)
            boss.hp = 0;
            boss.retreated = true;
            
            // Award partial XP for retreat
            const partialXP = Math.floor((boss.stats?.experience || 100) * 0.5);
            battleState.heroes.forEach(h => {
                if (h.hp > 0) h.xp = (h.xp || 0) + Math.floor(partialXP / battleState.heroes.filter(x => x.hp > 0).length);
            });
            showDiceRoll(`ðŸ“œ Gained ${partialXP} XP from boss retreat!`);
            
            renderBattle();
            updateBattleEnemyCards();
            checkBattleEnd();
            
            console.log(`[Negotiation] ${boss.name} has retreated!`);
        }
        
        // Trigger rage - enemy gets stronger!
        function triggerRage(enemy, reason) {
            const state = enemy.negotiationState;
            state.rageStacks++;
            state.enraged = true;
            
            // Boost HP by 10% per rage stack
            const hpBoost = Math.floor(enemy.maxHp * 0.1);
            enemy.hp = Math.min(enemy.maxHp, enemy.hp + hpBoost);
            enemy.maxHp += hpBoost;
            
            // Boost damage slightly
            enemy.attackDamage = Math.floor(enemy.attackDamage * 1.1);
            
            // Visual/audio feedback
            const emoji = enemy.isBoss ? 'ðŸ‘¿' : 'ðŸ˜¤';
            showDiceRoll(`${emoji} ${reason} ${enemy.name}! (+${hpBoost} HP, +10% damage)`);
            showBattleNotification(`${enemy.name} enters a RAGE!`);
            
            // Add chat message
            addChatMessage(enemy.name, 'hostile', enemy.spritePath,
                `*${enemy.name}'s eyes glow with fury* "ENOUGH! You will PAY for this!"`,
                true, enemy.voiceType);
            
            // Change color to indicate rage
            enemy.color = '#FF0000';
            
            renderBattle();
            updateBattleEnemyCards();
            
            console.log(`[Negotiation] ${enemy.name} has entered a rage! (stack ${state.rageStacks})`);
        }
        
        // Update boss morale when they take damage or miss attacks
        function updateBossMorale(boss, event) {
            if (!boss || !boss.isBoss) return;
            
            const state = initNegotiationState(boss);
            
            switch (event) {
                case 'took_damage':
                    state.morale -= 5;
                    break;
                case 'missed_attack':
                    state.failedAttacks++;
                    state.morale -= 3 * state.failedAttacks;  // Gets worse with consecutive misses
                    break;
                case 'hit_attack':
                    state.failedAttacks = 0;  // Reset on successful hit
                    state.morale = Math.min(100, state.morale + 5);  // Slight morale boost
                    break;
                case 'ally_died':
                    state.morale -= 15;
                    break;
            }
            
            state.morale = Math.max(0, Math.min(100, state.morale));
            
            // Check for retreat/rage at critical morale
            const hpPercent = (boss.hp / boss.maxHp) * 100;
            if (state.morale < 30 && hpPercent < 40 && !state.retreated && !state.enraged) {
                const crisisRoll = rollD20();
                console.log(`[Negotiation] ${boss.name} crisis check: d20(${crisisRoll}), HP: ${hpPercent.toFixed(0)}%, Morale: ${state.morale}`);
                
                if (crisisRoll <= 10) {
                    triggerBossRetreat(boss);
                } else if (crisisRoll >= 16) {
                    triggerRage(boss, 'Pushed to the brink,');
                }
            }
        }
        
        // Check for enraged double attack
        function shouldDoDoubleAttack(enemy) {
            if (!enemy.negotiationState?.enraged) return false;
            
            // 30% chance for double attack when enraged
            const doubleRoll = rollD20();
            if (doubleRoll >= 15) {
                showDiceRoll(`âš¡ ${enemy.name}'s rage fuels a DOUBLE ATTACK!`);
                return true;
            }
            return false;
        }

        // Generate unique encounter data via Dungeon Master LLM
        async function generateEncounter(type, baseData, roomLevel, retryCount = 0) {
            const maxRetries = 2;
            try {
                const response = await fetch('/api/generate-encounter', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        type: type,
                        baseData: baseData,
                        roomLevel: roomLevel,
                        useFreeModel: !settings.llmUsePaid
                    })
                });
                
                const result = await response.json();
                if (result.success && result.data) {
                    console.log(`[DM] Generated ${type}:`, result.data);
                    return result.data;
                } else {
                    console.warn(`[DM] Failed to generate ${type}:`, result.error || result.raw);
                    // Retry on JSON parse failure
                    if (retryCount < maxRetries && result.error && result.error.includes('JSON')) {
                        console.log(`[DM] Retrying ${type} generation (attempt ${retryCount + 2}/${maxRetries + 1})...`);
                        return generateEncounter(type, baseData, roomLevel, retryCount + 1);
                    }
                    return null;
                }
            } catch (error) {
                console.error('[DM] Encounter generation error:', error);
                return null;
            }
        }
        
        // Apply generated data to boss/mob
        function applyGeneratedData(enemy, generated) {
            if (!generated) return;
            
            // Generate unique entity ID for TTS voice consistency
            // Server caches voice assignment per entityId
            enemy.entityId = 'entity_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            
            // Apply name
            if (generated.name) {
                enemy.name = generated.name;
            }
            
            // Apply backstory
            if (generated.backstory) {
                enemy.backstory = generated.backstory;
            }
            
            // Apply personality
            if (generated.personality) {
                enemy.personality = generated.personality;
            }
            
            // Apply voice type (LLM-chosen based on gender/nature)
            if (generated.voiceType) {
                enemy.voiceType = generated.voiceType;
            }
            
            // Apply gender
            if (generated.gender) {
                enemy.gender = generated.gender;
            }
            
            // Apply stat modifiers
            if (generated.statModifiers) {
                if (generated.statModifiers.hpMod) {
                    enemy.hp = Math.max(1, enemy.hp + generated.statModifiers.hpMod);
                    enemy.maxHp = Math.max(1, enemy.maxHp + generated.statModifiers.hpMod);
                }
                if (generated.statModifiers.damageMod) {
                    enemy.attackDamage = Math.max(1, enemy.attackDamage + generated.statModifiers.damageMod);
                }
                if (generated.statModifiers.acMod) {
                    enemy.ac = Math.max(1, enemy.ac + generated.statModifiers.acMod);
                }
            }
            
            // Apply negotiation options
            if (generated.negotiation) {
                enemy.negotiation = generated.negotiation;
            }
            
            // Apply gold drop amount (LLM-determined based on backstory)
            if (generated.goldDrop !== undefined) {
                enemy.goldDrop = generated.goldDrop;
            } else {
                // Default gold based on enemy type
                enemy.goldDrop = enemy.isBoss ? (50 + Math.floor(Math.random() * 100)) : (5 + Math.floor(Math.random() * 20));
            }
            
            // Apply opening line
            if (generated.openingLine) {
                enemy.openingLine = generated.openingLine;
            }
        }
        
        // Trigger NPC free will chat (autonomous chat)
        function triggerFreeWillChat(npc, trigger) {
            if (!settings.llmFreeWill) return;
            if (!npc || !npc.backstory) return;
            
            // Don't spam - check cooldown
            if (npc.lastFreeWillChat && Date.now() - npc.lastFreeWillChat < 10000) return;
            npc.lastFreeWillChat = Date.now();
            
            // Build a context-specific prompt
            let contextPrompt = '';
            switch (trigger) {
                case 'battle_start':
                    if (npc.openingLine) {
                        addChatMessage(npc.name, npc.hostile ? 'hostile' : 'friendly', 
                            npc.spritePath || 'people/zooko_a_head_compressed.png', npc.openingLine, true, npc.voiceType, npc.personality, npc.entityId);
                        return;
                    }
                    contextPrompt = 'The battle just started. Say something to intimidate or greet the heroes.';
                    break;
                case 'took_damage':
                    contextPrompt = 'You just took damage! React with pain, anger, or determination.';
                    break;
                case 'dealt_damage':
                    contextPrompt = 'You just hit a hero! Gloat, taunt, or comment on your attack.';
                    break;
                case 'low_health':
                    contextPrompt = 'You are badly wounded. Express fear, defiance, or consider surrendering.';
                    break;
                case 'ally_died':
                    contextPrompt = 'One of your allies just died. React with grief, rage, or indifference.';
                    break;
                default:
                    return; // Unknown trigger, skip
            }
            
            // Make async LLM call for free will response
            (async () => {
                try {
                    const response = await fetch('/api/chat', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            npcName: npc.name,
                            backstory: npc.backstory,
                            npcType: npc.isBoss ? 'boss' : 'mob',
                            conversation: chatState.messages.slice(0, 5).reverse(),
                            message: contextPrompt,
                            playerName: 'System',
                            modelId: settings.llmUsePaid ? 3 : 2,  // Use Groq models for speed
                            rpMode: settings.rpMode !== false
                        })
                    });
                    
                    const result = await response.json();
                    if (result.success && result.response) {
                        const npcType = npc.hostile ? 'hostile' : (npc.questable ? 'questable' : 'friendly');
                        addChatMessage(npc.name, npcType, npc.spritePath || 'people/zooko_a_head_compressed.png', 
                            result.response, true, npc.voiceType, npc.personality, npc.entityId);
                    } else if (result.error) {
                        checkForRateLimitError(result.error);
                    }
                } catch (error) {
                    console.error('[Free Will] Chat error:', error);
                    checkForRateLimitError(error.message || String(error));
                }
            })();
        }
        
        // Trigger free will response to player broadcast message (ALL mode)
        // Each NPC decides if they want to respond based on personality/context
        function triggerFreeWillChatResponse(npc, playerName, playerMessage) {
            if (!npc || !npc.backstory) return;
            
            // Don't spam - check cooldown (shorter than regular free will)
            if (npc.lastFreeWillChat && Date.now() - npc.lastFreeWillChat < 3000) return;
            
            // 1d6 dice roll - only respond on a 1 (~17% chance)
            const diceRoll = Math.floor(Math.random() * 6) + 1;
            if (diceRoll !== 1) return;
            
            npc.lastFreeWillChat = Date.now();
            console.log(`[Free Will] ${npc.name} rolled a 1! Considering response...`);
            
            // Make async LLM call - NPC decides if they want to respond
            (async () => {
                try {
                    const response = await fetch('/api/chat', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            npcName: npc.name,
                            backstory: npc.backstory,
                            npcType: npc.isBoss ? 'boss' : (npc.isCaptive ? 'captive' : 'mob'),
                            conversation: chatState.messages.slice(0, 5).reverse(),
                            message: playerMessage,
                            playerName: playerName,
                            modelId: settings.llmUsePaid ? 3 : 2,  // Use Groq models for speed
                            rpMode: settings.rpMode !== false
                        })
                    });
                    
                    const result = await response.json();
                    if (result.success && result.response) {
                        // Skip if response indicates no response (silence, ignoring, etc)
                        const responseLower = result.response.toLowerCase();
                        if (responseLower.includes('*silence*') || 
                            responseLower.includes('*ignores*') ||
                            responseLower.includes('*says nothing*') ||
                            responseLower === '...' ||
                            result.response.trim().length < 3) {
                            return; // NPC chose not to respond
                        }
                        
                        const npcType = npc.hostile ? 'hostile' : (npc.questable ? 'questable' : 'friendly');
                        addChatMessage(npc.name, npcType, npc.spritePath || 'people/zooko_a_head_compressed.png', 
                            result.response, true, npc.voiceType, npc.personality, npc.entityId);
                    } else if (result.error) {
                        checkForRateLimitError(result.error);
                    }
                } catch (error) {
                    console.error('[Free Will Response] Chat error:', error);
                    checkForRateLimitError(error.message || String(error));
                }
            })();
        }
        
        // Start a battle encounter
        async function startBattle() {
            // Multiplayer clients cannot start battles - only host
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                showNotification('Only host can start battles', 'error');
                return;
            }
            
            // Check room type - route to non-combat room if not a combat type
            const roomType = preGeneratedEncounter.roomType || 'combat';
            const nonCombatTypes = ['store', 'npc', 'secret', 'exploration'];
            
            if (nonCombatTypes.includes(roomType)) {
                // This is a non-combat room - use the non-combat room system
                enterNonCombatRoom(roomType);
                return;
            }
            
            // Combat room types: 'combat', 'boss', 'mini_boss'
            // Stop dungeon menu story background animation
            stopDungeonMenuAnimation();
            
            // Switch to battle screen
            currentScreen = 'battle';
            document.getElementById('dungeonMenuScreen').style.display = 'none';
            document.getElementById('battleScreen').style.display = 'block';
            
            // If multiplayer host, notify clients
            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                sendWebSocketMessage({ type: 'game_start', screen: 'battle' });
            }
            
            // Move music controls and ticker to bottom left during battle
            document.getElementById('musicControls').classList.add('battleActive');
            document.getElementById('musicTicker').classList.add('battleActive');
            
            // Update gold display for battle screen
            updateGoldDisplay();
            
            // Start dice roll ticker
            startDiceRollTicker();
            
            // Initialize canvas
            battleState.canvas = document.getElementById('battleCanvas');
            battleState.ctx = battleState.canvas.getContext('2d');
            
            // Set canvas size
            battleState.canvas.width = window.innerWidth;
            battleState.canvas.height = window.innerHeight - 180;
            
            // Multiplayer client: Wait for battle_init from host
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                showDiceRoll('Waiting for host to start battle...');
                return; // Don't generate battle - wait for host's battle_init message
            }
            
            // Check if we have pre-generated encounter ready
            const usePreGenerated = preGeneratedEncounter.ready;
            
            // Load enemy data (only if not pre-generated)
            let bossesData = [];
            let mobsData = [];
            if (!usePreGenerated) {
                try {
                    const difficultyFile = getBossDifficultyFile();
                    const bossResponse = await fetch(difficultyFile);
                    bossesData = await bossResponse.json();
                    const mobResponse = await fetch('tunnelsofprivacy/mobs/mobs_data.json');
                    const mobObj = await mobResponse.json();
                    mobsData = mobObj.mobs || [];
                } catch(e) {
                    console.error('Failed to load enemy data:', e);
                }
            }
            
            // Load shared save to get hero stats
            const sharedSave = loadSharedSave();
            
            // Setup heroes with sprites
            battleState.heroes = [
                { 
                    name: 'Zooko', 
                    hp: sharedSave?.heroes?.zooko?.hp ?? 30, 
                    maxHp: sharedSave?.heroes?.zooko?.maxHp ?? 30,
                    xp: sharedSave?.heroes?.zooko?.xp ?? 0,
                    level: sharedSave?.heroes?.zooko?.level ?? 1,
                    healsRemaining: 2,
                    stats: sharedSave?.heroes?.zooko || {},
                    color: '#F2C94C',
                    x: 0, y: 0, platform: null, facing: 'center',
                    sprite: new Image(),
                    spritePath: 'tunnelsofprivacy/heros/zooko.png',
                    backpackSprite: new Image(),
                    backpackPath: 'tunnelsofprivacy/gear/zooko_backpack.png',
                    potions: [{ anim: null, visible: true }, { anim: null, visible: true }]
                },
                { 
                    name: 'Nate', 
                    hp: sharedSave?.heroes?.nate?.hp ?? 28, 
                    maxHp: sharedSave?.heroes?.nate?.maxHp ?? 30,
                    xp: sharedSave?.heroes?.nate?.xp ?? 0,
                    level: sharedSave?.heroes?.nate?.level ?? 1,
                    healsRemaining: 2,
                    stats: sharedSave?.heroes?.nate || {},
                    color: '#E74C3C',
                    x: 0, y: 0, platform: null, facing: 'center',
                    sprite: new Image(),
                    spritePath: 'tunnelsofprivacy/heros/nate.png',
                    backpackSprite: new Image(),
                    backpackPath: 'tunnelsofprivacy/gear/nate_backpack.png',
                    potions: [{ anim: null, visible: true }, { anim: null, visible: true }]
                },
                { 
                    name: 'Zancas', 
                    hp: sharedSave?.heroes?.zancas?.hp ?? 24, 
                    maxHp: sharedSave?.heroes?.zancas?.maxHp ?? 26,
                    xp: sharedSave?.heroes?.zancas?.xp ?? 0,
                    level: sharedSave?.heroes?.zancas?.level ?? 1,
                    healsRemaining: 2,
                    stats: sharedSave?.heroes?.zancas || {},
                    color: '#27AE60',
                    x: 0, y: 0, platform: null, facing: 'center',
                    sprite: new Image(),
                    spritePath: 'tunnelsofprivacy/heros/zancas.png',
                    backpackSprite: new Image(),
                    backpackPath: 'tunnelsofprivacy/gear/zancas_backpack.png',
                    potions: [{ anim: null, visible: true }, { anim: null, visible: true }]
                },
                { 
                    name: 'CyberAxe', 
                    hp: sharedSave?.heroes?.cyberaxe?.hp ?? 32, 
                    maxHp: sharedSave?.heroes?.cyberaxe?.maxHp ?? 35,
                    xp: sharedSave?.heroes?.cyberaxe?.xp ?? 0,
                    level: sharedSave?.heroes?.cyberaxe?.level ?? 1,
                    healsRemaining: 2,
                    stats: sharedSave?.heroes?.cyberaxe || {},
                    color: '#2E86DE',
                    x: 0, y: 0, platform: null, facing: 'center',
                    sprite: new Image(),
                    spritePath: 'tunnelsofprivacy/heros/cyberaxe.png',
                    backpackSprite: new Image(),
                    backpackPath: 'tunnelsofprivacy/gear/cyberaxe_backpack.png',
                    potions: [{ anim: null, visible: true }, { anim: null, visible: true }]
                }
            ];
            
            // Initialize animation controllers for heroes
            battleState.heroes.forEach(hero => {
                const heroKey = hero.name.toLowerCase();
                let idlePath = HERO_ANIM_PATHS[heroKey]?.idle;
                // Handle array of idle variants - pick random one
                if (Array.isArray(idlePath)) {
                    idlePath = idlePath[Math.floor(Math.random() * idlePath.length)];
                }
                if (idlePath) {
                    initAnimation(hero, idlePath, 'pingpong');
                }
            });
            
            // Load hero sprites with cache busting (fallback for when animation not loaded)
            battleState.heroes.forEach(hero => {
                hero.sprite.onload = () => {
                    renderBattle(); // Re-render when each sprite loads
                };
                // Add timestamp to prevent caching
                hero.sprite.src = hero.spritePath + '?v=' + Date.now();
                
                // Load backpack gear sprites
                if (hero.backpackPath) {
                    hero.backpackSprite.onload = () => {
                        renderBattle(); // Re-render when backpack loads
                    };
                    hero.backpackSprite.src = hero.backpackPath + '?v=' + Date.now();
                }
                
                // Initialize health potion static sprites
                if (hero.potions) {
                    const potionPath = 'tunnelsofprivacy/items/healing_potions_a_cropped.png';
                    // Load shared potion sprite once per hero
                    hero.potionSprite = new Image();
                    hero.potionSprite.onload = () => renderBattle();
                    hero.potionSprite.src = potionPath + '?v=' + Date.now();
                    
                    hero.potions.forEach((potion, idx) => {
                        potion.visible = idx < hero.healsRemaining;  // Show based on heals remaining
                    });
                }
            });
            
            // Setup enemies from loaded data (level 2 for testing)
            battleState.enemies = [];
            battleState.captiveNpc = null;  // Captive NPC to rescue
            const roomLevel = usePreGenerated ? preGeneratedEncounter.roomLevel : 2;
            
            // Show loading indicator for LLM generation (only if not pre-generated)
            if (!usePreGenerated) {
                showDiceRoll('Dungeon Master is preparing the encounter...');
            }
            
            if (usePreGenerated && preGeneratedEncounter.boss) {
                // Use pre-generated boss
                const boss = preGeneratedEncounter.boss.baseData;
                // Use standardized sprite path based on boss level
                const bossLevel = boss.mainLevel || preGeneratedEncounter.roomLevel;
                const bossSpritePath = `tunnelsofprivacy/bosses/lvl${bossLevel}/boss_lvl${bossLevel}.png`;
                const bossEnemy = {
                    name: boss.name,
                    species: boss.name,
                    hp: boss.stats.hp || 50,
                    maxHp: boss.stats.maxHp || 50,
                    ac: boss.stats.ac,
                    attackDamage: boss.stats.attackDamage,
                    speed: boss.stats.speed,
                    dex: boss.stats.initiative || 0,
                    hostile: boss.behavior?.hostile !== false,
                    backstory: boss.backstory || null,
                    isBoss: true,
                    color: '#8B45FF',
                    x: 0, y: 0, platform: null, facing: 'center',
                    sprite: new Image(),
                    spritePath: bossSpritePath,
                    isMob: false
                };
                applyGeneratedData(bossEnemy, preGeneratedEncounter.boss.generated);
                if (settings.diagMode) {
                    bossEnemy.hp = 5;
                    bossEnemy.maxHp = 5;
                }
                battleState.enemies.push(bossEnemy);
                console.log('[Battle] Using pre-generated boss:', bossEnemy.name);
            } else {
                // Generate boss on-the-fly (fallback)
                const boss = bossesData.find(b => b.mainLevel === roomLevel);
                if (boss) {
                    // Use standardized sprite path based on boss level
                    const bossLevel = boss.mainLevel || roomLevel;
                    const bossSpritePath = `tunnelsofprivacy/bosses/lvl${bossLevel}/boss_lvl${bossLevel}.png`;
                    const bossEnemy = {
                        name: boss.name,
                        species: boss.name,
                        hp: boss.stats.hp || 50,
                        maxHp: boss.stats.maxHp || 50,
                        ac: boss.stats.ac,
                        attackDamage: boss.stats.attackDamage,
                        speed: boss.stats.speed,
                        dex: boss.stats.initiative || 0,
                        hostile: boss.behavior?.hostile !== false,
                        backstory: boss.backstory || null,
                        isBoss: true,
                        color: '#8B45FF',
                        x: 0, y: 0, platform: null, facing: 'center',
                        sprite: new Image(),
                        spritePath: bossSpritePath,
                        isMob: false
                    };
                    const generatedBoss = await generateEncounter('boss', boss, roomLevel);
                    applyGeneratedData(bossEnemy, generatedBoss);
                    if (settings.diagMode) {
                        bossEnemy.hp = 5;
                        bossEnemy.maxHp = 5;
                    }
                    battleState.enemies.push(bossEnemy);
                }
            }
            
            if (usePreGenerated && preGeneratedEncounter.mobs.length > 0) {
                // Use pre-generated mobs
                for (const mobData of preGeneratedEncounter.mobs) {
                    const mob = mobData.baseData;
                    const mobEnemy = {
                        name: mob.name,
                        species: mob.name,
                        hp: mob.stats.hp || 15,
                        maxHp: mob.stats.maxHp || 15,
                        ac: mob.stats.ac,
                        attackDamage: mob.stats.attackDamage,
                        speed: mob.stats.speed,
                        dex: 0,
                        hostile: mob.behavior?.hostile !== false,
                        backstory: mob.backstory || null,
                        isBoss: false,
                        color: '#5C3317',
                        x: 0, y: 0, platform: null, facing: 'center',
                        sprite: new Image(),
                        spritePath: mob.spritePath,
                        isMob: true
                    };
                    applyGeneratedData(mobEnemy, mobData.generated);
                    if (settings.diagMode) {
                        mobEnemy.hp = 5;
                        mobEnemy.maxHp = 5;
                    }
                    battleState.enemies.push(mobEnemy);
                    console.log('[Battle] Using pre-generated mob:', mobEnemy.name);
                }
            } else if (!usePreGenerated) {
                // Generate mobs on-the-fly (fallback)
                const hostileMobs = mobsData.filter(m => m.behavior?.hostile && (m.minLevel === undefined || m.minLevel <= roomLevel));
                const mobCount = getMobCountForLevel(roomLevel);
                console.log(`[Battle] Spawning ${mobCount} mobs for level ${roomLevel}`);
                for (let i = 0; i < mobCount && i < hostileMobs.length; i++) {
                    const mob = hostileMobs[Math.floor(Math.random() * hostileMobs.length)];
                    const mobEnemy = {
                        name: mob.name,
                        species: mob.name,
                        hp: mob.stats.hp || 15,
                        maxHp: mob.stats.maxHp || 15,
                        ac: mob.stats.ac,
                        attackDamage: mob.stats.attackDamage,
                        speed: mob.stats.speed,
                        dex: 0,
                        hostile: mob.behavior?.hostile !== false,
                        backstory: mob.backstory || null,
                        isBoss: false,
                        color: '#5C3317',
                        x: 0, y: 0, platform: null, facing: 'center',
                        sprite: new Image(),
                        spritePath: mob.spritePath,
                        isMob: true
                    };
                    const generatedMob = await generateEncounter('mob', mob, roomLevel);
                    applyGeneratedData(mobEnemy, generatedMob);
                    if (settings.diagMode) {
                        mobEnemy.hp = 5;
                        mobEnemy.maxHp = 5;
                    }
                    battleState.enemies.push(mobEnemy);
                }
            }
            
            // Setup captive NPC
            if (usePreGenerated && preGeneratedEncounter.captive) {
                // Use pre-generated captive
                const captiveData = preGeneratedEncounter.captive.generated;
                const captiveSpritePath = `tunnelsofprivacy/npcs/captives/prisoners (${preGeneratedEncounter.captive.spriteNum}).png`;
                
                battleState.captiveNpc = {
                    name: captiveData?.name || 'Mysterious Prisoner',
                    species: captiveData?.species || 'human',
                    gender: captiveData?.gender || 'unknown',
                    voiceType: captiveData?.voiceType || null,
                    entityId: 'captive_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                    backstory: captiveData?.backstory || 'A prisoner needing rescue.',
                    personality: captiveData?.personality || 'grateful',
                    rescueReward: captiveData?.rescueReward || { gold: 20 },
                    goldReward: captiveData?.rescueReward?.gold || captiveData?.goldReward || 20,
                    dialogueOnRescue: captiveData?.dialogueOnRescue || 'Thank you for saving me!',
                    rescued: false,
                    x: 0,
                    y: 0,
                    sprite: new Image(),
                    spritePath: captiveSpritePath,
                    color: '#F2C94C',
                    isCaptive: true,
                    isMob: false,
                    canChat: true,
                    hostile: false,
                    hp: 1,
                    maxHp: 1
                };
                
                battleState.captiveNpc.sprite.onerror = () => {
                    console.log('[DM] Captive sprite not found, using fallback circle:', captiveSpritePath);
                };
                battleState.captiveNpc.sprite.onload = () => {
                    renderBattle();
                };
                battleState.captiveNpc.sprite.src = battleState.captiveNpc.spritePath + '?v=' + Date.now();
                console.log('[Battle] Using pre-generated captive:', battleState.captiveNpc.name);
            } else if (!usePreGenerated && Math.random() > 0.5) {
                // Generate captive on-the-fly (fallback)
                const captiveData = await generateEncounter('captive', {}, roomLevel);
                const captiveSpriteNum = Math.floor(Math.random() * 12) + 1;
                const captiveSpritePath = `tunnelsofprivacy/npcs/captives/prisoners (${captiveSpriteNum}).png`;
                
                battleState.captiveNpc = {
                    name: captiveData?.name || 'Mysterious Prisoner',
                    species: captiveData?.species || 'human',
                    gender: captiveData?.gender || 'unknown',
                    voiceType: captiveData?.voiceType || null,
                    entityId: 'captive_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                    backstory: captiveData?.backstory || 'A prisoner needing rescue.',
                    personality: captiveData?.personality || 'grateful',
                    rescueReward: captiveData?.rescueReward || { gold: 20 },
                    goldReward: captiveData?.rescueReward?.gold || captiveData?.goldReward || 20,
                    dialogueOnRescue: captiveData?.dialogueOnRescue || 'Thank you for saving me!',
                    rescued: false,
                    x: 0,
                    y: 0,
                    sprite: new Image(),
                    spritePath: captiveSpritePath,
                    color: '#F2C94C',
                    isCaptive: true,
                    isMob: false,
                    canChat: true,
                    hostile: false,
                    hp: 1,
                    maxHp: 1
                };
                
                battleState.captiveNpc.sprite.onerror = () => {
                    console.log('[DM] Captive sprite not found, using fallback circle:', captiveSpritePath);
                };
                battleState.captiveNpc.sprite.onload = () => {
                    renderBattle();
                };
                battleState.captiveNpc.sprite.src = battleState.captiveNpc.spritePath + '?v=' + Date.now();
                console.log('[DM] Captive NPC generated:', battleState.captiveNpc.name, 'sprite:', captiveSpritePath);
            }
            
            // Load enemy sprites
            battleState.enemies.forEach(enemy => {
                enemy.sprite.onload = () => {
                    renderBattle();
                };
                enemy.sprite.src = enemy.spritePath + '?v=' + Date.now();
            });
            
            // Load video background
            const selectedVideo = getRandomRoomVideo();
            battleState.backgroundVideoPath = selectedVideo;
            battleState.useVideoBackground = true;
            
            const videoEl = document.getElementById('battleBackgroundVideo');
            if (videoEl) {
                videoEl.querySelector('source').src = selectedVideo;
                videoEl.load();
                videoEl.style.display = 'block';
                
                // Wait for video to load metadata, then capture first frame for platform detection
                videoEl.onloadeddata = () => {
                    console.log('[Battle] Video loaded:', selectedVideo);
                    
                    // Capture first frame to an image for platform detection
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = videoEl.videoWidth;
                    tempCanvas.height = videoEl.videoHeight;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.drawImage(videoEl, 0, 0);
                    
                    // Create image from first frame
                    battleState.backgroundImage = new Image();
                    battleState.backgroundImage.onload = () => {
                        // Only host runs floor scanning
                        if (!multiplayerState.enabled || multiplayerState.role === 'host') {
                            // Run floor scanning to detect platforms
                            generateBattleLayout();
                            
                            // After layout is generated, send to clients
                            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                                sendBattleInitToClients();
                            }
                        }
                        
                        renderBattle();
                    };
                    battleState.backgroundImage.src = tempCanvas.toDataURL('image/png');
                    
                    // Start playing video
                    videoEl.play().catch(e => console.log('[Battle] Video autoplay blocked:', e));
                };
                
                videoEl.onerror = () => {
                    console.error('[Battle] Video failed to load:', selectedVideo);
                    // Fallback to static image
                    battleState.useVideoBackground = false;
                    videoEl.style.display = 'none';
                    loadFallbackBackground();
                };
            } else {
                // No video element, use fallback
                loadFallbackBackground();
            }
            
            // Reset pre-generated encounter after using it
            if (usePreGenerated) {
                resetPreGeneratedEncounter();
            }
            
            // Calculate initiative for all combatants
            const allCombatants = [...battleState.heroes, ...battleState.enemies];
            allCombatants.forEach(c => {
                const dexMod = calculateModifier(c.stats?.dex || c.dex || 10);
                c.initiative = rollD20() + dexMod;
            });
            
            // Setup turn order sorted by initiative (highest first)
            battleState.turnOrder = allCombatants.sort((a, b) => b.initiative - a.initiative);
            battleState.currentTurn = 0;
            battleState.active = true;
            battleState.won = false;
            battleState.hadBoss = battleState.enemies.some(e => e.isBoss); // Track if this is a boss battle
            battleState.targetingMode = false;
            battleState.pendingAction = null;
            battleState.allHeroes = []; // Reset for fresh battle - will be populated on retreat/death
            
            // Update UI
            updateBattleTurnInfo();
            updateBattleHeroCards();
            updateBattleEnemyCards();
            
            // Open chat window by default when entering battle
            chatState.visible = true;
            const chatWindow = document.getElementById('battleChatWindow');
            if (chatWindow) chatWindow.style.display = 'flex';
            updateChatTargets();  // Refresh entity buttons with enemy names
            
            // Render initial state (will re-render when bg loads)
            renderBattle();
            
            // Trigger free will chat for boss at battle start
            const mainBoss = battleState.enemies.find(e => e.isBoss);
            if (mainBoss) {
                setTimeout(() => triggerFreeWillChat(mainBoss, 'battle_start'), 1000);
            }
            
            // Show captive NPC notification if present
            if (battleState.captiveNpc) {
                setTimeout(() => {
                    showBattleNotification(`A prisoner is here: ${battleState.captiveNpc.name}!`);
                }, 2000);
            }
            
            // Start battle animation loop for continuous updates (targeting highlights, etc.)
            function battleAnimationLoop() {
                if (battleState.active) {
                    renderBattle();
                    requestAnimationFrame(battleAnimationLoop);
                }
            }
            battleAnimationLoop();
            
            // If first turn is AI, process it automatically
            const firstCombatant = battleState.turnOrder[0];
            if (!battleState.heroes.includes(firstCombatant)) {
                setTimeout(() => processAITurn(firstCombatant), 1500);
            }
        }
        
        // Fallback to static background image if video fails
        function loadFallbackBackground() {
            const backgroundOptions = [
                'backgrounds_lvl1 (8).png',
                'backgrounds_lvl1 (10).png',
                'backgrounds_lvl1 (12).png',
                'backgrounds_lvl1 (14).png',
                'backgrounds_lvl1 (15).png',
                'backgrounds_lvl1 (16).png'
            ];
            const selectedBg = backgroundOptions[Math.floor(Math.random() * backgroundOptions.length)];
            battleState.backgroundPath = `tunnelsofprivacy/backgrounds/lvl1-10/${selectedBg}`;
            battleState.useVideoBackground = false;
            
            battleState.backgroundImage = new Image();
            battleState.backgroundImage.onload = () => {
                // Only host runs floor scanning
                if (!multiplayerState.enabled || multiplayerState.role === 'host') {
                    generateBattleLayout();
                    if (multiplayerState.enabled && multiplayerState.role === 'host') {
                        sendBattleInitToClients();
                    }
                }
                renderBattle();
            };
            battleState.backgroundImage.src = battleState.backgroundPath;
        }
        
        // Send battle initialization data to clients (called after floor scanning completes)
        function sendBattleInitToClients() {
            const canvas = battleState.canvas;
            const battleData = {
                backgroundPath: battleState.backgroundPath,
                backgroundVideoPath: battleState.backgroundVideoPath,
                useVideoBackground: battleState.useVideoBackground,
                canvasWidth: canvas.width,
                canvasHeight: canvas.height,
                heroes: battleState.heroes.map(h => ({
                    name: h.name,
                    hp: h.hp,
                    maxHp: h.maxHp,
                    xp: h.xp,
                    healsRemaining: h.healsRemaining,
                    stats: h.stats,
                    x: h.x / canvas.width,
                    y: h.y / canvas.height,
                    platform: h.platform,
                    initiative: h.initiative,
                    spritePath: h.spritePath
                })),
                enemies: battleState.enemies.map(e => ({
                    name: e.name,
                    species: e.species,
                    hp: e.hp,
                    maxHp: e.maxHp,
                    ac: e.ac,
                    attackDamage: e.attackDamage,
                    speed: e.speed,
                    dex: e.dex,
                    hostile: e.hostile,
                    x: e.x / canvas.width,
                    y: e.y / canvas.height,
                    platform: e.platform,
                    initiative: e.initiative,
                    spritePath: e.spritePath,
                    isMob: e.isMob,
                    isBoss: e.isBoss,
                    goldDrop: e.goldDrop || 0,
                    backstory: e.backstory
                })),
                // Include captive NPC data for clients (full mob-like data)
                captiveNpc: battleState.captiveNpc ? {
                    name: battleState.captiveNpc.name,
                    species: battleState.captiveNpc.species,
                    backstory: battleState.captiveNpc.backstory,
                    personality: battleState.captiveNpc.personality,
                    rescueReward: battleState.captiveNpc.rescueReward,
                    goldReward: battleState.captiveNpc.goldReward || battleState.captiveNpc.rescueReward?.gold || 0,
                    dialogueOnRescue: battleState.captiveNpc.dialogueOnRescue,
                    rescued: battleState.captiveNpc.rescued,
                    hp: battleState.captiveNpc.hp || 1,
                    maxHp: battleState.captiveNpc.maxHp || 1,
                    x: battleState.captiveNpc.x / canvas.width,
                    y: battleState.captiveNpc.y / canvas.height,
                    spritePath: battleState.captiveNpc.spritePath,
                    color: battleState.captiveNpc.color,
                    isCaptive: true,
                    isMob: false,
                    canChat: true,
                    hostile: false,
                    facing: battleState.captiveNpc.facing || 'center'
                } : null,
                turnOrder: battleState.turnOrder.map(c => c.name),
                currentTurn: battleState.currentTurn
            };
            sendWebSocketMessage({ type: 'battle_init', battleData: battleData });
        }

        
        // Detect platforms using multi-method approach
        function detectPlatforms() {
            if (!battleState.backgroundImage || !battleState.backgroundImage.complete) {
                return [];
            }
            
            const tempCanvas = document.createElement('canvas');
            const ctx = tempCanvas.getContext('2d');
            tempCanvas.width = battleState.backgroundImage.width;
            tempCanvas.height = battleState.backgroundImage.height;
            
            ctx.drawImage(battleState.backgroundImage, 0, 0);
            const imageData = ctx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            const data = imageData.data;
            
            const allPlatforms = [];
            
            // METHOD 1: Adaptive thresholding with local contrast
            const method1 = detectByAdaptiveThreshold(data, tempCanvas.width, tempCanvas.height);
            allPlatforms.push(...method1);
            
            // METHOD 2: Multi-angle edge detection
            const method2 = detectByMultiAngle(data, tempCanvas.width, tempCanvas.height);
            allPlatforms.push(...method2);
            
            // METHOD 3: Color clustering
            const method3 = detectByColorClustering(data, tempCanvas.width, tempCanvas.height);
            allPlatforms.push(...method3);
            
            // Score and rank all platforms
            const scored = allPlatforms.map(p => ({
                ...p,
                score: scorePlatform(p, data, tempCanvas.width, tempCanvas.height)
            }));
            
            // Filter minimum score and sort
            const valid = scored.filter(p => p.score > 0.3).sort((a, b) => b.score - a.score);
            
            // Scale to canvas size
            const scaleX = battleState.canvas.width / tempCanvas.width;
            const scaleY = battleState.canvas.height / tempCanvas.height;
            
            return valid.map(p => ({
                x: p.x * scaleX,
                y: p.y * scaleY,
                w: p.w * scaleX,
                h: p.h * scaleY,
                type: p.type,
                score: p.score,
                color: p.color
            }));
        }
        
        // Adaptive thresholding - find LIGHT horizontal floor areas using box scanning
        function detectByAdaptiveThreshold(data, width, height) {
            const platforms = [];
            const boxWidth = 150; // Scan boxes 150px wide
            const boxHeight = 50; // 50px tall boxes
            const boxStepX = 50; // Move box right by 50px
            const boxStepY = 25; // Move box down by 25px
            const minBrightness = 100;
            
            // Scan bottom 60% of image only
            for (let boxY = Math.floor(height * 0.6); boxY < height - boxHeight - 10; boxY += boxStepY) {
                for (let boxX = 0; boxX < width - boxWidth; boxX += boxStepX) {
                    // Sample the entire box
                    let boxBrightnessSum = 0;
                    let boxSamples = 0;
                    
                    for (let dy = 0; dy < boxHeight; dy += 5) {
                        for (let dx = 0; dx < boxWidth; dx += 5) {
                            const x = boxX + dx;
                            const y = boxY + dy;
                            const i = (y * width + x) * 4;
                            const brightness = (data[i] + data[i+1] + data[i+2]) / 3;
                            boxBrightnessSum += brightness;
                            boxSamples++;
                        }
                    }
                    
                    const avgBrightness = boxBrightnessSum / boxSamples;
                    
                    // Check if box is bright enough
                    if (avgBrightness > minBrightness) {
                        // Depth test: trace down to find distance to ground
                        const depthScore = calculateDepthScore(data, width, height, boxX, boxY, boxWidth, boxHeight, avgBrightness);
                        
                        // Only accept platforms with good depth scores (close to ground or at bottom)
                        if (depthScore > 0.5) {
                            platforms.push({
                                x: boxX, y: boxY, w: boxWidth, h: boxHeight,
                                type: 'adaptive', color: '#FF00FF',
                                depthScore: depthScore
                            });
                        }
                    }
                }
            }
            
            return platforms;
        }
        
        // Multi-angle edge detection - find LIGHT floor areas at various slopes using boxes
        function detectByMultiAngle(data, width, height) {
            const platforms = [];
            const angles = [0, 5, -5];
            const boxWidth = 150;
            const boxHeight = 50;
            const boxStepX = 50;
            const boxStepY = 30;
            const minBrightness = 100;
            
            angles.forEach(angle => {
                const rad = angle * Math.PI / 180;
                const tanAngle = Math.tan(rad);
                
                for (let baseY = Math.floor(height * 0.6); baseY < height - boxHeight - 10; baseY += boxStepY) {
                    for (let boxX = 0; boxX < width - boxWidth; boxX += boxStepX) {
                        const centerY = Math.floor(baseY + boxX * tanAngle);
                        if (centerY < 0 || centerY >= height - boxHeight - 10) continue;
                        
                        // Sample box at this position
                        let boxBrightnessSum = 0;
                        let boxSamples = 0;
                        
                        for (let dy = 0; dy < boxHeight; dy += 5) {
                            for (let dx = 0; dx < boxWidth; dx += 5) {
                                const x = boxX + dx;
                                const y = centerY + dy;
                                if (y >= height) continue;
                                const i = (y * width + x) * 4;
                                const brightness = (data[i] + data[i+1] + data[i+2]) / 3;
                                boxBrightnessSum += brightness;
                                boxSamples++;
                            }
                        }
                        
                        const avgBrightness = boxBrightnessSum / boxSamples;
                        
                        if (avgBrightness > minBrightness) {
                            // Depth test
                            const depthScore = calculateDepthScore(data, width, height, boxX, centerY, boxWidth, boxHeight, avgBrightness);
                            
                            if (depthScore > 0.5) {
                                platforms.push({
                                    x: boxX, y: centerY, w: boxWidth, h: boxHeight,
                                    type: 'angle', color: '#00FFFF',
                                    depthScore: depthScore
                                });
                            }
                        }
                    }
                }
            });
            
            return platforms;
        }
        
        // Color clustering - find LIGHT colored horizontal floor regions using boxes
        function detectByColorClustering(data, width, height) {
            const platforms = [];
            const boxWidth = 150;
            const boxHeight = 50;
            const boxStepX = 50;
            const boxStepY = 25;
            const colorTolerance = 60;
            const minBrightness = 100;
            
            for (let boxY = Math.floor(height * 0.6); boxY < height - boxHeight - 10; boxY += boxStepY) {
                for (let boxX = 0; boxX < width - boxWidth; boxX += boxStepX) {
                    // Sample box at this position
                    let avgR = 0, avgG = 0, avgB = 0;
                    let samples = 0;
                    
                    for (let dy = 0; dy < boxHeight; dy += 5) {
                        for (let dx = 0; dx < boxWidth; dx += 5) {
                            const x = boxX + dx;
                            const y = boxY + dy;
                            const i = (y * width + x) * 4;
                            avgR += data[i];
                            avgG += data[i+1];
                            avgB += data[i+2];
                            samples++;
                        }
                    }
                    
                    avgR /= samples;
                    avgG /= samples;
                    avgB /= samples;
                    const brightness = (avgR + avgG + avgB) / 3;
                    
                    // Only consider LIGHT boxes as potential floor
                    if (brightness > minBrightness) {
                        // Depth test
                        const depthScore = calculateDepthScore(data, width, height, boxX, boxY, boxWidth, boxHeight, brightness);
                        
                        if (depthScore > 0.5) {
                            platforms.push({
                                x: boxX, y: boxY, w: boxWidth, h: boxHeight,
                                type: 'cluster', color: '#00FF00',
                                depthScore: depthScore
                            });
                        }
                    }
                }
            }
            
            return platforms;
        }
        
        // Calculate depth score - traces downward to find distance to ground
        function calculateDepthScore(data, width, height, boxX, boxY, boxWidth, boxHeight, platformBrightness) {
            const centerX = boxX + Math.floor(boxWidth / 2);
            const startY = boxY + boxHeight;
            const maxDepth = 200; // Don't trace more than 200px down
            
            let distanceToGround = 0;
            let foundGround = false;
            
            // Trace straight down from center of platform
            for (let y = startY; y < Math.min(height, startY + maxDepth); y += 5) {
                const i = (y * width + centerX) * 4;
                const brightness = (data[i] + data[i+1] + data[i+2]) / 3;
                
                // Check for ground indicators:
                // 1. Hit bottom of image
                if (y >= height - 10) {
                    distanceToGround = y - startY;
                    foundGround = true;
                    break;
                }
                
                // 2. Hit much darker area (void/background)
                if (brightness < 50) {
                    distanceToGround = y - startY;
                    foundGround = true;
                    break;
                }
                
                // 3. Hit similar brightness (continuous support)
                if (Math.abs(brightness - platformBrightness) < 30) {
                    // Keep tracing, we're still on connected surface
                    continue;
                }
            }
            
            // If we traced all the way down without finding ground, it's floating
            if (!foundGround) {
                return 0;
            }
            
            // Score based on distance to ground
            // 0 distance (at bottom) = 1.0 score
            // 50px or more = 0.5 score (minimum acceptable)
            // >200px = rejected above
            const score = 1.0 - (distanceToGround / 400);
            return Math.max(0.5, score);
        }
        
        // Score platform quality
        function scorePlatform(platform, data, width, height) {
            let score = 0;
            
            // Width score (wider = better, cap at 800px)
            const widthScore = Math.min(1.0, platform.w / 800);
            score += widthScore * 0.5;
            
            // Position score (lower on screen = better, floors are at bottom)
            const positionScore = platform.y / height;
            score += positionScore * 0.3;
            
            // Brightness consistency (floors should be consistently LIGHT)
            let brightnessSum = 0;
            let sampleCount = 0;
            for (let x = platform.x; x < platform.x + platform.w; x += 10) {
                const idx = (Math.floor(platform.y) * width + Math.floor(x)) * 4;
                const brightness = (data[idx] + data[idx+1] + data[idx+2]) / 3;
                brightnessSum += brightness;
                sampleCount++;
            }
            const avgBrightness = brightnessSum / sampleCount;
            const brightnessScore = avgBrightness > 100 ? Math.min(1.0, avgBrightness / 200) : 0;
            score += brightnessScore * 0.2;
            
            return score;
        }
        
        // Generate battle layout using detected platforms
        function generateBattleLayout() {
            const canvas = battleState.canvas;
            battleState.platforms = [];
            
            // Detect platforms
            const detected = detectPlatforms();
            console.log(`Detected ${detected.length} platforms total`);
            
            if (detected.length < 7) {
                console.log('Not enough platforms detected, using fallback');
                return generateFallbackLayout();
            }
            
            // Safe zone filtering - only check X bounds, platforms already scanned at bottom
            const marginX = 160; // 300px sprite / 2 + 10px buffer
            
            const safe = detected.filter(p => {
                const centerX = p.x + p.w / 2;
                return centerX > marginX && centerX < canvas.width - marginX;
            });
            
            console.log(`${safe.length} platforms in safe zone`);
            
            // Calculate required platforms: 4 heroes + enemies (up to ~20)
            const requiredPlatforms = 4 + battleState.enemies.length;
            
            if (safe.length < requiredPlatforms) {
                console.log(`Not enough safe platforms (need ${requiredPlatforms}), using fallback`);
                return generateFallbackLayout();
            }
            
            // Shuffle safe platforms for variety each battle
            const shuffled = [...safe].sort(() => Math.random() - 0.5);
            
            // Pick platforms ensuring spatial separation
            // Reduce distance for more enemies to fit them all
            const baseMinDistance = 200;
            const minDistance = battleState.enemies.length > 5 ? 120 : baseMinDistance;
            const selected = [];
            
            for (let i = 0; i < shuffled.length && selected.length < requiredPlatforms; i++) {
                const candidate = shuffled[i];
                const candidateX = candidate.x + candidate.w / 2;
                const candidateY = candidate.y;
                
                // Check if candidate overlaps with already selected platforms
                let overlaps = false;
                for (const existing of selected) {
                    const existingX = existing.x + existing.w / 2;
                    const existingY = existing.y;
                    
                    const dx = candidateX - existingX;
                    const dy = candidateY - existingY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < minDistance) {
                        overlaps = true;
                        break;
                    }
                }
                
                if (!overlaps) {
                    selected.push(candidate);
                }
            }
            
            console.log(`Selected ${selected.length} non-overlapping platforms (need ${requiredPlatforms})`);
            
            // Need enough non-overlapping platforms for heroes + enemies
            if (selected.length < requiredPlatforms) {
                console.log(`Could not find ${requiredPlatforms} non-overlapping platforms, using fallback`);
                return generateFallbackLayout();
            }
            
            // Position heroes
            for (let i = 0; i < 4; i++) {
                const p = selected[i];
                battleState.platforms.push(p);
                
                // Center of detection box
                const centerX = p.x + p.w / 2;
                const centerY = p.y + p.h / 2;
                
                // We need to solve: floor contact point (heroY + scaledBoxSize/2) = centerY
                // scaledBoxSize = 300 * (0.6 + heroY / canvas.height * 0.4)
                // This is circular, so we iterate to solve
                let heroY = centerY - 150; // Initial guess
                for (let iter = 0; iter < 5; iter++) {
                    const depthScale = 0.6 + (heroY / canvas.height) * 0.4;
                    const scaledBoxSize = 300 * depthScale;
                    heroY = centerY - scaledBoxSize / 2;
                }
                
                battleState.heroes[i].platform = p;
                battleState.heroes[i].x = centerX;
                battleState.heroes[i].y = heroY;
                battleState.heroes[i].facing = 'center';
            }
            
            // Position enemies
            for (let i = 0; i < battleState.enemies.length; i++) {
                const ep = selected[4 + i];
                battleState.platforms.push(ep);
                
                // Center of detection box
                const centerX = ep.x + ep.w / 2;
                const centerY = ep.y + ep.h / 2;
                
                const enemy = battleState.enemies[i];
                
                if (enemy.isMob) {
                    // For mobs: enemy.y is at FEET (bottom of sprite)
                    // Sprite bottom should be at centerY
                    enemy.x = centerX;
                    enemy.y = centerY;
                } else {
                    // For bosses: solve for Y position where floor contact point = centerY
                    let enemyY = centerY - 150; // Initial guess
                    for (let iter = 0; iter < 5; iter++) {
                        const depthScale = 0.6 + (enemyY / canvas.height) * 0.4;
                        const scaledBoxSize = 300 * depthScale;
                        enemyY = centerY - scaledBoxSize / 2;
                    }
                    enemy.x = centerX;
                    enemy.y = enemyY;
                }
                
                enemy.platform = ep;
                enemy.facing = 'center';
            }
            
            // Position captive NPC if present (far left, below heroes)
            if (battleState.captiveNpc && !battleState.captiveNpc.rescued) {
                battleState.captiveNpc.x = canvas.width * 0.10;
                battleState.captiveNpc.y = canvas.height * 0.80;
                battleState.captiveNpc.facing = 'center';
            }
            
            battleState.detectedPlatforms = detected;
            console.log('Platform layout generated successfully');
        }
        
        // Fallback positioning
        function generateFallbackLayout() {
            const canvas = battleState.canvas;
            const safePositions = {
                heroes: [
                    { x: 0.20, y: 0.40 },
                    { x: 0.25, y: 0.55 },
                    { x: 0.15, y: 0.65 },
                    { x: 0.30, y: 0.75 }
                ],
                // Extended enemy positions - spread across right side (x: 0.50-0.92, y: 0.28-0.80)
                // Positions ordered for visual variety: corners first, then fill in
                enemies: [
                    // First 4 - spread to corners and edges
                    { x: 0.55, y: 0.35 }, { x: 0.88, y: 0.72 }, { x: 0.72, y: 0.28 }, { x: 0.60, y: 0.78 },
                    // Next 4 - fill opposite areas  
                    { x: 0.92, y: 0.42 }, { x: 0.50, y: 0.55 }, { x: 0.80, y: 0.58 }, { x: 0.65, y: 0.45 },
                    // Next 4 - continue spreading
                    { x: 0.75, y: 0.80 }, { x: 0.58, y: 0.32 }, { x: 0.90, y: 0.55 }, { x: 0.52, y: 0.70 },
                    // Next 4 - fill remaining gaps
                    { x: 0.82, y: 0.35 }, { x: 0.68, y: 0.65 }, { x: 0.55, y: 0.48 }, { x: 0.85, y: 0.78 },
                    // Final 4 - last gaps
                    { x: 0.62, y: 0.60 }, { x: 0.78, y: 0.42 }, { x: 0.70, y: 0.75 }, { x: 0.95, y: 0.65 }
                ]
            };
            
            for (let i = 0; i < 4; i++) {
                const pos = safePositions.heroes[i];
                const heroX = canvas.width * pos.x;
                const heroY = canvas.height * pos.y;
                
                const platform = {
                    x: heroX - 50, y: heroY + 140, w: 100, h: 10,
                    type: 'fallback', color: '#6B4FA0'
                };
                
                battleState.platforms.push(platform);
                battleState.heroes[i].platform = platform;
                battleState.heroes[i].x = heroX;
                battleState.heroes[i].y = heroY;
                battleState.heroes[i].facing = 'center';
            }
            
            for (let i = 0; i < battleState.enemies.length; i++) {
                // Use modulo to wrap around if we have more enemies than positions
                const pos = safePositions.enemies[i % safePositions.enemies.length];
                // Add slight random offset if wrapping to avoid exact overlap
                const wrapOffset = Math.floor(i / safePositions.enemies.length) * 0.03;
                const enemyX = canvas.width * (pos.x + wrapOffset);
                const enemyY = canvas.height * pos.y;
                
                const enemyPlatform = {
                    x: enemyX - 75, y: enemyY + 140, w: 150, h: 10,
                    type: 'fallback', color: '#4A2A6B'
                };
                
                battleState.platforms.push(enemyPlatform);
                battleState.enemies[i].platform = enemyPlatform;
                battleState.enemies[i].x = enemyX;
                battleState.enemies[i].y = enemyY;
                battleState.enemies[i].facing = 'center';
            }
            
            // Position captive NPC if present (far left, below heroes - like a friendly mob)
            if (battleState.captiveNpc && !battleState.captiveNpc.rescued) {
                const captiveX = canvas.width * 0.10;  // Far left
                const captiveY = canvas.height * 0.80;  // Lower area (front of room)
                battleState.captiveNpc.x = captiveX;
                battleState.captiveNpc.y = captiveY;
                battleState.captiveNpc.facing = 'center';
            }
        }
        

        // Handle canvas clicks for targeting
        function handleBattleClick(event) {
            const rect = battleState.canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // Handle swap targeting (hero selection)
            if (battleState.swapTargetingMode && battleState.swapInitiator) {
                for (const hero of battleState.heroes) {
                    if (hero === battleState.swapInitiator || hero.hp <= 0) continue;
                    
                    const canvas = battleState.canvas;
                    const depthScale = 0.6 + (hero.y / canvas.height) * 0.4;
                    const hitWidth = 64 * depthScale;
                    const hitHeight = 64 * depthScale;
                    const hitX = hero.x - hitWidth / 2;
                    const hitY = hero.y - hitHeight / 2;
                    
                    if (x >= hitX && x <= hitX + hitWidth && y >= hitY && y <= hitY + hitHeight) {
                        const initiator = battleState.swapInitiator;
                        
                        // Multiplayer: Client sends to host
                        if (multiplayerState.enabled && multiplayerState.role === 'client') {
                            sendWebSocketMessage({
                                type: 'player_action',
                                action: 'swap',
                                target: battleState.heroes.indexOf(hero),
                                hero: initiator.name
                            });
                            
                            // Exit swap mode
                            battleState.swapTargetingMode = false;
                            battleState.swapInitiator = null;
                            battleState.canvas.style.cursor = 'default';
                            return;
                        }
                        
                        // Swap positions
                        const tempX = initiator.x;
                        const tempY = initiator.y;
                        const tempPlatform = initiator.platform;
                        
                        initiator.x = hero.x;
                        initiator.y = hero.y;
                        initiator.platform = hero.platform;
                        
                        hero.x = tempX;
                        hero.y = tempY;
                        hero.platform = tempPlatform;
                        
                        showDiceRoll(`${initiator.name} swapped positions with ${hero.name}!`);
                        
                        // Exit swap mode
                        battleState.swapTargetingMode = false;
                        battleState.swapInitiator = null;
                        battleState.canvas.style.cursor = 'default';
                        
                        // Swap uses all action points
                        advanceTurn();
                        
                        // Host broadcasts state
                        if (multiplayerState.enabled && multiplayerState.role === 'host') {
                            broadcastGameState();
                        }
                        return;
                    }
                }
                return;
            }
            
            // Handle enemy targeting
            if (!battleState.targetingMode || !battleState.pendingAction) return;
            
            // Check if click hit an enemy
            for (const enemy of battleState.enemies) {
                if (enemy.hp <= 0 || !enemy.hostile) continue;
                
                const canvas = battleState.canvas;
                const depthScale = 0.6 + (enemy.y / canvas.height) * 0.4;
                let hitWidth, hitHeight, hitX, hitY;
                
                if (enemy.isMob) {
                    const mobAspectRatio = 1344 / 768;
                    const baseHeight = 75;
                    const spriteHeight = baseHeight * depthScale;
                    const spriteWidth = spriteHeight * mobAspectRatio;
                    hitWidth = spriteWidth;
                    hitHeight = spriteHeight;
                    hitX = enemy.x - hitWidth / 2;
                    hitY = enemy.y - spriteHeight;
                } else {
                    hitWidth = 200 * depthScale;
                    hitHeight = 200 * depthScale;
                    hitX = enemy.x - hitWidth / 2;
                    hitY = enemy.y - hitHeight / 2;
                }
                
                if (x >= hitX && x <= hitX + hitWidth && y >= hitY && y <= hitY + hitHeight) {
                    // Target found!
                    const attacker = battleState.turnOrder[battleState.currentTurn];
                    const enemyIndex = battleState.enemies.indexOf(enemy);
                    
                    // Multiplayer: Client sends to host
                    if (multiplayerState.enabled && multiplayerState.role === 'client') {
                        sendWebSocketMessage({
                            type: 'player_action',
                            action: battleState.pendingAction,
                            target: enemyIndex,
                            hero: attacker.name
                        });
                        
                        // Exit targeting mode
                        battleState.targetingMode = false;
                        battleState.pendingAction = null;
                        battleState.canvas.style.cursor = 'default';
                        return;
                    }
                    
                    executeAttack(attacker, enemy, battleState.pendingAction);
                    
                    // Exit targeting mode
                    battleState.targetingMode = false;
                    battleState.pendingAction = null;
                    battleState.canvas.style.cursor = 'default';
                    return;
                }
            }
        }
        
        // Render battle scene
        function renderBattle() {
            const ctx = battleState.ctx;
            const canvas = battleState.canvas;
            
            // Setup click handler
            if (!canvas.hasClickHandler) {
                canvas.addEventListener('click', handleBattleClick);
                canvas.hasClickHandler = true;
            }
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw background - video plays behind transparent canvas, or draw static image
            if (battleState.useVideoBackground) {
                // Video is playing behind canvas via HTML video element
                // Canvas stays transparent to show video
            } else if (battleState.backgroundImage && battleState.backgroundImage.complete && battleState.backgroundImage.naturalHeight !== 0) {
                ctx.drawImage(battleState.backgroundImage, 0, 0, canvas.width, canvas.height);
            } else {
                // Fallback: Clear canvas with gradient
                ctx.fillStyle = '#1a0f2e';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw starry background
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                for (let i = 0; i < 100; i++) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    const r = Math.random() * 2;
                    ctx.beginPath();
                    ctx.arc(x, y, r, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Draw detected platform spawn areas if hitboxes enabled
            if (settings.showHitboxes && battleState.detectedPlatforms) {
                battleState.detectedPlatforms.forEach(platform => {
                    // Different colors for different detection methods
                    let fillColor, strokeColor;
                    
                    if (platform.type === 'detected') {
                        // Edge detection = GREEN
                        fillColor = 'rgba(0, 255, 0, 0.2)';
                        strokeColor = 'rgba(0, 255, 0, 0.8)';
                    } else if (platform.type === 'sampled') {
                        // Grid sampling = MAGENTA
                        fillColor = 'rgba(255, 0, 255, 0.2)';
                        strokeColor = 'rgba(255, 0, 255, 0.8)';
                    } else if (platform.type === 'gradient') {
                        // Gradient/flat area = CYAN
                        fillColor = 'rgba(0, 255, 255, 0.2)';
                        strokeColor = 'rgba(0, 255, 255, 0.8)';
                    } else {
                        // Unknown = WHITE
                        fillColor = 'rgba(255, 255, 255, 0.2)';
                        strokeColor = 'rgba(255, 255, 255, 0.8)';
                    }
                    
                    ctx.fillStyle = fillColor;
                    ctx.fillRect(platform.x, platform.y, platform.w, platform.h);
                    
                    ctx.strokeStyle = strokeColor;
                    ctx.lineWidth = 1;
                    ctx.strokeRect(platform.x, platform.y, platform.w, platform.h);
                });
            }
            
            // Draw platforms
            battleState.platforms.forEach(platform => {
                // Don't draw platforms, keep them invisible for collision only
                // ctx.fillStyle = platform.color;
                // ctx.fillRect(platform.x, platform.y, platform.w, platform.h);
                
                // Platform edge highlight
                // ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                // ctx.lineWidth = 2;
                // ctx.strokeRect(platform.x, platform.y, platform.w, platform.h);
            });
            
            // Draw heroes
            battleState.heroes.forEach(hero => {
                // Calculate depth-based scale (higher Y = farther back = smaller)
                // Y range: 0 (top) to canvas.height (bottom)
                // Scale range: 0.6 (top/far) to 1.0 (bottom/near)
                const depthScale = 0.6 + (hero.y / canvas.height) * 0.4;
                
                // Green highlight for swap targeting (other heroes)
                if (battleState.swapTargetingMode && hero !== battleState.swapInitiator && hero.hp > 0) {
                    ctx.save();
                    ctx.strokeStyle = '#00FF00';
                    ctx.lineWidth = 4 * depthScale;
                    ctx.shadowColor = '#00FF00';
                    ctx.shadowBlur = 20 * depthScale;
                    const pulseSize = Math.sin(Date.now() / 200) * 3 * depthScale;
                    const boxWidth = 300 * depthScale;
                    const boxHeight = 300 * depthScale;
                    ctx.strokeRect(
                        hero.x - boxWidth / 2 - pulseSize,
                        hero.y - boxHeight / 2 - pulseSize,
                        boxWidth + pulseSize * 2,
                        boxHeight + pulseSize * 2
                    );
                    ctx.restore();
                }
                
                // Update animation frame
                const currentTime = performance.now();
                updateAnimation(hero, currentTime);
                
                // Draw hero sprite (animated or fallback)
                const spriteWidth = 300 * depthScale;
                const spriteHeight = 300 * depthScale;
                const spriteX = hero.x - spriteWidth / 2;
                // Per-hero offset adjustments (scaled with depth)
                let offsetY = 10 * depthScale; // Default (Zooko, Nate)
                if (hero.name === 'Zancas') {
                    offsetY = 20 * depthScale; // Zancas down 10px more
                } else if (hero.name === 'CyberAxe') {
                    offsetY = 13 * depthScale; // CyberAxe down 3px more
                }
                const spriteY = hero.y - spriteHeight / 2 + offsetY;
                
                const flipX = hero.facing === 'left';
                drawAnimatedSprite(ctx, hero, spriteX, spriteY, spriteWidth, spriteHeight, flipX);
                
                // Draw backpack at hero's feet (in front of the hero)
                if (hero.backpackSprite && hero.backpackSprite.complete && hero.backpackSprite.naturalHeight > 0) {
                    // Per-hero backpack sizes
                    const backpackSizes = { 'Zooko': 110, 'Nate': 110, 'Zancas': 110, 'CyberAxe': 100 };
                    const backpackSize = backpackSizes[hero.name] || 100;
                    const backpackWidth = backpackSize * depthScale;
                    const backpackHeight = backpackSize * depthScale;
                    // Position backpack at feet (lower left of hero) - per-hero Y offset
                    const backpackYOffsets = { 'Zooko': 100, 'Nate': 90, 'Zancas': 95, 'CyberAxe': 90 };
                    const backpackYOffset = backpackYOffsets[hero.name] || 100;
                    const backpackX = hero.x - backpackWidth / 2 - (60 * depthScale);
                    const backpackY = hero.y + (backpackYOffset * depthScale); // At feet level
                    
                    // Draw shadow behind backpack for depth
                    ctx.save();
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                    ctx.shadowBlur = 12 * depthScale;
                    ctx.shadowOffsetX = 4 * depthScale;
                    ctx.shadowOffsetY = 4 * depthScale;
                    ctx.drawImage(hero.backpackSprite, backpackX, backpackY, backpackWidth, backpackHeight);
                    ctx.restore();
                    
                    // Draw health potions in front of backpack (left and right)
                    if (hero.potions) {
                        const potionSize = 40 * depthScale;
                        const potionSpacing = 10 * depthScale;  // Space from backpack edge
                        // Per-hero inward offset for potions (Zooko, Nate, Zancas need potions closer together)
                        const potionInward = (hero.name === 'Zooko' || hero.name === 'Nate' || hero.name === 'Zancas') ? 5 * depthScale : 0;
                        
                        hero.potions.forEach((potion, idx) => {
                            if (!potion.visible || !hero.potionSprite || !hero.potionSprite.complete) return;
                            
                            // Position: left potion on left of backpack, right potion on right
                            const potionX = idx === 0 
                                ? backpackX - potionSpacing + potionInward  // Left potion (moved right)
                                : backpackX + backpackWidth - potionSize + potionSpacing - potionInward;  // Right potion (moved left)
                            const potionY = backpackY + (backpackHeight - potionSize) / 2 + (15 * depthScale);  // Lowered
                            
                            // Draw static potion sprite
                            ctx.drawImage(hero.potionSprite, potionX, potionY, potionSize, potionSize);
                        });
                    }
                }
                
                // Fallback check - if no animation and no static sprite loaded
                if ((!hero.anim || !hero.anim.sheet) && (!hero.sprite || !hero.sprite.complete || hero.sprite.naturalHeight === 0)) {
                    // Fallback to colored circle if sprite not loaded
                    ctx.fillStyle = hero.color;
                    ctx.beginPath();
                    ctx.arc(hero.x, hero.y, 90 * depthScale, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                
                // Ground-plane nameplate (at hero's feet, tilted for 3D perspective)
                ctx.save();
                
                // Position at hero's feet (bottom of sprite area)
                const groundY = hero.y + 160 * depthScale;  // Below hero sprite (moved down)
                
                // Calculate tilt based on screen position (left=-5Â°, middle=0Â°, right=+5Â°)
                const screenThird = canvas.width / 3;
                let tiltAngle = 0;
                if (hero.x < screenThird) {
                    // Left third: -5 degrees
                    tiltAngle = -5;
                } else if (hero.x > screenThird * 2) {
                    // Right third: +5 degrees
                    tiltAngle = 5;
                }
                // Middle third: 0 degrees (no tilt)
                
                // Convert degrees to radians for sin calculation
                const tiltRadians = tiltAngle * Math.PI / 180;
                const tiltSkew = Math.sin(tiltRadians);  // sin(5Â°) â‰ˆ 0.087, sin(-5Â°) â‰ˆ -0.087, sin(0Â°) = 0
                
                // Apply perspective transform - squish vertically for ground plane effect
                // 50% taller than original 35% = 52.5% scale
                ctx.translate(hero.x, groundY);
                ctx.transform(1, tiltSkew, 0, 0.525, 0, 0);  // Dynamic tilt + 52.5% vertical scale
                ctx.translate(-hero.x, -groundY);
                
                const barWidth = 100 * depthScale;
                const barHeight = 20 * depthScale;  // Taller since it gets squished
                const barX = hero.x - barWidth / 2;
                const barY = groundY;
                
                // Shadow/glow under the nameplate
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.beginPath();
                ctx.ellipse(hero.x, barY + barHeight + 10 * depthScale, barWidth * 0.6, 8 * depthScale, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Hero name (above HP bar on ground)
                ctx.fillStyle = '#FFFFFF';
                ctx.font = `bold ${Math.floor(16 * depthScale)}px Inter`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText(hero.name.toUpperCase(), hero.x, barY - 2 * depthScale);
                
                // HP bar background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(barX, barY, barWidth, barHeight);
                
                // HP bar border
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 2;
                ctx.strokeRect(barX, barY, barWidth, barHeight);
                
                // HP fill (GREEN -> YELLOW for heroes)
                const hpPercent = hero.hp / hero.maxHp;
                ctx.fillStyle = hpPercent > 0.5 ? '#27AE60' : hpPercent > 0.25 ? '#F39C12' : '#F1C40F';
                ctx.fillRect(barX + 2, barY + 2, (barWidth - 4) * hpPercent, barHeight - 4);
                
                // HP text INSIDE bar (centered)
                ctx.fillStyle = '#FFFFFF';
                ctx.font = `bold ${Math.floor(14 * depthScale)}px JetBrains Mono`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(`${hero.hp}/${hero.maxHp}`, hero.x, barY + barHeight / 2);
                
                ctx.restore();  // Restore normal transform
            });
            
            // Draw enemies
            battleState.enemies.forEach(enemy => {
                // Calculate depth-based scale (higher Y = farther back = smaller)
                const depthScale = 0.6 + (enemy.y / canvas.height) * 0.4;
                
                // Draw enemy sprite
                if (enemy.sprite && enemy.sprite.complete && enemy.sprite.naturalHeight !== 0) {
                    let spriteWidth, spriteHeight, spriteX, spriteY;
                    
                    if (enemy.isMob) {
                        // Mobs are 1344x768, render 4x smaller with correct aspect ratio
                        const mobAspectRatio = 1344 / 768; // 1.75
                        const baseHeight = 75; // 768 / 4 / 2.56 â‰ˆ 75px base height
                        spriteHeight = baseHeight * depthScale;
                        spriteWidth = spriteHeight * mobAspectRatio;
                        spriteX = enemy.x - spriteWidth / 2;
                        // Position so BOTTOM of sprite is at enemy.y (feet on ground)
                        spriteY = enemy.y - spriteHeight;
                    } else {
                        // Bosses are 300x300, centered
                        spriteWidth = 300 * depthScale;
                        spriteHeight = 300 * depthScale;
                        spriteX = enemy.x - spriteWidth / 2;
                        spriteY = enemy.y - spriteHeight / 2 + (10 * depthScale); // Offset down, scaled
                    }
                    
                    ctx.save();
                    if (enemy.facing === 'left') {
                        ctx.translate(enemy.x, enemy.y);
                        ctx.scale(-1, 1);
                        ctx.translate(-enemy.x, -enemy.y);
                    }
                    ctx.drawImage(enemy.sprite, spriteX, spriteY, spriteWidth, spriteHeight);
                    ctx.restore();
                } else {
                    // Fallback to colored circle if sprite not loaded
                    ctx.fillStyle = enemy.color;
                    ctx.beginPath();
                    ctx.arc(enemy.x, enemy.y, 50 * depthScale, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
                
                // Calculate HP bar position first, then build labels above it
                let barOffsetY;
                if (enemy.isMob) {
                    const mobAspectRatio = 1344 / 768;
                    const baseHeight = 75;
                    const spriteHeight = baseHeight * depthScale;
                    barOffsetY = enemy.y - spriteHeight - (5 * depthScale);
                } else {
                    // For bosses, position above centered sprite
                    barOffsetY = enemy.y - 165 * depthScale;
                }
                
                // HP bar with text inside
                const barWidth = 100 * depthScale;
                const barHeight = 14 * depthScale;
                const barX = enemy.x - barWidth / 2;
                const barY = barOffsetY;
                
                // Calculate label positions (build upward from HP bar)
                const speciesOffsetY = barY - (5 * depthScale);  // Species just above bar
                const nameOffsetY = speciesOffsetY - (12 * depthScale);  // Name above species
                
                // Name (unique name - RED for enemies)
                ctx.fillStyle = '#FF4444';
                ctx.font = `bold ${Math.floor(14 * depthScale)}px Inter`;
                ctx.textAlign = 'center';
                ctx.fillText(enemy.name.toUpperCase(), enemy.x, nameOffsetY);
                
                // Species/Type (smaller, between name and bar) - ALWAYS show
                ctx.fillStyle = '#AAAAAA';
                if (enemy.isMob) {
                    // Mobs: species in gray, normal weight
                    ctx.font = `${Math.floor(10 * depthScale)}px Inter`;
                    ctx.fillText(enemy.species || 'Creature', enemy.x, speciesOffsetY);
                } else {
                    // Bosses: species in gray but BOLD
                    ctx.font = `bold ${Math.floor(10 * depthScale)}px Inter`;
                    ctx.fillText(enemy.species || 'Boss', enemy.x, speciesOffsetY);
                }
                
                // Background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(barX, barY, barWidth, barHeight);
                
                // HP fill (RED for enemies)
                const hpPercent = enemy.hp / enemy.maxHp;
                ctx.fillStyle = hpPercent > 0.5 ? '#E74C3C' : hpPercent > 0.25 ? '#C0392B' : '#A93226';
                ctx.fillRect(barX, barY, barWidth * hpPercent, barHeight);
                
                // HP text INSIDE bar (centered)
                ctx.fillStyle = '#FFFFFF';
                ctx.font = `bold ${Math.floor(10 * depthScale)}px JetBrains Mono`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(`${enemy.hp}/${enemy.maxHp}`, enemy.x, barY + barHeight / 2);
                ctx.textBaseline = 'alphabetic';  // Reset
                
                // Gold display BELOW HP bar (public ledger - they use Bitcoin/gold, not Zcash!)
                const goldAmount = enemy.goldDrop || 0;
                const goldY = barY + barHeight + (12 * depthScale);
                ctx.fillStyle = '#FFD700';  // Gold color
                ctx.font = `bold ${Math.floor(10 * depthScale)}px JetBrains Mono`;
                ctx.textAlign = 'center';
                ctx.fillText(`ðŸ’° ${goldAmount}`, enemy.x, goldY);
                
                // Highlight clickable enemies in targeting mode
                if (battleState.targetingMode && enemy.hostile) {
                    const depthScale = 0.6 + (enemy.y / canvas.height) * 0.4;
                    let highlightWidth, highlightHeight, highlightX, highlightY;
                    
                    if (enemy.isMob) {
                        const mobAspectRatio = 1344 / 768;
                        const baseHeight = 75;
                        const spriteHeight = baseHeight * depthScale;
                        const spriteWidth = spriteHeight * mobAspectRatio;
                        highlightWidth = spriteWidth + 20;
                        highlightHeight = spriteHeight + 20;
                        highlightX = enemy.x - highlightWidth / 2;
                        highlightY = enemy.y - spriteHeight - 10;
                    } else {
                        highlightWidth = 220 * depthScale;
                        highlightHeight = 220 * depthScale;
                        highlightX = enemy.x - highlightWidth / 2;
                        highlightY = enemy.y - highlightHeight / 2;
                    }
                    
                    // Pulsing glow effect
                    const pulseAlpha = 0.3 + Math.sin(Date.now() / 200) * 0.2;
                    ctx.strokeStyle = `rgba(255, 255, 0, ${pulseAlpha})`;
                    ctx.lineWidth = 4;
                    ctx.strokeRect(highlightX, highlightY, highlightWidth, highlightHeight);
                    
                    // Glow shadow
                    ctx.shadowColor = 'rgba(255, 255, 0, 0.8)';
                    ctx.shadowBlur = 20;
                    ctx.strokeRect(highlightX, highlightY, highlightWidth, highlightHeight);
                    ctx.shadowBlur = 0;
                }
            });
            
            // Draw captive NPC if present and not rescued (rendered like a mob)
            if (battleState.captiveNpc && !battleState.captiveNpc.rescued && battleState.captiveNpc.x > 0) {
                const captive = battleState.captiveNpc;
                const depthScale = 0.6 + (captive.y / canvas.height) * 0.4;
                
                // Draw captive sprite (static image) or fallback to colored circle
                if (captive.sprite && captive.sprite.complete && captive.sprite.naturalHeight !== 0) {
                    // Static captive image - use actual aspect ratio
                    const imgWidth = captive.sprite.naturalWidth;
                    const imgHeight = captive.sprite.naturalHeight;
                    const aspectRatio = imgWidth / imgHeight;
                    
                    // Scale to reasonable size (base height ~250px at full scale - 25% larger)
                    const baseHeight = 250;
                    const spriteHeight = baseHeight * depthScale;
                    const spriteWidth = spriteHeight * aspectRatio;
                    const spriteX = captive.x - spriteWidth / 2;
                    const spriteY = captive.y - spriteHeight;  // Bottom at captive.y
                    
                    ctx.save();
                    if (captive.facing === 'left') {
                        ctx.translate(captive.x, captive.y);
                        ctx.scale(-1, 1);
                        ctx.translate(-captive.x, -captive.y);
                    }
                    ctx.drawImage(captive.sprite, spriteX, spriteY, spriteWidth, spriteHeight);
                    ctx.restore();
                } else {
                    // Fallback to gold circle (like mobs fallback)
                    ctx.fillStyle = captive.color || '#F2C94C';
                    ctx.beginPath();
                    ctx.arc(captive.x, captive.y, 50 * depthScale, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    
                    // Add chain icon in center
                    ctx.fillStyle = '#8B4513';
                    ctx.font = `bold ${Math.floor(24 * depthScale)}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('â›“ï¸', captive.x, captive.y);
                }
                
                // Captive name and HP bar - positioned above sprite (same as enemies)
                const captiveBaseHeight = 250;
                const spriteHeight = captiveBaseHeight * depthScale;
                const barOffsetY = captive.y - spriteHeight - (5 * depthScale);
                
                // HP bar with text inside (if captive has HP)
                const barWidth = 80 * depthScale;
                const barHeight = 14 * depthScale;
                const barX = captive.x - barWidth / 2;
                const barY = barOffsetY;
                
                // Calculate label positions (build upward from HP bar - same as enemies)
                const speciesOffsetY = barY - (5 * depthScale);  // Species just above bar
                const nameOffsetY = speciesOffsetY - (12 * depthScale);  // Name above species
                
                // Name (GOLD for friendly)
                ctx.fillStyle = '#F2C94C';
                ctx.font = `bold ${Math.floor(14 * depthScale)}px Inter`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'alphabetic';
                ctx.fillText(captive.name.toUpperCase(), captive.x, nameOffsetY);
                
                // Species label below name
                ctx.fillStyle = '#27AE60';
                ctx.font = `${Math.floor(10 * depthScale)}px Inter`;
                ctx.fillText(`â›“ï¸ ${captive.species || 'Captive'}`, captive.x, speciesOffsetY);
                
                // Draw HP bar
                if (captive.hp && captive.maxHp) {
                    // Background
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(barX, barY, barWidth, barHeight);
                    
                    // HP fill (GREEN for friendly)
                    const hpPercent = captive.hp / captive.maxHp;
                    ctx.fillStyle = '#27AE60';
                    ctx.fillRect(barX, barY, barWidth * hpPercent, barHeight);
                    
                    // HP text INSIDE bar
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = `bold ${Math.floor(10 * depthScale)}px JetBrains Mono`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(`${captive.hp}/${captive.maxHp}`, captive.x, barY + barHeight / 2);
                    ctx.textBaseline = 'alphabetic';
                    
                    // Gold display BELOW HP bar (public ledger - NPCs also on transparent chain)
                    const goldAmount = captive.goldDrop || 0;
                    const goldY = barY + barHeight + (12 * depthScale);
                    ctx.fillStyle = '#FFD700';
                    ctx.font = `bold ${Math.floor(10 * depthScale)}px JetBrains Mono`;
                    ctx.textAlign = 'center';
                    ctx.fillText(`ðŸ’° ${goldAmount}`, captive.x, goldY);
                }
            }
            
            // Draw hitboxes if enabled
            if (settings.showHitboxes) {
                // Draw hero spawn area boxes (scaled with depth)
                battleState.heroes.forEach(hero => {
                    const depthScale = 0.6 + (hero.y / canvas.height) * 0.4;
                    const boxSize = 300 * depthScale;
                    ctx.strokeStyle = '#00FF00';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(hero.x - boxSize / 2, hero.y - boxSize / 2, boxSize, boxSize);
                    
                    // Draw center point (hero.x, hero.y)
                    ctx.fillStyle = '#00FF00';
                    ctx.beginPath();
                    ctx.arc(hero.x, hero.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw FLOOR CONTACT POINT - bottom center of hitbox where feet should touch
                    const floorY = hero.y + boxSize / 2;
                    ctx.fillStyle = '#FF00FF';
                    ctx.beginPath();
                    ctx.arc(hero.x, floorY, 8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Draw x/y coordinates at top of hitbox
                    const topY = hero.y - boxSize / 2 - 5;
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = 'bold 12px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(`x:${Math.round(hero.x)} y:${Math.round(hero.y)}`, hero.x, topY);
                });
                
                // Draw enemy spawn area boxes (scaled with depth)
                battleState.enemies.forEach(enemy => {
                    const depthScale = 0.6 + (enemy.y / canvas.height) * 0.4;
                    
                    let boxSize, boxY, topY;
                    if (enemy.isMob) {
                        // Mobs: hitbox matches sprite size (aspect ratio 1.75:1)
                        const mobAspectRatio = 1344 / 768;
                        const baseHeight = 75;
                        const spriteHeight = baseHeight * depthScale;
                        const spriteWidth = spriteHeight * mobAspectRatio;
                        // Hitbox from feet (enemy.y) upward
                        ctx.strokeStyle = '#FF0000';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(enemy.x - spriteWidth / 2, enemy.y - spriteHeight, spriteWidth, spriteHeight);
                        
                        // Draw floor contact point at enemy.y (feet)
                        ctx.fillStyle = '#FF00FF';
                        ctx.beginPath();
                        ctx.arc(enemy.x, enemy.y, 8, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#FFFFFF';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        
                        // Top of hitbox for coordinates
                        topY = enemy.y - spriteHeight - 5;
                    } else {
                        // Bosses: 300x300 scaled box centered
                        const boxSize = 300 * depthScale;
                        ctx.strokeStyle = '#FF0000';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(enemy.x - boxSize / 2, enemy.y - boxSize / 2, boxSize, boxSize);
                        
                        // Draw center point
                        ctx.fillStyle = '#FF0000';
                        ctx.beginPath();
                        ctx.arc(enemy.x, enemy.y, 5, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Draw floor contact point
                        const floorY = enemy.y + boxSize / 2;
                        ctx.fillStyle = '#FF00FF';
                        ctx.beginPath();
                        ctx.arc(enemy.x, floorY, 8, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#FFFFFF';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        
                        // Top of hitbox for coordinates
                        topY = enemy.y - boxSize / 2 - 5;
                    }
                    
                    // Draw x/y coordinates at top of hitbox
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = 'bold 12px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(`x:${Math.round(enemy.x)} y:${Math.round(enemy.y)}`, enemy.x, topY);
                });
                
                // Draw platform hitboxes
                battleState.platforms.forEach(platform => {
                    ctx.strokeStyle = '#FFFF00';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(platform.x, platform.y, platform.w, platform.h);
                });
            }
        }
        
        // Update turn info display
        function updateBattleTurnInfo() {
            const currentHero = battleState.turnOrder[battleState.currentTurn];
            const turnInfo = document.getElementById('battleTurnInfo');
            
            // Safety check: currentHero can be undefined if turnOrder is empty or currentTurn is out of bounds
            if (!currentHero) {
                if (turnInfo) turnInfo.textContent = 'Waiting...';
                return;
            }
            
            if (turnInfo) {
                let turnText = `${currentHero.name.toUpperCase()}'S TURN`;
                
                // Multiplayer: Show if it's you or waiting
                if (multiplayerState.enabled) {
                    if (multiplayerState.role === 'client') {
                        if (multiplayerState.myHeroes.includes(currentHero.name.toLowerCase())) {
                            turnText += ' (YOU)';
                        } else {
                            turnText = `Waiting for ${currentHero.name.toUpperCase()}...`;
                        }
                    }
                }
                
                turnInfo.textContent = turnText;
            }
            
            // Update active hero card highlighting
            document.querySelectorAll('.battleHeroCard').forEach(card => card.classList.remove('active'));
            const activeCard = document.getElementById(`battleCard${currentHero.name}`);
            if (activeCard) activeCard.classList.add('active');
            
            // Trigger myturn animation if hero has one (plays once, returns to idle)
            if (battleState.heroes.includes(currentHero) && currentHero.hp > 0) {
                const heroKey = currentHero.name.toLowerCase();
                const paths = HERO_ANIM_PATHS[heroKey];
                if (paths && paths.myturn) {
                    setAnimationState(currentHero, 'myturn', 'once', () => {
                        setAnimationState(currentHero, 'idle', 'pingpong');
                    });
                }
            }
            
            // Disable/enable buttons based on turn in multiplayer
            if (multiplayerState.enabled) {
                const isMyTurn = multiplayerState.myHeroes.includes(currentHero.name.toLowerCase());
                document.querySelectorAll('.battleButton').forEach(btn => {
                    // Always allow retreat/leave and talk buttons
                    if (btn.textContent.includes('RETREAT') || btn.textContent.includes('LEAVE') || btn.textContent.includes('TALK')) return;
                    btn.disabled = !isMyTurn;
                    btn.style.opacity = isMyTurn ? '1' : '0.3';
                });
            }
        }
        
        // Update gold display in both dungeon menu and battle screen
        function updateGoldDisplay() {
            let gold = 0;
            
            // Clients use cached gold from host, host/single-player use localStorage
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                gold = multiplayerState.goldCache || 0;
            } else {
                const sharedSave = loadSharedSave();
                gold = sharedSave?.dungeonState?.gold || 0;
            }
            
            const dungeonMenuGold = document.getElementById('dungeonMenuGold');
            const battleGold = document.getElementById('battleGold');
            
            if (dungeonMenuGold) dungeonMenuGold.textContent = gold;
            if (battleGold) battleGold.textContent = gold;
        }
        
        // Update battle hero card stats
        function updateBattleHeroCards() {
            // Include all heroes from original selection (alive or dead)
            const allHeroNames = ['nate', 'zooko', 'cyberaxe', 'zancas'];
            
            allHeroNames.forEach(heroName => {
                const hero = battleState.heroes.find(h => h.name.toLowerCase() === heroName);
                const card = document.getElementById(`battleCard${heroName.charAt(0).toUpperCase() + heroName.slice(1)}`);
                
                if (card) {
                    // Grey out if hero is dead/retreated
                    if (!hero || hero.hp <= 0 || hero.retreated) {
                        card.style.opacity = '0.3';
                        card.style.filter = 'grayscale(100%)';
                    } else {
                        card.style.opacity = '1';
                        card.style.filter = 'none';
                    }
                }
                
                if (!hero) return; // Skip if hero not in battle
                
                const hpEl = document.getElementById(`b${heroName}-hp`);
                const maxHpEl = document.getElementById(`b${heroName}-maxhp`);
                const acEl = document.getElementById(`b${heroName}-ac`);
                const xpEl = document.getElementById(`b${heroName}-xp`);
                const healsEl = document.getElementById(`b${heroName}-heals`);
                
                if (hpEl) hpEl.textContent = hero.hp;
                if (maxHpEl) maxHpEl.textContent = hero.maxHp;
                if (acEl) acEl.textContent = hero.stats.ac || 10;
                if (xpEl) xpEl.textContent = hero.xp || 0;
                
                // Update heal potions display
                if (healsEl) {
                    const healsRemaining = hero.healsRemaining || 0;
                    let potionsHTML = '';
                    for (let i = 0; i < 2; i++) {
                        if (i < healsRemaining) {
                            potionsHTML += '<img src="tunnelsofprivacy/items/healing_potions_a_cropped.png" style="width:20px;height:20px;vertical-align:middle;margin-right:2px;">';
                        } else {
                            potionsHTML += '<img src="tunnelsofprivacy/items/healing_potions_a_empty.png" style="width:20px;height:20px;vertical-align:middle;margin-right:2px;">';
                        }
                    }
                    healsEl.innerHTML = potionsHTML;
                }
            });
        }
        
        // Update battle enemy cards
        function updateBattleEnemyCards() {
            const container = document.getElementById('battleEnemyCards');
            if (!container) return;
            
            // Sort enemies: bosses first, then mobs
            const sortedEnemies = [...battleState.enemies].sort((a, b) => {
                if (a.isMob === b.isMob) return 0;
                return a.isMob ? 1 : -1; // Bosses (isMob=false) first
            });
            
            // Count total cards including captive
            const totalCards = sortedEnemies.length + (battleState.captiveNpc && !battleState.captiveNpc.rescued ? 1 : 0);
            
            // Set 3-column layout if more than 8 cards to prevent overlap with music controls
            if (totalCards > 8) {
                container.classList.add('threeColumns');
            } else {
                container.classList.remove('threeColumns');
            }
            
            // Clear and rebuild cards
            container.innerHTML = '';
            
            sortedEnemies.forEach((enemy, index) => {
                const card = document.createElement('div');
                card.className = 'battleEnemyCard';
                card.id = `enemyCard${index}`;
                card.dataset.enemyIndex = battleState.enemies.indexOf(enemy);
                
                // Check if this mob has betrayed and is now friendly
                const isBetrayed = enemy.negotiationState?.betrayed || !enemy.hostile;
                
                if (!enemy.isMob) {
                    card.classList.add('boss');
                }
                
                if (enemy.hp <= 0) {
                    card.classList.add('dead');
                }
                
                // Style betrayed mobs as friendly (green)
                if (isBetrayed && !enemy.isBoss) {
                    card.classList.add('friendly');
                    card.style.borderColor = '#00FF00';
                    card.style.boxShadow = '0 0 15px rgba(0, 255, 0, 0.4)';
                }
                
                // Add targetable class if in targeting mode and hostile
                if (battleState.targetingMode && enemy.hostile && enemy.hp > 0) {
                    card.classList.add('targetable');
                }
                
                // Portrait
                const portrait = document.createElement('div');
                portrait.className = 'battleEnemyPortrait';
                portrait.style.backgroundImage = `url('${enemy.spritePath}')`;
                // Green border for betrayed mobs
                if (isBetrayed && !enemy.isBoss) {
                    portrait.style.borderColor = '#00FF00';
                }
                card.appendChild(portrait);
                
                // Name - add ally indicator for betrayed mobs
                const name = document.createElement('div');
                name.className = 'battleEnemyName';
                if (isBetrayed && !enemy.isBoss) {
                    name.innerHTML = `ðŸ¤ ${enemy.name.toUpperCase()}`;
                    name.style.color = '#00FF00';
                } else {
                    name.textContent = enemy.name.toUpperCase();
                }
                card.appendChild(name);
                
                // HP stat - green for betrayed mobs
                const hpStat = document.createElement('div');
                hpStat.className = 'battleEnemyStat';
                hpStat.style.color = isBetrayed && !enemy.isBoss ? '#00FF00' : '#ff6b6b';
                hpStat.innerHTML = `HP: <span>${enemy.hp}</span>/<span>${enemy.maxHp}</span>`;
                card.appendChild(hpStat);
                
                // AC stat
                const acStat = document.createElement('div');
                acStat.className = 'battleEnemyStat';
                acStat.innerHTML = `AC: <span>${enemy.ac || 10}</span>`;
                card.appendChild(acStat);
                
                // Gold stat (public ledger - enemies use Bitcoin/gold, not Zcash!)
                const goldStat = document.createElement('div');
                goldStat.className = 'battleEnemyStat';
                goldStat.style.color = '#FFD700';
                goldStat.innerHTML = `ðŸ’° <span>${enemy.goldDrop || 0}</span>`;
                card.appendChild(goldStat);
                
                // Click handler for targeting
                card.addEventListener('click', () => {
                    if (battleState.targetingMode && enemy.hostile && enemy.hp > 0) {
                        const attacker = battleState.turnOrder[battleState.currentTurn];
                        executeAttack(attacker, enemy, battleState.pendingAction);
                        
                        // Exit targeting mode
                        battleState.targetingMode = false;
                        battleState.pendingAction = null;
                        document.getElementById('battleCanvas').style.cursor = 'default';
                        updateBattleEnemyCards(); // Refresh to remove targetable class
                    }
                });
                
                // Hover-to-enlarge functionality (hold for 0.5s)
                let hoverTimeout = null;
                card.addEventListener('mouseenter', () => {
                    hoverTimeout = setTimeout(() => {
                        // Get card position for proper enlargement
                        const rect = card.getBoundingClientRect();
                        card.style.position = 'fixed';
                        card.style.left = rect.left + 'px';
                        card.style.top = rect.top + 'px';
                        card.classList.add('enlarged');
                    }, 500);
                });
                card.addEventListener('mouseleave', () => {
                    clearTimeout(hoverTimeout);
                    card.classList.remove('enlarged');
                    card.style.position = '';
                    card.style.left = '';
                    card.style.top = '';
                });
                
                container.appendChild(card);
            });
            
            // Add captive card if present and not rescued
            if (battleState.captiveNpc && !battleState.captiveNpc.rescued) {
                const captive = battleState.captiveNpc;
                const card = document.createElement('div');
                card.className = 'battleEnemyCard captive';
                card.id = 'captiveCard';
                
                // Portrait
                const portrait = document.createElement('div');
                portrait.className = 'battleEnemyPortrait';
                portrait.style.backgroundImage = `url('${captive.spritePath}')`;
                card.appendChild(portrait);
                
                // Name with chain emoji
                const name = document.createElement('div');
                name.className = 'battleEnemyName';
                name.textContent = `â›“ï¸ ${captive.name.toUpperCase()}`;
                card.appendChild(name);
                
                // HP stat
                const hpStat = document.createElement('div');
                hpStat.className = 'battleEnemyStat';
                hpStat.style.color = '#27AE60';
                hpStat.innerHTML = `HP: <span>${captive.hp || '?'}</span>/<span>${captive.maxHp || '?'}</span>`;
                card.appendChild(hpStat);
                
                // AC stat
                const acStat = document.createElement('div');
                acStat.className = 'battleEnemyStat';
                acStat.innerHTML = `AC: <span>${captive.ac || 10}</span>`;
                card.appendChild(acStat);
                
                // Gold stat (captive's reward - public on Bitcoin/gold network!)
                const goldStat = document.createElement('div');
                goldStat.className = 'battleEnemyStat';
                goldStat.style.color = '#FFD700';
                goldStat.innerHTML = `ðŸ’° <span>${captive.goldReward || 0}</span>`;
                card.appendChild(goldStat);
                
                // "CAPTIVE" label
                const label = document.createElement('div');
                label.className = 'battleEnemyStat';
                label.style.color = '#F2C94C';
                label.style.fontWeight = 'bold';
                label.textContent = 'CAPTIVE';
                card.appendChild(label);
                
                // Hover-to-enlarge functionality (hold for 0.5s)
                let hoverTimeout = null;
                card.addEventListener('mouseenter', () => {
                    hoverTimeout = setTimeout(() => {
                        const rect = card.getBoundingClientRect();
                        card.style.position = 'fixed';
                        card.style.left = rect.left + 'px';
                        card.style.top = rect.top + 'px';
                        card.classList.add('enlarged');
                    }, 500);
                });
                card.addEventListener('mouseleave', () => {
                    clearTimeout(hoverTimeout);
                    card.classList.remove('enlarged');
                    card.style.position = '';
                    card.style.left = '';
                    card.style.top = '';
                });
                
                container.appendChild(card);
            }
        }
        
        // D&D modifier calculation
        function calculateModifier(stat) {
            return Math.floor((stat - 10) / 2);
        }
        
        // Find closest hero to an enemy
        function findClosestHero(enemy, heroes) {
            let target = heroes[0];
            let minDistance = Math.sqrt(Math.pow(enemy.x - target.x, 2) + Math.pow(enemy.y - target.y, 2));
            
            for (let i = 1; i < heroes.length; i++) {
                const hero = heroes[i];
                const distance = Math.sqrt(Math.pow(enemy.x - hero.x, 2) + Math.pow(enemy.y - hero.y, 2));
                if (distance < minDistance) {
                    minDistance = distance;
                    target = hero;
                }
            }
            return target;
        }
        
        // Dice rolling functions
        function rollD20() {
            return Math.floor(Math.random() * 20) + 1;
        }
        
        function rollD6(count = 1) {
            let total = 0;
            for (let i = 0; i < count; i++) {
                total += Math.floor(Math.random() * 6) + 1;
            }
            return total;
        }
        
        // Dice roll ticker system
        let diceRollTickerInterval = null;
        const diceRollTickerMessages = [
            'â³ ...Waiting to Roll... â³',
            'ðŸŽ® ...Tunnels of Privacy... ðŸŽ®',
            '...Created by CyberAxe for Zcash...'
        ];
        let diceRollTickerIndex = 0;
        let diceRollTickerCharIndex = 0;
        let currentMessage = '';
        
        function startDiceRollTicker() {
            if (diceRollTickerInterval) return; // Already running
            const display = document.getElementById('diceRollDisplay');
            if (display) {
                display.style.overflow = 'visible';
                display.style.whiteSpace = 'normal';
            }
            
            // Waterfall effect: reveal text from center outward
            diceRollTickerInterval = setInterval(() => {
                const display = document.getElementById('diceRollDisplay');
                if (display) {
                    const message = diceRollTickerMessages[diceRollTickerIndex];
                    const totalLength = message.length;
                    
                    if (diceRollTickerCharIndex < totalLength) {
                        // Build text from center outward
                        const center = Math.floor(totalLength / 2);
                        const revealRadius = Math.floor(diceRollTickerCharIndex / 2);
                        
                        let visibleText = '';
                        for (let i = 0; i < totalLength; i++) {
                            const distanceFromCenter = Math.abs(i - center);
                            if (distanceFromCenter <= revealRadius) {
                                visibleText += message[i];
                            } else {
                                visibleText += ' ';
                            }
                        }
                        
                        display.innerHTML = visibleText;
                        diceRollTickerCharIndex++;
                    } else {
                        // Hold full message for 2 seconds
                        if (diceRollTickerCharIndex === totalLength) {
                            display.innerHTML = message;
                        }
                        diceRollTickerCharIndex++;
                        
                        // After holding, move to next message
                        if (diceRollTickerCharIndex > totalLength + 13) { // 13 frames * 150ms â‰ˆ 2 seconds
                            diceRollTickerIndex = (diceRollTickerIndex + 1) % diceRollTickerMessages.length;
                            diceRollTickerCharIndex = 0;
                        }
                    }
                }
            }, 150);
        }
        
        function stopDiceRollTicker() {
            if (diceRollTickerInterval) {
                clearInterval(diceRollTickerInterval);
                diceRollTickerInterval = null;
                diceRollTickerIndex = 0;
                diceRollTickerCharIndex = 0;
            }
        }
        
        // Display dice roll result
        function showDiceRoll(text) {
            const display = document.getElementById('diceRollDisplay');
            if (display) {
                stopDiceRollTicker();
                display.style.overflow = 'visible';
                display.style.whiteSpace = 'normal';
                display.innerHTML = text;
                display.style.display = 'block';
                setTimeout(() => {
                    display.style.overflow = 'hidden';
                    display.style.whiteSpace = 'nowrap';
                    diceRollTickerPosition = 0;
                    startDiceRollTicker();
                }, 3000);
            }
        }
        
        // Show battle notification banner
        function showBattleNotification(text) {
            const notification = document.getElementById('battleNotification');
            if (notification) {
                notification.textContent = text;
                notification.style.display = 'block';
                setTimeout(() => {
                    notification.style.display = 'none';
                }, 3000);
            }
        }
        
        // Confirmation modal system
        let confirmationCallback = null;
        
        function showConfirmation(title, message, callback) {
            document.getElementById('confirmationTitle').textContent = title;
            document.getElementById('confirmationMessage').textContent = message;
            confirmationCallback = callback;
            document.getElementById('confirmationModal').style.display = 'block';
        }
        
        function confirmModalAction(confirmed) {
            document.getElementById('confirmationModal').style.display = 'none';
            if (confirmationCallback) {
                confirmationCallback(confirmed);
                confirmationCallback = null;
            }
        }
        
        // Handle battle actions
        function battleAction(action) {
            if (action === 'retreat') {
                // Check if battle is won (leave instead of retreat)
                if (battleState.won && multiplayerState.enabled) {
                    // Only host can leave after victory - clients wait
                    if (multiplayerState.role === 'host') {
                        // Host clicked leave - end battle for everyone
                        sendWebSocketMessage({ type: 'battle_end', reason: 'victory' });
                        setTimeout(() => {
                            endBattle();
                        }, 1000);
                    } else {
                        // Client clicked leave - show persistent message to wait for host
                        const notification = document.getElementById('battleNotification');
                        if (notification) {
                            notification.textContent = 'Waiting for host to leave...';
                            notification.style.display = 'block';
                            // Don't auto-hide - will hide when battle_end is received
                        }
                    }
                    return;
                }
                
                // Regular retreat logic (battle not won)
                if (multiplayerState.enabled) {
                    multiplayerState.myHeroes.forEach(heroName => {
                        const hero = battleState.heroes.find(h => h.name.toLowerCase() === heroName);
                        if (hero) {
                            hero.retreated = true;
                        }
                    });
                    
                    if (multiplayerState.role === 'host') {
                        // Save all heroes for stat persistence (before filtering)
                        // Merge with existing allHeroes to preserve previously retreated heroes
                        if (battleState.allHeroes.length === 0) {
                            battleState.allHeroes = [...battleState.heroes];
                        } else {
                            // Add any heroes not already in allHeroes
                            battleState.heroes.forEach(hero => {
                                if (!battleState.allHeroes.find(h => h.name === hero.name)) {
                                    battleState.allHeroes.push(hero);
                                }
                            });
                        }
                        
                        // Remove retreated heroes from arrays
                        battleState.heroes = battleState.heroes.filter(h => !h.retreated);
                        battleState.turnOrder = battleState.turnOrder.filter(combatant => {
                            if (battleState.heroes.includes(combatant)) return true;
                            if (battleState.enemies.includes(combatant)) return combatant.hp > 0;
                            return false;
                        });
                        
                        // Update UI and broadcast
                        updateBattleHeroCards();
                        renderBattle();
                        broadcastGameState();
                        
                        // Check if any heroes still alive
                        if (battleState.heroes.length === 0) {
                            showBattleNotification('DEFEAT! ALL HEROES RETREATED!');
                            
                            // Notify clients to end battle
                            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                                sendWebSocketMessage({
                                    type: 'battle_end',
                                    reason: 'retreat'
                                });
                            }
                            
                            setTimeout(() => {
                                // Hide notification
                                const notification = document.getElementById('battleNotification');
                                if (notification) notification.style.display = 'none';
                                
                                endBattle();
                            }, 2000);
                        } else {
                            // Reset turn if current combatant was removed
                            const currentCombatant = battleState.turnOrder[battleState.currentTurn];
                            if (!currentCombatant) {
                                battleState.currentTurn = 0;
                                updateBattleTurnInfo();
                            }
                        }
                    } else {
                        // Client sends retreat to host
                        sendWebSocketMessage({
                            type: 'player_action',
                            action: 'retreat',
                            heroes: multiplayerState.myHeroes
                        });
                        
                        // Update local UI immediately
                        updateBattleHeroCards();
                        renderBattle();
                    }
                } else {
                    // Single player - just end battle
                    endBattle();
                }
                return;
            }
            
            // Talk action - toggle chat window (no turn cost, can use anytime)
            if (action === 'talk') {
                toggleChatWindow();
                return;
            }
            
            const currentCombatant = battleState.turnOrder[battleState.currentTurn];
            
            // Check if it's a hero's turn
            const isHeroTurn = battleState.heroes.includes(currentCombatant);
            
            if (!isHeroTurn) {
                console.log('Not hero turn');
                return;
            }
            
            // Multiplayer: Check if this is my hero
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                if (!multiplayerState.myHeroes.includes(currentCombatant.name.toLowerCase())) {
                    showDiceRoll('Not your turn!');
                    return;
                }
            }
            
            // Check if hero is disabled (0 HP)
            if (currentCombatant.hp <= 0) {
                showDiceRoll(`${currentCombatant.name} is disabled!`);
                advanceTurn();
                return;
            }
            
            // Reset defending state when hero takes a new action
            if (currentCombatant.defending) {
                currentCombatant.defending = false;
                // Reset from defend animation to idle
                const heroKey = currentCombatant.name.toLowerCase();
                const paths = HERO_ANIM_PATHS[heroKey];
                if (paths && paths.defend) {
                    setAnimationState(currentCombatant, 'idle', 'pingpong');
                }
            }
            
            // Enter targeting mode for attacks
            if (action === 'light' || action === 'heavy' || action === 'special') {
                // Multiplayer: Client enters targeting mode but won't execute until host confirms
                battleState.targetingMode = true;
                battleState.pendingAction = action;
                // Show targeting UI feedback
                document.getElementById('battleCanvas').style.cursor = 'crosshair';
                // Highlight enemies on canvas and cards
                updateBattleEnemyCards();
                renderBattle();
                return;
            }
            
            // Defend action - reduce damage by 50% until next turn
            if (action === 'defend') {
                // Multiplayer: Client sends to host
                if (multiplayerState.enabled && multiplayerState.role === 'client') {
                    sendWebSocketMessage({
                        type: 'player_action',
                        action: 'defend',
                        hero: currentCombatant.name
                    });
                    return;
                }
                
                currentCombatant.defending = true;
                
                // Trigger defend animation (ping-pong while defending)
                const heroKey = currentCombatant.name.toLowerCase();
                const paths = HERO_ANIM_PATHS[heroKey];
                if (paths && paths.defend) {
                    setAnimationState(currentCombatant, 'defend', 'pingpong');
                }
                
                showDiceRoll(`${currentCombatant.name} defends!`);
                advanceTurn();
                return;
            }
            
            // Heal action - restore 50% of max HP (costs 1 action point)
            if (action === 'heal') {
                if (currentCombatant.healsRemaining <= 0) {
                    showDiceRoll(`${currentCombatant.name} has no heals left!`);
                    return;
                }
                
                // Multiplayer: Client sends to host
                if (multiplayerState.enabled && multiplayerState.role === 'client') {
                    sendWebSocketMessage({
                        type: 'player_action',
                        action: 'heal',
                        hero: currentCombatant.name
                    });
                    return;
                }
                
                const healAmount = Math.floor(currentCombatant.maxHp * 0.5);
                currentCombatant.hp = Math.min(currentCombatant.maxHp, currentCombatant.hp + healAmount);
                currentCombatant.healsRemaining--;
                currentCombatant.usedHeal = true; // Mark that heal was used this turn
                
                // Hide a potion sprite (consume the rightmost visible one)
                if (currentCombatant.potions) {
                    for (let i = currentCombatant.potions.length - 1; i >= 0; i--) {
                        if (currentCombatant.potions[i].visible) {
                            currentCombatant.potions[i].visible = false;
                            break;
                        }
                    }
                }
                
                // Trigger heal animation if hero has one (plays once, returns to idle)
                const heroKey = currentCombatant.name.toLowerCase();
                const paths = HERO_ANIM_PATHS[heroKey];
                if (paths && paths.heal) {
                    setAnimationState(currentCombatant, 'heal', 'once', () => {
                        setAnimationState(currentCombatant, 'idle', 'pingpong');
                    });
                }
                
                showDiceRoll(`${currentCombatant.name} heals for ${healAmount} HP! (1 action used)`);
                updateBattleHeroCards();
                
                // Disable heavy and special buttons after heal
                document.getElementById('battleHeavyBtn').disabled = true;
                document.getElementById('battleHeavyBtn').style.opacity = '0.5';
                document.getElementById('battleSpecialBtn').disabled = true;
                document.getElementById('battleSpecialBtn').style.opacity = '0.5';
                
                // Host broadcasts state
                if (multiplayerState.enabled && multiplayerState.role === 'host') {
                    broadcastGameState();
                }
                
                return; // Don't advance turn
            }
            
            // Swap action - swap positions with another hero
            if (action === 'swap') {
                // Multiplayer: Client enters swap targeting mode
                battleState.swapTargetingMode = true;
                battleState.swapInitiator = currentCombatant;
                document.getElementById('battleCanvas').style.cursor = 'pointer';
                showDiceRoll(`${currentCombatant.name}: Select a hero to swap with`);
                renderBattle();
                return;
            }
            
            // Taunt action - draw enemy aggro with CHA check
            if (action === 'taunt') {
                // Multiplayer: Client sends to host
                if (multiplayerState.enabled && multiplayerState.role === 'client') {
                    sendWebSocketMessage({
                        type: 'player_action',
                        action: 'taunt',
                        hero: currentCombatant.name
                    });
                    return;
                }
                
                const chaModifier = calculateModifier(currentCombatant.stats?.cha || 10);
                const tauntRoll = rollD20() + chaModifier;
                const tauntDC = 12; // Base difficulty
                
                // Trigger taunt animation if hero has one (plays once, returns to idle)
                const heroKey = currentCombatant.name.toLowerCase();
                const paths = HERO_ANIM_PATHS[heroKey];
                if (paths && paths.taunt) {
                    setAnimationState(currentCombatant, 'taunt', 'once', () => {
                        setAnimationState(currentCombatant, 'idle', 'pingpong');
                    });
                }
                
                if (tauntRoll >= tauntDC) {
                    currentCombatant.taunting = true;
                    currentCombatant.tauntTurns = 3; // Lasts 3 turns
                    showDiceRoll(`${currentCombatant.name} taunts! d20(${tauntRoll}) SUCCESS!`);
                } else {
                    showDiceRoll(`${currentCombatant.name} taunt fails! d20(${tauntRoll}) vs DC ${tauntDC}`);
                }
                advanceTurn();
                
                // Host broadcasts state
                if (multiplayerState.enabled && multiplayerState.role === 'host') {
                    broadcastGameState();
                }
                return;
            }
            
            // Skip action - end turn without doing anything
            if (action === 'skip') {
                // Multiplayer: Client sends to host
                if (multiplayerState.enabled && multiplayerState.role === 'client') {
                    sendWebSocketMessage({
                        type: 'player_action',
                        action: 'skip',
                        hero: currentCombatant.name
                    });
                    return;
                }
                
                showDiceRoll(`${currentCombatant.name} skips turn.`);
                advanceTurn();
                
                // Host broadcasts state
                if (multiplayerState.enabled && multiplayerState.role === 'host') {
                    broadcastGameState();
                }
                return;
            }
        }
        
        // Execute attack on target
        function executeAttack(attacker, target, actionType) {
            // Check if hero has attack animation
            const isHero = battleState.heroes.includes(attacker);
            const heroKey = isHero ? attacker.name.toLowerCase() : null;
            const animState = actionType + '_attack'; // 'light_attack', 'heavy_attack', 'special_attack'
            const paths = heroKey ? HERO_ANIM_PATHS[heroKey] : null;
            const hasAnimation = paths && paths[animState];
            
            // Trigger attack animation if hero has one
            if (hasAnimation) {
                setAnimationState(attacker, animState, 'once', () => {
                    setAnimationState(attacker, 'idle', 'pingpong');
                });
            }
            
            // Delay attack logic to sync with animation (2 seconds)
            const delay = hasAnimation ? 2000 : 0;
            
            setTimeout(() => {
                executeAttackLogic(attacker, target, actionType);
            }, delay);
        }
        
        // Actual attack logic (separated for animation delay)
        function executeAttackLogic(attacker, target, actionType) {
            const attackerStats = attacker.stats || {};
            const str = attackerStats.str || 10;
            const dex = attackerStats.dex || 10;
            const wis = attackerStats.wis || 10;
            
            let attackRoll = rollD20();
            let modifier = 0;
            let damageRoll = 0;
            let attackName = '';
            
            // Calculate attack and damage based on action type
            if (actionType === 'light') {
                modifier = calculateModifier(dex);
                attackRoll += calculateModifier(str);
                damageRoll = rollD6(1) + modifier;
                attackName = 'Light Attack';
            } else if (actionType === 'heavy') {
                modifier = calculateModifier(str);
                attackRoll += modifier;
                damageRoll = rollD6(2) + modifier;
                attackName = 'Heavy Attack';
            } else if (actionType === 'special') {
                modifier = calculateModifier(wis);
                attackRoll += modifier;
                damageRoll = rollD6(3) + modifier;
                attackName = 'Special Attack';
            }
            
            // Check if attack hits
            const targetAC = target.ac || 10;
            
            // Award 1 XP for attempting attack
            attacker.xp = (attacker.xp || 0) + 1;
            
            if (attackRoll >= targetAC) {
                // Apply defending reduction
                if (target.defending) {
                    damageRoll = Math.floor(damageRoll / 2);
                    target.defending = false;
                    
                    // Award 3 XP to defender for successfully defending
                    if (battleState.heroes.includes(target)) {
                        target.xp = (target.xp || 0) + 3;
                    }
                }
                
                target.hp = Math.max(0, target.hp - damageRoll);
                
                // Update boss morale when they take damage
                if (target.isBoss) {
                    updateBossMorale(target, 'took_damage');
                }
                
                // Trigger free will chat for damaged enemy
                if (battleState.enemies.includes(target) && target.hp > 0) {
                    if (target.hp < target.maxHp * 0.3) {
                        triggerFreeWillChat(target, 'low_health');
                    } else {
                        triggerFreeWillChat(target, 'took_damage');
                    }
                }
                
                // Trigger free will chat for attacker if enemy dealt damage
                if (battleState.enemies.includes(attacker)) {
                    triggerFreeWillChat(attacker, 'dealt_damage');
                }
                
                // Award 2 XP for hitting (total 3 including attempt)
                attacker.xp += 2;
                
                // Generate fake dice rolls for display
                const numDice = actionType === 'light' ? 1 : (actionType === 'heavy' ? 2 : 3);
                const diceRolls = [];
                for (let i = 0; i < numDice; i++) {
                    diceRolls.push(Math.floor(Math.random() * 6) + 1);
                }
                const diceTotal = diceRolls.reduce((a, b) => a + b, 0);
                showDiceRoll(`ðŸŽ² Rolled: ${diceRolls.join(', ')} = <span style="color:#00ff00">${diceTotal}</span> vs <span style="color:#00ff00">${targetAC}</span> <span style="color:#00ff00">âœ“</span>`);
            } else {
                // Miss - award 1 XP to defender if they're a hero
                if (battleState.heroes.includes(target)) {
                    target.xp = (target.xp || 0) + 1;
                }
                // Generate fake dice rolls for display
                const numDice = actionType === 'light' ? 1 : (actionType === 'heavy' ? 2 : 3);
                const diceRolls = [];
                for (let i = 0; i < numDice; i++) {
                    diceRolls.push(Math.floor(Math.random() * 6) + 1);
                }
                const diceTotal = diceRolls.reduce((a, b) => a + b, 0);
                showDiceRoll(`ðŸŽ² Rolled: ${diceRolls.join(', ')} = <span style="color:#ff0000">${diceTotal}</span> vs <span style="color:#ff0000">${targetAC}</span> <span style="color:#ff0000">âœ—</span>`);
            }
            
            renderBattle();
            updateBattleEnemyCards();
            updateBattleHeroCards();
            updateChatTargets();  // Update chat target buttons
            
            // Check if target is dead
            if (target.hp <= 0) {
                // Award 10 XP for killing blow
                attacker.xp += 10;
                
                // Award gold from enemy
                const goldDrop = target.goldDrop || (target.isBoss ? 100 : 10);
                const sharedSave = JSON.parse(localStorage.getItem('top_shared_save') || '{}');
                if (!sharedSave.dungeonState) sharedSave.dungeonState = {};
                sharedSave.dungeonState.gold = (sharedSave.dungeonState.gold || 0) + goldDrop;
                localStorage.setItem('top_shared_save', JSON.stringify(sharedSave));
                
                addChatMessage('System', 'system', null, `ðŸ’° ${attacker.name} looted ${goldDrop} gold from ${target.name}!`, false);
                updateGoldDisplay();
                updateBattleHeroCards();
                
                // Update boss morale when ally dies
                const boss = battleState.enemies.find(e => e.isBoss && e.hp > 0);
                if (boss && target !== boss) {
                    updateBossMorale(boss, 'ally_died');
                }
                
                // Remove from battle
                battleState.enemies = battleState.enemies.filter(e => e !== target);
                battleState.turnOrder = battleState.turnOrder.filter(c => c !== target);
                
                // Check win condition
                if (battleState.enemies.length === 0) {
                    battleState.won = true;
                    
                    // Track level progress - room explored
                    incrementRoomsExplored();
                    
                    // Check if this battle had a boss
                    if (battleState.hadBoss) {
                        markBossDefeated();
                    }
                    
                    // Award 100 XP to all heroes for clearing the room
                    battleState.heroes.forEach(hero => {
                        hero.xp = (hero.xp || 0) + 100;
                    });
                    updateBattleHeroCards();
                    
                    showBattleNotification('ROOM CLEARED!');
                    
                    // Rescue captive NPC if present
                    if (battleState.captiveNpc && !battleState.captiveNpc.rescued) {
                        battleState.captiveNpc.rescued = true;
                        incrementCaptivesFreed(); // Track captive rescue
                        setTimeout(() => {
                            // Show rescue dialogue
                            addChatMessage(
                                battleState.captiveNpc.name,
                                'friendly',
                                'people/zooko_a_head_compressed.png',
                                battleState.captiveNpc.dialogueOnRescue,
                                true,
                                battleState.captiveNpc.voiceType
                            );
                            
                            // Give reward
                            const reward = battleState.captiveNpc.rescueReward;
                            let rewardText = 'Rescued ' + battleState.captiveNpc.name + '!';
                            if (reward.gold) {
                                rewardText += ` +${reward.gold} gold`;
                            }
                            if (reward.item) {
                                rewardText += ` +${reward.item}`;
                            }
                            if (reward.info) {
                                setTimeout(() => {
                                    addChatMessage(
                                        battleState.captiveNpc.name,
                                        'friendly',
                                        'people/zooko_a_head_compressed.png',
                                        `*whispers* ${reward.info}`,
                                        true,
                                        battleState.captiveNpc.voiceType
                                    );
                                }, 2000);
                            }
                            showBattleNotification(rewardText);
                            
                            // Update UI to remove captive from chat targets and HUD
                            updateChatTargets();
                            updateBattleEnemyCards();
                        }, 1500);
                    }
                    
                    // Change retreat button to leave
                    const retreatBtn = document.querySelector('.battleButton.retreat');
                    if (retreatBtn) {
                        retreatBtn.textContent = 'ðŸšª LEAVE';
                    }
                    // Broadcast final state (includes captive.rescued = true)
                    if (multiplayerState.enabled && multiplayerState.role === 'host') {
                        broadcastGameState();
                    }
                    return;
                }
            }
            
            advanceTurn();
            
            // Broadcast state after action
            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                broadcastGameState();
            }
        }
        
        // Process AI turn
        function processAITurn(combatant) {
            if (!combatant.hostile) {
                // Check if this is a betrayed mob that should attack enemies
                if (combatant.negotiationState?.betrayed) {
                    // Betrayed mob attacks hostile enemies (prioritize boss)
                    const hostileEnemies = battleState.enemies.filter(e => e.hostile && e.hp > 0 && e !== combatant);
                    if (hostileEnemies.length > 0) {
                        // Prioritize boss
                        const boss = hostileEnemies.find(e => e.isBoss);
                        const target = boss || hostileEnemies[0];
                        
                        const attackRoll = rollD20();
                        const damage = combatant.attackDamage || rollD6(1);
                        
                        if (attackRoll >= (target.ac || 10)) {
                            target.hp = Math.max(0, target.hp - damage);
                            showDiceRoll(`ðŸ¤ ${combatant.name} BETRAYS! Attacks ${target.name} for ${damage} damage!`);
                            
                            if (target.hp <= 0) {
                                showBattleNotification(`${target.name} defeated by betrayal!`);
                                battleState.enemies = battleState.enemies.filter(e => e !== target);
                                battleState.turnOrder = battleState.turnOrder.filter(c => c !== target);
                            }
                        } else {
                            showDiceRoll(`ðŸ¤ ${combatant.name} attacks ${target.name}: MISS!`);
                        }
                        
                        renderBattle();
                        updateBattleEnemyCards();
                        advanceTurn();
                        return;
                    }
                }
                
                // Friendly/neutral NPCs skip turn
                showDiceRoll(`${combatant.name} waits...`);
                advanceTurn();
                return;
            }
            
            // Hostile AI: pick closest hero and attack
            const aliveHeroes = battleState.heroes.filter(h => h.hp > 0);
            if (aliveHeroes.length === 0) {
                // Game over
                showBattleNotification('DEFEAT! ALL HEROES FALLEN!');
                
                // Notify clients if multiplayer
                if (multiplayerState.enabled && multiplayerState.role === 'host') {
                    sendWebSocketMessage({
                        type: 'battle_end',
                        reason: 'defeat'
                    });
                }
                
                setTimeout(() => {
                    // Hide notification
                    const notification = document.getElementById('battleNotification');
                    if (notification) notification.style.display = 'none';
                    
                    endBattle();
                }, 2000);
                return;
            }
            
            // Check for taunting heroes first
            const tauntingHeroes = aliveHeroes.filter(h => h.taunting && h.tauntTurns > 0);
            let target;
            
            if (tauntingHeroes.length > 0) {
                // Roll to resist taunt
                const resistRoll = rollD20();
                const resistDC = 15; // Base resist DC
                
                if (resistRoll < resistDC) {
                    // Failed to resist, attack taunter
                    target = tauntingHeroes[0];
                    showDiceRoll(`${combatant.name} is taunted by ${target.name}!`);
                } else {
                    // Resisted taunt, clear taunt status
                    tauntingHeroes.forEach(h => {
                        h.taunting = false;
                        h.tauntTurns = 0;
                    });
                    showDiceRoll(`${combatant.name} resists taunt! d20(${resistRoll})`);
                    // Fall through to normal targeting
                    target = findClosestHero(combatant, aliveHeroes);
                }
            } else {
                // No taunters, find closest hero
                target = findClosestHero(combatant, aliveHeroes);
            }
            
            // AI attack roll
            const attackRoll = rollD20();
            const damage = combatant.attackDamage || rollD6(1);
            
            // Don't damage heroes already at 0 HP
            if (target.hp <= 0) {
                showDiceRoll(`${combatant.name} ignores disabled ${target.name}`);
                advanceTurn();
                return;
            }
            
            if (attackRoll >= (target.stats?.ac || 10)) {
                let finalDamage = damage;
                if (target.defending) {
                    finalDamage = Math.floor(damage / 2);
                    target.defending = false;
                    // Reset from defend animation (hit animation will play next)
                }
                
                target.hp = Math.max(0, target.hp - finalDamage);
                
                // Trigger hit animation if hero has one (and not knocked out)
                if (battleState.heroes.includes(target) && target.hp > 0) {
                    const heroKey = target.name.toLowerCase();
                    const paths = HERO_ANIM_PATHS[heroKey];
                    if (paths && paths.hit) {
                        setAnimationState(target, 'hit', 'once', () => {
                            setAnimationState(target, 'idle', 'pingpong');
                        });
                    }
                }
                
                showDiceRoll(`${combatant.name} attacks ${target.name}: HIT for ${finalDamage} damage!`);
                
                // Update boss morale on successful hit
                if (combatant.isBoss) {
                    updateBossMorale(combatant, 'hit_attack');
                }
            } else {
                showDiceRoll(`${combatant.name} attacks ${target.name}: MISS!`);
                
                // Update boss morale on missed attack
                if (combatant.isBoss) {
                    updateBossMorale(combatant, 'missed_attack');
                }
            }
            
            renderBattle();
            updateBattleHeroCards();
            updateBattleEnemyCards();
            updateChatTargets();  // Update chat target buttons
            
            // Broadcast AI action to clients
            broadcastGameState();
            
            // Check if hero died
            if (target.hp <= 0) {
                // Trigger knockout animation if available
                if (battleState.heroes.includes(target)) {
                    const heroKey = target.name.toLowerCase();
                    const paths = HERO_ANIM_PATHS[heroKey];
                    if (paths && paths.knockout) {
                        setAnimationState(target, 'knockout', 'once');
                    }
                }
                
                const allHeroesDead = battleState.heroes.every(h => h.hp <= 0);
                if (allHeroesDead) {
                    showBattleNotification('DEFEAT! ALL HEROES FALLEN!');
                    
                    // Notify clients if multiplayer
                    if (multiplayerState.enabled && multiplayerState.role === 'host') {
                        sendWebSocketMessage({
                            type: 'battle_end',
                            reason: 'defeat'
                        });
                    }
                    
                    setTimeout(() => {
                        // Hide notification
                        const notification = document.getElementById('battleNotification');
                        if (notification) notification.style.display = 'none';
                        
                        endBattle();
                    }, 2000);
                    return;
                }
            }
            
            // Check for enraged double attack
            if (shouldDoDoubleAttack(combatant)) {
                // Do a second attack after a short delay
                setTimeout(() => {
                    if (combatant.hp > 0 && battleState.active) {
                        const stillAliveHeroes = battleState.heroes.filter(h => h.hp > 0);
                        if (stillAliveHeroes.length > 0) {
                            const secondTarget = findClosestHero(combatant, stillAliveHeroes);
                            const secondRoll = rollD20();
                            const secondDamage = combatant.attackDamage || rollD6(1);
                            
                            if (secondRoll >= (secondTarget.stats?.ac || 10)) {
                                let finalDmg = secondDamage;
                                if (secondTarget.defending) {
                                    finalDmg = Math.floor(secondDamage / 2);
                                    secondTarget.defending = false;
                                }
                                secondTarget.hp = Math.max(0, secondTarget.hp - finalDmg);
                                showDiceRoll(`âš¡ ${combatant.name} RAGE ATTACK: ${finalDmg} damage to ${secondTarget.name}!`);
                            } else {
                                showDiceRoll(`âš¡ ${combatant.name} rage attack MISSES ${secondTarget.name}!`);
                            }
                            renderBattle();
                            updateBattleHeroCards();
                            
                            // Check for hero death
                            if (secondTarget.hp <= 0) {
                                const allDead = battleState.heroes.every(h => h.hp <= 0);
                                if (allDead) {
                                    showBattleNotification('DEFEAT!');
                                    setTimeout(() => endBattle(), 2000);
                                    return;
                                }
                            }
                        }
                    }
                    advanceTurn();
                }, 800);
                return;  // Don't advance turn yet - wait for double attack
            }
            
            advanceTurn();
        }
        
        // Advance to next turn
        function advanceTurn() {
            battleState.currentTurn = (battleState.currentTurn + 1) % battleState.turnOrder.length;
            const nextCombatant = battleState.turnOrder[battleState.currentTurn];
            
            // Reset action state for new turn
            battleState.heroes.forEach(hero => {
                hero.usedHeal = false;
            });
            
            // Re-enable all buttons at start of turn
            const heavyBtn = document.getElementById('battleHeavyBtn');
            const specialBtn = document.getElementById('battleSpecialBtn');
            if (heavyBtn) {
                heavyBtn.disabled = false;
                heavyBtn.style.opacity = '1';
            }
            if (specialBtn) {
                specialBtn.disabled = false;
                specialBtn.style.opacity = '1';
            }
            
            // Decrement taunt turns for all heroes
            battleState.heroes.forEach(hero => {
                if (hero.tauntTurns > 0) {
                    hero.tauntTurns--;
                    if (hero.tauntTurns <= 0) {
                        hero.taunting = false;
                    }
                }
            });
            
            updateBattleTurnInfo();
            
            // Broadcast turn advancement to clients
            broadcastGameState();
            
            // Auto-skip if current combatant has 0 HP or is retreated
            if (nextCombatant && (nextCombatant.hp <= 0 || nextCombatant.retreated)) {
                if (battleState.heroes.includes(nextCombatant)) {
                    showDiceRoll(`${nextCombatant.name} is disabled - skipping turn`);
                }
                setTimeout(() => advanceTurn(), 500);
                return;
            }
            
            // If next turn is AI, process automatically
            if (!battleState.heroes.includes(nextCombatant)) {
                setTimeout(() => processAITurn(nextCombatant), 1000);
            }
        }
        
        // End battle and return to dungeon menu
        function endBattle() {
            // Save hero stats to shared save
            const sharedSave = loadSharedSave();
            if (sharedSave && sharedSave.heroes) {
                // Use allHeroes to include dead/retreated heroes
                const heroesToSave = battleState.allHeroes.length > 0 ? battleState.allHeroes : battleState.heroes;
                
                heroesToSave.forEach(hero => {
                    const heroKey = hero.name.toLowerCase();
                    if (sharedSave.heroes[heroKey]) {
                        // Save all stats back to save file
                        sharedSave.heroes[heroKey].hp = hero.hp ?? 0;
                        sharedSave.heroes[heroKey].maxHp = hero.maxHp ?? 0;
                        sharedSave.heroes[heroKey].str = hero.stats?.str ?? sharedSave.heroes[heroKey].str;
                        sharedSave.heroes[heroKey].dex = hero.stats?.dex ?? sharedSave.heroes[heroKey].dex;
                        sharedSave.heroes[heroKey].con = hero.stats?.con ?? sharedSave.heroes[heroKey].con;
                        sharedSave.heroes[heroKey].int = hero.stats?.int ?? sharedSave.heroes[heroKey].int;
                        sharedSave.heroes[heroKey].wis = hero.stats?.wis ?? sharedSave.heroes[heroKey].wis;
                        sharedSave.heroes[heroKey].cha = hero.stats?.cha ?? sharedSave.heroes[heroKey].cha;
                        sharedSave.heroes[heroKey].xp = hero.xp ?? 0;
                        sharedSave.heroes[heroKey].level = hero.level ?? 1;
                    }
                });
                
                // Save current dungeon level
                const dungeonLevelEl = document.getElementById('dungeonMenuLevel');
                if (dungeonLevelEl && sharedSave.dungeonState) {
                    sharedSave.dungeonState.currentLevel = parseInt(dungeonLevelEl.textContent) || 1;
                }
                
                saveSharedSave(sharedSave);
                
                // Host saves to localStorage only - clients will update from next state_update
            }
            
            battleState.active = false;
            currentScreen = 'dungeonMenu';
            stopBattleVideo(); // Stop and hide video background
            document.getElementById('battleScreen').style.display = 'none';
            document.getElementById('dungeonMenuScreen').style.display = 'block';
            
            // Move music controls back to center
            document.getElementById('musicControls').classList.remove('battleActive');
            document.getElementById('musicControls').classList.add('dungeonMenuActive');
            document.getElementById('musicTicker').classList.remove('battleActive');
            document.getElementById('musicTicker').classList.add('dungeonMenuActive');
            
            // Update dungeon menu hero displays with saved stats
            updateDungeonMenuHeroes();
            updateGoldDisplay();
            
            // Move music controls and ticker back to center bottom
            document.getElementById('musicControls').classList.remove('battleActive');
            document.getElementById('musicTicker').classList.remove('battleActive');
            
            // Clear battle chat
            clearBattleChat();
            
            // Clear TTS voice cache (entities leaving room)
            fetch('/api/tts/clear-voice-cache', { method: 'POST' })
                .catch(e => console.log('[TTS] Voice cache clear failed (server offline?):', e.message));
            
            // Pre-generate next encounter while player is in dungeon menu
            preGenerateNextEncounter();
        }
        
        // ===== END BATTLE SYSTEM =====
        
        // Exit portal and return to arcade game
        function exitPortal() {
            try {
                // Load shared save
                const sharedSave = loadSharedSave();
                if (!sharedSave) {
                    alert('No shared save found! Cannot return to arcade.');
                    return;
                }
                
                // Get current dungeon level
                const dungeonLevelEl = document.getElementById('dungeonMenuLevel') || document.getElementById('dungeonLevel');
                const currentLevel = dungeonLevelEl ? (parseInt(dungeonLevelEl.textContent) || 1) : 1;
                
                // Update dungeon state
                sharedSave.dungeonState = {
                    currentLevel: currentLevel,
                    inventory: sharedSave.dungeonState?.inventory || [],
                    gold: sharedSave.dungeonState?.gold || 0,
                    questProgress: sharedSave.dungeonState?.questProgress || {
                        hasScepter: false,
                        hasReturned: false,
                        bossesDefeated: []
                    }
                };
                sharedSave.lastPlayed = Date.now();
                
                // Save updated shared state
                saveSharedSave(sharedSave);
                
                // Navigate back to arcade
                window.location.href = 'zlock_consensus.html';
            } catch (e) {
                console.error('Failed to exit portal:', e);
                alert('Portal exit failed! ' + e.message);
            }
        }
        
        // Update hero stat display (both title and dungeon screens)
        function updateHeroDisplay(heroName, stats) {
            const prefix = heroName.toLowerCase();
            
            // Title screen hero stats
            const levelEl = document.getElementById(`${prefix}-level`);
            const hpEl = document.getElementById(`${prefix}-hp`);
            const maxhpEl = document.getElementById(`${prefix}-maxhp`);
            const strEl = document.getElementById(`${prefix}-str`);
            const dexEl = document.getElementById(`${prefix}-dex`);
            const conEl = document.getElementById(`${prefix}-con`);
            const intEl = document.getElementById(`${prefix}-int`);
            const wisEl = document.getElementById(`${prefix}-wis`);
            const chaEl = document.getElementById(`${prefix}-cha`);
            const xpEl = document.getElementById(`${prefix}-xp`);
            
            // Dungeon screen hero stats (prefixed with 'd')
            const dhpEl = document.getElementById(`d${prefix}-hp`);
            const dmaxhpEl = document.getElementById(`d${prefix}-maxhp`);
            const dxpEl = document.getElementById(`d${prefix}-xp`);
            const dstrEl = document.getElementById(`d${prefix}-str`);
            const ddexEl = document.getElementById(`d${prefix}-dex`);
            const dconEl = document.getElementById(`d${prefix}-con`);
            const dintEl = document.getElementById(`d${prefix}-int`);
            const dwisEl = document.getElementById(`d${prefix}-wis`);
            const dchaEl = document.getElementById(`d${prefix}-cha`);
            
            // Update title screen
            if (levelEl) levelEl.textContent = stats.level || 1;
            if (hpEl) hpEl.textContent = stats.hp || 0;
            if (maxhpEl) maxhpEl.textContent = stats.maxHp || 0;
            if (strEl) strEl.textContent = stats.str || 0;
            if (dexEl) dexEl.textContent = stats.dex || 0;
            if (conEl) conEl.textContent = stats.con || 0;
            if (intEl) intEl.textContent = stats.int || 0;
            if (wisEl) wisEl.textContent = stats.wis || 0;
            if (chaEl) chaEl.textContent = stats.cha || 0;
            if (xpEl) xpEl.textContent = stats.xp || 0;
            
            // Update dungeon screen
            if (dhpEl) dhpEl.textContent = stats.hp || 0;
            if (dmaxhpEl) dmaxhpEl.textContent = stats.maxHp || 0;
            if (dxpEl) dxpEl.textContent = stats.xp || 0;
            if (dstrEl) dstrEl.textContent = stats.str || 0;
            if (ddexEl) ddexEl.textContent = stats.dex || 0;
            if (dconEl) dconEl.textContent = stats.con || 0;
            if (dintEl) dintEl.textContent = stats.int || 0;
            if (dwisEl) dwisEl.textContent = stats.wis || 0;
            if (dchaEl) dchaEl.textContent = stats.cha || 0;
        }
        
        // Update dungeon menu hero stats from save
        function updateDungeonMenuHeroes() {
            // Start story background animation when entering dungeon menu (do this first!)
            if (currentScreen === 'dungeonMenu') {
                startDungeonMenuAnimation();
                updateDifficultyButtons(); // Ensure difficulty button shows current selection
            }
            
            // Clients use cached stats from host broadcasts, host uses localStorage
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                // Client: Display from cache
                updateHeroDisplay('zooko', multiplayerState.heroStatsCache.zooko || {});
                updateHeroDisplay('nate', multiplayerState.heroStatsCache.nate || {});
                updateHeroDisplay('zancas', multiplayerState.heroStatsCache.zancas || {});
                updateHeroDisplay('cyberaxe', multiplayerState.heroStatsCache.cyberaxe || {});
            } else {
                // Host or solo: Load from localStorage
                const sharedSave = loadSharedSave();
                if (!sharedSave || !sharedSave.heroes) return;
                
                updateHeroDisplay('zooko', sharedSave.heroes.zooko);
                updateHeroDisplay('nate', sharedSave.heroes.nate);
                updateHeroDisplay('zancas', sharedSave.heroes.zancas);
                updateHeroDisplay('cyberaxe', sharedSave.heroes.cyberaxe);
            }
        }
        
        // Refresh all game data and broadcast to clients
        function refreshGameData() {
            const sharedSave = loadSharedSave();
            
            if (!sharedSave) {
                showNotification('No save data found', 'error');
                return;
            }
            
            // Update local displays
            updateDungeonMenuHeroes();
            
            // If multiplayer host, broadcast current game state
            if (multiplayerState.enabled && multiplayerState.role === 'host' && battleState.active) {
                broadcastGameState();
                showNotification('Data refreshed and synced to all players', 'success');
            } else if (multiplayerState.enabled && multiplayerState.role === 'client') {
                showNotification('Data refreshed from cache', 'info');
            } else {
                showNotification('Data refreshed', 'success');
            }
        }
        
        // Start adventure - switch from title to dungeon menu
        function startAdventure() {
            // Check if save exists and warn user
            const existingSave = loadSharedSave();
            if (existingSave && (existingSave.arcadeState || existingSave.dungeonState)) {
                showConfirmation(
                    'START NEW ADVENTURE?',
                    'This will replace your current save game. Save to file first if you want to keep your progress!',
                    (confirmed) => {
                        if (!confirmed) return;
                        showSinglePlayerHeroSelection();
                    }
                );
                return;
            }
            
            // No save exists, show hero selection for rolling stats
            showSinglePlayerHeroSelection();
        }
        
        // Show hero selection modal for single player mode
        function showSinglePlayerHeroSelection() {
            // Mark as single player mode (not multiplayer)
            multiplayerState.enabled = false;
            multiplayerState.role = 'host'; // Act as host for single player
            multiplayerState.myHeroes = ['zooko', 'nate', 'zancas', 'cyberaxe']; // Own all heroes
            multiplayerState.playerHeroes = {
                zooko: { playerName: 'You' },
                nate: { playerName: 'You' },
                zancas: { playerName: 'You' },
                cyberaxe: { playerName: 'You' }
            };
            multiplayerState.playerName = 'Adventurer';
            
            // Show hero selection modal
            document.getElementById('heroSelectionModal').style.display = 'block';
            document.getElementById('musicControls').classList.add('heroSelectionActive');
            document.getElementById('musicTicker').classList.add('battleActive');
            
            // Hide room code section for single player
            const codeDisplay = document.getElementById('heroSelectionCode');
            if (codeDisplay) codeDisplay.parentElement.style.display = 'none';
            
            // Hide player name input row for single player
            const playerNameInput = document.getElementById('playerNameInput');
            if (playerNameInput) playerNameInput.parentElement.style.display = 'none';
            
            // Hide PLAYERS count box for single player
            const playerCountBox = document.getElementById('playerCountBox');
            if (playerCountBox) playerCountBox.style.display = 'none';
            
            // Hide Connected Players list for single player
            const connectedPlayersList = document.getElementById('connectedPlayersList');
            if (connectedPlayersList) connectedPlayersList.style.display = 'none';
            
            // Change title to ROLL HERO STATS for single player
            const heroSelectionTitle = document.getElementById('heroSelectionTitle');
            if (heroSelectionTitle) heroSelectionTitle.textContent = 'ROLL HERO STATS';
            
            // Update waiting message for single player
            const waitingMsg = document.getElementById('heroWaitingMessage');
            if (waitingMsg) waitingMsg.textContent = 'All heroes are yours! Roll stats for each hero.';
            
            // Mark all heroes as selected by this player
            document.querySelectorAll('.heroSelectCard').forEach(card => {
                card.classList.add('selected');
                card.style.borderWidth = '5px';
                const playerLabel = card.querySelector('.heroPlayerLabel');
                if (playerLabel) {
                    playerLabel.textContent = 'You';
                    playerLabel.style.display = 'block';
                }
            });
            
            // Hide reconnect options, show game start options
            const reconnectOptions = document.getElementById('reconnectOptions');
            const gameStartOptions = document.getElementById('gameStartOptions');
            const backBtn = document.getElementById('heroSelectionBackBtn');
            if (reconnectOptions) reconnectOptions.style.display = 'none';
            if (gameStartOptions) gameStartOptions.style.display = 'block';
            if (backBtn) backBtn.style.display = 'none';
            
            // Update hero stats display first
            updateHeroSelectionStats();
            
            // Go directly to roll phase (phase 2) for single player
            inRollPhase = true;
            heroSelectionHasSave = false; // Force allowing rolls
            document.getElementById('gameStartPhase1').style.display = 'none';
            document.getElementById('gameStartPhase2').style.display = 'block';
            
            // Show roll buttons for all heroes
            showAllRollButtons();
            
            // Clear any previous rolled stats
            multiplayerState.rolledHeroStats = {};
            
            // Update status
            updateRollPhaseStatus();
        }
        
        function proceedWithNewAdventure() {
            const titleScreen = document.getElementById('titleScreen');
            const dungeonMenuScreen = document.getElementById('dungeonMenuScreen');
            
            if (titleScreen) titleScreen.style.display = 'none';
            if (dungeonMenuScreen) dungeonMenuScreen.style.display = 'block';
            
            currentScreen = 'dungeonMenu';
            
            // Center music controls for dungeon menu
            document.getElementById('musicControls').classList.add('dungeonMenuActive');
            document.getElementById('musicTicker').classList.add('dungeonMenuActive');
            
            // Create fresh save
            let sharedSave = createDefaultSharedSave();
            saveSharedSave(sharedSave);
            
            // Sync dungeon level display
            if (sharedSave && sharedSave.arcadeState && sharedSave.arcadeState.level) {
                const dungeonMenuLevel = document.getElementById('dungeonMenuLevel');
                if (dungeonMenuLevel) {
                    dungeonMenuLevel.textContent = sharedSave.arcadeState.level;
                }
                // Set room level for encounter generation
                preGeneratedEncounter.roomLevel = sharedSave.arcadeState.level;
            }
            // Also check dungeonState.currentLevel (from stairs)
            if (sharedSave && sharedSave.dungeonState && sharedSave.dungeonState.currentLevel) {
                const dungeonMenuLevel = document.getElementById('dungeonMenuLevel');
                if (dungeonMenuLevel) {
                    dungeonMenuLevel.textContent = sharedSave.dungeonState.currentLevel;
                }
                preGeneratedEncounter.roomLevel = sharedSave.dungeonState.currentLevel;
            }
            
            // Load hero stats from save to dungeon menu
            updateDungeonMenuHeroes();
            
            // Apply client UI restrictions
            applyClientUIRestrictions();
            
            // Initialize level layout for current level
            const currentLevel = preGeneratedEncounter.roomLevel || 1;
            initializeLevelLayout(currentLevel);
            
            // Pre-generate next encounter while player is in dungeon menu
            preGenerateNextEncounter();
            
            // If multiplayer host, notify clients to start and send save data
            if (multiplayerState.enabled && multiplayerState.role === 'host') {
                sendWebSocketMessage({ 
                    type: 'game_start', 
                    screen: 'dungeonMenu',
                    saveData: sharedSave
                });
            }
        }
        
        // Apply client UI restrictions (disable host-only buttons)
        function applyClientUIRestrictions() {
            if (multiplayerState.enabled && multiplayerState.role === 'client') {
                // Disable EXPLORE LEVEL button
                const exploreLevelBtn = document.getElementById('exploreLevelBtn');
                if (exploreLevelBtn) {
                    exploreLevelBtn.disabled = true;
                    exploreLevelBtn.style.opacity = '0.5';
                    exploreLevelBtn.style.cursor = 'not-allowed';
                    exploreLevelBtn.innerHTML = 'EXPLORE LEVEL<br>(HOST/PARTY LEADER ONLY)';
                }
                
                // Disable STAIRS buttons (UP/DOWN)
                const stairsUpBtn = document.getElementById('stairsUpBtn');
                if (stairsUpBtn) {
                    stairsUpBtn.disabled = true;
                    stairsUpBtn.style.opacity = '0.5';
                    stairsUpBtn.style.cursor = 'not-allowed';
                    stairsUpBtn.title = 'Only party leader can use stairs';
                }
                const stairsDownBtn = document.getElementById('stairsDownBtn');
                if (stairsDownBtn) {
                    stairsDownBtn.disabled = true;
                    stairsDownBtn.style.opacity = '0.5';
                    stairsDownBtn.style.cursor = 'not-allowed';
                    stairsDownBtn.title = 'Only party leader can use stairs';
                }
                
                // Disable FAST TRAVEL button and input
                const fastTravelBtn = document.getElementById('fastTravelBtn');
                if (fastTravelBtn) {
                    fastTravelBtn.disabled = true;
                    fastTravelBtn.style.opacity = '0.5';
                    fastTravelBtn.style.cursor = 'not-allowed';
                    fastTravelBtn.title = 'Only party leader can fast travel';
                }
                const fastTravelInput = document.getElementById('fastTravelLevel');
                if (fastTravelInput) {
                    fastTravelInput.disabled = true;
                    fastTravelInput.style.opacity = '0.5';
                }
                
                // Disable DIFFICULTY buttons
                const diffButtons = ['diffCasualBtn', 'diffNormalBtn', 'diffExpertBtn'];
                diffButtons.forEach(btnId => {
                    const btn = document.getElementById(btnId);
                    if (btn) {
                        btn.disabled = true;
                        btn.style.cursor = 'not-allowed';
                        btn.title = 'Only party leader can change difficulty';
                    }
                });
                
                // Disable CAMP button
                const campBtn = document.getElementById('campBtn');
                if (campBtn) {
                    campBtn.disabled = true;
                    campBtn.style.opacity = '0.5';
                    campBtn.style.cursor = 'not-allowed';
                    campBtn.title = 'Only party leader can set up camp';
                }
            }
        }
        
        // Pause game
        function pauseGame() {
            if (currentScreen === 'title') return; // Can't pause on title screen
            
            isPaused = true;
            const pauseScreen = document.getElementById('pauseScreen');
            if (pauseScreen) pauseScreen.style.display = 'flex';
            
            // Show resync button only for clients in multiplayer
            const resyncBtn = document.getElementById('resyncBtn');
            if (resyncBtn) {
                resyncBtn.style.display = (multiplayerState.enabled && multiplayerState.role === 'client') ? 'block' : 'none';
            }
        }
        
        // Request resync from host (client only)
        function requestResync() {
            if (!multiplayerState.enabled || multiplayerState.role !== 'client') {
                showNotification('Resync only available for clients', 'error');
                return;
            }
            
            multiplayerState.awaitingResync = true;
            sendWebSocketMessage({ type: 'request_resync' });
            showNotification('Requesting resync from host...', 'info');
        }
        
        // Resume game
        function resumeGame() {
            isPaused = false;
            const pauseScreen = document.getElementById('pauseScreen');
            if (pauseScreen) pauseScreen.style.display = 'none';
        }
        
        // Save game from pause menu
        function saveGameFromPause() {
            try {
                let sharedSave = loadSharedSave();
                if (!sharedSave) {
                    // Create new save if none exists
                    sharedSave = createDefaultSharedSave();
                }
                
                // Update last played timestamp
                sharedSave.lastPlayed = Date.now();
                
                // Save to localStorage
                if (saveSharedSave(sharedSave)) {
                    alert('Game saved successfully!');
                    // Update button states to reflect save exists
                    updateTitleScreenButtons();
                } else {
                    alert('Failed to save game!');
                }
            } catch (e) {
                console.error('Save error:', e);
                alert('Error saving game: ' + e.message);
            }
        }
        
        // Download save file
        function downloadSaveFile() {
            try {
                const sharedSave = loadSharedSave();
                if (!sharedSave) {
                    alert('No save data to download!');
                    return;
                }
                
                // Update timestamp
                sharedSave.lastPlayed = Date.now();
                saveSharedSave(sharedSave);
                
                // Create filename with date/time
                const now = new Date();
                const dateStr = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
                const hours = now.getHours();
                const minutes = String(now.getMinutes()).padStart(2, '0');
                const ampm = hours >= 12 ? 'pm' : 'am';
                const hour12 = hours % 12 || 12;
                const timeStr = `${hour12}_${minutes}_${ampm}`;
                
                const level = sharedSave.arcadeState ? sharedSave.arcadeState.level : 1;
                const filename = `tunnels-save-level${level}-${dateStr}-${timeStr}.json`;
                
                // Download JSON
                const jsonString = JSON.stringify(sharedSave, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                alert(`Save file downloaded: ${filename}`);
            } catch (e) {
                console.error('Download error:', e);
                alert('Error downloading save file: ' + e.message);
            }
        }
        
        // Show settings from pause
        function showSettingsFromPause() {
            showSettings();
        }
        
        // Quit to menu
        function quitToMenu() {
            // Save game state before quitting
            const sharedSave = loadSharedSave();
            if (sharedSave) {
                // Update dungeon level if visible
                const dungeonLevelEl = document.getElementById('dungeonMenuLevel');
                if (dungeonLevelEl && sharedSave.dungeonState) {
                    sharedSave.dungeonState.currentLevel = parseInt(dungeonLevelEl.textContent) || 1;
                }
                sharedSave.lastPlayed = Date.now();
                saveSharedSave(sharedSave);
            }
            
            // Stop dungeon menu story background animation
            stopDungeonMenuAnimation();
            
            isPaused = false;
            currentScreen = 'title';
            
            const pauseScreen = document.getElementById('pauseScreen');
            const dungeonMenuScreen = document.getElementById('dungeonMenuScreen');
            const titleScreen = document.getElementById('titleScreen');
            const battleScreen = document.getElementById('battleScreen');
            
            if (pauseScreen) pauseScreen.style.display = 'none';
            if (dungeonMenuScreen) dungeonMenuScreen.style.display = 'none';
            if (battleScreen) battleScreen.style.display = 'none';
            if (titleScreen) titleScreen.style.display = 'block';
            
            // Reset music controls to title screen position (bottom left)
            document.getElementById('musicControls').classList.remove('dungeonMenuActive');
            document.getElementById('musicTicker').classList.remove('dungeonMenuActive');
            
            // Reload hero stats from save
            const savedData = loadSharedSave();
            const heroStatsEl = document.getElementById('heroStats');
            
            if (savedData && savedData.heroes) {
                // Show hero party
                if (heroStatsEl) heroStatsEl.style.display = 'block';
                
                // Update each hero's display
                updateHeroDisplay('zooko', savedData.heroes.zooko);
                updateHeroDisplay('nate', savedData.heroes.nate);
                updateHeroDisplay('zancas', savedData.heroes.zancas);
                updateHeroDisplay('cyberaxe', savedData.heroes.cyberaxe);
            } else {
                // Hide hero party when no save exists
                if (heroStatsEl) heroStatsEl.style.display = 'none';
            }
            
            // Update CONTINUE button state based on save existence
            updateTitleScreenButtons();
        }
        
        // ESC key listener
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                e.preventDefault();
                
                // Close all panels first
                const overlay = document.getElementById('overlay');
                const settingsPanel = document.getElementById('settingsPanel');
                const loadSavePanel = document.getElementById('loadSavePanel');
                
                if (overlay && overlay.style.display === 'block') {
                    closeAllPanels();
                    return;
                }
                
                // Toggle pause
                if (isPaused) {
                    resumeGame();
                } else {
                    pauseGame();
                }
            }
        });
        
        // ===== GAMEPAD FUNCTIONS =====
        function onGamepadConnected(e) {
            gamepadConnected = true;
            gamepadIndex = e.gamepad.index;
            console.log(`ðŸŽ® Controller Connected: ${e.gamepad.id}`);
        }
        
        function onGamepadDisconnected(e) {
            if (e.gamepad.index === gamepadIndex) {
                gamepadConnected = false;
                gamepadIndex = null;
                gamepadButtonStates = {};
                console.log('ðŸŽ® Controller Disconnected');
            }
        }
        
        function updateGamepad() {
            if (!gamepadConnected || gamepadIndex === null) return;
            
            // Don't process gamepad input while loading modal is visible
            const loadingModal = document.getElementById('loadingModal');
            if (loadingModal && loadingModal.style.display !== 'none') return;
            
            const now = Date.now();
            if (now - lastGamepadUpdate < gamepadUpdateInterval) return;
            lastGamepadUpdate = now;
            
            const gamepads = navigator.getGamepads();
            const gamepad = gamepads[gamepadIndex];
            
            if (!gamepad) return;
            
            // Process buttons
            gamepad.buttons.forEach((button, index) => {
                const wasPressed = gamepadButtonStates[index] || false;
                const isPressed = button.pressed;
                
                // Button just pressed (rising edge)
                if (isPressed && !wasPressed) {
                    handleGamepadButtonPress(index);
                }
                
                gamepadButtonStates[index] = isPressed;
            });
        }
        
        function handleGamepadButtonPress(buttonIndex) {
            // ===== SETTINGS PANEL NAVIGATION =====
            const settingsPanel = document.getElementById('settingsPanel');
            if (settingsPanel && settingsPanel.style.display === 'block') {
                // B button - Close
                if (buttonIndex === GamepadButtons.B) {
                    closeAllPanels();
                    return;
                }
                return; // Block all other inputs when settings is open
            }
            // ===== END SETTINGS PANEL NAVIGATION =====
            
            // ===== LOAD SAVE PANEL NAVIGATION =====
            const loadSavePanel = document.getElementById('loadSavePanel');
            if (loadSavePanel && loadSavePanel.style.display === 'block') {
                // B button - Close
                if (buttonIndex === GamepadButtons.B) {
                    closeAllPanels();
                    return;
                }
                return; // Block all other inputs when load save panel is open
            }
            // ===== END LOAD SAVE PANEL NAVIGATION =====
            
            // ===== TITLE SCREEN NAVIGATION =====
            if (currentScreen === 'title') {
                // A button - Start Adventure
                if (buttonIndex === GamepadButtons.A) {
                    startAdventure();
                    return;
                }
                // Y button - Settings
                else if (buttonIndex === GamepadButtons.Y) {
                    showSettings();
                    return;
                }
                // B button - Load Save File
                else if (buttonIndex === GamepadButtons.B) {
                    showLoadSave();
                    return;
                }
                // BACK button (SELECT) - Exit Portal
                else if (buttonIndex === GamepadButtons.SELECT) {
                    exitPortal();
                    return;
                }
            }
            // ===== END TITLE SCREEN NAVIGATION =====
            
            // ===== PAUSE MENU NAVIGATION =====
            if (isPaused) {
                // A button - Resume
                if (buttonIndex === GamepadButtons.A) {
                    resumeGame();
                    return;
                }
                // B button - Resume (also works)
                else if (buttonIndex === GamepadButtons.B) {
                    resumeGame();
                    return;
                }
                // Y button - Settings
                else if (buttonIndex === GamepadButtons.Y) {
                    showSettingsFromPause();
                    return;
                }
                // SELECT button - Quit to Menu
                else if (buttonIndex === GamepadButtons.SELECT) {
                    quitToMenu();
                    return;
                }
            }
            // ===== END PAUSE MENU NAVIGATION =====
            
            // START button - Pause/Resume
            if (buttonIndex === GamepadButtons.START) {
                if (currentScreen === 'title') return; // Can't pause on title screen
                
                if (isPaused) {
                    resumeGame();
                } else {
                    pauseGame();
                }
                return;
            }
        }
        
        // Poll gamepad in animation loop
        function gamepadLoop() {
            updateGamepad();
            requestAnimationFrame(gamepadLoop);
        }
        
        // Gamepad polling for Click to Enter
        function pollGamepadForClickToPlay() {
            const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
            for (let i = 0; i < gamepads.length; i++) {
                const gp = gamepads[i];
                if (gp && gp.buttons[0] && gp.buttons[0].pressed) { // A button
                    const clickToPlayPrompt = document.getElementById('clickToPlayPrompt');
                    if (clickToPlayPrompt && clickToPlayPrompt.style.display !== 'none') {
                        clickToPlayPrompt.click();
                        return;
                    }
                }
            }
            
            // Continue polling if loading modal is visible
            const loadingModal = document.getElementById('loadingModal');
            if (loadingModal && loadingModal.style.display !== 'none') {
                requestAnimationFrame(pollGamepadForClickToPlay);
            }
        }
        // ===== END GAMEPAD FUNCTIONS =====
        
        // Initialize on page load
        // Preload images and audio into browser cache
        function preloadAssets() {
            const imageList = [
                // Story intro backgrounds (sprite sheets for dungeon menu animation)
                'story/intro/intro_a.png',
                'story/intro/intro_b.png',
                'story/intro/intro_c.png',
                'story/intro/intro_d.png',
                'story/intro/intro_e.png',
                'story/intro/intro_f.png',
                // Story level backgrounds
                'story/lvl1/story_lvl_1.png',
                'story/lvl1/story_lvl_1_loop.png',
                'story/lvl2/story_lvl_2.png',
                'story/lvl2/story_lvl_2_idle.png',
                'story/lvl3/story_lvl_3.png',
                'story/lvl3/story_lvl_3_idle.png',
                'story/lvl4/story_lvl_4.png',
                'story/lvl4/story_lvl_4_idle.png',
                'story/lvl5/story_lvl_5.png',
                'story/lvl5/story_lvl_5_idle.png',
                'story/lvl6/story_lvl_6.png',
                'story/lvl6/story_lvl_6_idle.png',
                'story/lvl7/story_lvl_7.png',
                'story/lvl7/story_lvl_7_idle.png',
                'story/lvl8/story_lvl_8.png',
                'story/lvl8/story_lvl_8_idle.png',
                'story/lvl9/story_lvl_9.png',
                'story/lvl9/story_lvl_9_idle.png',
                'story/lvl10/story_lvl_10.png',
                'story/lvl10/story_lvl_10_idle.png',
                // Story up (ascension) backgrounds
                'story/up_1/story_up_1.png',
                'story/up_1/story_up_1_idle.png',
                'story/up_2/story_up_2.png',
                'story/up_2/story_up_2_idle.png',
                'story/up_3/story_up_3.png',
                'story/up_3/story_up_3_idle.png',
                'story/up_4/story_up_4.png',
                'story/up_4/story_up_4_idle.png',
                'story/up_5/story_up_5.png',
                'story/up_5/story_up_5_idle.png',
                // Story end
                'story/end/end.png',
                // Character head icons
                'people/zooko_a_head_compressed.png',
                'people/Nate_a_head_compressed.png',
                'people/Zancas_a_head_compressed.png',
                'people/cyberaxe_a_head_compressed.png',
                // Hero sprite sheet animations
                'tunnelsofprivacy/heros/zooko_idle.png',
                'tunnelsofprivacy/heros/zooko_idle_a.png',
                'tunnelsofprivacy/heros/zooko_idle_b.png',
                'tunnelsofprivacy/heros/zooko_light_attack.png',
                'tunnelsofprivacy/heros/zooko_heavy_attack.png',
                'tunnelsofprivacy/heros/zooko_special_attack.png',
                'tunnelsofprivacy/heros/zooko_knockout.png',
                'tunnelsofprivacy/heros/zooko_hit.png',
                'tunnelsofprivacy/heros/zooko_def.png',
                'tunnelsofprivacy/heros/nate_idle.png',
                'tunnelsofprivacy/heros/nate_idle_a.png',
                'tunnelsofprivacy/heros/nate_idle_b.png',
                'tunnelsofprivacy/heros/nate_idle_c.png',
                'tunnelsofprivacy/heros/nate_light_attack.png',
                'tunnelsofprivacy/heros/nate_heavy_attack.png',
                'tunnelsofprivacy/heros/nate_special_attack.png',
                'tunnelsofprivacy/heros/nate_special_attack_a.png',
                'tunnelsofprivacy/heros/nate_knockout.png',
                'tunnelsofprivacy/heros/nate_hit.png',
                'tunnelsofprivacy/heros/nate_def.png',
                'tunnelsofprivacy/heros/nate_heal.png',
                'tunnelsofprivacy/heros/nate_taunt.png',
                'tunnelsofprivacy/heros/nate_myturn.png',
                'tunnelsofprivacy/heros/zancas_idle.png',
                'tunnelsofprivacy/heros/zancas_idle_a.png',
                'tunnelsofprivacy/heros/zancas_idle_b.png',
                'tunnelsofprivacy/heros/zancas_light_attack.png',
                'tunnelsofprivacy/heros/zancas_heavy_attack.png',
                'tunnelsofprivacy/heros/zancas_special_attack.png',
                'tunnelsofprivacy/heros/zancas_knockout.png',
                'tunnelsofprivacy/heros/zancas_hit.png',
                'tunnelsofprivacy/heros/zancas_def.png',
                'tunnelsofprivacy/heros/zancas_heal.png',
                'tunnelsofprivacy/heros/cyberaxe_idle.png',
                'tunnelsofprivacy/heros/cyberaxe_idle_a.png',
                'tunnelsofprivacy/heros/cyberaxe_idle_b.png',
                'tunnelsofprivacy/heros/cyberaxe_light_attack.png',
                'tunnelsofprivacy/heros/cyberaxe_heavy_attack.png',
                'tunnelsofprivacy/heros/cyberaxe_special_attack.png',
                'tunnelsofprivacy/heros/cyberaxe_knockout.png',
                'tunnelsofprivacy/heros/cyberaxe_hit.png',
                'tunnelsofprivacy/heros/cyberaxe_def.png',
                // Battle backgrounds (lvl 1-10)
                'tunnelsofprivacy/backgrounds/lvl1-10/backgrounds_lvl1 (8).png',
                'tunnelsofprivacy/backgrounds/lvl1-10/backgrounds_lvl1 (10).png',
                'tunnelsofprivacy/backgrounds/lvl1-10/backgrounds_lvl1 (12).png',
                'tunnelsofprivacy/backgrounds/lvl1-10/backgrounds_lvl1 (14).png',
                'tunnelsofprivacy/backgrounds/lvl1-10/backgrounds_lvl1 (15).png',
                'tunnelsofprivacy/backgrounds/lvl1-10/backgrounds_lvl1 (16).png',
                // Boss sprites (first 10 levels for initial preload)
                'tunnelsofprivacy/bosses/lvl1/boss_lvl1.png',
                'tunnelsofprivacy/bosses/lvl2/boss_lvl2.png',
                'tunnelsofprivacy/bosses/lvl3/boss_lvl3.png',
                'tunnelsofprivacy/bosses/lvl4/boss_lvl4.png',
                'tunnelsofprivacy/bosses/lvl5/boss_lvl5.png',
                'tunnelsofprivacy/bosses/lvl6/boss_lvl6.png',
                'tunnelsofprivacy/bosses/lvl7/boss_lvl7.png',
                'tunnelsofprivacy/bosses/lvl8/boss_lvl8.png',
                'tunnelsofprivacy/bosses/lvl9/boss_lvl9.png',
                'tunnelsofprivacy/bosses/lvl10/boss_lvl10.png',
                // Captive/prisoner sprites
                'tunnelsofprivacy/npcs/captives/prisoners (1).png',
                'tunnelsofprivacy/npcs/captives/prisoners (2).png',
                'tunnelsofprivacy/npcs/captives/prisoners (3).png',
                'tunnelsofprivacy/npcs/captives/prisoners (4).png',
                'tunnelsofprivacy/npcs/captives/prisoners (5).png',
                'tunnelsofprivacy/npcs/captives/prisoners (6).png',
                'tunnelsofprivacy/npcs/captives/prisoners (7).png',
                'tunnelsofprivacy/npcs/captives/prisoners (8).png',
                'tunnelsofprivacy/npcs/captives/prisoners (9).png',
                'tunnelsofprivacy/npcs/captives/prisoners (10).png',
                'tunnelsofprivacy/npcs/captives/prisoners (11).png',
                'tunnelsofprivacy/npcs/captives/prisoners (12).png',
                // Item sprites
                'tunnelsofprivacy/items/healing_potions_a_cropped.png',
                'tunnelsofprivacy/items/healing_potions_a_empty.png',
                // Gear/backpack sprites
                'tunnelsofprivacy/gear/zooko_backpack.png',
                'tunnelsofprivacy/gear/nate_backpack.png',
                'tunnelsofprivacy/gear/zancas_backpack.png',
                'tunnelsofprivacy/gear/cyberaxe_backpack.png',
                // Common mob sprites (basic enemies)
                'tunnelsofprivacy/mobs/beetle1.png',
                'tunnelsofprivacy/mobs/beetle2.png',
                'tunnelsofprivacy/mobs/blob1.png',
                'tunnelsofprivacy/mobs/blob2.png',
                'tunnelsofprivacy/mobs/rat1.png',
                'tunnelsofprivacy/mobs/spider1.png',
                'tunnelsofprivacy/mobs/worm1.png',
                'tunnelsofprivacy/mobs/mite1.png',
                'tunnelsofprivacy/mobs/moth1.png',
                'tunnelsofprivacy/mobs/moth2.png',
                'tunnelsofprivacy/mobs/orb1.png',
                'tunnelsofprivacy/mobs/gnawer1.png',
                'tunnelsofprivacy/mobs/goblin1.png',
                'tunnelsofprivacy/mobs/insect1.png',
                'tunnelsofprivacy/mobs/creature1.png',
                'tunnelsofprivacy/mobs/creature2.png',
                'tunnelsofprivacy/mobs/creature3.png',
                'tunnelsofprivacy/mobs/creature4.png',
                'tunnelsofprivacy/mobs/creature5.png',
                'tunnelsofprivacy/mobs/creature6.png'
            ];
            
            artTotal = imageList.length;
            assetsToLoad += imageList.length;
            
            // Preload images (also populates spriteSheetCache for animation system)
            imageList.forEach(imagePath => {
                const img = new Image();
                img.src = imagePath;
                img.addEventListener('load', () => {
                    // Cache sprite sheets for animation system
                    if (imagePath.includes('tunnelsofprivacy/heros/')) {
                        spriteSheetCache[imagePath] = img;
                    }
                    artLoaded++;
                    assetsLoaded++;
                    updateLoadingProgress();
                }, { once: true });
                img.addEventListener('error', (e) => {
                    console.error(`Failed to preload: ${imagePath}`, e);
                    artLoaded++;
                    assetsLoaded++;
                    updateLoadingProgress();
                }, { once: true });
            });
            
            // Preload music if enabled
            if (musicEnabled && musicVolume > 0) {
                audioTotal = 1;
                assetsToLoad += 1;
                
                const musicPlayer = document.getElementById('musicPlayer');
                if (musicPlayer) {
                    musicPlayer.volume = Math.min(1.0, musicVolume / 100);
                    musicPlayer.preload = 'metadata'; // Changed from 'auto' to avoid hanging
                    
                    // Set a timeout in case music doesn't load
                    const musicTimeout = setTimeout(() => {
                        audioLoaded++;
                        assetsLoaded++;
                        updateLoadingProgress();
                    }, 3000); // 3 second timeout
                    
                    musicPlayer.addEventListener('loadedmetadata', () => {
                        clearTimeout(musicTimeout);
                        audioLoaded++;
                        assetsLoaded++;
                        updateLoadingProgress();
                    }, { once: true });
                    
                    musicPlayer.addEventListener('error', (e) => {
                        console.error('Failed to preload music', e);
                        clearTimeout(musicTimeout);
                        audioLoaded++;
                        assetsLoaded++;
                        updateLoadingProgress();
                    }, { once: true });
                    
                    musicPlayer.load();
                } else {
                    // Music player doesn't exist, skip it
                    audioLoaded++;
                    assetsLoaded++;
                    updateLoadingProgress();
                }
            }
            
            updateLoadingProgress();
        }
        
        // Update loading progress indicator
        function updateLoadingProgress() {
            const loadingIndicator = document.getElementById('loadingIndicator');
            const loadingBar = document.getElementById('loadingBar');
            const loadingArt = document.getElementById('loadingArt');
            const loadingSound = document.getElementById('loadingSound');
            
            if (loadingIndicator && assetsToLoad > 0) {
                const percent = Math.floor((assetsLoaded / assetsToLoad) * 100);
                loadingIndicator.textContent = `${percent}%`;
                
                if (loadingBar) {
                    loadingBar.style.width = `${percent}%`;
                    loadingBar.textContent = `${percent}%`;
                }
                
                // Update category counts
                if (loadingArt) {
                    loadingArt.innerHTML = `ðŸŽ¨ Art: <span style="color: #8B45FF; font-weight: bold;">${artLoaded}/${artTotal}</span>`;
                }
                if (loadingSound) {
                    loadingSound.innerHTML = `ðŸ”Š Sound: <span style="color: #8B45FF; font-weight: bold;">${audioLoaded}/${audioTotal}</span>`;
                }
            }
            
            checkAllAssetsReady();
        }
        
        function checkAllAssetsReady() {
            if (assetsToLoad > 0 && assetsLoaded >= assetsToLoad && !allAssetsReady) {
                allAssetsReady = true;
                
                const loadingIndicator = document.getElementById('loadingIndicator');
                const loadingBar = document.getElementById('loadingBar');
                const loadingModal = document.getElementById('loadingModal');
                const loadingNote = document.getElementById('loadingNote');
                const clickToPlayPrompt = document.getElementById('clickToPlayPrompt');
                
                if (loadingIndicator) {
                    loadingIndicator.textContent = 'âœ“ All Assets Ready!';
                    loadingIndicator.style.color = '#2ECC71';
                }
                
                if (loadingBar) {
                    loadingBar.style.width = '100%';
                    loadingBar.textContent = '100%';
                    loadingBar.style.background = 'linear-gradient(90deg, #2ECC71, #27AE60)';
                }
                
                if (loadingNote) {
                    loadingNote.style.display = 'none';
                }
                
                if (clickToPlayPrompt) {
                    clickToPlayPrompt.style.display = 'block';
                    
                    // Start gamepad polling for A button
                    pollGamepadForClickToPlay();
                    
                    const handleClick = () => {
                        // Start music when user clicks - always start with main theme
                        if (musicEnabled && musicVolume > 0 && !musicStarted) {
                            loadMusic(themeTracks[0]); // Always start with main theme (index 0)
                        }
                        
                        // Fade out and remove loading modal
                        if (loadingModal) {
                            loadingModal.style.opacity = '0';
                            loadingModal.style.transition = 'opacity 0.5s ease';
                            setTimeout(() => {
                                loadingModal.style.display = 'none';
                            }, 500);
                        }
                        
                        // Remove click handler
                        clickToPlayPrompt.removeEventListener('click', handleClick);
                        document.removeEventListener('keydown', handleKeyDown);
                    };
                    
                    const handleKeyDown = (e) => {
                        if (e.key === 'a' || e.key === 'A' || e.key === 'Enter') {
                            handleClick();
                        }
                    };
                    
                    clickToPlayPrompt.addEventListener('click', handleClick);
                    document.addEventListener('keydown', handleKeyDown);
                }
            }
        }
        
        // ===== MULTIPLAYER WEBSOCKET FUNCTIONS =====
        
        function connectWebSocket() {
            if (multiplayerState.ws && multiplayerState.ws.readyState === WebSocket.OPEN) {
                return; // Already connected
            }
            
            const wsUrl = `ws://${window.location.hostname}:8765`;
            console.log('[MP] Connecting to WebSocket:', wsUrl);
            
            multiplayerState.ws = new WebSocket(wsUrl);
            
            multiplayerState.ws.onopen = () => {
                console.log('[MP] WebSocket connected');
                multiplayerState.enabled = true;
            };
            
            multiplayerState.ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                handleWebSocketMessage(data);
            };
            
            multiplayerState.ws.onerror = (error) => {
                console.error('[MP] WebSocket error:', error);
                showNotification('Multiplayer connection error', 'error');
            };
            
            multiplayerState.ws.onclose = () => {
                console.log('[MP] WebSocket closed');
                if (multiplayerState.enabled && !multiplayerState.isReconnecting) {
                    showNotification('Disconnected from multiplayer', 'warning');
                    resetMultiplayerState();
                }
            };
        }
        
        function handleWebSocketMessage(data) {
            console.log('[MP] Received:', data);
            
            switch(data.type) {
                case 'room_created':
                    multiplayerState.roomCode = data.code;
                    multiplayerState.role = 'host';
                    multiplayerState.myPlayerId = data.player_id;
                    // Get player name from data (set by user on title screen)
                    if (data.players && data.players[0]) {
                        multiplayerState.playerName = data.players[0].name;
                    }
                    // Store initial player list
                    if (data.players) {
                        multiplayerState.connectedPlayers = data.players;
                    }
                    showNotification(`Room created: ${data.code}`, 'success');
                    // Host enters hero selection immediately
                    showHeroSelection();
                    break;
                
                case 'joined':
                    multiplayerState.roomCode = data.code;
                    multiplayerState.role = 'client';
                    multiplayerState.myPlayerId = data.player_id;
                    // Store player list
                    if (data.players) {
                        multiplayerState.connectedPlayers = data.players;
                        // Find my name from the list
                        const me = data.players.find(p => p.id === data.player_id);
                        if (me) {
                            multiplayerState.playerName = me.name;
                        }
                    }
                    
                    // Check if this is a reconnection
                    if (data.reconnected) {
                        multiplayerState.isReconnecting = true;
                        showNotification(`Reconnected to room: ${data.code}`, 'success');
                    } else {
                        multiplayerState.isReconnecting = false;
                        showNotification(`Joined room: ${data.code}`, 'success');
                    }
                    
                    // Show hero selection
                    showHeroSelection();
                    
                    // Sync current hero selections from host (if any heroes already selected)
                    if (data.heroes && Object.keys(data.heroes).length > 0) {
                        updateHeroSelection({ heroes: data.heroes, players: data.players });
                    }
                    break;
                
                case 'error':
                    showNotification(data.message, 'error');
                    break;
                
                case 'name_taken':
                    // Name is already in use - prompt to change
                    showNotification(data.message, 'error');
                    // Generate a new random name and show it to user
                    const newRandomName = generateRandomPlayerName();
                    multiplayerState.playerName = newRandomName;
                    const nameInput = document.getElementById('multiplayerPlayerName');
                    if (nameInput) {
                        nameInput.value = newRandomName;
                        nameInput.focus();
                        nameInput.select();
                    }
                    // Close WebSocket since we were rejected
                    if (multiplayerState.ws) {
                        multiplayerState.ws.close();
                        multiplayerState.ws = null;
                    }
                    break;
                
                case 'players_update':
                    // Update connected players list
                    if (data.players) {
                        multiplayerState.connectedPlayers = data.players;
                    }
                    // Update hero selections if provided
                    if (data.heroes) {
                        updateHeroSelection({ heroes: data.heroes });
                    } else {
                        // Just update the player list display
                        updateConnectedPlayersListOnly();
                    }
                    break;
                
                case 'player_joined':
                    showNotification(`Player joined (${data.player_count} total)`, 'info');
                    break;
                
                case 'hero_selected':
                    // Update player list if provided
                    if (data.players) {
                        multiplayerState.connectedPlayers = data.players;
                    }
                    // Store heroes data for roll phase tracking
                    if (data.heroes) {
                        multiplayerState.playerHeroes = data.heroes;
                    }
                    // Update hero selections
                    updateHeroSelection(data);
                    break;
                
                case 'hero_stats_rolled':
                    // Another player rolled stats for their hero - update display
                    if (data.hero && data.stats) {
                        const heroKey = data.hero;
                        const stats = data.stats;
                        
                        // Update the hero card display
                        const fields = ['str', 'dex', 'con', 'int', 'wis', 'cha', 'hp', 'ac'];
                        fields.forEach(field => {
                            const el = document.getElementById(`sel-${heroKey}-${field}`);
                            if (el && stats[field] !== undefined) el.textContent = stats[field];
                        });
                        const maxHpEl = document.getElementById(`sel-${heroKey}-maxhp`);
                        if (maxHpEl && stats.maxHp !== undefined) maxHpEl.textContent = stats.maxHp;
                        
                        // Store in multiplayerState so host can use it
                        if (!multiplayerState.rolledHeroStats) {
                            multiplayerState.rolledHeroStats = {};
                        }
                        multiplayerState.rolledHeroStats[heroKey] = stats;
                        
                        // Update roll phase status (to check if all have rolled)
                        updateRollPhaseStatus();
                        
                        const heroName = heroKey.charAt(0).toUpperCase() + heroKey.slice(1);
                        showNotification(`${heroName}'s stats rolled by player`, 'info');
                    }
                    break;
                
                case 'player_action':
                    // Host receives client action
                    if (multiplayerState.role === 'host') {
                        processClientAction(data);
                    }
                    break;
                
                case 'request_resync':
                    // Client is requesting a full state resync
                    if (multiplayerState.role === 'host') {
                        console.log('[HOST] Client requested resync');
                        if (battleState.active) {
                            // Send full battle state
                            broadcastGameState();
                            showNotification('Resync sent to clients', 'info');
                        }
                    }
                    break;
                
                case 'state_update':
                    // Client receives state from host
                    if (multiplayerState.role === 'client') {
                        updateGameStateFromHost(data.state);
                    }
                    break;
                
                case 'battle_init':
                    // Client receives battle initialization from host
                    if (multiplayerState.role === 'client') {
                        initializeBattleFromHost(data.battleData);
                    }
                    break;
                
                case 'battle_end':
                    // Host notifies battle has ended
                    if (multiplayerState.role === 'client') {
                        const reason = data.reason;
                        if (reason === 'retreat') {
                            showBattleNotification('DEFEAT! ALL HEROES RETREATED!');
                        } else if (reason === 'defeat') {
                            showBattleNotification('DEFEAT! ALL HEROES FALLEN!');
                        }
                        
                        setTimeout(() => {
                            // Hide notification
                            const notification = document.getElementById('battleNotification');
                            if (notification) notification.style.display = 'none';
                            
                            // Client: Switch UI and display from cached stats
                            battleState.active = false;
                            currentScreen = 'dungeonMenu';
                            stopBattleVideo(); // Stop and hide video background
                            document.getElementById('battleScreen').style.display = 'none';
                            document.getElementById('dungeonMenuScreen').style.display = 'block';
                            
                            // Move music controls and ticker back to center bottom
                            document.getElementById('musicControls').classList.remove('battleActive');
                            document.getElementById('musicControls').classList.add('dungeonMenuActive');
                            document.getElementById('musicTicker').classList.remove('battleActive');
                            document.getElementById('musicTicker').classList.add('dungeonMenuActive');
                            
                            // Update dungeon menu from cached stats (already updated from state_update broadcasts)
                            updateDungeonMenuHeroes();
                            updateGoldDisplay();
                        }, 2000);
                    }
                    break;
                
                case 'non_combat_room':
                    // Host notifies about non-combat room (store, NPC, secret, exploration)
                    if (multiplayerState.role === 'client') {
                        if (data.action === 'enter') {
                            // Client enters non-combat room with host's data
                            clientEnterNonCombatRoom(data.roomType, data.data);
                        } else if (data.action === 'leave') {
                            // Host left - client follows immediately
                            console.log('[MP] Host left non-combat room, following...');
                            executeLeaveNonCombatRoom();
                            showNotification('Party left the room', 'info');
                        }
                    }
                    break;
                
                case 'level_change':
                    // Host notifies level change from stairs/fast travel
                    if (multiplayerState.role === 'client') {
                        const newLevel = data.newLevel;
                        console.log('[MP] Received level change from host:', newLevel);
                        
                        // Update UI
                        const dungeonLevelEl = document.getElementById('dungeonMenuLevel');
                        if (dungeonLevelEl) {
                            dungeonLevelEl.textContent = newLevel;
                        }
                        
                        // Update story background for new level
                        updateDungeonMenuBackground();
                        
                        // Reset encounter state for new level (client doesn't generate, waits for host)
                        preGeneratedEncounter = {
                            ready: false,
                            generating: false,
                            boss: null,
                            mobs: [],
                            captive: null,
                            background: null,
                            roomLevel: newLevel
                        };
                        updateExploreLoadingBar(0);
                        
                        showNotification(`Party moved to level ${newLevel}`, 'info');
                    }
                    break;
                
                case 'level_progress_update':
                    // Host broadcasts level progress changes to clients
                    if (multiplayerState.role === 'client') {
                        console.log('[MP] Received level progress update from host');
                        updateLevelProgressFromHost(data.progress);
                    }
                    break;
                
                case 'difficulty_change':
                    // Host notifies difficulty change
                    if (multiplayerState.role === 'client') {
                        const newDifficulty = data.difficulty;
                        console.log('[MP] Received difficulty change from host:', newDifficulty);
                        
                        // Update local setting (don't save - client doesn't persist host settings)
                        settings.difficulty = newDifficulty;
                        
                        // Update button visuals
                        updateDifficultyButtons();
                        
                        // Reset encounter state (client waits for host to regenerate)
                        preGeneratedEncounter = {
                            ready: false,
                            generating: false,
                            boss: null,
                            mobs: [],
                            captive: null,
                            background: null,
                            roomLevel: preGeneratedEncounter.roomLevel || 1
                        };
                        updateExploreLoadingBar(0);
                        
                        const difficultyNames = { 'casual': 'Casual', 'normal': 'Normal', 'expert': 'Expert' };
                        showNotification(`Difficulty changed to ${difficultyNames[newDifficulty]}`, 'info');
                    }
                    break;
                
                case 'kicked':
                    showNotification(data.message, 'error');
                    resetMultiplayerState();
                    break;
                
                case 'camp_started':
                    // Host started camping - show camping screen on client
                    if (multiplayerState.role === 'client') {
                        console.log('[MP] Received camp_started from host');
                        
                        campState.active = true;
                        campState.selectedHours = data.hours;
                        campState.hoursRemaining = data.hours;
                        
                        // Hide dungeon menu, show camping screen
                        document.getElementById('dungeonMenuScreen').style.display = 'none';
                        const campingScreen = document.getElementById('campingScreen');
                        if (campingScreen) {
                            campingScreen.style.display = 'block';
                        }
                        
                        // Load and play camp video (same as host)
                        const videoEl = document.getElementById('campVideo');
                        if (videoEl && data.videoSrc) {
                            videoEl.querySelector('source').src = data.videoSrc;
                            videoEl.load();
                            videoEl.play().catch(e => console.log('[Camp] Video autoplay blocked:', e));
                        }
                        
                        // Update UI
                        document.getElementById('campTimeRemaining').textContent = data.hours;
                        document.getElementById('campProgressBar').style.width = '0%';
                        document.getElementById('campHealedSoFar').textContent = '0';
                        document.getElementById('campEventLog').innerHTML = '<div style="color: #89A0B4; font-size: 12px; text-align: center;">The campfire crackles softly...</div>';
                        
                        showNotification(`Party leader is setting up camp for ${data.hours} hours`, 'info');
                    }
                    break;
                
                case 'camp_completed':
                    // Host finished camping
                    if (multiplayerState.role === 'client') {
                        console.log('[MP] Received camp_completed from host');
                        
                        campState.active = false;
                        
                        // Stop video
                        const campVideoEl = document.getElementById('campVideo');
                        if (campVideoEl) {
                            campVideoEl.pause();
                        }
                        
                        // Update hero HP from host data
                        if (data.heroes) {
                            data.heroes.forEach(heroData => {
                                const hero = battleState.heroes.find(h => h.name === heroData.name);
                                if (hero) {
                                    hero.hp = heroData.hp;
                                    hero.maxHp = heroData.maxHp;
                                }
                            });
                        }
                        
                        // Return to dungeon menu
                        document.getElementById('campingScreen').style.display = 'none';
                        document.getElementById('dungeonMenuScreen').style.display = 'block';
                        updateDungeonMenuHeroes();
                        
                        showNotification(`Party rested for ${data.hoursRested} hours! +${data.healedAmount} HP healed.`, 'success');
                    }
                    break;
                
                case 'camp_progress':
                    // Host sends progress updates during camping
                    if (multiplayerState.role === 'client' && campState.active) {
                        document.getElementById('campProgressBar').style.width = `${data.progress}%`;
                        document.getElementById('campTimeRemaining').textContent = data.hoursRemaining;
                        document.getElementById('campHealedSoFar').textContent = data.healedSoFar;
                    }
                    break;
                
                case 'camp_event':
                    // Host sends camp event text
                    if (multiplayerState.role === 'client' && campState.active) {
                        addCampEvent(data.text);
                    }
                    break;
                
                case 'host_disconnected':
                    showNotification(data.message, 'error');
                    resetMultiplayerState();
                    currentScreen = 'title';
                    stopBattleVideo(); // Stop and hide video background
                    document.getElementById('battleScreen').style.display = 'none';
                    document.getElementById('dungeonMenuScreen').style.display = 'none';
                    document.getElementById('titleScreen').style.display = 'block';
                    break;
                
                case 'player_disconnected':
                    if (multiplayerState.role === 'host') {
                        handlePlayerDisconnect(data.player_id);
                    }
                    
                    // Update hero selection UI if heroes were released
                    if (data.heroes) {
                        updateHeroSelection({ heroes: data.heroes, players: data.players });
                        
                        // Show notification about released heroes
                        if (data.released_heroes && data.released_heroes.length > 0) {
                            const heroNames = data.released_heroes.map(h => h.charAt(0).toUpperCase() + h.slice(1)).join(', ');
                            showNotification(`Player disconnected - ${heroNames} now available`, 'info');
                        }
                    }
                    break;
                
                case 'request_sync':
                    // Client requesting full sync after reconnection
                    if (multiplayerState.role === 'host') {
                        // Transfer heroes back from host to reconnecting player
                        if (data.heroes && Array.isArray(data.heroes)) {
                            data.heroes.forEach(heroName => {
                                const heroKey = heroName.toLowerCase();
                                // Remove from host's control
                                const hostIndex = multiplayerState.myHeroes.indexOf(heroKey);
                                if (hostIndex > -1) {
                                    multiplayerState.myHeroes.splice(hostIndex, 1);
                                    showNotification(`${heroName} returned to player control`, 'info');
                                }
                            });
                        }
                        
                        const sharedSave = loadSharedSave();
                        
                        if (sharedSave) {
                            // Send current save state to rejoining client
                            sendWebSocketMessage({ 
                                type: 'sync_state', 
                                screen: currentScreen,
                                saveData: sharedSave
                            });
                            
                            // If in battle, also send battle_init
                            if (currentScreen === 'battle' && battleState.active) {
                                setTimeout(() => {
                                    sendBattleInitToClients();
                                }, 100);
                            }
                        }
                    }
                    break;
                
                case 'sync_state':
                    // Client receiving sync after reconnection
                    if (multiplayerState.role === 'client') {
                        // Save host's save data
                        if (data.saveData) {
                            saveSharedSave(data.saveData);
                            
                            // Populate heroStatsCache
                            if (data.saveData.heroes) {
                                ['zooko', 'nate', 'zancas', 'cyberaxe'].forEach(heroKey => {
                                    const heroData = data.saveData.heroes[heroKey];
                                    if (heroData) {
                                        multiplayerState.heroStatsCache[heroKey] = {
                                            hp: heroData.hp,
                                            maxHp: heroData.maxHp,
                                            xp: heroData.xp,
                                            level: heroData.level,
                                            str: heroData.str,
                                            dex: heroData.dex,
                                            con: heroData.con,
                                            int: heroData.int,
                                            wis: heroData.wis,
                                            cha: heroData.cha
                                        };
                                    }
                                });
                            }
                        }
                        
                        // Hide modals and title screen
                        document.getElementById('titleScreen').style.display = 'none';
                        document.getElementById('heroSelectionModal').style.display = 'none';
                        document.getElementById('musicControls').classList.remove('heroSelectionActive');
                        
                        // Go to the screen where host is
                        if (data.screen === 'dungeonMenu') {
                            stopBattleVideo(); // Stop and hide video background
                            document.getElementById('battleScreen').style.display = 'none';
                            document.getElementById('musicTicker').classList.remove('battleActive');
                            document.getElementById('musicControls').classList.add('dungeonMenuActive');
                            document.getElementById('musicTicker').classList.add('dungeonMenuActive');
                            document.getElementById('dungeonMenuScreen').style.display = 'block';
                            currentScreen = 'dungeonMenu';
                            updateDungeonMenuHeroes();
                            applyClientUIRestrictions();
                            showNotification('Rejoined game!', 'success');
                        } else if (data.screen === 'battle') {
                            document.getElementById('dungeonMenuScreen').style.display = 'none';
                            document.getElementById('musicTicker').classList.remove('dungeonMenuActive');
                            document.getElementById('musicControls').classList.remove('dungeonMenuActive');
                            document.getElementById('battleScreen').style.display = 'block';
                            document.getElementById('musicTicker').classList.add('battleActive');
                            document.getElementById('musicControls').classList.add('battleActive');
                            currentScreen = 'battle';
                            showNotification('Rejoined battle - waiting for sync...', 'info');
                        }
                    }
                    break;
                
                case 'code_changed':
                    multiplayerState.roomCode = data.code;
                    showNotification(`Room code changed to: ${data.code}`, 'info');
                    // Update hero selection display if visible
                    const heroCodeDisplay = document.getElementById('heroSelectionCode');
                    if (heroCodeDisplay && heroCodeDisplay.textContent !== '******') {
                        heroCodeDisplay.textContent = data.code;
                    }
                    break;
                
                case 'skip_turn':
                    // Advance turn (force skip)
                    advanceTurn();
                    break;
                
                case 'roll_phase_start':
                    // Host started roll phase - clients show roll buttons
                    if (multiplayerState.role === 'client') {
                        inRollPhase = true;
                        // This is a new game, not reconnecting
                        multiplayerState.isReconnecting = false;
                        // CRITICAL: Force heroSelectionHasSave to false for clients
                        // Client's local save is irrelevant - host is starting a NEW game
                        heroSelectionHasSave = false;
                        showAllRollButtons();
                        // Show phase 2 UI
                        document.getElementById('gameStartPhase1').style.display = 'none';
                        document.getElementById('gameStartPhase2').style.display = 'block';
                        // Hide reconnect options since this is a new game
                        const reconnectOpts = document.getElementById('reconnectOptions');
                        if (reconnectOpts) reconnectOpts.style.display = 'none';
                        updateRollPhaseStatus();
                        showNotification('Roll phase started! Roll stats for your hero.', 'info');
                    }
                    break;
                
                case 'roll_phase_cancel':
                    // Host cancelled roll phase - clients hide roll buttons
                    if (multiplayerState.role === 'client') {
                        inRollPhase = false;
                        hideAllRollButtons();
                        // Show phase 1 UI
                        document.getElementById('gameStartPhase1').style.display = 'block';
                        document.getElementById('gameStartPhase2').style.display = 'none';
                        showNotification('Roll phase cancelled by host.', 'info');
                    }
                    break;
                
                case 'game_start':
                    // Host started the game - clients follow
                    if (multiplayerState.role === 'client') {
                        // Save host's save data to local storage
                        if (data.saveData) {
                            saveSharedSave(data.saveData);
                            
                            // Populate heroStatsCache from saveData for client display
                            if (data.saveData.heroes) {
                                ['zooko', 'nate', 'zancas', 'cyberaxe'].forEach(heroKey => {
                                    const heroData = data.saveData.heroes[heroKey];
                                    if (heroData) {
                                        multiplayerState.heroStatsCache[heroKey] = {
                                            hp: heroData.hp,
                                            maxHp: heroData.maxHp,
                                            xp: heroData.xp,
                                            level: heroData.level,
                                            str: heroData.str,
                                            dex: heroData.dex,
                                            con: heroData.con,
                                            int: heroData.int,
                                            wis: heroData.wis,
                                            cha: heroData.cha
                                        };
                                    }
                                });
                            }
                            
                            // Cache gold from saveData for client display
                            if (data.saveData.dungeonState) {
                                multiplayerState.goldCache = data.saveData.dungeonState.gold || 0;
                            }
                        }
                        
                        document.getElementById('titleScreen').style.display = 'none';
                        document.getElementById('heroSelectionModal').style.display = 'none';
                        // Reset music controls position
                        document.getElementById('musicControls').classList.remove('heroSelectionActive');
                        
                        if (data.screen === 'dungeonMenu') {
                            stopBattleVideo(); // Stop and hide video background
                            document.getElementById('battleScreen').style.display = 'none';
                            document.getElementById('musicTicker').classList.remove('battleActive');
                            document.getElementById('musicControls').classList.add('dungeonMenuActive');
                            document.getElementById('musicTicker').classList.add('dungeonMenuActive');
                            document.getElementById('dungeonMenuScreen').style.display = 'block';
                            currentScreen = 'dungeonMenu';
                            
                            // Load hero stats from save
                            updateDungeonMenuHeroes();
                            updateGoldDisplay();
                            
                            // Apply client UI restrictions
                            applyClientUIRestrictions();
                        } else if (data.screen === 'battle') {
                            // Stop dungeon menu story background animation
                            stopDungeonMenuAnimation();
                            
                            // Client waits for battle_init message from host
                            // Just show the screen, don't initialize yet
                            document.getElementById('dungeonMenuScreen').style.display = 'none';
                            document.getElementById('battleScreen').style.display = 'block';
                            document.getElementById('musicTicker').classList.add('battleActive');
                            document.getElementById('musicControls').classList.add('battleActive');
                            currentScreen = 'battle';
                            
                            // Initialize canvas
                            battleState.canvas = document.getElementById('battleCanvas');
                            battleState.ctx = battleState.canvas.getContext('2d');
                            battleState.canvas.width = window.innerWidth;
                            battleState.canvas.height = window.innerHeight - 180;
                            battleState.active = true;
                            
                            // Move music controls to battle position
                            document.getElementById('musicControls').classList.add('battleActive');
                            
                            showNotification('Waiting for host to initialize battle...', 'info');
                            return; // Wait for battle_init
                        } else {
                            // Fallback to dungeon menu for any other screen value
                            stopBattleVideo(); // Stop and hide video background
                            document.getElementById('battleScreen').style.display = 'none';
                            document.getElementById('musicTicker').classList.remove('battleActive');
                            document.getElementById('musicControls').classList.add('dungeonMenuActive');
                            document.getElementById('musicTicker').classList.add('dungeonMenuActive');
                            document.getElementById('dungeonMenuScreen').style.display = 'block';
                            currentScreen = 'dungeonMenu';
                            updateDungeonMenuHeroes();
                            updateGoldDisplay();
                            applyClientUIRestrictions();
                        }
                        showNotification('Host started the game!', 'success');
                    }
                    break;
                
                case 'chat_message':
                    // Receive chat message broadcast from host
                    if (multiplayerState.role === 'client' && data.message) {
                        // Skip if this is our own message (we already added it locally)
                        const myName = multiplayerState.playerName || 'Player';
                        if (data.message.senderName === myName && !data.message.isNpc) {
                            break;
                        }
                        // Add to local chat without re-broadcasting
                        chatState.messages.unshift(data.message);
                        if (chatState.messages.length > 50) {
                            chatState.messages.pop();
                        }
                        renderChatMessages();
                    }
                    break;
                
                case 'chat_request':
                    // Host receives chat request from client - process LLM and broadcast
                    if (multiplayerState.role === 'host') {
                        handleClientChatRequest(data);
                    }
                    break;
                
                case 'animation_sync':
                    // Client receives animation update from host
                    if (multiplayerState.role === 'client' && data.combatantName && data.animState) {
                        // Find the combatant by name
                        const combatant = battleState.heroes.find(h => h.name === data.combatantName) ||
                                          battleState.enemies.find(e => e.name === data.combatantName);
                        if (combatant) {
                            // Apply animation locally without re-broadcasting
                            setAnimationState(combatant, data.animState, data.playMode || 'pingpong', null, false);
                        }
                    }
                    break;
                
                default:
                    console.warn('[MP] Unhandled message type:', data.type, data);
                    break;
            }
            
            // Log message to debug panel
            logDebugMessage(data.type, data, 'in');
            updateDebugStatus();
        }
        
        // Handle chat request from client (host-only)
        async function handleClientChatRequest(data) {
            const playerName = data.playerName || 'Player';
            const message = data.message || '';
            const clientTarget = data.targetEntity;  // Client's selected target
            
            // Get player's hero avatar
            const heroAvatar = 'people/zooko_a_head_compressed.png';
            
            // Add player message to chat (will broadcast)
            addChatMessage(playerName, 'player', heroAvatar, message, false);
            
            // Get NPC to respond based on client's target selection
            let respondingNpc = null;
            
            if (clientTarget) {
                // Use client's selected target
                if (clientTarget.type === 'captive') {
                    respondingNpc = battleState.captiveNpc;
                } else if (clientTarget.type === 'enemy' && clientTarget.index !== undefined) {
                    respondingNpc = battleState.enemies[clientTarget.index];
                }
                
                // Validate target is still valid
                if (respondingNpc && (respondingNpc.hp <= 0 || respondingNpc.rescued)) {
                    respondingNpc = null;
                }
            }
            
            // If no specific target (broadcast mode / ALL), give all NPCs a chance to respond via free will
            if (!clientTarget) {
                // Trigger free will for all alive NPCs - each decides if they want to respond
                const allNpcs = [];
                
                // Add captive if present and can chat
                if (battleState.captiveNpc && !battleState.captiveNpc.rescued && battleState.captiveNpc.canChat) {
                    allNpcs.push(battleState.captiveNpc);
                }
                
                // Add all alive enemies with backstory
                battleState.enemies.forEach(enemy => {
                    if (enemy.hp > 0 && enemy.backstory) {
                        allNpcs.push(enemy);
                    }
                });
                
                if (allNpcs.length === 0) {
                    addChatMessage('System', 'friendly', 'people/zooko_a_head_compressed.png', 
                        '*No one responds...*', true);
                    return;
                }
                
                // Give each NPC a chance to respond (free will style)
                for (const npc of allNpcs) {
                    triggerFreeWillChatResponse(npc, playerName, message);
                }
                return;
            }

            if (!respondingNpc) {
                addChatMessage('System', 'friendly', 'people/zooko_a_head_compressed.png', 
                    '*No one responds...*', true);
                return;
            }
            
            try {
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        npcName: respondingNpc.name,
                        backstory: respondingNpc.backstory || 'A mysterious creature.',
                        npcType: respondingNpc.isBoss ? 'boss' : 'mob',
                        conversation: chatState.messages.slice(0, 10).reverse(),
                        message: message,
                        playerName: playerName,
                        rpMode: settings.rpMode !== false
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    const npcType = respondingNpc.hostile ? 'hostile' : 
                        (respondingNpc.questable ? 'questable' : 'friendly');
                    
                    addChatMessage(
                        respondingNpc.name,
                        npcType,
                        respondingNpc.spritePath || 'people/zooko_a_head_compressed.png',
                        result.response,
                        true,
                        respondingNpc.voiceType
                    );
                } else if (result.error) {
                    checkForRateLimitError(result.error);
                }
            } catch (error) {
                console.error('Chat fetch error:', error);
                checkForRateLimitError(error.message || String(error));
            }
        }
        
        function sendWebSocketMessage(data) {
            if (multiplayerState.ws && multiplayerState.ws.readyState === WebSocket.OPEN) {
                multiplayerState.ws.send(JSON.stringify(data));
                logDebugMessage(data.type, data, 'out');
                updateDebugStatus();
            } else {
                console.error('[MP] WebSocket not connected. State:', multiplayerState.ws ? multiplayerState.ws.readyState : 'null');
            }
        }
        
        function createMultiplayerRoom() {
            // Get player name
            const playerNameInput = document.getElementById('multiplayerPlayerName');
            const playerName = playerNameInput ? playerNameInput.value.trim() : '';
            if (!playerName) {
                multiplayerState.playerName = generateRandomPlayerName();
            } else {
                multiplayerState.playerName = playerName;
            }
            
            // Save player name to settings
            settings.playerName = multiplayerState.playerName;
            saveSettings();
            
            // Close settings panel
            closeAllPanels();
            
            connectWebSocket();
            setTimeout(() => {
                sendWebSocketMessage({ type: 'create_room', player_name: playerName });
            }, 100);
        }
        
        function joinMultiplayerRoom() {
            const code = document.getElementById('joinRoomCodeInput').value.trim().toUpperCase();
            if (code.length !== 6) {
                showNotification('Please enter a 6-character room code', 'error');
                return;
            }
            
            // Get player name
            const playerNameInput = document.getElementById('multiplayerPlayerName');
            const playerName = playerNameInput ? playerNameInput.value.trim() : '';
            if (!playerName) {
                multiplayerState.playerName = generateRandomPlayerName();
            } else {
                multiplayerState.playerName = playerName;
            }
            
            // Save player name to settings
            settings.playerName = multiplayerState.playerName;
            saveSettings();
            
            connectWebSocket();
            setTimeout(() => {
                sendWebSocketMessage({ type: 'join_room', code, player_name: multiplayerState.playerName });
            }, 100);
        }
        
        function quickJoinRoom() {
            const code = document.getElementById('titleJoinCode').value.trim().toUpperCase();
            if (code.length !== 6) {
                showNotification('Please enter a 6-character room code', 'error');
                return;
            }
            
            // Get player name
            const playerNameInput = document.getElementById('multiplayerPlayerName');
            const playerName = playerNameInput ? playerNameInput.value.trim() : '';
            if (!playerName) {
                multiplayerState.playerName = generateRandomPlayerName();
            } else {
                multiplayerState.playerName = playerName;
            }
            
            // Save player name to settings
            settings.playerName = multiplayerState.playerName;
            saveSettings();
            
            connectWebSocket();
            setTimeout(() => {
                sendWebSocketMessage({ type: 'join_room', code, player_name: multiplayerState.playerName });
            }, 100);
        }
        
        function leaveRoom() {
            if (multiplayerState.ws) {
                multiplayerState.ws.close();
            }
            resetMultiplayerState();
            document.getElementById('connectionStatus').style.display = 'none';
            document.getElementById('joinRoomBtn').style.display = 'block';
            document.getElementById('leaveRoomBtn').style.display = 'none';
            showNotification('Left room', 'info');
        }
        
        function stopHosting() {
            if (multiplayerState.ws) {
                multiplayerState.ws.close();
            }
            resetMultiplayerState();
            const roomCodeDisplay = document.getElementById('roomCodeDisplay');
            const createRoomBtn = document.getElementById('createRoomBtn');
            const changeCodeBtn = document.getElementById('changeCodeBtn');
            const stopHostingBtn = document.getElementById('stopHostingBtn');
            const hostControlsBtn = document.getElementById('hostControlsBtn');
            if (roomCodeDisplay) roomCodeDisplay.style.display = 'none';
            if (createRoomBtn) createRoomBtn.style.display = 'block';
            if (changeCodeBtn) changeCodeBtn.style.display = 'none';
            if (stopHostingBtn) stopHostingBtn.style.display = 'none';
            if (hostControlsBtn) hostControlsBtn.style.display = 'none';
            showNotification('Stopped hosting', 'info');
        }
        
        function changeRoomCode() {
            if (confirm('Changing the room code will disconnect all players. Continue?')) {
                sendWebSocketMessage({ type: 'change_code' });
            }
        }
        
        function changeRoomCodeFromPanel() {
            closeHostControls();
            changeRoomCode();
        }
        
        function resetMultiplayerState() {
            multiplayerState.enabled = false;
            multiplayerState.role = null;
            multiplayerState.roomCode = null;
            multiplayerState.myHeroes = [];
            multiplayerState.myPlayerId = null;
            multiplayerState.playerHeroes = {};
            multiplayerState.connectedPlayers = [];
            if (multiplayerState.ws) {
                multiplayerState.ws.close();
                multiplayerState.ws = null;
            }
        }
        
        function toggleRoomCodeVisibility() {
            const codeSpan = document.getElementById('heroSelectionCode');
            const btn = event.target;
            
            if (codeSpan.textContent === '******') {
                codeSpan.textContent = multiplayerState.roomCode;
                btn.textContent = 'ðŸ‘ HIDE';
            } else {
                codeSpan.textContent = '******';
                btn.textContent = 'ðŸ‘ SHOW';
            }
        }
        
        function cancelHeroSelection() {
            // For single player, just go back without confirm
            if (!multiplayerState.enabled) {
                document.getElementById('heroSelectionModal').style.display = 'none';
                document.getElementById('musicControls').classList.remove('heroSelectionActive');
                document.getElementById('musicTicker').classList.remove('battleActive');
                
                // Restore hidden elements
                const codeDisplay = document.getElementById('heroSelectionCode');
                if (codeDisplay) codeDisplay.parentElement.style.display = '';
                const playerNameInput = document.getElementById('playerNameInput');
                if (playerNameInput) playerNameInput.parentElement.style.display = '';
                const backBtn = document.getElementById('heroSelectionBackBtn');
                if (backBtn) backBtn.style.display = '';
                const playerCountBox = document.getElementById('playerCountBox');
                if (playerCountBox) playerCountBox.style.display = '';
                const connectedPlayersList = document.getElementById('connectedPlayersList');
                if (connectedPlayersList) connectedPlayersList.style.display = '';
                const heroSelectionTitle = document.getElementById('heroSelectionTitle');
                if (heroSelectionTitle) heroSelectionTitle.textContent = 'SELECT YOUR HERO';
                const waitingMsg = document.getElementById('heroWaitingMessage');
                if (waitingMsg) waitingMsg.textContent = 'Click heroes to select. Players can select multiple heroes.';
                
                // Reset hero card selections
                document.querySelectorAll('.heroSelectCard').forEach(card => {
                    card.classList.remove('selected', 'taken');
                    card.style.borderWidth = '3px';
                    card.style.opacity = '1';
                    const playerLabel = card.querySelector('.heroPlayerLabel');
                    if (playerLabel) playerLabel.style.display = 'none';
                });
                
                // Reset multiplayer state
                multiplayerState.myHeroes = [];
                multiplayerState.playerHeroes = {};
                multiplayerState.role = null;
                return;
            }
            
            if (confirm('Leave multiplayer session?')) {
                document.getElementById('heroSelectionModal').style.display = 'none';
                // Move music controls back to center
                document.getElementById('musicControls').classList.remove('heroSelectionActive');
                document.getElementById('musicTicker').classList.remove('battleActive');
                if (multiplayerState.role === 'host') {
                    stopHosting();
                } else {
                    leaveRoom();
                }
            }
        }
        
        function showHeroSelection() {
            document.getElementById('heroSelectionModal').style.display = 'block';
            // Move music controls to left
            document.getElementById('musicControls').classList.add('heroSelectionActive');
            document.getElementById('musicTicker').classList.add('battleActive');
            // Update room code display
            const codeDisplay = document.getElementById('heroSelectionCode');
            if (codeDisplay && multiplayerState.roomCode) {
                codeDisplay.textContent = multiplayerState.roomCode;
            }
            // Set player name input to current player name
            const nameInput = document.getElementById('playerNameInput');
            if (nameInput) {
                nameInput.value = multiplayerState.playerName;
            }
            
            // Show reconnect options if this is a reconnection
            const reconnectOptions = document.getElementById('reconnectOptions');
            const gameStartOptions = document.getElementById('gameStartOptions');
            if (multiplayerState.isReconnecting) {
                if (reconnectOptions) reconnectOptions.style.display = 'block';
                if (gameStartOptions) gameStartOptions.style.display = 'none';
            } else {
                if (reconnectOptions) reconnectOptions.style.display = 'none';
                // Also ensure gameStartOptions shows phase 1 and hides phase 2 on fresh start
                if (gameStartOptions) {
                    document.getElementById('gameStartPhase1').style.display = 'block';
                    document.getElementById('gameStartPhase2').style.display = 'none';
                }
            }
            
            // Update hero selection cards with current stats
            updateHeroSelectionStats();
        }
        
        // Update hero selection cards with stats from save or defaults
        function updateHeroSelectionStats() {
            // Try to load existing save data
            const saveData = localStorage.getItem(STORAGE_KEYS.SHARED_SAVE);
            let heroes = null;
            let gold = 0;
            let hasSave = false;
            
            if (saveData) {
                try {
                    const parsed = JSON.parse(saveData);
                    if (parsed.heroes) {
                        heroes = parsed.heroes;
                        hasSave = true;
                    }
                    if (parsed.dungeonState?.gold !== undefined) {
                        gold = parsed.dungeonState.gold;
                    }
                } catch (e) {
                    console.warn('Failed to parse save data for hero selection:', e);
                }
            }
            
            // If no save, use default values
            if (!heroes) {
                heroes = createDefaultSharedSave().heroes;
                gold = 0;
            }
            
            // Update each hero's stats on the selection cards
            const heroNames = ['zooko', 'nate', 'zancas', 'cyberaxe'];
            heroNames.forEach(heroKey => {
                const hero = heroes[heroKey];
                if (hero) {
                    // Update HP
                    const hpEl = document.getElementById(`sel-${heroKey}-hp`);
                    const maxHpEl = document.getElementById(`sel-${heroKey}-maxhp`);
                    if (hpEl) hpEl.textContent = hero.hp || 0;
                    if (maxHpEl) maxHpEl.textContent = hero.maxHp || 0;
                    
                    // Update XP and Level
                    const xpEl = document.getElementById(`sel-${heroKey}-xp`);
                    const levelEl = document.getElementById(`sel-${heroKey}-level`);
                    if (xpEl) xpEl.textContent = hero.xp || 0;
                    if (levelEl) levelEl.textContent = hero.level || 1;
                    
                    // Update base stats
                    const stats = ['str', 'dex', 'con', 'int', 'wis', 'cha', 'ac'];
                    stats.forEach(stat => {
                        const el = document.getElementById(`sel-${heroKey}-${stat}`);
                        if (el) el.textContent = hero[stat] || 0;
                    });
                }
            });
            
            // Update party gold display (now in top bar)
            const goldEl = document.getElementById('sel-party-gold-top');
            if (goldEl) goldEl.textContent = gold;
            
            // Show/hide roll buttons based on new game status
            updateRollButtonsVisibility(hasSave);
        }
        
        // Track if we have a saved game (affects roll button visibility)
        let heroSelectionHasSave = false;
        
        // Current dice roll state
        let currentDiceRollHero = null;
        let rolledStats = { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 };
        let rolledDice = {}; // Store individual die values for display
        
        // Update roll button visibility - only show for claimed heroes on new game
        function updateRollButtonsVisibility(hasSave) {
            heroSelectionHasSave = hasSave;
            const heroNames = ['zooko', 'nate', 'zancas', 'cyberaxe'];
            
            heroNames.forEach(heroKey => {
                const rollBtn = document.querySelector(`.heroRollButton[data-hero="${heroKey}"]`);
                if (rollBtn) {
                    // Show roll button only if: no save AND this player owns this hero
                    const isMyHero = multiplayerState.myHeroes.includes(heroKey);
                    if (!hasSave && isMyHero) {
                        rollBtn.classList.add('visible');
                    } else {
                        rollBtn.classList.remove('visible');
                    }
                }
            });
        }
        
        // Open the dice roll modal for a specific hero
        function openDiceRollModal(heroName) {
            // Verify this player owns this hero
            if (!multiplayerState.myHeroes.includes(heroName)) {
                showNotification('You can only roll stats for your own heroes', 'error');
                return;
            }
            
            // Verify it's a new game (no save)
            if (heroSelectionHasSave) {
                showNotification('Can only roll stats for new games', 'error');
                return;
            }
            
            currentDiceRollHero = heroName;
            
            // Set hero name in modal title
            const heroDisplayName = heroName.charAt(0).toUpperCase() + heroName.slice(1);
            document.getElementById('diceRollHeroName').textContent = heroDisplayName.toUpperCase();
            
            // Reset dice display
            const stats = ['str', 'dex', 'con', 'int', 'wis', 'cha'];
            stats.forEach(stat => {
                const row = document.querySelector(`.diceStatRow[data-stat="${stat}"]`);
                if (row) {
                    row.querySelectorAll('.die').forEach(die => {
                        die.textContent = '-';
                        die.classList.remove('rolling');
                    });
                    row.querySelector('.diceStatTotal').textContent = '-';
                }
            });
            
            document.getElementById('diceRollHP').textContent = '-';
            document.getElementById('diceRollAC').textContent = '-';
            document.getElementById('diceRollTotal').textContent = '-';
            
            // Show modal
            document.getElementById('diceRollModal').classList.add('visible');
        }
        
        // Close the dice roll modal without accepting
        function closeDiceRollModal() {
            document.getElementById('diceRollModal').classList.remove('visible');
            currentDiceRollHero = null;
        }
        
        // Roll a single d6
        function rollD6() {
            return Math.floor(Math.random() * 6) + 1;
        }
        
        // Roll 3d6 and return { dice: [d1, d2, d3], total: sum }
        function roll3d6() {
            const dice = [rollD6(), rollD6(), rollD6()];
            return { dice, total: dice[0] + dice[1] + dice[2] };
        }
        
        // Calculate HP from CON: 10 + CON modifier (CON - 10) / 2
        function calculateHP(con) {
            const modifier = Math.floor((con - 10) / 2);
            return Math.max(1, 10 + modifier);
        }
        
        // Calculate AC from DEX: 10 + DEX modifier
        function calculateAC(dex) {
            const modifier = Math.floor((dex - 10) / 2);
            return 10 + modifier;
        }
        
        // Roll all dice with animation
        function rollAllDice() {
            const stats = ['str', 'dex', 'con', 'int', 'wis', 'cha'];
            
            // Start rolling animation on all dice
            stats.forEach(stat => {
                const row = document.querySelector(`.diceStatRow[data-stat="${stat}"]`);
                if (row) {
                    row.querySelectorAll('.die').forEach(die => {
                        die.classList.add('rolling');
                    });
                }
            });
            
            // Animate dice for 1 second with random values
            let animationFrames = 0;
            const maxFrames = 20;
            
            const animateInterval = setInterval(() => {
                animationFrames++;
                
                // Show random values during animation
                stats.forEach(stat => {
                    const row = document.querySelector(`.diceStatRow[data-stat="${stat}"]`);
                    if (row) {
                        row.querySelectorAll('.die').forEach(die => {
                            die.textContent = rollD6();
                        });
                    }
                });
                
                if (animationFrames >= maxFrames) {
                    clearInterval(animateInterval);
                    
                    // Final roll - these are the real values
                    stats.forEach(stat => {
                        const result = roll3d6();
                        rolledStats[stat] = result.total;
                        rolledDice[stat] = result.dice;
                        
                        const row = document.querySelector(`.diceStatRow[data-stat="${stat}"]`);
                        if (row) {
                            const dice = row.querySelectorAll('.die');
                            dice[0].textContent = result.dice[0];
                            dice[1].textContent = result.dice[1];
                            dice[2].textContent = result.dice[2];
                            dice.forEach(die => die.classList.remove('rolling'));
                            
                            const totalEl = row.querySelector('.diceStatTotal');
                            totalEl.textContent = result.total;
                            
                            // Color code the total based on value
                            if (result.total >= 18) {
                                totalEl.style.color = '#9B59B6'; // Purple for 18
                            } else if (result.total >= 13) {
                                totalEl.style.color = '#27AE60'; // Green for 13-17
                            } else if (result.total < 8) {
                                totalEl.style.color = '#E74C3C'; // Red for <8
                            } else {
                                totalEl.style.color = '#F2C94C'; // Default gold for 8-12
                            }
                        }
                    });
                    
                    // Calculate and display derived stats
                    const hp = calculateHP(rolledStats.con);
                    const ac = calculateAC(rolledStats.dex);
                    const total = rolledStats.str + rolledStats.dex + rolledStats.con + rolledStats.int + rolledStats.wis + rolledStats.cha;
                    document.getElementById('diceRollHP').textContent = hp;
                    document.getElementById('diceRollAC').textContent = ac;
                    
                    const totalEl = document.getElementById('diceRollTotal');
                    totalEl.textContent = total;
                    
                    // Color code total: Red <40, Yellow 41-60, Green 61-80, Purple >80
                    if (total > 80) {
                        totalEl.style.color = '#9B59B6'; // Purple for 81+
                    } else if (total >= 61) {
                        totalEl.style.color = '#27AE60'; // Green for 61-80
                    } else if (total >= 41) {
                        totalEl.style.color = '#F2C94C'; // Yellow for 41-60
                    } else {
                        totalEl.style.color = '#E74C3C'; // Red for 40 and below
                    }
                }
            }, 50);
        }
        
        // Accept the rolled stats and apply them to the hero
        function acceptRolledStats() {
            if (!currentDiceRollHero) return;
            
            // Verify we have rolled (check if any stat is non-zero)
            if (rolledStats.str === 0) {
                showNotification('Roll the dice first!', 'error');
                return;
            }
            
            const heroKey = currentDiceRollHero;
            
            // Calculate derived stats
            const hp = calculateHP(rolledStats.con);
            const ac = calculateAC(rolledStats.dex);
            
            // Update the hero card display
            document.getElementById(`sel-${heroKey}-str`).textContent = rolledStats.str;
            document.getElementById(`sel-${heroKey}-dex`).textContent = rolledStats.dex;
            document.getElementById(`sel-${heroKey}-con`).textContent = rolledStats.con;
            document.getElementById(`sel-${heroKey}-int`).textContent = rolledStats.int;
            document.getElementById(`sel-${heroKey}-wis`).textContent = rolledStats.wis;
            document.getElementById(`sel-${heroKey}-cha`).textContent = rolledStats.cha;
            document.getElementById(`sel-${heroKey}-hp`).textContent = hp;
            document.getElementById(`sel-${heroKey}-maxhp`).textContent = hp;
            document.getElementById(`sel-${heroKey}-ac`).textContent = ac;
            
            // Store in multiplayerState for when game starts
            if (!multiplayerState.rolledHeroStats) {
                multiplayerState.rolledHeroStats = {};
            }
            multiplayerState.rolledHeroStats[heroKey] = {
                str: rolledStats.str,
                dex: rolledStats.dex,
                con: rolledStats.con,
                int: rolledStats.int,
                wis: rolledStats.wis,
                cha: rolledStats.cha,
                hp: hp,
                maxHp: hp,
                ac: ac,
                xp: 0,
                level: 1
            };
            
            // In multiplayer, broadcast rolled stats to other players
            if (multiplayerState.ws && multiplayerState.ws.readyState === WebSocket.OPEN) {
                sendWebSocketMessage({
                    type: 'hero_stats_rolled',
                    hero: heroKey,
                    stats: multiplayerState.rolledHeroStats[heroKey]
                });
            }
            
            showNotification(`${heroKey.charAt(0).toUpperCase() + heroKey.slice(1)}'s stats accepted!`, 'success');
            
            // Close modal
            closeDiceRollModal();
            
            // Update roll phase status (check if all heroes rolled)
            updateRollPhaseStatus();
            
            // Reset rolled stats for next roll
            rolledStats = { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 };
        }
        
        function updatePlayerName() {
            const nameInput = document.getElementById('playerNameInput');
            const newName = nameInput.value.trim() || 'Player';
            multiplayerState.playerName = newName;
            
            // Always notify server of name change
            sendWebSocketMessage({ 
                type: 'update_name', 
                playerName: newName 
            });
        }
        
        function selectHero(heroName) {
            // In single player mode, heroes cannot be selected/deselected
            if (!multiplayerState.enabled) {
                // Just show a message if they try to click
                showNotification('All heroes are yours in single player!', 'info');
                return;
            }
            
            const card = document.querySelector(`[data-hero="${heroName}"]`);
            
            // If clicking own hero, deselect it
            if (multiplayerState.myHeroes.includes(heroName)) {
                multiplayerState.myHeroes = multiplayerState.myHeroes.filter(h => h !== heroName);
                card.classList.remove('selected');
                card.style.borderWidth = '3px';
                sendWebSocketMessage({ type: 'deselect_hero', hero: heroName });
                showNotification('Hero deselected', 'info');
                
                // Hide roll button when deselected
                const rollBtn = card.querySelector('.heroRollButton');
                if (rollBtn) rollBtn.classList.remove('visible');
                
                return;
            }
            
            // Check if already taken by someone else
            if (card.classList.contains('taken')) {
                showNotification('Hero already taken', 'error');
                return;
            }
            
            // Select new hero (no limit on how many per player)
            multiplayerState.myHeroes.push(heroName);
            card.classList.add('selected');
            card.style.borderWidth = '5px';
            
            // Show roll button only if in roll phase
            if (inRollPhase) {
                const rollBtn = card.querySelector('.heroRollButton');
                if (rollBtn) rollBtn.classList.add('visible');
            }
            
            // Get player name from input, or use current playerName from state
            const nameInput = document.getElementById('playerNameInput');
            const playerName = nameInput.value.trim() || multiplayerState.playerName;
            multiplayerState.playerName = playerName;
            
            sendWebSocketMessage({ 
                type: 'select_hero', 
                hero: heroName, 
                playerName: playerName 
            });
        }
        
        function updateHeroSelection(data) {
            // Store heroes data in multiplayerState for roll phase tracking
            multiplayerState.playerHeroes = data.heroes || {};
            
            // Reset all cards first
            document.querySelectorAll('.heroSelectCard').forEach(card => {
                card.classList.remove('taken');
                card.style.opacity = '1';
                card.style.cursor = 'pointer';
                card.querySelector('.heroTakenLabel').style.display = 'none';
                card.querySelector('.heroPlayerLabel').style.display = 'none';
            });
            
            // Update hero selection UI with player names
            Object.keys(data.heroes).forEach(hero => {
                const heroData = data.heroes[hero];
                const card = document.querySelector(`[data-hero="${hero}"]`);
                if (card && heroData) {
                    card.classList.add('taken');
                    card.style.opacity = '0.7';
                    
                    const playerLabel = card.querySelector('.heroPlayerLabel');
                    if (playerLabel) {
                        playerLabel.textContent = heroData.playerName || 'Player';
                        playerLabel.style.display = 'block';
                    }
                    
                    // Don't disable if it's my hero
                    if (!multiplayerState.myHeroes.includes(hero)) {
                        card.style.cursor = 'not-allowed';
                        card.querySelector('.heroTakenLabel').style.display = 'block';
                    }
                }
            });
            
            // Update connected players list
            updateConnectedPlayersList(data.heroes);
            
            // Update player count
            const playerCount = multiplayerState.connectedPlayers.length;
            const countDisplay = document.getElementById('playerCountDisplay');
            if (countDisplay) {
                countDisplay.textContent = `${playerCount}/4`;
            }
            
            // Update waiting message and show game start options when all 4 heroes selected
            const heroCount = Object.keys(data.heroes).length;
            const waitingMsg = document.getElementById('heroWaitingMessage');
            const gameStartOptions = document.getElementById('gameStartOptions');
            const backBtn = document.getElementById('heroSelectionBackBtn');
            
            if (heroCount === 4) {
                if (waitingMsg) waitingMsg.style.display = 'none';
                if (gameStartOptions && multiplayerState.role === 'host') {
                    gameStartOptions.style.display = 'block';
                    if (backBtn) backBtn.style.display = 'none'; // Hide standalone back button
                }
            } else {
                if (waitingMsg) {
                    waitingMsg.style.display = 'block';
                    waitingMsg.textContent = `Select heroes (${heroCount}/4 selected). Players can select multiple heroes.`;
                }
                if (gameStartOptions) gameStartOptions.style.display = 'none';
                if (backBtn) backBtn.style.display = 'flex'; // Show standalone back button
            }
            
            // Update multiplayer status indicator
            updateMultiplayerStatus();
        }
        
        function updateConnectedPlayersList(heroes) {
            const listContent = document.getElementById('playersListContent');
            if (!listContent) return;
            
            listContent.innerHTML = '';
            
            // Show all connected players
            if (multiplayerState.connectedPlayers.length === 0) {
                listContent.innerHTML = '<div style="color: #89A0B4; font-size: 12px;">No players connected</div>';
                return;
            }
            
            multiplayerState.connectedPlayers.forEach(player => {
                const playerBadge = document.createElement('div');
                playerBadge.style.cssText = 'padding: 6px 12px; background: rgba(42, 157, 143, 0.3); border: 1px solid #2A9D8F; border-radius: 5px; font-size: 12px; margin-bottom: 5px;';
                
                const heroText = player.heroes && player.heroes.length > 0 
                    ? ` â†’ ${player.heroes.map(h => h.toUpperCase()).join(', ')}` 
                    : ' â†’ (no heroes)';
                playerBadge.innerHTML = `<span style="color: #F2C94C;">${player.name}</span> <span style="color: #89A0B4;">${heroText}</span>`;
                listContent.appendChild(playerBadge);
            });
        }
        
        function updateConnectedPlayersListOnly() {
            // Update just the player list without touching hero cards
            const listContent = document.getElementById('playersListContent');
            if (!listContent) return;
            
            listContent.innerHTML = '';
            
            if (multiplayerState.connectedPlayers.length === 0) {
                listContent.innerHTML = '<div style="color: #89A0B4; font-size: 12px;">No players connected</div>';
                return;
            }
            
            multiplayerState.connectedPlayers.forEach(player => {
                const playerBadge = document.createElement('div');
                playerBadge.style.cssText = 'padding: 6px 12px; background: rgba(42, 157, 143, 0.3); border: 1px solid #2A9D8F; border-radius: 5px; font-size: 12px; margin-bottom: 5px;';
                
                const heroText = player.heroes && player.heroes.length > 0 
                    ? ` â†’ ${player.heroes.map(h => h.toUpperCase()).join(', ')}` 
                    : ' â†’ (no heroes)';
                playerBadge.innerHTML = `<span style="color: #F2C94C;">${player.name}</span> <span style="color: #89A0B4;">${heroText}</span>`;
                listContent.appendChild(playerBadge);
            });
        }
        
        function updateMultiplayerStatus() {
            const statusDiv = document.getElementById('multiplayerStatus');
            const statusText = document.getElementById('mpStatusText');
            
            if (multiplayerState.enabled && multiplayerState.roomCode) {
                statusDiv.style.display = 'block';
                const playerCount = multiplayerState.connectedPlayers.length;
                const role = multiplayerState.role === 'host' ? 'ðŸ‘‘ HOST' : 'ðŸŽ® CLIENT';
                statusText.textContent = `${role} | Room: ${multiplayerState.roomCode} | Players: ${playerCount}/4`;
            } else {
                statusDiv.style.display = 'none';
            }
        }
        
        function startMultiplayerBattle() {
            // This function is now handled by showing game start options
            // See continueGame(), loadSaveGame(), startNewAdventure()
        }
        
        // Multiplayer: Continue game from save (host only)
        function continueGameMultiplayer() {
            if (multiplayerState.role !== 'host') {
                showNotification('Only host can start the game', 'error');
                return;
            }
            
            // Ensure save exists
            let sharedSave = loadSharedSave();
            if (!sharedSave) {
                sharedSave = createDefaultSharedSave();
                saveSharedSave(sharedSave);
            }
            
            // Hide hero selection
            document.getElementById('heroSelectionModal').style.display = 'none';
            document.getElementById('musicControls').classList.remove('heroSelectionActive');
            document.getElementById('musicTicker').classList.remove('battleActive');
            
            // Center music controls for dungeon menu
            document.getElementById('musicControls').classList.add('dungeonMenuActive');
            document.getElementById('musicTicker').classList.add('dungeonMenuActive');
            
            // Show dungeon menu
            currentScreen = 'dungeonMenu';
            document.getElementById('titleScreen').style.display = 'none';
            document.getElementById('dungeonMenuScreen').style.display = 'block';
            
            // Update dungeon menu with save data (after currentScreen is set)
            updateDungeonMenuHeroes();
            
            // Notify all clients to start WITH save data
            sendWebSocketMessage({ 
                type: 'game_start', 
                screen: 'dungeonMenu', 
                mode: 'continue',
                saveData: sharedSave
            });
            
            showNotification('Continuing from last save...', 'success');
            
            // Pre-generate next encounter while in dungeon menu (host only)
            preGenerateNextEncounter();
        }
        
        function loadSaveGame() {
            if (multiplayerState.role !== 'host') {
                showNotification('Only host can start the game', 'error');
                return;
            }
            
            // Ensure save exists
            let sharedSave = loadSharedSave();
            if (!sharedSave) {
                sharedSave = createDefaultSharedSave();
                saveSharedSave(sharedSave);
            }
            
            // Hide hero selection
            document.getElementById('heroSelectionModal').style.display = 'none';
            document.getElementById('musicControls').classList.remove('heroSelectionActive');
            document.getElementById('musicControls').classList.add('dungeonMenuActive');
            document.getElementById('musicTicker').classList.remove('battleActive');
            document.getElementById('musicTicker').classList.add('dungeonMenuActive');
            
            // For now, just show dungeon menu - load game UI can be added later
            currentScreen = 'dungeonMenu';
            document.getElementById('titleScreen').style.display = 'none';
            document.getElementById('dungeonMenuScreen').style.display = 'block';
            
            // Update dungeon menu with save data
            updateDungeonMenuHeroes();
            
            // Notify all clients to start WITH save data
            sendWebSocketMessage({ 
                type: 'game_start', 
                screen: 'dungeonMenu', 
                mode: 'load',
                saveData: sharedSave
            });
            
            showNotification('Load game functionality - showing dungeon menu', 'info');
            
            // Pre-generate next encounter while in dungeon menu (host only)
            preGenerateNextEncounter();
        }
        
        // Track if we're in roll phase
        let inRollPhase = false;
        
        // Enter roll phase - show roll buttons and wait for all rolls
        function enterRollPhase() {
            // Allow host OR single player (not enabled = single player)
            if (multiplayerState.enabled && multiplayerState.role !== 'host') {
                showNotification('Only host can start new game', 'error');
                return;
            }
            
            inRollPhase = true;
            
            // Force heroSelectionHasSave to false since we're starting a NEW game
            heroSelectionHasSave = false;
            
            // Switch to phase 2 UI
            document.getElementById('gameStartPhase1').style.display = 'none';
            document.getElementById('gameStartPhase2').style.display = 'block';
            
            // Show roll buttons for all claimed heroes
            showAllRollButtons();
            
            // Clear any previous rolled stats
            multiplayerState.rolledHeroStats = {};
            
            // Update status
            updateRollPhaseStatus();
            
            // Broadcast to clients that roll phase has started (only in multiplayer)
            if (multiplayerState.enabled) {
                sendWebSocketMessage({
                    type: 'roll_phase_start'
                });
            }
            
            showNotification('Roll phase started! Roll stats for your heroes.', 'info');
        }
        
        // Cancel roll phase and go back to phase 1
        function cancelRollPhase() {
            inRollPhase = false;
            
            // Switch back to phase 1 UI
            document.getElementById('gameStartPhase1').style.display = 'block';
            document.getElementById('gameStartPhase2').style.display = 'none';
            
            // Hide all roll buttons
            hideAllRollButtons();
            
            // Clear rolled stats
            multiplayerState.rolledHeroStats = {};
            
            // Broadcast to clients (only in multiplayer)
            if (multiplayerState.enabled) {
                sendWebSocketMessage({
                    type: 'roll_phase_cancel'
                });
            }
        }
        
        // Show roll buttons for all heroes (during roll phase)
        function showAllRollButtons() {
            const heroNames = ['zooko', 'nate', 'zancas', 'cyberaxe'];
            heroNames.forEach(heroKey => {
                const rollBtn = document.querySelector(`.heroRollButton[data-hero="${heroKey}"]`);
                if (rollBtn) {
                    // Show button only for heroes this player owns
                    if (multiplayerState.myHeroes.includes(heroKey)) {
                        rollBtn.classList.add('visible');
                    }
                }
            });
        }
        
        // Hide all roll buttons
        function hideAllRollButtons() {
            document.querySelectorAll('.heroRollButton').forEach(btn => {
                btn.classList.remove('visible');
            });
        }
        
        // Update roll phase status message
        function updateRollPhaseStatus() {
            // Get list of CLAIMED heroes (from playerHeroes which tracks all claimed heroes)
            const claimedHeroes = Object.keys(multiplayerState.playerHeroes || {});
            const totalHeroes = claimedHeroes.length;
            const rolledCount = claimedHeroes.filter(h => multiplayerState.rolledHeroStats[h]).length;
            
            // In single player OR as host, we can launch
            const canLaunch = !multiplayerState.enabled || multiplayerState.role === 'host';
            
            const statusEl = document.getElementById('rollPhaseStatus');
            const launchBtn = document.getElementById('launchGameBtn');
            
            if (statusEl) {
                if (totalHeroes === 0) {
                    statusEl.textContent = 'Waiting for heroes to be claimed...';
                    statusEl.style.color = '#89A0B4';
                } else if (rolledCount === totalHeroes) {
                    statusEl.textContent = 'âœ“ All heroes have rolled! Ready to launch.';
                    statusEl.style.color = '#27AE60';
                } else {
                    statusEl.textContent = `Rolling stats... (${rolledCount}/${totalHeroes} heroes ready)`;
                    statusEl.style.color = '#89A0B4';
                }
            }
            
            if (launchBtn) {
                if (totalHeroes > 0 && rolledCount === totalHeroes && canLaunch) {
                    launchBtn.disabled = false;
                    launchBtn.style.color = '#fff';
                    launchBtn.style.cursor = 'pointer';
                    launchBtn.style.background = 'linear-gradient(135deg, rgba(39, 174, 96, 0.5), rgba(39, 174, 96, 0.3))';
                } else {
                    launchBtn.disabled = true;
                    launchBtn.style.color = '#666';
                    launchBtn.style.cursor = 'not-allowed';
                    launchBtn.style.background = 'linear-gradient(135deg, rgba(39, 174, 96, 0.3), rgba(39, 174, 96, 0.2))';
                }
            }
        }
        
        // Launch the game with rolled stats
        function launchNewGame() {
            // Allow host OR single player
            if (multiplayerState.enabled && multiplayerState.role !== 'host') {
                showNotification('Only host can launch the game', 'error');
                return;
            }
            
            // Verify all CLAIMED heroes have rolled
            const claimedHeroes = Object.keys(multiplayerState.playerHeroes || {});
            const allRolled = claimedHeroes.every(h => multiplayerState.rolledHeroStats[h]);
            
            if (!allRolled || claimedHeroes.length === 0) {
                showNotification('Not all heroes have rolled yet!', 'error');
                return;
            }
            
            // Hide hero selection
            document.getElementById('heroSelectionModal').style.display = 'none';
            document.getElementById('musicControls').classList.remove('heroSelectionActive');
            document.getElementById('musicTicker').classList.remove('battleActive');
            
            // Restore hidden elements for single player (in case they go back)
            if (!multiplayerState.enabled) {
                const codeDisplay = document.getElementById('heroSelectionCode');
                if (codeDisplay) codeDisplay.parentElement.style.display = '';
                const playerNameInput = document.getElementById('playerNameInput');
                if (playerNameInput) playerNameInput.parentElement.style.display = '';
                const backBtn = document.getElementById('heroSelectionBackBtn');
                if (backBtn) backBtn.style.display = '';
            }
            
            // Create fresh save with rolled stats
            const newSave = createDefaultSharedSave();
            saveSharedSave(newSave);
            
            inRollPhase = false;
            currentScreen = 'dungeonMenu';
            document.getElementById('titleScreen').style.display = 'none';
            document.getElementById('dungeonMenuScreen').style.display = 'block';
            
            // Update dungeon menu with new save data (after currentScreen is set)
            updateDungeonMenuHeroes();
            
            // Center music controls
            document.getElementById('musicControls').classList.remove('heroSelectionActive');
            document.getElementById('musicControls').classList.add('dungeonMenuActive');
            document.getElementById('musicTicker').classList.remove('battleActive');
            document.getElementById('musicTicker').classList.add('dungeonMenuActive');
            
            // Notify all clients to start WITH save data (only in multiplayer)
            if (multiplayerState.enabled) {
                sendWebSocketMessage({ 
                    type: 'game_start', 
                    screen: 'dungeonMenu', 
                    mode: 'new',
                    saveData: newSave
                });
            }
            
            showNotification('Adventure begins!', 'success');
            
            // Pre-generate next encounter
            preGenerateNextEncounter();
        }
        
        function startNewAdventure() {
            if (multiplayerState.role !== 'host') {
                showNotification('Only host can start the game', 'error');
                return;
            }
            
            showConfirmation(
                'START NEW ADVENTURE?',
                'This will replace your local save game. All progress will be lost.',
                (confirmed) => {
                    if (!confirmed) return;
                    
                    // Hide hero selection
                    document.getElementById('heroSelectionModal').style.display = 'none';
                    document.getElementById('musicControls').classList.remove('heroSelectionActive');
                    document.getElementById('musicTicker').classList.remove('battleActive');
                    
                    // Create fresh save FIRST
                    const newSave = createDefaultSharedSave();
                    saveSharedSave(newSave);
                    
                    currentScreen = 'dungeonMenu';
                    document.getElementById('titleScreen').style.display = 'none';
                    document.getElementById('dungeonMenuScreen').style.display = 'block';
                    
                    // Update dungeon menu with new save data (after currentScreen is set)
                    updateDungeonMenuHeroes();
                    
                    // Center music controls
                    document.getElementById('musicControls').classList.remove('heroSelectionActive');
                    document.getElementById('musicControls').classList.add('dungeonMenuActive');
                    document.getElementById('musicTicker').classList.remove('battleActive');
                    document.getElementById('musicTicker').classList.add('dungeonMenuActive');
                    
                    // Notify all clients to start WITH save data
                    sendWebSocketMessage({ 
                        type: 'game_start', 
                        screen: 'dungeonMenu', 
                        mode: 'new',
                        saveData: newSave
                    });
                    
                    showNotification('Starting new adventure...', 'success');
                    
                    // Pre-generate next encounter while in dungeon menu (host only)
                    preGenerateNextEncounter();
                }
            );
        }
        
        function rejoinGame() {
            if (multiplayerState.role !== 'client') {
                showNotification('Only clients can rejoin', 'error');
                return;
            }
            
            if (multiplayerState.myHeroes.length === 0) {
                showNotification('Please select at least one hero', 'warning');
                return;
            }
            
            // Request current game state from host
            sendWebSocketMessage({ 
                type: 'request_sync',
                heroes: multiplayerState.myHeroes
            });
            
            showNotification('Rejoining game...', 'info');
            multiplayerState.isReconnecting = false;
            
            // Don't hide anything here - let game_start handler manage all screen transitions
        }
        
        function showHostControls() {
            document.getElementById('hostControlsPanel').style.display = 'block';
            updatePlayerList();
        }
        
        function closeHostControls() {
            document.getElementById('hostControlsPanel').style.display = 'none';
        }
        
        function updatePlayerList() {
            const list = document.getElementById('playerList');
            list.innerHTML = '';
            
            multiplayerState.connectedPlayers.forEach(player => {
                const div = document.createElement('div');
                div.style.cssText = 'padding: 10px; margin-bottom: 10px; background: rgba(0,0,0,0.5); border-radius: 5px; display: flex; justify-content: space-between; align-items: center;';
                div.innerHTML = `
                    <div>
                        <div style="color: #F2C94C; font-size: 14px;">${player.hero || 'No hero selected'}</div>
                        <div style="color: #89A0B4; font-size: 11px;">Player ${player.id}</div>
                    </div>
                    <div>
                        <button onclick="skipPlayerTurn(${player.id})" style="padding: 5px 10px; margin-right: 5px; background: #F39C12; border: none; border-radius: 3px; color: white; cursor: pointer;">SKIP TURN</button>
                        <button onclick="kickPlayer(${player.id})" style="padding: 5px 10px; background: #EB5757; border: none; border-radius: 3px; color: white; cursor: pointer;">KICK</button>
                    </div>
                `;
                list.appendChild(div);
            });
            
            // Update multiplayer status indicator
            updateMultiplayerStatus();
        }
        
        function kickPlayer(playerId) {
            if (confirm('Kick this player?')) {
                sendWebSocketMessage({ type: 'kick_player', player_id: playerId });
            }
        }
        
        function skipPlayerTurn(playerId) {
            sendWebSocketMessage({ type: 'skip_turn', player_id: playerId });
        }
        
        function handlePlayerDisconnect(playerId) {
            // Find disconnected player info
            const disconnectedPlayer = multiplayerState.connectedPlayers.find(p => p.id === playerId);
            
            // Find heroes controlled by this player
            const disconnectedHeroes = [];
            if (disconnectedPlayer && disconnectedPlayer.heroes) {
                disconnectedPlayer.heroes.forEach(heroName => {
                    disconnectedHeroes.push(heroName);
                    // Transfer control to host
                    const hero = battleState.heroes?.find(h => h.name.toLowerCase() === heroName.toLowerCase());
                    if (hero) {
                        hero.aiControlled = false; // Host controls it, not AI
                    }
                    // Add to host's heroes (stored lowercase)
                    const heroLower = heroName.toLowerCase();
                    if (!multiplayerState.myHeroes.includes(heroLower)) {
                        multiplayerState.myHeroes.push(heroLower);
                    }
                });
            }
            
            if (disconnectedHeroes.length > 0) {
                showNotification(`Player disconnected - you now control: ${disconnectedHeroes.join(', ')}`, 'warning');
                // Update UI to enable buttons for these heroes
                if (battleState.active && battleState.currentHeroIndex !== undefined) {
                    updateHeroTurn();
                }
            }
            
            // Remove from connected players
            multiplayerState.connectedPlayers = multiplayerState.connectedPlayers.filter(p => p.id !== playerId);
        }
        
        function processClientAction(data) {
            // Host processes action from client
            const action = data.action;
            const target = data.target;
            const heroName = data.hero;
            const heroesArray = data.heroes;
            
            // Handle retreat - marks player's heroes as retreated
            if (action === 'retreat' && heroesArray) {
                heroesArray.forEach(hName => {
                    const hero = battleState.heroes.find(h => h.name.toLowerCase() === hName.toLowerCase());
                    if (hero) {
                        hero.retreated = true;
                    }
                });
                
                // Save all heroes for stat persistence (before filtering)
                // Merge with existing allHeroes to preserve previously retreated heroes
                if (battleState.allHeroes.length === 0) {
                    battleState.allHeroes = [...battleState.heroes];
                } else {
                    // Add any heroes not already in allHeroes
                    battleState.heroes.forEach(hero => {
                        if (!battleState.allHeroes.find(h => h.name === hero.name)) {
                            battleState.allHeroes.push(hero);
                        }
                    });
                }
                
                // Remove retreated heroes from arrays
                battleState.heroes = battleState.heroes.filter(h => !h.retreated);
                battleState.turnOrder = battleState.turnOrder.filter(combatant => {
                    if (battleState.heroes.includes(combatant)) return true;
                    if (battleState.enemies.includes(combatant)) return combatant.hp > 0;
                    return false;
                });
                
                updateBattleHeroCards();
                renderBattle();
                broadcastGameState();
                
                // Check if any heroes still alive
                if (battleState.heroes.length === 0) {
                    showBattleNotification('DEFEAT! ALL HEROES RETREATED!');
                    
                    // Notify all clients to end battle
                    sendWebSocketMessage({
                        type: 'battle_end',
                        reason: 'retreat'
                    });
                    
                    setTimeout(() => {
                        // Hide notification
                        const notification = document.getElementById('battleNotification');
                        if (notification) notification.style.display = 'none';
                        
                        endBattle();
                    }, 2000);
                } else {
                    // Reset turn if current combatant was removed
                    const currentCombatant = battleState.turnOrder[battleState.currentTurn];
                    if (!currentCombatant) {
                        battleState.currentTurn = 0;
                        updateBattleTurnInfo();
                    }
                }
                return;
            }
            
            // Find hero
            const hero = battleState.heroes.find(h => h.name.toLowerCase() === heroName.toLowerCase());
            if (!hero) return;
            
            // Execute action (existing battle logic)
            if (action === 'light' || action === 'heavy' || action === 'special') {
                const enemy = battleState.enemies[target];
                if (enemy) {
                    executeAttack(hero, enemy, action);
                }
            } else if (action === 'swap') {
                // Handle swap with target hero
                const targetHero = battleState.heroes[target];
                if (targetHero && targetHero !== hero) {
                    const tempX = hero.x;
                    const tempY = hero.y;
                    const tempPlatform = hero.platform;
                    
                    hero.x = targetHero.x;
                    hero.y = targetHero.y;
                    hero.platform = targetHero.platform;
                    
                    targetHero.x = tempX;
                    targetHero.y = tempY;
                    targetHero.platform = tempPlatform;
                    
                    showDiceRoll(`${hero.name} swapped positions with ${targetHero.name}!`);
                    advanceTurn();
                }
            } else if (action === 'defend') {
                hero.defending = true;
                showDiceRoll(`${hero.name} defends!`);
                advanceTurn();
            } else if (action === 'heal') {
                if (hero.healsRemaining > 0) {
                    const healAmount = Math.floor(hero.maxHp * 0.5);
                    hero.hp = Math.min(hero.maxHp, hero.hp + healAmount);
                    hero.healsRemaining--;
                    hero.usedHeal = true;
                    
                    // Hide a potion sprite (consume the rightmost visible one)
                    if (hero.potions) {
                        for (let i = hero.potions.length - 1; i >= 0; i--) {
                            if (hero.potions[i].visible) {
                                hero.potions[i].visible = false;
                                break;
                            }
                        }
                    }
                    
                    showDiceRoll(`${hero.name} heals for ${healAmount} HP! (1 action used)`);
                    updateBattleHeroCards();
                }
            } else if (action === 'taunt') {
                const chaModifier = calculateModifier(hero.stats?.cha || 10);
                const tauntRoll = rollD20() + chaModifier;
                const tauntDC = 12;
                
                if (tauntRoll >= tauntDC) {
                    hero.taunting = true;
                    hero.tauntTurns = 3;
                    showDiceRoll(`${hero.name} taunts! d20(${tauntRoll}) SUCCESS!`);
                } else {
                    showDiceRoll(`${hero.name} taunt fails! d20(${tauntRoll}) vs DC ${tauntDC}`);
                }
                advanceTurn();
            } else if (action === 'skip') {
                showDiceRoll(`${hero.name} skips turn.`);
                advanceTurn();
            }
            
            // Broadcast state to all clients
            broadcastGameState();
        }
        
        function broadcastGameState() {
            if (multiplayerState.role !== 'host') return;
            
            const canvas = battleState.canvas;
            
            const state = {
                turnOrder: battleState.turnOrder.map(c => ({ name: c.name, hp: c.hp })),
                heroes: battleState.heroes.map(h => ({
                    name: h.name,
                    hp: h.hp,
                    maxHp: h.maxHp,
                    xp: h.xp,
                    level: h.level,
                    healsRemaining: h.healsRemaining,
                    potionVisibility: h.potions ? h.potions.map(p => p.visible) : [true, true],
                    stats: h.stats,
                    x: h.x / canvas.width,
                    y: h.y / canvas.height,
                    platform: h.platform,
                    defending: h.defending,
                    taunting: h.taunting,
                    tauntTurns: h.tauntTurns || 0,
                    usedHeal: h.usedHeal || false,
                    facing: h.facing,
                    retreated: h.retreated || false,
                    color: h.color,
                    spritePath: h.spritePath,
                    initiative: h.initiative
                })),
                enemies: battleState.enemies.map(e => ({
                    name: e.name,
                    species: e.species,
                    hp: e.hp,
                    maxHp: e.maxHp,
                    ac: e.ac,
                    attackDamage: e.attackDamage,
                    speed: e.speed,
                    dex: e.dex,
                    hostile: e.hostile,
                    x: e.x / canvas.width,
                    y: e.y / canvas.height,
                    platform: e.platform,
                    facing: e.facing,
                    isMob: e.isMob,
                    isBoss: e.isBoss,
                    spritePath: e.spritePath,
                    backstory: e.backstory,
                    initiative: e.initiative,
                    goldDrop: e.goldDrop || 0
                })),
                // Include captive state for sync
                captiveNpc: battleState.captiveNpc ? {
                    name: battleState.captiveNpc.name,
                    rescued: battleState.captiveNpc.rescued,
                    hp: battleState.captiveNpc.hp || 1,
                    maxHp: battleState.captiveNpc.maxHp || 1,
                    goldReward: battleState.captiveNpc.goldReward || 0,
                    x: battleState.captiveNpc.x / canvas.width,
                    y: battleState.captiveNpc.y / canvas.height
                } : null,
                currentTurn: battleState.currentTurn,
                // Sync gold to clients
                gold: loadSharedSave()?.dungeonState?.gold || 0
            };
            
            sendWebSocketMessage({ type: 'state_update', state });
        }
        
        function updateGameStateFromHost(state) {
            // Client updates local state from host
            battleState.currentTurn = state.currentTurn;
            
            const canvas = battleState.canvas;
            
            // Rebuild heroes array to handle removals (retreats)
            battleState.heroes = state.heroes.map(heroData => {
                const existingHero = battleState.heroes.find(h => h.name === heroData.name);
                if (existingHero) {
                    // Update ALL fields from host state for complete sync
                    existingHero.hp = heroData.hp;
                    existingHero.maxHp = heroData.maxHp;
                    existingHero.xp = heroData.xp;
                    existingHero.level = heroData.level;
                    existingHero.healsRemaining = heroData.healsRemaining;
                    // Sync potion visibility from host
                    if (existingHero.potions && heroData.potionVisibility) {
                        heroData.potionVisibility.forEach((visible, idx) => {
                            if (existingHero.potions[idx]) {
                                existingHero.potions[idx].visible = visible;
                            }
                        });
                    }
                    existingHero.stats = heroData.stats;
                    existingHero.x = heroData.x * canvas.width;
                    existingHero.y = (heroData.y * canvas.height) - 25;
                    existingHero.platform = heroData.platform;
                    existingHero.defending = heroData.defending;
                    existingHero.taunting = heroData.taunting;
                    existingHero.tauntTurns = heroData.tauntTurns || 0;
                    existingHero.usedHeal = heroData.usedHeal || false;
                    existingHero.facing = heroData.facing;
                    existingHero.retreated = heroData.retreated || false;
                    existingHero.color = heroData.color;
                    existingHero.spritePath = heroData.spritePath;
                    existingHero.initiative = heroData.initiative;
                    return existingHero;
                } else {
                    console.warn('[MP] Received unknown hero:', heroData.name);
                    return null;
                }
            }).filter(h => h !== null);
            
            // Update enemies - rebuild array to handle removals
            battleState.enemies = state.enemies.map(enemyData => {
                const existingEnemy = battleState.enemies.find(e => e.name === enemyData.name);
                if (existingEnemy) {
                    // Update ALL enemy fields from host state for complete sync
                    existingEnemy.hp = enemyData.hp;
                    existingEnemy.maxHp = enemyData.maxHp;
                    existingEnemy.ac = enemyData.ac;
                    existingEnemy.attackDamage = enemyData.attackDamage;
                    existingEnemy.speed = enemyData.speed;
                    existingEnemy.dex = enemyData.dex;
                    existingEnemy.hostile = enemyData.hostile;
                    existingEnemy.x = enemyData.x * canvas.width;
                    existingEnemy.y = (enemyData.y * canvas.height) - 25;
                    existingEnemy.platform = enemyData.platform;
                    existingEnemy.facing = enemyData.facing;
                    existingEnemy.isMob = enemyData.isMob;
                    existingEnemy.isBoss = enemyData.isBoss;
                    existingEnemy.spritePath = enemyData.spritePath;
                    existingEnemy.backstory = enemyData.backstory;
                    existingEnemy.initiative = enemyData.initiative;
                    existingEnemy.goldDrop = enemyData.goldDrop || 0;
                    existingEnemy.species = enemyData.species;
                    return existingEnemy;
                } else {
                    // This shouldn't happen in normal gameplay, but handle it
                    console.warn('[MP] Received unknown enemy:', enemyData.name);
                    return null;
                }
            }).filter(e => e !== null);
            
            // Update captive NPC state from host
            if (state.captiveNpc && battleState.captiveNpc) {
                battleState.captiveNpc.rescued = state.captiveNpc.rescued;
                battleState.captiveNpc.hp = state.captiveNpc.hp;
                battleState.captiveNpc.maxHp = state.captiveNpc.maxHp;
                battleState.captiveNpc.goldReward = state.captiveNpc.goldReward;
                if (state.captiveNpc.x !== undefined) {
                    battleState.captiveNpc.x = state.captiveNpc.x * canvas.width;
                    battleState.captiveNpc.y = state.captiveNpc.y * canvas.height;
                }
            }
            
            // Rebuild turn order to match host
            battleState.turnOrder = state.turnOrder.map(combatantData => {
                return battleState.heroes.find(h => h.name === combatantData.name) || 
                       battleState.enemies.find(e => e.name === combatantData.name);
            }).filter(c => c);
            
            // Update client hero stats cache from host state
            if (multiplayerState.role === 'client') {
                state.heroes.forEach(heroData => {
                    const heroKey = heroData.name.toLowerCase();
                    if (multiplayerState.heroStatsCache[heroKey] !== undefined) {
                        multiplayerState.heroStatsCache[heroKey] = {
                            hp: heroData.hp,
                            maxHp: heroData.maxHp,
                            xp: heroData.xp,
                            level: heroData.level,
                            str: heroData.stats?.str,
                            dex: heroData.stats?.dex,
                            con: heroData.stats?.con,
                            int: heroData.stats?.int,
                            wis: heroData.stats?.wis,
                            cha: heroData.stats?.cha
                        };
                    }
                });
            }
            
            // Check win condition for clients - change retreat button and show notification
            if (multiplayerState.role === 'client' && battleState.enemies.length === 0 && !battleState.won) {
                battleState.won = true;
                showBattleNotification('ROOM CLEARED!');
                const retreatBtn = document.querySelector('.battleButton.retreat');
                if (retreatBtn) {
                    retreatBtn.textContent = 'ðŸšª LEAVE';
                }
            }
            
            // Update gold cache for clients
            if (state.gold !== undefined) {
                multiplayerState.goldCache = state.gold;
                updateGoldDisplay();
            }
            
            // Check if this was a resync response
            if (multiplayerState.awaitingResync) {
                multiplayerState.awaitingResync = false;
                showNotification('âœ… Resynced with host!', 'success');
            }
            
            // Re-render
            renderBattle();
            updateBattleHeroCards();
            updateBattleEnemyCards();
            updateBattleTurnInfo();
            updateChatTargets();  // Refresh chat buttons when enemies die
        }
        
        function initializeBattleFromHost(battleData) {
            // Client receives full battle initialization from host
            // Ensure canvas is initialized
            if (!battleState.canvas) {
                battleState.canvas = document.getElementById('battleCanvas');
                battleState.ctx = battleState.canvas.getContext('2d');
                battleState.canvas.width = window.innerWidth;
                battleState.canvas.height = window.innerHeight - 180;
            }
            
            const canvas = battleState.canvas;
            
            // Set background - check if host is using video
            battleState.backgroundPath = battleData.backgroundPath;
            battleState.backgroundVideoPath = battleData.backgroundVideoPath || '';
            battleState.useVideoBackground = battleData.useVideoBackground || false;
            
            if (battleState.useVideoBackground && battleData.backgroundVideoPath) {
                // Load video background (same as host)
                const videoEl = document.getElementById('battleBackgroundVideo');
                if (videoEl) {
                    videoEl.querySelector('source').src = battleData.backgroundVideoPath;
                    videoEl.load();
                    videoEl.style.display = 'block';
                    
                    videoEl.onloadeddata = () => {
                        console.log('[MP] Client video loaded:', battleData.backgroundVideoPath);
                        
                        // Capture first frame for backgroundImage (used in detection visualization)
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = videoEl.videoWidth;
                        tempCanvas.height = videoEl.videoHeight;
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCtx.drawImage(videoEl, 0, 0);
                        
                        battleState.backgroundImage = new Image();
                        battleState.backgroundImage.onload = () => renderBattle();
                        battleState.backgroundImage.src = tempCanvas.toDataURL('image/png');
                        
                        videoEl.play().catch(e => console.log('[MP] Video autoplay blocked:', e));
                    };
                    
                    videoEl.onerror = () => {
                        console.error('[MP] Client video failed, using fallback');
                        battleState.useVideoBackground = false;
                        videoEl.style.display = 'none';
                        loadClientFallbackBackground(battleData.backgroundPath);
                    };
                } else {
                    loadClientFallbackBackground(battleData.backgroundPath);
                }
            } else {
                // Use static image background
                loadClientFallbackBackground(battleData.backgroundPath);
            }
            
            // Helper function to load static background for client
            function loadClientFallbackBackground(bgPath) {
                battleState.useVideoBackground = false;
                const videoEl = document.getElementById('battleBackgroundVideo');
                if (videoEl) videoEl.style.display = 'none';
                
                battleState.backgroundImage = new Image();
                battleState.backgroundImage.onload = () => renderBattle();
                battleState.backgroundImage.onerror = () => console.error('[MP] Background failed:', bgPath);
                battleState.backgroundImage.src = bgPath;
            }
            
            // Setup heroes with host's data
            battleState.heroes = battleData.heroes.map(hData => {
                const hero = {
                    name: hData.name,
                    hp: hData.hp,
                    maxHp: hData.maxHp,
                    xp: hData.xp,
                    level: hData.level ?? 1,
                    healsRemaining: hData.healsRemaining,
                    stats: hData.stats,
                    color: hData.name === 'Zooko' ? '#F2C94C' : hData.name === 'Nate' ? '#E74C3C' : hData.name === 'Zancas' ? '#27AE60' : '#2E86DE',
                    x: hData.x * canvas.width,
                    y: (hData.y * canvas.height) - 25,
                    platform: hData.platform,
                    initiative: hData.initiative,
                    facing: 'center',
                    sprite: new Image(),
                    spritePath: hData.spritePath
                };
                hero.sprite.onload = () => {
                    renderBattle();
                };
                hero.sprite.onerror = () => {
                    console.error('[MP ERROR] Hero sprite failed:', hero.name, hero.spritePath);
                };
                hero.sprite.src = hero.spritePath + '?v=' + Date.now();
                return hero;
            });
            
            // Initialize animation controllers for heroes (so clients can receive animation_sync)
            battleState.heroes.forEach(hero => {
                const heroKey = hero.name.toLowerCase();
                let idlePath = HERO_ANIM_PATHS[heroKey]?.idle;
                // Handle array of idle variants - pick random one
                if (Array.isArray(idlePath)) {
                    idlePath = idlePath[Math.floor(Math.random() * idlePath.length)];
                }
                if (idlePath) {
                    initAnimation(hero, idlePath, 'pingpong');
                }
                
                // Initialize health potion animations for clients
                // Initialize health potion static sprites for clients
                hero.potions = [{ visible: true }, { visible: true }];
                const potionPath = 'tunnelsofprivacy/items/healing_potions_a_cropped.png';
                hero.potionSprite = new Image();
                hero.potionSprite.onload = () => renderBattle();
                hero.potionSprite.src = potionPath + '?v=' + Date.now();
                
                hero.potions.forEach((potion, idx) => {
                    potion.visible = idx < hero.healsRemaining;  // Show based on heals remaining
                });
                
                // Load backpack sprite for client
                hero.backpackSprite = new Image();
                hero.backpackPath = `tunnelsofprivacy/gear/${heroKey}_backpack.png`;
                hero.backpackSprite.onload = () => renderBattle();
                hero.backpackSprite.src = hero.backpackPath + '?v=' + Date.now();
            });
            
            // Setup enemies with host's data
            battleState.enemies = battleData.enemies.map(eData => {
                const enemy = {
                    name: eData.name,
                    species: eData.species,
                    hp: eData.hp,
                    maxHp: eData.maxHp,
                    ac: eData.ac,
                    attackDamage: eData.attackDamage,
                    speed: eData.speed,
                    dex: eData.dex,
                    hostile: eData.hostile,
                    color: eData.isMob ? '#5C3317' : '#8B45FF',
                    x: eData.x * canvas.width,
                    y: (eData.y * canvas.height) - 25,
                    platform: eData.platform,
                    initiative: eData.initiative,
                    facing: 'center',
                    sprite: new Image(),
                    spritePath: eData.spritePath,
                    isMob: eData.isMob,
                    isBoss: eData.isBoss,
                    goldDrop: eData.goldDrop || 0,
                    backstory: eData.backstory
                };
                enemy.sprite.onload = () => {
                    renderBattle();
                };
                enemy.sprite.onerror = () => {
                    console.error('[MP ERROR] Enemy sprite failed:', enemy.name, enemy.spritePath);
                };
                enemy.sprite.src = enemy.spritePath + '?v=' + Date.now();
                return enemy;
            });
            
            // Setup turn order from host
            const allCombatants = [...battleState.heroes, ...battleState.enemies];
            battleState.turnOrder = battleData.turnOrder.map(name => 
                allCombatants.find(c => c.name === name)
            ).filter(c => c); // Filter out any not found
            
            if (battleState.turnOrder.length === 0) {
                console.error('[MP ERROR] Turn order is empty after initialization!');
            }
            
            // Setup captive NPC from host's data (full mob-like entity)
            if (battleData.captiveNpc) {
                battleState.captiveNpc = {
                    name: battleData.captiveNpc.name,
                    species: battleData.captiveNpc.species,
                    backstory: battleData.captiveNpc.backstory,
                    personality: battleData.captiveNpc.personality,
                    rescueReward: battleData.captiveNpc.rescueReward,
                    goldReward: battleData.captiveNpc.goldReward || battleData.captiveNpc.rescueReward?.gold || 0,
                    dialogueOnRescue: battleData.captiveNpc.dialogueOnRescue,
                    rescued: battleData.captiveNpc.rescued,
                    hp: battleData.captiveNpc.hp || 1,
                    maxHp: battleData.captiveNpc.maxHp || 1,
                    x: battleData.captiveNpc.x * canvas.width,
                    y: battleData.captiveNpc.y * canvas.height,
                    spritePath: battleData.captiveNpc.spritePath,
                    color: battleData.captiveNpc.color || '#F2C94C',
                    sprite: new Image(),
                    isCaptive: true,
                    isMob: false,
                    canChat: true,
                    hostile: false,
                    facing: battleData.captiveNpc.facing || 'center'
                };
                // Handle sprite load with graceful fallback
                battleState.captiveNpc.sprite.onerror = () => {
                    console.log('[MP] Captive sprite not found, using fallback circle');
                };
                battleState.captiveNpc.sprite.onload = () => {
                    renderBattle();
                };
                battleState.captiveNpc.sprite.src = battleState.captiveNpc.spritePath + '?v=' + Date.now();
                console.log('[MP] Captive NPC received:', battleState.captiveNpc.name);
            } else {
                battleState.captiveNpc = null;
            }
            
            battleState.currentTurn = battleData.currentTurn;
            battleState.active = true;
            battleState.targetingMode = false;
            battleState.pendingAction = null;
            battleState.allHeroes = []; // Reset for fresh battle - will be populated on retreat/death
            
            // Update UI
            updateBattleTurnInfo();
            updateBattleHeroCards();
            updateBattleEnemyCards();
            renderBattle();
            
            // Show captive NPC notification if present (same as host)
            if (battleState.captiveNpc) {
                setTimeout(() => {
                    showBattleNotification(`A prisoner is here: ${battleState.captiveNpc.name}!`);
                }, 2000);
            }
            
            // Start battle animation loop for continuous updates
            function battleAnimationLoop() {
                if (battleState.active) {
                    renderBattle();
                    requestAnimationFrame(battleAnimationLoop);
                }
            }
            battleAnimationLoop();
            
            showNotification('Battle initialized!', 'success');
        }
        
        function showNotification(message, type = 'info') {
            // Simple notification system
            const color = type === 'error' ? '#EB5757' : type === 'success' ? '#27AE60' : type === 'warning' ? '#F39C12' : '#3498DB';
            showDiceRoll(message);
        }
        
        // Show rate limit warning on right side of screen
        function showRateLimitWarning() {
            // Remove existing warning if any
            const existing = document.getElementById('rateLimitWarning');
            if (existing) existing.remove();
            
            const warning = document.createElement('div');
            warning.id = 'rateLimitWarning';
            warning.innerHTML = `
                <div style="
                    position: fixed;
                    top: 50%;
                    right: 20px;
                    transform: translateY(-50%);
                    background: linear-gradient(135deg, rgba(235, 87, 87, 0.95), rgba(180, 50, 50, 0.95));
                    border: 2px solid #EB5757;
                    border-radius: 12px;
                    padding: 16px 20px;
                    max-width: 280px;
                    z-index: 10000;
                    backdrop-filter: blur(10px);
                    box-shadow: 0 8px 32px rgba(235, 87, 87, 0.4);
                    animation: slideInRight 0.3s ease-out;
                ">
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                        <span style="font-size: 24px;">âš ï¸</span>
                        <span style="font-weight: 700; font-size: 14px; color: #fff;">LLM Rate Limited</span>
                    </div>
                    <div style="font-size: 12px; color: rgba(255,255,255,0.9); line-height: 1.4; margin-bottom: 12px;">
                        API request limit reached.<br>
                        <strong>Wait 30-60 seconds</strong> and retry,<br>
                        or switch to <strong>Paid Models</strong> in Settings.
                    </div>
                    <button onclick="document.getElementById('rateLimitWarning').remove()" style="
                        background: rgba(255,255,255,0.2);
                        border: 1px solid rgba(255,255,255,0.3);
                        border-radius: 6px;
                        padding: 6px 16px;
                        color: #fff;
                        font-size: 11px;
                        cursor: pointer;
                        width: 100%;
                        transition: background 0.2s;
                    " onmouseover="this.style.background='rgba(255,255,255,0.3)'" onmouseout="this.style.background='rgba(255,255,255,0.2)'">
                        DISMISS
                    </button>
                </div>
            `;
            document.body.appendChild(warning);
            
            // Auto-dismiss after 10 seconds
            setTimeout(() => {
                const el = document.getElementById('rateLimitWarning');
                if (el) el.remove();
            }, 10000);
        }
        
        // Check if error is a rate limit error and show warning
        function checkForRateLimitError(error) {
            if (error && (error.includes('429') || error.toLowerCase().includes('rate limit'))) {
                showRateLimitWarning();
                return true;
            }
            return false;
        }

        // ===== NETWORK DEBUG FUNCTIONS =====
        let debugMessageLog = [];
        const MAX_DEBUG_MESSAGES = 20;
        
        function toggleNetworkDebug() {
            const panel = document.getElementById('networkDebugPanel');
            const checkbox = document.getElementById('networkDebug');
            
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
                if (checkbox) checkbox.checked = true;
            } else {
                panel.style.display = 'none';
                if (checkbox) checkbox.checked = false;
            }
        }
        
        function logDebugMessage(type, data, direction = 'out') {
            const timestamp = new Date().toLocaleTimeString();
            const arrow = direction === 'out' ? 'â¬†ï¸' : 'â¬‡ï¸';
            const color = direction === 'out' ? '#F39C12' : '#3498DB';
            
            debugMessageLog.push({
                timestamp,
                type,
                data,
                direction,
                arrow,
                color
            });
            
            // Keep only last 20 messages
            if (debugMessageLog.length > MAX_DEBUG_MESSAGES) {
                debugMessageLog.shift();
            }
            
            updateDebugLogDisplay();
        }
        
        function updateDebugLogDisplay() {
            const logDiv = document.getElementById('debugMessageLog');
            if (!logDiv) return;
            
            logDiv.innerHTML = debugMessageLog.map(msg => `
                <div style="margin-bottom: 8px; padding: 5px; border-left: 3px solid ${msg.color}; background: rgba(0,0,0,0.3);">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 3px;">
                        <span style="color: #89A0B4; font-size: 10px;">${msg.timestamp}</span>
                        <span style="font-size: 10px;">${msg.arrow} ${msg.type}</span>
                    </div>
                    <div style="color: #E9F0F7; font-size: 10px; word-break: break-word;">${JSON.stringify(msg.data, null, 2).slice(0, 200)}</div>
                </div>
            `).join('');
            
            // Auto-scroll to bottom
            logDiv.scrollTop = logDiv.scrollHeight;
        }
        
        function clearDebugLog() {
            debugMessageLog = [];
            updateDebugLogDisplay();
        }
        
        function updateDebugStatus() {
            const connStatus = document.getElementById('debugConnStatus');
            const roomState = document.getElementById('debugRoomState');
            
            if (connStatus) {
                if (multiplayerState.ws && multiplayerState.ws.readyState === WebSocket.OPEN) {
                    connStatus.textContent = 'âœ… Connected';
                    connStatus.style.color = '#27AE60';
                } else {
                    connStatus.textContent = 'âŒ Disconnected';
                    connStatus.style.color = '#EB5757';
                }
            }
            
            if (roomState) {
                if (multiplayerState.enabled && multiplayerState.roomCode) {
                    const role = multiplayerState.role === 'host' ? 'ðŸ‘‘ HOST' : 'ðŸŽ® CLIENT';
                    const players = multiplayerState.connectedPlayers.length;
                    roomState.innerHTML = `
                        <div>${role}</div>
                        <div style="margin-top: 3px;">Code: <span style="color: #F2C94C; font-weight: bold;">${multiplayerState.roomCode}</span></div>
                        <div style="margin-top: 3px;">Players: ${players}/4</div>
                        <div style="margin-top: 3px;">My Heroes: <span style="color: #F2C94C;">${multiplayerState.myHeroes.join(', ') || 'None'}</span></div>
                    `;
                    roomState.style.color = '#2A9D8F';
                } else {
                    roomState.textContent = 'No room';
                    roomState.style.color = '#89A0B4';
                }
            }
        }
        
        // ===== END MULTIPLAYER FUNCTIONS =====
        
        function init() {
            console.log('Tunnels of Privacy - Initializing...');
            
            // Load settings
            loadSettings();
            console.log('Settings loaded:', settings);
            
            // Check TTS availability
            checkTTSAvailability();
            
            // ===== GAMEPAD SUPPORT =====
            // Handle gamepad connections
            window.addEventListener('gamepadconnected', onGamepadConnected);
            window.addEventListener('gamepaddisconnected', onGamepadDisconnected);
            // Start gamepad polling loop
            gamepadLoop();
            // ===== END GAMEPAD SUPPORT =====
            
            // Preload assets
            preloadAssets();
            
            // Start background animation
            startStoryIntroAnimation();
            
            // Load shared save and display hero stats
            const sharedSave = loadSharedSave();
            const heroStatsEl = document.getElementById('heroStats');
            
            if (sharedSave && sharedSave.heroes) {
                console.log('Loaded shared save with heroes:', sharedSave.heroes);
                
                // Show hero party
                if (heroStatsEl) heroStatsEl.style.display = 'block';
                
                // Update each hero's display
                updateHeroDisplay('zooko', sharedSave.heroes.zooko);
                updateHeroDisplay('nate', sharedSave.heroes.nate);
                updateHeroDisplay('zancas', sharedSave.heroes.zancas);
                updateHeroDisplay('cyberaxe', sharedSave.heroes.cyberaxe);
                
                // Update dungeon level from arcade level
                if (sharedSave.arcadeState && sharedSave.arcadeState.level) {
                    const arcadeLevel = sharedSave.arcadeState.level;
                    document.getElementById('dungeonLevel').textContent = arcadeLevel;
                    console.log('Dungeon depth set to arcade level:', arcadeLevel);
                } else {
                    console.log('No arcade level found - defaulting to level 1');
                }
            } else {
                console.log('No shared save found - hiding hero party');
                // Hide hero party when no save exists
                if (heroStatsEl) heroStatsEl.style.display = 'none';
            }
            
            // Update title screen button states
            updateTitleScreenButtons();
            
            // Initialize hackathon info tooltips
            initTooltipSystem();
            
            // Load level progress stats (total bosses defeated, current level progress)
            loadLevelProgress();
            
            console.log('Initialization complete. Portal system ready.');
        }
        
        // Run init when page loads
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
