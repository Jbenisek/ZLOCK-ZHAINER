<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TUNNELS OF PRIVACY - Dungeon Crawler v0.2.20</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet" media="print" onload="this.media='all'; this.onload=null;">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #0A0E12 0%, #1A1E2A 100%);
            color: #E9F0F7;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            cursor: default;
        }
        
        #gameContainer {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #titleScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 14, 18, 0.95);
            z-index: 100;
            pointer-events: none;
        }
        
        #dungeonMenuScreen {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0A0E12 0%, #1A1E2A 100%);
            z-index: 100;
        }
        
        #battleScreen {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a0f2e 0%, #0f0a1e 100%);
            z-index: 100;
        }
        
        #battleCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: calc(100% - 180px);
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        #battleUI {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 180px;
            background: linear-gradient(180deg, rgba(10, 14, 18, 0) 0%, rgba(10, 14, 18, 0.95) 20%, rgba(10, 14, 18, 0.98) 100%);
            display: flex;
            flex-direction: row;
            align-items: flex-end;
            justify-content: center;
            padding: 15px;
            gap: 15px;
        }
        
        #battleUILeft {
            display: flex;
            flex-direction: row;
            gap: 10px;
            flex-shrink: 0;
        }
        
        #battleUICenter {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            gap: 10px;
        }
        
        #battleUIRight {
            display: flex;
            flex-direction: row;
            gap: 10px;
            flex-shrink: 0;
        }
        
        .battleHeroCard {
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            border: 2px solid #2A9D8F;
            border-radius: 8px;
            padding: 8px;
            width: 140px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
        }
        
        .battleHeroCard.active {
            border-color: #F2C94C;
            box-shadow: 0 0 20px rgba(242, 201, 76, 0.6);
        }
        
        .battleHeroPortrait {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-size: cover;
            background-position: center;
            border: 2px solid #2A9D8F;
            margin: 0 auto 6px auto;
            box-shadow: 0 0 10px rgba(42, 157, 143, 0.4);
        }
        
        .battleHeroName {
            font-family: 'Inter', sans-serif;
            font-size: 11px;
            font-weight: 700;
            text-align: center;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .battleHeroStat {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: #BFD1E0;
            text-align: center;
            margin: 2px 0;
        }
        
        #battleTurnInfo {
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            color: #F2C94C;
            text-shadow: 0 0 10px rgba(242, 201, 76, 0.5);
            margin-bottom: 5px;
        }
        
        #battleActions {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            width: 100%;
            max-width: 700px;
        }
        
        .battleButton {
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            border: 2px solid #2A9D8F;
            color: #E9F0F7;
            font-family: 'Inter', sans-serif;
            font-size: 13px;
            font-weight: 600;
            padding: 12px 8px;
            border-radius: 8px;
            cursor: pointer;
            pointer-events: all;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        
        .battleButton:hover:not(:disabled) {
            background: linear-gradient(135deg, rgba(42, 157, 143, 0.3), rgba(42, 157, 143, 0.2));
            border-color: #3DBAA3;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(42, 157, 143, 0.4);
        }
        
        .battleButton:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        .battleButton.attack-weak { border-color: #3498DB; }
        .battleButton.attack-weak:hover:not(:disabled) { 
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.3), rgba(52, 152, 219, 0.2));
            border-color: #5DADE2;
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
        }
        
        .battleButton.attack-strong { border-color: #E74C3C; }
        .battleButton.attack-strong:hover:not(:disabled) { 
            background: linear-gradient(135deg, rgba(231, 76, 60, 0.3), rgba(231, 76, 60, 0.2));
            border-color: #EC7063;
            box-shadow: 0 6px 20px rgba(231, 76, 60, 0.4);
        }
        
        .battleButton.special { border-color: #F39C12; }
        .battleButton.special:hover:not(:disabled) { 
            background: linear-gradient(135deg, rgba(243, 156, 18, 0.3), rgba(243, 156, 18, 0.2));
            border-color: #F8C471;
            box-shadow: 0 6px 20px rgba(243, 156, 18, 0.4);
        }
        
        .battleButton.defend { border-color: #27AE60; }
        .battleButton.defend:hover:not(:disabled) { 
            background: linear-gradient(135deg, rgba(39, 174, 96, 0.3), rgba(39, 174, 96, 0.2));
            border-color: #52BE80;
            box-shadow: 0 6px 20px rgba(39, 174, 96, 0.4);
        }
        
        .battleButton.heal { border-color: #9B59B6; }
        .battleButton.heal:hover:not(:disabled) { 
            background: linear-gradient(135deg, rgba(155, 89, 182, 0.3), rgba(155, 89, 182, 0.2));
            border-color: #AF7AC5;
            box-shadow: 0 6px 20px rgba(155, 89, 182, 0.4);
        }
        
        .battleButton.retreat { border-color: #95A5A6; }
        .battleButton.retreat:hover:not(:disabled) { 
            background: linear-gradient(135deg, rgba(149, 165, 166, 0.3), rgba(149, 165, 166, 0.2));
            border-color: #BDC3C7;
            box-shadow: 0 6px 20px rgba(149, 165, 166, 0.4);
        }
        
        #pauseScreen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 14, 18, 0.98);
            z-index: 1000;
            pointer-events: all;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        #pauseTitle {
            font-size: 72px;
            font-weight: 900;
            color: #8B45FF;
            text-shadow: 0 0 40px rgba(139, 69, 255, 0.6);
            margin-bottom: 40px;
            letter-spacing: 8px;
        }
        
        #storyIntroBackground {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.3;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            transition: opacity 2s ease-in-out;
        }
        
        #title {
            display: none;
        }
        
        #subtitle {
            display: none;
        }
        
        /* Center Column - Main Menu Buttons */
        #menuButtonsCenter {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            pointer-events: none;
        }
        
        .menuButton {
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            border: 2px solid #2A9D8F;
            color: #E9F0F7;
            font-family: 'Inter', sans-serif;
            font-size: 18px;
            font-weight: 700;
            padding: 14px 40px;
            margin: 8px;
            cursor: pointer;
            transition: all 0.2s;
            border-radius: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
            width: 380px;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: all;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
        }
        
        .menuButton:hover {
            background: linear-gradient(135deg, rgba(20, 27, 34, 0.95), rgba(42, 157, 143, 0.2));
            box-shadow: 0 6px 25px rgba(42, 157, 143, 0.4);
            transform: translateY(-2px);
            border-color: #4ECDC4;
        }
        
        .menuButton:active {
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.98), rgba(15, 19, 24, 0.95));
            transform: translateY(0px);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }
        
        .menuButton:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .portalButton {
            background: linear-gradient(135deg, rgba(139, 69, 255, 0.4), rgba(139, 69, 255, 0.3));
            border-color: #8B45FF;
        }
        
        .portalButton:hover {
            background: linear-gradient(135deg, rgba(139, 69, 255, 0.6), rgba(139, 69, 255, 0.5));
            border-color: #A45FFF;
            box-shadow: 0 5px 20px rgba(139, 69, 255, 0.5);
        }
        
        /* Left Column - Hero Stats (Title Screen) */
        #heroStats {
            position: absolute;
            left: 60px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(20, 27, 34, 0.8);
            border: 2px solid #26313B;
            border-radius: 12px;
            padding: 25px;
            width: 320px;
            pointer-events: all;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
        }
        
        /* Hero Cards in Corners (Dungeon Menu) */
        .dungeonHeroCard {
            position: absolute;
            background: linear-gradient(135deg, rgba(39, 174, 96, 0.1), rgba(39, 174, 96, 0.05));
            border: 1px solid #27AE60;
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            width: 160px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
        }
        
        #dungeonZooko { top: 20px; left: 20px; border-color: #EB5757; box-shadow: 0 0 15px rgba(235, 87, 87, 0.3); }
        #dungeonNate { bottom: 80px; left: 20px; border-color: #F2C94C; box-shadow: 0 0 15px rgba(242, 201, 76, 0.3); }
        #dungeonZancas { top: 20px; right: 20px; border-color: #27AE60; box-shadow: 0 0 15px rgba(39, 174, 96, 0.3); }
        #dungeonCyberAxe { bottom: 80px; right: 20px; border-color: #2E86DE; box-shadow: 0 0 15px rgba(46, 134, 222, 0.3); }
        
        .heroRow {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 12px;
        }
        
        .heroCard {
            background: linear-gradient(135deg, rgba(39, 174, 96, 0.1), rgba(39, 174, 96, 0.05));
            border: 1px solid #27AE60;
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            position: relative;
        }
        
        .heroPortrait {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            margin: 0 auto 8px auto;
            background-size: cover;
            background-position: center;
            border: 2px solid #27AE60;
            box-shadow: 0 0 10px rgba(39, 174, 96, 0.4);
        }
        
        .heroName {
            font-weight: 700;
            font-size: 14px;
            color: #F2C94C;
            margin-bottom: 8px;
        }
        
        .heroStat {
            font-size: 11px;
            color: #ffffff;
            margin: 2px 0;
            font-family: 'JetBrains Mono', monospace;
            font-weight: 700;
        }
        
        #versionDisplay {
            position: absolute;
            bottom: 20px;
            right: 20px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: #5A7A8F;
        }
        
        .comingSoon {
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            border-color: #EB5757;
            color: #EB5757;
        }
        
        .comingSoon:hover {
            background: linear-gradient(135deg, rgba(235, 87, 87, 0.2), rgba(235, 87, 87, 0.1));
            box-shadow: 0 6px 25px rgba(235, 87, 87, 0.4);
            transform: translateY(-2px);
            border-color: #FF6B6B;
        }
        
        /* Center Column - Level Display (at top of center buttons) */
        #dungeonLevelDisplay {
            text-align: center;
            padding: 15px;
            background: linear-gradient(135deg, rgba(139, 69, 255, 0.2), rgba(75, 0, 130, 0.2));
            border: 2px solid #8B45FF;
            border-radius: 10px;
            width: 380px;
            pointer-events: none;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            margin-bottom: 20px;
        }
        
        /* Music Ticker */
        #musicTicker {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(42, 157, 143, 0.3);
            border: 2px solid #2A9D8F;
            border-radius: 8px;
            overflow: hidden;
            width: 400px;
            max-width: 25%;
            z-index: 500;
            pointer-events: auto;
        }
        
        #musicTickerWrapper {
            display: flex;
            width: fit-content;
            animation: scrollTicker 30s linear infinite;
        }
        
        #musicTicker:hover #musicTickerWrapper {
            animation-duration: 60s;
        }
        
        .tickerText {
            color: #F2C94C;
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            font-weight: 700;
            white-space: nowrap;
            padding-right: 100px;
        }
        
        @keyframes scrollTicker {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }
        
        /* Music Control Panel - Bottom of Screen Above Ticker */
        #musicControls {
            position: fixed;
            bottom: 65px;
            left: 10px;
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            border: 2px solid #2A9D8F;
            border-radius: 8px;
            padding: 12px;
            min-width: 240px;
            max-width: 25%;
            pointer-events: auto;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8);
            z-index: 500;
        }
        
        .musicControlTitle {
            margin: 0 0 10px 0;
            color: #2A9D8F;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            text-align: center;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .musicButton {
            padding: 8px 16px;
            background: linear-gradient(135deg, rgba(42, 157, 143, 0.4), rgba(42, 157, 143, 0.3));
            border: 2px solid #2A9D8F;
            color: #F2C94C;
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            font-weight: bold;
            margin: 3px 0;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 6px;
            width: 100%;
            text-align: center;
        }
        
        .musicButton:hover {
            background: linear-gradient(135deg, rgba(42, 157, 143, 0.6), rgba(42, 157, 143, 0.5));
            border-color: #2ECC71;
        }
        
        .musicButton:active {
            transform: translateY(1px);
        }
        
        .volumeControl {
            margin: 10px 0 0 0;
        }
        
        .volumeLabel {
            color: #BFD1E0;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            display: block;
            margin-bottom: 4px;
        }
        
        .volumeSlider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(139, 69, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }
        
        .volumeSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #8B45FF;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(139, 69, 255, 0.5);
        }
        
        .volumeSlider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #8B45FF;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 5px rgba(139, 69, 255, 0.5);
        }
        
        #overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 14, 18, 0.9);
            z-index: 150;
            pointer-events: all;
        }
        
        #settingsPanel {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9));
            border: 2px solid #2A9D8F;
            border-radius: 12px;
            padding: 25px;
            max-width: 450px;
            width: auto;
            z-index: 1100;
            pointer-events: all;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
        }
        
        .panelTitle {
            font-size: 28px;
            font-weight: 900;
            color: #2A9D8F;
            margin-bottom: 20px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .settingRow {
            margin: 20px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .settingLabel {
            font-size: 18px;
            color: #E9F0F7;
        }
        
        input[type="range"] {
            width: 200px;
        }
        
        /* Loading Screen Styles */
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }
        
        @keyframes slowBlink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
    </style>
</head>
<body>
    <!-- Loading Modal -->
    <div id="loadingModal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.95); display: flex; align-items: center; justify-content: center; z-index: 10000;">
        <div style="background: linear-gradient(135deg, #1a2332 0%, #0d1218 100%); padding: 40px 60px; border-radius: 15px; border: 2px solid #8B45FF; box-shadow: 0 10px 50px rgba(139, 69, 255, 0.5); text-align: center; min-width: 500px;">
            <div style="font-size: 48px; margin-bottom: 20px; animation: pulse 1.5s ease-in-out infinite;">üè∞</div>
            <div style="font-size: 24px; font-weight: bold; color: #8B45FF; margin-bottom: 10px;">TUNNELS OF PRIVACY</div>
            <div style="font-size: 14px; color: #F2C94C; margin-bottom: 15px; font-style: italic;">A Dungeon Crawler Adventure</div>
            <div id="loadingNote" style="font-size: 12px; color: #BFD1E0; margin-bottom: 20px; line-height: 1.5;">Loading assets... This may take a moment on first visit</div>
            
            <!-- Category breakdown -->
            <div style="margin-bottom: 15px; text-align: left; font-size: 13px; color: #BFD1E0;">
                <div id="loadingArt" style="margin-bottom: 5px;">üé® Art: <span style="color: #8B45FF; font-weight: bold;">0/0</span></div>
                <div id="loadingSound" style="margin-bottom: 5px;">üîä Sound: <span style="color: #8B45FF; font-weight: bold;">0/0</span></div>
            </div>
            
            <!-- Overall progress -->
            <div id="loadingIndicator" style="font-size: 18px; color: #2ECC71; margin-bottom: 20px; font-weight: bold;">0%</div>
            
            <div style="width: 100%; height: 30px; background: rgba(139, 69, 255, 0.2); border-radius: 15px; overflow: hidden; border: 1px solid #8B45FF;">
                <div id="loadingBar" style="height: 100%; width: 0%; background: linear-gradient(90deg, #8B45FF, #2ECC71); transition: width 0.3s ease; border-radius: 15px; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 14px;"></div>
            </div>
            
            <!-- Click to Play prompt (hidden until ready) -->
            <div id="clickToPlayPrompt" style="display: none; margin-top: 30px; font-size: 24px; color: #2ECC71; font-weight: bold; animation: slowBlink 2s ease-in-out infinite; cursor: pointer;">
                <div style="margin-bottom: 10px;">üéÆ CLICK TO ENTER üéÆ</div>
                <div style="font-size: 14px; color: #89A0B4;">
                    <span style="display: inline-block; padding: 5px 10px; background: rgba(52, 152, 219, 0.3); border-radius: 5px; margin-right: 5px;">MOUSE</span>
                    or
                    <span style="display: inline-block; padding: 5px 10px; background: rgba(46, 204, 113, 0.3); border-radius: 5px; margin-left: 5px;">üéÆ A</span>
                </div>
            </div>
        </div>
    </div>
    
    <div id="gameContainer">
        <!-- Dungeon Menu Screen -->
        <div id="dungeonMenuScreen">
            <!-- Hero Cards in Corners -->
            <div class="dungeonHeroCard" id="dungeonZooko">
                <div class="heroPortrait" style="background-image: url('people/zooko_a_head_compressed.png'); border-color: #EB5757; box-shadow: 0 0 10px rgba(235, 87, 87, 0.4);"></div>
                <div class="heroName" style="color: #EB5757;">ZOOKO</div>
                <div class="heroStat" style="color: #ff6b6b; font-size: 12px; margin: 4px 0;">HP: <span id="dzooko-hp">22</span>/<span id="dzooko-maxhp">25</span></div>
                <div class="heroStat">STR: <span id="dzooko-str">8</span>  INT: <span id="dzooko-int">15</span></div>
                <div class="heroStat">DEX: <span id="dzooko-dex">11</span>  WIS: <span id="dzooko-wis">13</span></div>
                <div class="heroStat">CON: <span id="dzooko-con">10</span>  CHA: <span id="dzooko-cha">12</span></div>
            </div>
            
            <div class="dungeonHeroCard" id="dungeonNate">
                <div class="heroPortrait" style="background-image: url('people/Nate_a_head_compressed.png'); border-color: #F2C94C; box-shadow: 0 0 10px rgba(242, 201, 76, 0.4);"></div>
                <div class="heroName" style="color: #F2C94C;">NATE</div>
                <div class="heroStat" style="color: #ff6b6b; font-size: 12px; margin: 4px 0;">HP: <span id="dnate-hp">28</span>/<span id="dnate-maxhp">30</span></div>
                <div class="heroStat">STR: <span id="dnate-str">14</span>  INT: <span id="dnate-int">10</span></div>
                <div class="heroStat">DEX: <span id="dnate-dex">12</span>  WIS: <span id="dnate-wis">9</span></div>
                <div class="heroStat">CON: <span id="dnate-con">13</span>  CHA: <span id="dnate-cha">11</span></div>
            </div>
            
            <div class="dungeonHeroCard" id="dungeonZancas">
                <div class="heroPortrait" style="background-image: url('people/Zancas_a_head_compressed.png'); border-color: #27AE60; box-shadow: 0 0 10px rgba(39, 174, 96, 0.4);"></div>
                <div class="heroName" style="color: #27AE60;">ZANCAS</div>
                <div class="heroStat" style="color: #ff6b6b; font-size: 12px; margin: 4px 0;">HP: <span id="dzancas-hp">24</span>/<span id="dzancas-maxhp">26</span></div>
                <div class="heroStat">STR: <span id="dzancas-str">10</span>  INT: <span id="dzancas-int">12</span></div>
                <div class="heroStat">DEX: <span id="dzancas-dex">15</span>  WIS: <span id="dzancas-wis">14</span></div>
                <div class="heroStat">CON: <span id="dzancas-con">11</span>  CHA: <span id="dzancas-cha">13</span></div>
            </div>
            
            <div class="dungeonHeroCard" id="dungeonCyberAxe">
                <div class="heroPortrait" style="background-image: url('people/cyberaxe_a_head_compressed.png'); border-color: #2E86DE; box-shadow: 0 0 10px rgba(46, 134, 222, 0.4);"></div>
                <div class="heroName" style="color: #2E86DE;">CYBERAXE</div>
                <div class="heroStat" style="color: #ff6b6b; font-size: 12px; margin: 4px 0;">HP: <span id="dcyberaxe-hp">32</span>/<span id="dcyberaxe-maxhp">35</span></div>
                <div class="heroStat">STR: <span id="dcyberaxe-str">16</span>  INT: <span id="dcyberaxe-int">8</span></div>
                <div class="heroStat">DEX: <span id="dcyberaxe-dex">10</span>  WIS: <span id="dcyberaxe-wis">11</span></div>
                <div class="heroStat">CON: <span id="dcyberaxe-con">14</span>  CHA: <span id="dcyberaxe-cha">9</span></div>
            </div>
            
            <!-- Center Menu -->
            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); display: flex; flex-direction: column; align-items: center; gap: 12px;">
                <div style="text-align: center; padding: 15px; background: linear-gradient(135deg, rgba(139, 69, 255, 0.2), rgba(75, 0, 130, 0.2)); border: 2px solid #8B45FF; border-radius: 10px; width: 380px; backdrop-filter: blur(10px); box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4); margin-bottom: 10px;">
                    <div style="color: #BFD1E0; font-size: 14px; margin-bottom: 5px;">Dungeon Menu</div>
                    <div style="color: #F2C94C; font-size: 28px; font-weight: 900; text-shadow: 0 0 20px rgba(242, 201, 76, 0.5);">LEVEL <span id="dungeonMenuLevel">1</span></div>
                </div>
                
                <button class="menuButton" onclick="startBattle()">EXPLORE LEVEL</button>
                <button class="menuButton comingSoon" disabled>ENTER LEVEL STORE<br><span style="font-size: 12px; font-weight: 400;">(If Found)</span></button>
                <button class="menuButton">INVENTORY</button>
                <button class="menuButton">REST / SLEEP</button>
            </div>
        </div>
        
        <!-- Battle Screen -->
        <div id="battleScreen">
            <canvas id="battleCanvas"></canvas>
            <div id="battleUI">
                <!-- Left Hero Cards: Zooko & Nate -->
                <div id="battleUILeft">
                    <div class="battleHeroCard" id="battleCardZooko">
                        <div class="battleHeroPortrait" style="background-image: url('people/zooko_a_head_compressed.png'); border-color: #F2C94C;"></div>
                        <div class="battleHeroName" style="color: #F2C94C;">ZOOKO</div>
                        <div class="battleHeroStat" style="color: #ff6b6b;">HP: <span id="bzooko-hp">30</span>/<span id="bzooko-maxhp">30</span></div>
                        <div class="battleHeroStat">AC: <span id="bzooko-ac">12</span></div>
                    </div>
                    <div class="battleHeroCard" id="battleCardNate">
                        <div class="battleHeroPortrait" style="background-image: url('people/Nate_a_head_compressed.png'); border-color: #E74C3C;"></div>
                        <div class="battleHeroName" style="color: #E74C3C;">NATE</div>
                        <div class="battleHeroStat" style="color: #ff6b6b;">HP: <span id="bnate-hp">28</span>/<span id="bnate-maxhp">30</span></div>
                        <div class="battleHeroStat">AC: <span id="bnate-ac">14</span></div>
                    </div>
                </div>
                
                <!-- Center Action Bar -->
                <div id="battleUICenter">
                    <div id="battleTurnInfo">ZOOKO'S TURN</div>
                    <div id="battleActions">
                        <button class="battleButton attack-weak" onclick="battleAction('weakAttack')">‚öî WEAK ATTACK</button>
                        <button class="battleButton attack-strong" onclick="battleAction('strongAttack')">‚ö° STRONG ATTACK</button>
                        <button class="battleButton special" onclick="battleAction('special')">‚ú® SPECIAL</button>
                        <button class="battleButton defend" onclick="battleAction('defend')">üõ° DEFEND</button>
                        <button class="battleButton heal" onclick="battleAction('heal')" disabled>üíö HEAL</button>
                        <button class="battleButton" onclick="battleAction('skip')">‚è≠ SKIP</button>
                        <button class="battleButton" onclick="battleAction('talk')">üí¨ TALK</button>
                        <button class="battleButton retreat" onclick="battleAction('retreat')">üèÉ RETREAT</button>
                    </div>
                </div>
                
                <!-- Right Hero Cards: Zancas & CyberAxe -->
                <div id="battleUIRight">
                    <div class="battleHeroCard" id="battleCardZancas">
                        <div class="battleHeroPortrait" style="background-image: url('people/Zancas_a_head_compressed.png'); border-color: #27AE60;"></div>
                        <div class="battleHeroName" style="color: #27AE60;">ZANCAS</div>
                        <div class="battleHeroStat" style="color: #ff6b6b;">HP: <span id="bzancas-hp">24</span>/<span id="bzancas-maxhp">26</span></div>
                        <div class="battleHeroStat">AC: <span id="bzancas-ac">15</span></div>
                    </div>
                    <div class="battleHeroCard" id="battleCardCyberAxe">
                        <div class="battleHeroPortrait" style="background-image: url('people/cyberaxe_a_head_compressed.png'); border-color: #2E86DE;"></div>
                        <div class="battleHeroName" style="color: #2E86DE;">CYBERAXE</div>
                        <div class="battleHeroStat" style="color: #ff6b6b;">HP: <span id="bcyberaxe-hp">32</span>/<span id="bcyberaxe-maxhp">35</span></div>
                        <div class="battleHeroStat">AC: <span id="bcyberaxe-ac">15</span></div>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="titleScreen">
            <!-- Story Intro Background Animation -->
            <div id="storyIntroBackground"></div>
            
            <div id="title">TUNNELS OF PRIVACY</div>
            <div id="subtitle">A Dungeon Crawler Adventure</div>
            
            <!-- Left Column - Hero Party -->
            <div id="heroStats">
                <h3 style="color: #F2C94C; margin-bottom: 12px; text-align: center; font-size: 16px;">Hero Party</h3>
                <div class="heroRow">
                    <div class="heroCard" style="border-color: #EB5757; box-shadow: 0 0 15px rgba(235, 87, 87, 0.3);">
                        <div class="heroPortrait" style="background-image: url('people/zooko_a_head_compressed.png'); border-color: #EB5757; box-shadow: 0 0 10px rgba(235, 87, 87, 0.4);"></div>
                        <div class="heroName" style="color: #EB5757;">ZOOKO</div>
                        <div class="heroStat" style="color: #ff6b6b; font-size: 12px; margin: 4px 0;">HP: <span id="zooko-hp">22</span>/<span id="zooko-maxhp">25</span></div>
                        <div class="heroStat">STR: <span id="zooko-str">8</span>  INT: <span id="zooko-int">15</span></div>
                        <div class="heroStat">DEX: <span id="zooko-dex">11</span>  WIS: <span id="zooko-wis">13</span></div>
                        <div class="heroStat">CON: <span id="zooko-con">10</span>  CHA: <span id="zooko-cha">12</span></div>
                    </div>
                    <div class="heroCard" style="border-color: #F2C94C; box-shadow: 0 0 15px rgba(242, 201, 76, 0.3);">
                        <div class="heroPortrait" style="background-image: url('people/Nate_a_head_compressed.png'); border-color: #F2C94C; box-shadow: 0 0 10px rgba(242, 201, 76, 0.4);"></div>
                        <div class="heroName" style="color: #F2C94C;">NATE</div>
                        <div class="heroStat" style="color: #ff6b6b; font-size: 12px; margin: 4px 0;">HP: <span id="nate-hp">28</span>/<span id="nate-maxhp">30</span></div>
                        <div class="heroStat">STR: <span id="nate-str">14</span>  INT: <span id="nate-int">10</span></div>
                        <div class="heroStat">DEX: <span id="nate-dex">12</span>  WIS: <span id="nate-wis">9</span></div>
                        <div class="heroStat">CON: <span id="nate-con">13</span>  CHA: <span id="nate-cha">11</span></div>
                    </div>
                    <div class="heroCard" style="border-color: #27AE60; box-shadow: 0 0 15px rgba(39, 174, 96, 0.3);">
                        <div class="heroPortrait" style="background-image: url('people/Zancas_a_head_compressed.png'); border-color: #27AE60; box-shadow: 0 0 10px rgba(39, 174, 96, 0.4);"></div>
                        <div class="heroName" style="color: #27AE60;">ZANCAS</div>
                        <div class="heroStat" style="color: #ff6b6b; font-size: 12px; margin: 4px 0;">HP: <span id="zancas-hp">24</span>/<span id="zancas-maxhp">26</span></div>
                        <div class="heroStat">STR: <span id="zancas-str">10</span>  INT: <span id="zancas-int">12</span></div>
                        <div class="heroStat">DEX: <span id="zancas-dex">15</span>  WIS: <span id="zancas-wis">14</span></div>
                        <div class="heroStat">CON: <span id="zancas-con">11</span>  CHA: <span id="zancas-cha">13</span></div>
                    </div>
                    <div class="heroCard" style="border-color: #2E86DE; box-shadow: 0 0 15px rgba(46, 134, 222, 0.3);">
                        <div class="heroPortrait" style="background-image: url('people/cyberaxe_a_head_compressed.png'); border-color: #2E86DE; box-shadow: 0 0 10px rgba(46, 134, 222, 0.4);"></div>
                        <div class="heroName" style="color: #2E86DE;">CYBERAXE</div>
                        <div class="heroStat" style="color: #ff6b6b; font-size: 12px; margin: 4px 0;">HP: <span id="cyberaxe-hp">32</span>/<span id="cyberaxe-maxhp">35</span></div>
                        <div class="heroStat">STR: <span id="cyberaxe-str">16</span>  INT: <span id="cyberaxe-int">8</span></div>
                        <div class="heroStat">DEX: <span id="cyberaxe-dex">10</span>  WIS: <span id="cyberaxe-wis">11</span></div>
                        <div class="heroStat">CON: <span id="cyberaxe-con">14</span>  CHA: <span id="cyberaxe-cha">9</span></div>
                    </div>
                </div>
                <div style="text-align: center; margin-top: 15px; color: #89A0B4; font-size: 13px;">
                    Dungeon gameplay coming soon! Portal system is now active.
                </div>
            </div>
            
            <!-- Center Column - Level Display, Menu Buttons, Music Controls -->
            <div id="menuButtonsCenter">
                <div id="dungeonLevelDisplay">
                    <div style="color: #BFD1E0; font-size: 14px; margin-bottom: 5px;">Current Dungeon Depth</div>
                    <div style="color: #F2C94C; font-size: 36px; font-weight: 900; text-shadow: 0 0 20px rgba(242, 201, 76, 0.5);">LEVEL <span id="dungeonLevel">1</span></div>
                </div>
                
                <button id="startAdventureBtn" class="menuButton" onclick="startAdventure()">START ADVENTURE<span style="display: inline-block; width: 26px; height: 26px; background: #27AE60; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">A</span></button>
                <button id="continueBtn" class="menuButton comingSoon" disabled onclick="continueGame()">CONTINUE<span style="display: inline-block; width: 26px; height: 26px; background: #EB5757; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">A</span></button>
                <button class="menuButton" onclick="showLoadSave()">LOAD SAVE FILE<span style="display: inline-block; width: 26px; height: 26px; background: #3498DB; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">B</span></button>
                <button class="menuButton" onclick="showSettings()">SETTINGS<span style="display: inline-block; width: 26px; height: 26px; background: #2A9D8F; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">Y</span></button>
                <button class="menuButton portalButton" onclick="exitPortal()">EXIT PORTAL<br><span style="font-size: 10px; font-weight: 400;">(Return to Arcade)</span><span style="display: inline-block; padding: 4px 10px; background: #8B45FF; border-radius: 5px; margin-left: 10px; font-weight: bold; color: white; font-size: 12px;">BACK</span></button>
            </div>
            
            <div id="versionDisplay">Tunnels of Privacy v0.2.16 ‚Ä¢ Portal System Active</div>
        </div>
        
        <!-- Music Control Panel - Bottom Above Ticker (OUTSIDE titleScreen so always visible) -->
        <div id="musicControls">
            <h3 class="musicControlTitle">üéµ Music Controls</h3>
            
            <!-- Playback Controls -->
            <div style="display: flex; gap: 6px; justify-content: center; margin-bottom: 12px;">
                <button onclick="musicPrevious()" class="musicButton" style="padding: 8px 12px; width: auto;">‚èÆ</button>
                <button id="musicPlayPauseBtn" onclick="musicPlayPause()" class="musicButton" style="padding: 8px 16px; border-color: #F2C94C; width: auto;">‚ñ∂</button>
                <button onclick="musicNext()" class="musicButton" style="padding: 8px 12px; width: auto;">‚è≠</button>
            </div>
            
            <!-- Volume Control -->
            <div style="margin-bottom: 12px;">
                <label style="color: #BFD1E0; font-family: 'JetBrains Mono', monospace; font-size: 10px; display: block; margin-bottom: 4px; text-align: center;">Volume:</label>
                <div style="display: flex; align-items: center; gap: 8px; justify-content: center;">
                    <input type="range" class="volumeSlider" id="volumeSlider" min="1" max="150" value="75" oninput="updateVolume()" style="flex: 1; max-width: 200px;">
                    <span id="volumeSliderValue" style="color: #2D9CDB; font-family: 'JetBrains Mono', monospace; font-size: 10px; font-weight: bold; min-width: 30px; text-align: right;">75</span>
                </div>
            </div>
        </div>
        
        <!-- Music Ticker (OUTSIDE titleScreen so always visible) -->
        <div id="musicTicker">
            <div id="musicTickerWrapper">
                <span class="tickerText" id="musicTickerText1">‚ô´ Theme Song ‚ô´</span>
                <span class="tickerText" id="musicTickerText2">‚ô´ Theme Song ‚ô´</span>
            </div>
        </div>
    </div>
    
    <!-- Pause Screen -->
    <div id="pauseScreen">
        <div id="pauseTitle">PAUSED</div>
        <button class="menuButton" onclick="resumeGame()">RESUME<span style="display: inline-block; width: 26px; height: 26px; background: #E74C3C; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">B</span></button>
        <button class="menuButton" onclick="saveGameFromPause()" style="background: linear-gradient(135deg, rgba(46, 134, 222, 0.4), rgba(46, 134, 222, 0.3)); border-color: #3498DB;">SAVE GAME<span style="display: inline-block; width: 26px; height: 26px; background: #3498DB; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">üíæ</span></button>
        <button class="menuButton" onclick="downloadSaveFile()" style="background: linear-gradient(135deg, rgba(39, 174, 96, 0.4), rgba(39, 174, 96, 0.3)); border-color: #27AE60;">SAVE GAME FILE<span style="display: inline-block; width: 26px; height: 26px; background: #27AE60; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">‚¨á</span></button>
        <button class="menuButton" onclick="showSettingsFromPause()">SETTINGS<span style="display: inline-block; width: 26px; height: 26px; background: #F39C12; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">Y</span></button>
        <button class="menuButton" onclick="quitToMenu()">QUIT TO MENU<span style="display: inline-block; padding: 4px 10px; background: #555; border-radius: 5px; margin-left: 10px; font-weight: bold; color: white; font-size: 12px;">‚óÄ</span></button>
    </div>
    
    <!-- Overlay for modal panels -->
    <div id="overlay" onclick="closeAllPanels()"></div>
    
    <!-- Settings Panel -->
    <div id="settingsPanel">
        <div class="panelTitle">SETTINGS</div>
        
        <!-- Music Controls -->
        <div class="settingRow" style="margin-bottom: 10px;">
            <span class="settingLabel" style="font-size: 16px;">Music Enabled</span>
            <input type="checkbox" id="musicEnabled" checked onchange="updateSettings()">
        </div>
        
        <div class="settingRow" style="margin-bottom: 15px;">
            <span class="settingLabel" style="font-size: 16px;">Music Volume</span>
            <input type="range" id="musicVolume" min="1" max="150" value="75" oninput="updateSettings()" style="width: 150px;">
            <span id="musicVolumeValue" style="margin-left: 8px; font-weight: bold; color: #2D9CDB; font-size: 14px;">75</span>
        </div>
        
        <!-- Hitbox Toggle -->
        <div class="settingRow" style="margin-bottom: 15px;">
            <span class="settingLabel" style="font-size: 16px;">Show Hitboxes</span>
            <input type="checkbox" id="showHitboxes" onchange="updateSettings()">
        </div>
        
        <div style="margin: 10px 0; padding: 10px; background: rgba(42, 157, 143, 0.1); border-radius: 5px; font-size: 11px; color: #89A0B4;">
            üí° Settings are saved independently for Tunnels of Privacy
        </div>
        
        <button class="menuButton" onclick="clearCache()" style="margin-top: 15px; width: 100%; padding: 12px; font-size: 14px; background: linear-gradient(135deg, rgba(235, 87, 87, 0.4), rgba(235, 87, 87, 0.3)); border-color: #EB5757;">CLEAR CACHE<span style="display: inline-block; width: 26px; height: 26px; background: #EB5757; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">X</span></button>
        <button class="menuButton" onclick="closeAllPanels()" style="margin-top: 15px; width: 100%; padding: 12px; font-size: 14px;">CLOSE<span style="display: inline-block; width: 26px; height: 26px; background: #E74C3C; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">B</span></button>
        
        <div style="display: block; width: 100%; margin-top: 15px; padding: 10px 0; text-align: center; font-family: 'JetBrains Mono', monospace; font-size: 11px; color: #5A7A8F; border-top: 1px solid rgba(255, 255, 255, 0.1);">
            Tunnels of Privacy v0.2.16
        </div>
    </div>
    
    <!-- Load Save Panel -->
    <div id="loadSavePanel" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, rgba(10, 14, 18, 0.95), rgba(20, 27, 34, 0.9)); border: 2px solid #3498DB; border-radius: 12px; padding: 25px; max-width: 600px; width: 85vw; z-index: 200; pointer-events: all; box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8); backdrop-filter: blur(10px);">
        <div class="panelTitle" style="color: #3498DB;">LOAD SAVE FILE</div>
        
        <div style="margin: 15px 0; padding: 15px; background: rgba(52, 152, 219, 0.1); border-radius: 8px; border: 1px solid rgba(52, 152, 219, 0.3);">
            <div style="color: #BFD1E0; font-family: 'JetBrains Mono', monospace; font-size: 12px; margin-bottom: 10px;">
                üì• Import save file from arcade game or previous dungeon run
            </div>
            <input type="file" id="saveFileInput" accept=".json" style="display: block; width: 100%; padding: 10px; background: rgba(10, 14, 18, 0.8); border: 2px solid #3498DB; border-radius: 6px; color: #E9F0F7; font-family: 'JetBrains Mono', monospace; font-size: 12px; cursor: pointer; margin-bottom: 10px;">
            <button class="menuButton" onclick="loadSaveFile()" style="width: 100%; margin: 0;">LOAD FILE<span style="display: inline-block; width: 26px; height: 26px; background: #27AE60; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">A</span></button>
        </div>
        
        <div style="margin: 15px 0; padding: 10px; background: rgba(241, 196, 15, 0.1); border-radius: 5px; font-size: 11px; color: #89A0B4;">
            üí° You can export save files from the arcade game's settings menu. This allows you to continue your adventure with the same hero stats and progress.
        </div>
        
        <button class="menuButton" onclick="closeAllPanels()" style="margin-top: 15px; width: 100%; padding: 12px; font-size: 14px;">CLOSE<span style="display: inline-block; width: 26px; height: 26px; background: #E74C3C; border-radius: 50%; text-align: center; line-height: 26px; margin-left: 10px; font-weight: bold; color: white; font-size: 14px;">B</span></button>
    </div>

    <script>
        // Portal System - localStorage keys with "top_" prefix
        const STORAGE_KEYS = {
            SETTINGS: 'top_tunnels_settings',
            SHARED_SAVE: 'top_shared_save'
        };
        
        const GAME_VERSION = 'v0.2.18';
        
        // ===== GAMEPAD SUPPORT =====
        let gamepadConnected = false;
        let gamepadIndex = null;
        let gamepadButtonStates = {};
        let gamepadAxisDeadzone = 0.25;
        let lastGamepadUpdate = 0;
        const gamepadUpdateInterval = 16; // ~60Hz polling
        
        // Button mapping (standard gamepad layout)
        const GamepadButtons = {
            A: 0,           // Bottom face button (A on Xbox, X on PlayStation)
            B: 1,           // Right face button (B on Xbox, Circle on PlayStation)
            X: 2,           // Left face button (X on Xbox, Square on PlayStation)
            Y: 3,           // Top face button (Y on Xbox, Triangle on PlayStation)
            LB: 4,          // Left bumper
            RB: 5,          // Right bumper
            LT: 6,          // Left trigger
            RT: 7,          // Right trigger
            SELECT: 8,      // Select/Back/Share
            START: 9,       // Start/Menu/Options
            L3: 10,         // Left stick button
            R3: 11,         // Right stick button
            DPAD_UP: 12,
            DPAD_DOWN: 13,
            DPAD_LEFT: 14,
            DPAD_RIGHT: 15
        };
        
        // Axis mapping
        const GamepadAxes = {
            LEFT_X: 0,
            LEFT_Y: 1,
            RIGHT_X: 2,
            RIGHT_Y: 3
        };
        // ===== END GAMEPAD SUPPORT =====
        
        // Music System
        let currentMusic = null;
        let musicEnabled = true;
        let musicVolume = 75; // Music volume (1-150)
        let musicStarted = false;
        let currentTrackIndex = 0;
        
        // Asset loading tracking
        let assetsToLoad = 0;
        let assetsLoaded = 0;
        let artTotal = 0;
        let artLoaded = 0;
        let audioTotal = 0;
        let audioLoaded = 0;
        let allAssetsReady = false;
        
        // Ticker facts system
        let tickerFacts = [];
        let currentTickerFact = '';
        
        // Game state
        let isPaused = false;
        let currentScreen = 'title'; // 'title', 'dungeonMenu', 'exploration'
        
        // Load ticker facts from JSON file
        fetch('ticker_facts.json')
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                tickerFacts = data.facts;
                
                // Pick initial random fact
                if (tickerFacts.length > 0) {
                    currentTickerFact = tickerFacts[Math.floor(Math.random() * tickerFacts.length)];
                }
            })
            .catch(err => {});
        
        // ===== STORY INTRO BACKGROUND ANIMATION =====
        // intro_a.png is 8x16 atlas (128 frames) at 16fps
        let storyIntroCurrentFrame = 0;
        let storyIntroDirection = 1; // 1 = forward, -1 = backward (ping-pong)
        let storyIntroIntervalId = null;
        const INTRO_COLS = 8;
        const INTRO_ROWS = 16;
        const INTRO_TOTAL_FRAMES = 128;
        const INTRO_FPS = 16;
        
        function startStoryIntroAnimation() {
            const bgElement = document.getElementById('storyIntroBackground');
            if (!bgElement) return;
            
            // Use dungeon intro animation
            const imageFile = 'story/intro/intro_a.png';
            
            // Set intro_a atlas as background
            bgElement.style.backgroundImage = `url('${imageFile}')`;
            bgElement.style.backgroundSize = `${INTRO_COLS * 100}% ${INTRO_ROWS * 100}%`;
            bgElement.style.opacity = '1';
            
            // Start frame animation at 16fps
            const frameInterval = 1000 / INTRO_FPS; // ~62.5ms per frame
            storyIntroIntervalId = window.setInterval(() => {
                // Calculate current frame position in atlas
                const col = storyIntroCurrentFrame % INTRO_COLS;
                const row = Math.floor(storyIntroCurrentFrame / INTRO_COLS);
                
                // Set background position to show current frame
                const xPercent = (col / (INTRO_COLS - 1)) * 100;
                const yPercent = (row / (INTRO_ROWS - 1)) * 100;
                bgElement.style.backgroundPosition = `${xPercent}% ${yPercent}%`;
                
                // Advance frame with ping-pong
                storyIntroCurrentFrame += storyIntroDirection;
                
                // Reverse at boundaries (ping-pong mode)
                if (storyIntroCurrentFrame >= INTRO_TOTAL_FRAMES - 1) {
                    storyIntroCurrentFrame = INTRO_TOTAL_FRAMES - 1;
                    storyIntroDirection = -1;
                } else if (storyIntroCurrentFrame <= 0) {
                    storyIntroCurrentFrame = 0;
                    storyIntroDirection = 1;
                }
            }, frameInterval);
        }
        
        function stopStoryIntroAnimation() {
            if (storyIntroIntervalId) {
                window.clearInterval(storyIntroIntervalId);
                storyIntroIntervalId = null;
            }
        }
        // ===== END STORY INTRO BACKGROUND ANIMATION =====
        
        const themeTracks = [
            { file: 'music/theme_a.webm', name: 'Electric Coin Company' },
            { file: 'music/theme_b.webm', name: 'Zcash Foundation' },
            { file: 'music/theme_c_boss.webm', name: 'Proof of Work Battle' },
            { file: 'music/theme_d.webm', name: 'ZecWallet Lite' },
            { file: 'music/theme_e.webm', name: 'Private by Default' },
            { file: 'music/theme_f.webm', name: 'Halo Arc Dreams' },
            { file: 'music/theme_g.webm', name: 'Mining the Future' },
            { file: 'music/theme_h.webm', name: 'zkSNARK Symphony' },
            { file: 'music/theme_i.webm', name: 'Trusted Setup Ceremony' },
            { file: 'music/theme_j.webm', name: 'Shielded Sunset' }
        ];
        
        function loadMusic(trackData) {
            if (!musicEnabled) return;
            
            // Check if we're already playing this track
            if (currentMusic && currentMusic.src.endsWith(trackData.file)) {
                return; // Don't restart the same track
            }
            
            // Update music ticker with track name
            const tickerText1 = document.getElementById('musicTickerText1');
            const tickerText2 = document.getElementById('musicTickerText2');
            if (tickerText1 && tickerText2 && trackData.name) {
                // Pick a new random fact each time track changes
                if (tickerFacts.length > 0) {
                    currentTickerFact = tickerFacts[Math.floor(Math.random() * tickerFacts.length)];
                }
                
                const musicInfo = `‚ô´ Theme Song: ${trackData.name} ‚ô´`;
                
                // Combine music info with fun fact
                const finalText = currentTickerFact ? `${musicInfo}  ‚Ä¢  ${currentTickerFact}` : musicInfo;
                tickerText1.textContent = finalText;
                tickerText2.textContent = finalText;
            }
            
            // Use musicVolume divided by 100 (1-150 scale), clamped to max 1.0
            const volumeScale = Math.min(1.0, musicVolume / 100);
            
            // Create new audio element
            const newMusic = new Audio(trackData.file);
            newMusic.loop = false;
            newMusic.volume = 0; // Start silent
            
            // When song ends, play next random track
            newMusic.addEventListener('ended', () => {
                if (!musicEnabled) return;
                const randomTrack = themeTracks[Math.floor(Math.random() * themeTracks.length)];
                loadMusic(randomTrack);
            });
            
            // Fade in new track
            newMusic.play().then(() => {
                fadeMusic(newMusic, 0, volumeScale, 1000);
                musicStarted = true;
                updateMusicButton();
            }).catch(err => {
                console.log('Music autoplay blocked:', err);
            });
            
            // Fade out old track
            if (currentMusic) {
                const oldMusic = currentMusic;
                fadeMusic(oldMusic, oldMusic.volume, 0, 1000, () => {
                    oldMusic.pause();
                    oldMusic.src = '';
                });
            }
            
            currentMusic = newMusic;
        }
        
        function fadeMusic(audioElement, startVol, endVol, duration, callback) {
            const steps = 20;
            const stepTime = duration / steps;
            const volStep = (endVol - startVol) / steps;
            let currentStep = 0;
            
            const fadeInterval = setInterval(() => {
                currentStep++;
                const newVol = startVol + (volStep * currentStep);
                audioElement.volume = Math.max(0, Math.min(1, newVol));
                
                if (currentStep >= steps) {
                    clearInterval(fadeInterval);
                    audioElement.volume = Math.max(0, Math.min(1.5, endVol));
                    if (callback) callback();
                }
            }, stepTime);
        }
        
        // Music Control Functions
        function musicPlayPause() {
            const btn = document.getElementById('musicPlayPauseBtn');
            
            if (!currentMusic) {
                // No music loaded yet, start the music system
                musicEnabled = true;
                const randomTrack = themeTracks[Math.floor(Math.random() * themeTracks.length)];
                loadMusic(randomTrack);
                if (btn) btn.textContent = '‚è∏';
                return;
            }
            
            if (currentMusic.paused) {
                currentMusic.play().catch(err => console.log('Play error:', err));
                musicEnabled = true;
                if (btn) btn.textContent = '‚è∏';
            } else {
                currentMusic.pause();
                musicEnabled = false;
                if (btn) btn.textContent = '‚ñ∂';
            }
        }
        
        function musicPrevious() {
            if (currentMusic) {
                currentMusic.pause();
            }
            
            musicEnabled = true; // Enable music if it was paused
            const randomTrack = themeTracks[Math.floor(Math.random() * themeTracks.length)];
            loadMusic(randomTrack);
        }
        
        function musicNext() {
            if (currentMusic) {
                currentMusic.pause();
            }
            
            musicEnabled = true; // Enable music if it was paused
            const randomTrack = themeTracks[Math.floor(Math.random() * themeTracks.length)];
            loadMusic(randomTrack);
        }
        
        function updateMusicButton() {
            const btn = document.getElementById('musicPlayPauseBtn');
            if (btn) {
                if (currentMusic && !currentMusic.paused) {
                    btn.textContent = '‚è∏';
                } else {
                    btn.textContent = '‚ñ∂';
                }
            }
        }
        
        function updateVolume() {
            const slider = document.getElementById('volumeSlider');
            if (!slider) return;
            
            musicVolume = parseInt(slider.value);
            
            // Update settings object
            settings.musicVolume = musicVolume;
            
            // Update volume display
            const volumeDisplay = document.getElementById('volumeSliderValue');
            if (volumeDisplay) {
                volumeDisplay.textContent = musicVolume;
            }
            
            // Update settings panel slider if open
            const settingsSlider = document.getElementById('musicVolume');
            if (settingsSlider) {
                settingsSlider.value = musicVolume;
            }
            const settingsVolumeDisplay = document.getElementById('musicVolumeValue');
            if (settingsVolumeDisplay) {
                settingsVolumeDisplay.textContent = musicVolume;
            }
            
            if (currentMusic) {
                currentMusic.volume = Math.min(1.0, musicVolume / 100);
            }
            
            // Save to localStorage
            saveSettings();
        }
        
        // Settings System
        let settings = {
            musicEnabled: true,
            musicVolume: 75,
            showHitboxes: false
        };
        
        function showSettings() {
            document.getElementById('overlay').style.display = 'block';
            document.getElementById('settingsPanel').style.display = 'block';
            
            // Load current settings into UI
            document.getElementById('musicEnabled').checked = settings.musicEnabled;
            document.getElementById('musicVolume').value = settings.musicVolume;
            document.getElementById('musicVolumeValue').textContent = settings.musicVolume;
            document.getElementById('showHitboxes').checked = settings.showHitboxes;
        }
        
        function updateSettings() {
            // Read values from UI
            settings.musicEnabled = document.getElementById('musicEnabled').checked;
            settings.musicVolume = parseInt(document.getElementById('musicVolume').value);
            settings.showHitboxes = document.getElementById('showHitboxes').checked;
            
            // Update display
            document.getElementById('musicVolumeValue').textContent = settings.musicVolume;
            
            // Apply to game state
            musicEnabled = settings.musicEnabled;
            musicVolume = settings.musicVolume;
            
            // Re-render battle if active to show/hide hitboxes
            if (battleState.active) {
                renderBattle();
            }
            
            // Handle music enable/disable
            if (currentMusic) {
                if (musicEnabled) {
                    // Enable: Resume if paused
                    if (currentMusic.paused) {
                        currentMusic.play().catch(err => console.log('Play error:', err));
                    }
                    currentMusic.volume = Math.min(1.0, musicVolume / 100);
                } else {
                    // Disable: Pause music
                    currentMusic.pause();
                }
            }
            
            // Update volume slider in main controls
            const mainSlider = document.getElementById('volumeSlider');
            if (mainSlider) {
                mainSlider.value = musicVolume;
            }
            
            // Update play/pause button
            updateMusicButton();
            
            // Save to localStorage
            saveSettings();
        }
        
        function closeAllPanels() {
            document.getElementById('overlay').style.display = 'none';
            document.getElementById('settingsPanel').style.display = 'none';
            const loadSavePanel = document.getElementById('loadSavePanel');
            if (loadSavePanel) {
                loadSavePanel.style.display = 'none';
            }
        }
        
        function showLoadSave() {
            document.getElementById('overlay').style.display = 'block';
            const loadSavePanel = document.getElementById('loadSavePanel');
            if (loadSavePanel) {
                loadSavePanel.style.display = 'block';
            }
        }
        
        function loadSaveFile() {
            const fileInput = document.getElementById('saveFileInput');
            const file = fileInput.files[0];
            
            if (!file) {
                alert('Please select a save file first!');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const saveData = JSON.parse(e.target.result);
                    
                    // Validate save data structure
                    if (!saveData || !saveData.heroes) {
                        alert('Invalid save file format! Missing hero data.');
                        return;
                    }
                    
                    // Save to localStorage
                    if (saveSharedSave(saveData)) {
                        alert('Save file loaded successfully!');
                        
                        // Refresh hero displays
                        if (saveData.heroes.zooko) updateHeroDisplay('zooko', saveData.heroes.zooko);
                        if (saveData.heroes.nate) updateHeroDisplay('nate', saveData.heroes.nate);
                        if (saveData.heroes.zancas) updateHeroDisplay('zancas', saveData.heroes.zancas);
                        if (saveData.heroes.cyberaxe) updateHeroDisplay('cyberaxe', saveData.heroes.cyberaxe);
                        
                        // Update dungeon level if arcade state exists
                        if (saveData.arcadeState && saveData.arcadeState.level) {
                            document.getElementById('dungeonLevel').textContent = saveData.arcadeState.level;
                        }
                        
                        // Update title screen buttons
                        updateTitleScreenButtons();
                        
                        // Close panel
                        closeAllPanels();
                        
                        // Clear file input
                        fileInput.value = '';
                    } else {
                        alert('Failed to save the loaded data to localStorage.');
                    }
                } catch (error) {
                    alert('Error reading save file: ' + error.message);
                    console.error('Save file load error:', error);
                }
            };
            
            reader.onerror = function() {
                alert('Error reading file!');
            };
            
            reader.readAsText(file);
        }
        
        function saveSettings() {
            try {
                localStorage.setItem(STORAGE_KEYS.SETTINGS, JSON.stringify(settings));
            } catch (e) {
                console.error('Failed to save settings:', e);
            }
        }
        
        function loadSettings() {
            try {
                const saved = localStorage.getItem(STORAGE_KEYS.SETTINGS);
                if (saved) {
                    const loaded = JSON.parse(saved);
                    settings = { ...settings, ...loaded };
                    
                    // Apply to game state
                    musicEnabled = settings.musicEnabled;
                    musicVolume = settings.musicVolume;
                    
                    // Update main volume slider and display
                    const mainSlider = document.getElementById('volumeSlider');
                    if (mainSlider) {
                        mainSlider.value = musicVolume;
                    }
                    const volumeDisplay = document.getElementById('volumeSliderValue');
                    if (volumeDisplay) {
                        volumeDisplay.textContent = musicVolume;
                    }
                }
            } catch (e) {
                console.error('Failed to load settings:', e);
            }
        }
        
        // Load shared save and populate hero stats
        function loadSharedSave() {
            try {
                const saved = localStorage.getItem(STORAGE_KEYS.SHARED_SAVE);
                if (!saved) return null;
                
                const sharedSave = JSON.parse(saved);
                return migrateSharedSave(sharedSave);
            } catch (e) {
                console.error('Failed to load shared save:', e);
                return null;
            }
        }
        
        // Save shared save to localStorage
        function saveSharedSave(sharedSave) {
            try {
                const jsonString = JSON.stringify(sharedSave);
                localStorage.setItem(STORAGE_KEYS.SHARED_SAVE, jsonString);
                console.log('Shared save written. Size:', jsonString.length, 'bytes');
                return true;
            } catch (e) {
                console.error('Failed to save shared save:', e);
                return false;
            }
        }
        
        // Migrate shared save between versions
        function migrateSharedSave(sharedSave) {
            // Currently at version 1, no migrations needed yet
            return sharedSave;
        }
        
        // Creates default shared save with initial hero stats
        function createDefaultSharedSave() {
            return {
                saveVersion: 1,
                lastPlayed: Date.now(),
                arcadeState: null,
                dungeonState: {
                    currentLevel: 1,
                    inventory: [],
                    gold: 0,
                    questProgress: {
                        hasScepter: false,
                        hasReturned: false,
                        bossesDefeated: []
                    }
                },
                heroes: {
                    zooko: {
                        name: 'Zooko',
                        str: 8, dex: 11, con: 10, int: 15, wis: 13, cha: 9,
                        hp: 22, maxHp: 25, ac: 12, xp: 0, level: 1
                    },
                    nate: {
                        name: 'Nate',
                        str: 14, dex: 12, con: 13, int: 10, wis: 9, cha: 11,
                        hp: 28, maxHp: 30, ac: 14, xp: 0, level: 1
                    },
                    zancas: {
                        name: 'Zancas',
                        str: 10, dex: 15, con: 11, int: 12, wis: 14, cha: 8,
                        hp: 24, maxHp: 26, ac: 13, xp: 0, level: 1
                    },
                    cyberaxe: {
                        name: 'CyberAxe',
                        str: 16, dex: 10, con: 14, int: 8, wis: 11, cha: 10,
                        hp: 32, maxHp: 35, ac: 15, xp: 0, level: 1
                    }
                }
            };
        }
        
        // Clear cache - deletes all localStorage data and forces hard reload
        function clearCache() {
            if (confirm('This will delete ALL saved data including your progress. Are you sure?')) {
                try {
                    localStorage.removeItem(STORAGE_KEYS.SETTINGS);
                    localStorage.removeItem(STORAGE_KEYS.SHARED_SAVE);
                    
                    // Clear browser cache for images and assets
                    if ('caches' in window) {
                        caches.keys().then(function(names) {
                            for (let name of names) caches.delete(name);
                        });
                    }
                    
                    alert('Cache cleared! The page will reload with fresh assets.');
                    // Force hard reload (bypass cache)
                    location.reload(true);
                } catch (e) {
                    console.error('Clear cache error:', e);
                    alert('Error clearing cache: ' + e.message);
                }
            }
        }
        
        // Update title screen button states based on save existence
        function updateTitleScreenButtons() {
            const sharedSave = loadSharedSave();
            const startBtn = document.getElementById('startAdventureBtn');
            const continueBtn = document.getElementById('continueBtn');
            
            if (sharedSave && (sharedSave.arcadeState || sharedSave.dungeonState)) {
                // Has save - enable CONTINUE, disable START ADVENTURE
                continueBtn.disabled = false;
                continueBtn.classList.remove('comingSoon');
                startBtn.disabled = true;
                startBtn.style.opacity = '0.5';
                startBtn.style.cursor = 'not-allowed';
            } else {
                // No save - enable START ADVENTURE, disable CONTINUE
                startBtn.disabled = false;
                startBtn.style.opacity = '1';
                startBtn.style.cursor = 'pointer';
                continueBtn.disabled = true;
                continueBtn.classList.add('comingSoon');
            }
        }
        
        // Continue game - same as start adventure for now
        function continueGame() {
            startAdventure();
        }
        
        // ===== BATTLE SYSTEM =====
        
        // Battle state
        let battleState = {
            active: false,
            currentTurn: 0,
            turnOrder: [],
            heroes: [],
            enemies: [],
            platforms: [],
            canvas: null,
            ctx: null,
            backgroundImage: null,
            backgroundPath: '',
            detectedPlatforms: []
        };
        
        // Start a battle encounter
        function startBattle() {
            // Switch to battle screen
            currentScreen = 'battle';
            document.getElementById('dungeonMenuScreen').style.display = 'none';
            document.getElementById('battleScreen').style.display = 'block';
            
            // Initialize canvas
            battleState.canvas = document.getElementById('battleCanvas');
            battleState.ctx = battleState.canvas.getContext('2d');
            
            // Set canvas size
            battleState.canvas.width = window.innerWidth;
            battleState.canvas.height = window.innerHeight - 180;
            
            // Load shared save to get hero stats
            const sharedSave = loadSharedSave();
            
            // Setup heroes with sprites
            battleState.heroes = [
                { 
                    name: 'Zooko', 
                    hp: sharedSave?.heroes?.zooko?.hp || 30, 
                    maxHp: sharedSave?.heroes?.zooko?.maxHp || 30,
                    stats: sharedSave?.heroes?.zooko || {},
                    color: '#F2C94C',
                    x: 0, y: 0, platform: null, facing: 'center',
                    sprite: new Image(),
                    spritePath: 'tunnelsofprivacy/heros/zooko.png'
                },
                { 
                    name: 'Nate', 
                    hp: sharedSave?.heroes?.nate?.hp || 28, 
                    maxHp: sharedSave?.heroes?.nate?.maxHp || 30,
                    stats: sharedSave?.heroes?.nate || {},
                    color: '#E74C3C',
                    x: 0, y: 0, platform: null, facing: 'center',
                    sprite: new Image(),
                    spritePath: 'tunnelsofprivacy/heros/nate.png'
                },
                { 
                    name: 'Zancas', 
                    hp: sharedSave?.heroes?.zancas?.hp || 24, 
                    maxHp: sharedSave?.heroes?.zancas?.maxHp || 26,
                    stats: sharedSave?.heroes?.zancas || {},
                    color: '#27AE60',
                    x: 0, y: 0, platform: null, facing: 'center',
                    sprite: new Image(),
                    spritePath: 'tunnelsofprivacy/heros/zancas.png'
                },
                { 
                    name: 'CyberAxe', 
                    hp: sharedSave?.heroes?.cyberaxe?.hp || 32, 
                    maxHp: sharedSave?.heroes?.cyberaxe?.maxHp || 35,
                    stats: sharedSave?.heroes?.cyberaxe || {},
                    color: '#2E86DE',
                    x: 0, y: 0, platform: null, facing: 'center',
                    sprite: new Image(),
                    spritePath: 'tunnelsofprivacy/heros/cyberaxe.png'
                }
            ];
            
            // Load hero sprites with cache busting
            battleState.heroes.forEach(hero => {
                hero.sprite.onload = () => {
                    renderBattle(); // Re-render when each sprite loads
                };
                // Add timestamp to prevent caching
                hero.sprite.src = hero.spritePath + '?v=' + Date.now();
            });
            
            // Setup test enemies - boss + 2 mobs
            battleState.enemies = [
                { 
                    name: 'Shadow Kraken', 
                    hp: 50, 
                    maxHp: 50,
                    color: '#8B45FF',
                    x: 0, y: 0, platform: null, facing: 'center',
                    sprite: new Image(),
                    spritePath: 'tunnelsofprivacy/bosses/lvl1/boss_lvl1.png',
                    isMob: false
                },
                {
                    name: 'Cave Spider',
                    hp: 10,
                    maxHp: 10,
                    color: '#5C3317',
                    x: 0, y: 0, platform: null, facing: 'center',
                    sprite: new Image(),
                    spritePath: 'tunnelsofprivacy/mobs/spider1.png',
                    isMob: true
                },
                {
                    name: 'Dire Rat',
                    hp: 6,
                    maxHp: 6,
                    color: '#6B5B4F',
                    x: 0, y: 0, platform: null, facing: 'center',
                    sprite: new Image(),
                    spritePath: 'tunnelsofprivacy/mobs/rat1.png',
                    isMob: true
                }
            ];
            
            // Load enemy sprites
            battleState.enemies.forEach(enemy => {
                enemy.sprite.onload = () => {
                    renderBattle();
                };
                enemy.sprite.src = enemy.spritePath + '?v=' + Date.now();
            });
            
            // Load random background from lvl1-10
            const backgroundOptions = [
                'backgrounds_lvl1 (8).png',
                'backgrounds_lvl1 (10).png',
                'backgrounds_lvl1 (12).png',
                'backgrounds_lvl1 (14).png',
                'backgrounds_lvl1 (15).png',
                'backgrounds_lvl1 (16).png'
            ];
            const randomBg = backgroundOptions[Math.floor(Math.random() * backgroundOptions.length)];
            battleState.backgroundPath = `tunnelsofprivacy/backgrounds/lvl1-10/${randomBg}`;
            battleState.backgroundImage = new Image();
            battleState.backgroundImage.onload = () => {
                // Generate battle layout with fixed positioning
                generateBattleLayout();
                // Re-render when background loads
                renderBattle();
            };
            battleState.backgroundImage.src = battleState.backgroundPath;
            
            // Setup turn order (by DEX for now, placeholder)
            battleState.turnOrder = [...battleState.heroes];
            battleState.currentTurn = 0;
            battleState.active = true;
            
            // Update UI
            updateBattleTurnInfo();
            updateBattleHeroCards();
            
            // Render initial state (will re-render when bg loads)
            renderBattle();
        }
        

        
        // Detect platforms using multi-method approach
        function detectPlatforms() {
            if (!battleState.backgroundImage || !battleState.backgroundImage.complete) {
                return [];
            }
            
            const tempCanvas = document.createElement('canvas');
            const ctx = tempCanvas.getContext('2d');
            tempCanvas.width = battleState.backgroundImage.width;
            tempCanvas.height = battleState.backgroundImage.height;
            
            ctx.drawImage(battleState.backgroundImage, 0, 0);
            const imageData = ctx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            const data = imageData.data;
            
            const allPlatforms = [];
            
            // METHOD 1: Adaptive thresholding with local contrast
            const method1 = detectByAdaptiveThreshold(data, tempCanvas.width, tempCanvas.height);
            allPlatforms.push(...method1);
            
            // METHOD 2: Multi-angle edge detection
            const method2 = detectByMultiAngle(data, tempCanvas.width, tempCanvas.height);
            allPlatforms.push(...method2);
            
            // METHOD 3: Color clustering
            const method3 = detectByColorClustering(data, tempCanvas.width, tempCanvas.height);
            allPlatforms.push(...method3);
            
            // Score and rank all platforms
            const scored = allPlatforms.map(p => ({
                ...p,
                score: scorePlatform(p, data, tempCanvas.width, tempCanvas.height)
            }));
            
            // Filter minimum score and sort
            const valid = scored.filter(p => p.score > 0.3).sort((a, b) => b.score - a.score);
            
            // Scale to canvas size
            const scaleX = battleState.canvas.width / tempCanvas.width;
            const scaleY = battleState.canvas.height / tempCanvas.height;
            
            return valid.map(p => ({
                x: p.x * scaleX,
                y: p.y * scaleY,
                w: p.w * scaleX,
                h: p.h * scaleY,
                type: p.type,
                score: p.score,
                color: p.color
            }));
        }
        
        // Adaptive thresholding - find LIGHT horizontal floor areas using box scanning
        function detectByAdaptiveThreshold(data, width, height) {
            const platforms = [];
            const boxWidth = 150; // Scan boxes 150px wide
            const boxHeight = 50; // 50px tall boxes
            const boxStepX = 50; // Move box right by 50px
            const boxStepY = 25; // Move box down by 25px
            const minBrightness = 100;
            
            // Scan bottom 60% of image only
            for (let boxY = Math.floor(height * 0.6); boxY < height - boxHeight - 10; boxY += boxStepY) {
                for (let boxX = 0; boxX < width - boxWidth; boxX += boxStepX) {
                    // Sample the entire box
                    let boxBrightnessSum = 0;
                    let boxSamples = 0;
                    
                    for (let dy = 0; dy < boxHeight; dy += 5) {
                        for (let dx = 0; dx < boxWidth; dx += 5) {
                            const x = boxX + dx;
                            const y = boxY + dy;
                            const i = (y * width + x) * 4;
                            const brightness = (data[i] + data[i+1] + data[i+2]) / 3;
                            boxBrightnessSum += brightness;
                            boxSamples++;
                        }
                    }
                    
                    const avgBrightness = boxBrightnessSum / boxSamples;
                    
                    // Check if box is bright enough
                    if (avgBrightness > minBrightness) {
                        // Depth test: trace down to find distance to ground
                        const depthScore = calculateDepthScore(data, width, height, boxX, boxY, boxWidth, boxHeight, avgBrightness);
                        
                        // Only accept platforms with good depth scores (close to ground or at bottom)
                        if (depthScore > 0.5) {
                            platforms.push({
                                x: boxX, y: boxY, w: boxWidth, h: boxHeight,
                                type: 'adaptive', color: '#FF00FF',
                                depthScore: depthScore
                            });
                        }
                    }
                }
            }
            
            return platforms;
        }
        
        // Multi-angle edge detection - find LIGHT floor areas at various slopes using boxes
        function detectByMultiAngle(data, width, height) {
            const platforms = [];
            const angles = [0, 5, -5];
            const boxWidth = 150;
            const boxHeight = 50;
            const boxStepX = 50;
            const boxStepY = 30;
            const minBrightness = 100;
            
            angles.forEach(angle => {
                const rad = angle * Math.PI / 180;
                const tanAngle = Math.tan(rad);
                
                for (let baseY = Math.floor(height * 0.6); baseY < height - boxHeight - 10; baseY += boxStepY) {
                    for (let boxX = 0; boxX < width - boxWidth; boxX += boxStepX) {
                        const centerY = Math.floor(baseY + boxX * tanAngle);
                        if (centerY < 0 || centerY >= height - boxHeight - 10) continue;
                        
                        // Sample box at this position
                        let boxBrightnessSum = 0;
                        let boxSamples = 0;
                        
                        for (let dy = 0; dy < boxHeight; dy += 5) {
                            for (let dx = 0; dx < boxWidth; dx += 5) {
                                const x = boxX + dx;
                                const y = centerY + dy;
                                if (y >= height) continue;
                                const i = (y * width + x) * 4;
                                const brightness = (data[i] + data[i+1] + data[i+2]) / 3;
                                boxBrightnessSum += brightness;
                                boxSamples++;
                            }
                        }
                        
                        const avgBrightness = boxBrightnessSum / boxSamples;
                        
                        if (avgBrightness > minBrightness) {
                            // Depth test
                            const depthScore = calculateDepthScore(data, width, height, boxX, centerY, boxWidth, boxHeight, avgBrightness);
                            
                            if (depthScore > 0.5) {
                                platforms.push({
                                    x: boxX, y: centerY, w: boxWidth, h: boxHeight,
                                    type: 'angle', color: '#00FFFF',
                                    depthScore: depthScore
                                });
                            }
                        }
                    }
                }
            });
            
            return platforms;
        }
        
        // Color clustering - find LIGHT colored horizontal floor regions using boxes
        function detectByColorClustering(data, width, height) {
            const platforms = [];
            const boxWidth = 150;
            const boxHeight = 50;
            const boxStepX = 50;
            const boxStepY = 25;
            const colorTolerance = 60;
            const minBrightness = 100;
            
            for (let boxY = Math.floor(height * 0.6); boxY < height - boxHeight - 10; boxY += boxStepY) {
                for (let boxX = 0; boxX < width - boxWidth; boxX += boxStepX) {
                    // Sample box at this position
                    let avgR = 0, avgG = 0, avgB = 0;
                    let samples = 0;
                    
                    for (let dy = 0; dy < boxHeight; dy += 5) {
                        for (let dx = 0; dx < boxWidth; dx += 5) {
                            const x = boxX + dx;
                            const y = boxY + dy;
                            const i = (y * width + x) * 4;
                            avgR += data[i];
                            avgG += data[i+1];
                            avgB += data[i+2];
                            samples++;
                        }
                    }
                    
                    avgR /= samples;
                    avgG /= samples;
                    avgB /= samples;
                    const brightness = (avgR + avgG + avgB) / 3;
                    
                    // Only consider LIGHT boxes as potential floor
                    if (brightness > minBrightness) {
                        // Depth test
                        const depthScore = calculateDepthScore(data, width, height, boxX, boxY, boxWidth, boxHeight, brightness);
                        
                        if (depthScore > 0.5) {
                            platforms.push({
                                x: boxX, y: boxY, w: boxWidth, h: boxHeight,
                                type: 'cluster', color: '#00FF00',
                                depthScore: depthScore
                            });
                        }
                    }
                }
            }
            
            return platforms;
        }
        
        // Calculate depth score - traces downward to find distance to ground
        function calculateDepthScore(data, width, height, boxX, boxY, boxWidth, boxHeight, platformBrightness) {
            const centerX = boxX + Math.floor(boxWidth / 2);
            const startY = boxY + boxHeight;
            const maxDepth = 200; // Don't trace more than 200px down
            
            let distanceToGround = 0;
            let foundGround = false;
            
            // Trace straight down from center of platform
            for (let y = startY; y < Math.min(height, startY + maxDepth); y += 5) {
                const i = (y * width + centerX) * 4;
                const brightness = (data[i] + data[i+1] + data[i+2]) / 3;
                
                // Check for ground indicators:
                // 1. Hit bottom of image
                if (y >= height - 10) {
                    distanceToGround = y - startY;
                    foundGround = true;
                    break;
                }
                
                // 2. Hit much darker area (void/background)
                if (brightness < 50) {
                    distanceToGround = y - startY;
                    foundGround = true;
                    break;
                }
                
                // 3. Hit similar brightness (continuous support)
                if (Math.abs(brightness - platformBrightness) < 30) {
                    // Keep tracing, we're still on connected surface
                    continue;
                }
            }
            
            // If we traced all the way down without finding ground, it's floating
            if (!foundGround) {
                return 0;
            }
            
            // Score based on distance to ground
            // 0 distance (at bottom) = 1.0 score
            // 50px or more = 0.5 score (minimum acceptable)
            // >200px = rejected above
            const score = 1.0 - (distanceToGround / 400);
            return Math.max(0.5, score);
        }
        
        // Score platform quality
        function scorePlatform(platform, data, width, height) {
            let score = 0;
            
            // Width score (wider = better, cap at 800px)
            const widthScore = Math.min(1.0, platform.w / 800);
            score += widthScore * 0.5;
            
            // Position score (lower on screen = better, floors are at bottom)
            const positionScore = platform.y / height;
            score += positionScore * 0.3;
            
            // Brightness consistency (floors should be consistently LIGHT)
            let brightnessSum = 0;
            let sampleCount = 0;
            for (let x = platform.x; x < platform.x + platform.w; x += 10) {
                const idx = (Math.floor(platform.y) * width + Math.floor(x)) * 4;
                const brightness = (data[idx] + data[idx+1] + data[idx+2]) / 3;
                brightnessSum += brightness;
                sampleCount++;
            }
            const avgBrightness = brightnessSum / sampleCount;
            const brightnessScore = avgBrightness > 100 ? Math.min(1.0, avgBrightness / 200) : 0;
            score += brightnessScore * 0.2;
            
            return score;
        }
        
        // Generate battle layout using detected platforms
        function generateBattleLayout() {
            const canvas = battleState.canvas;
            battleState.platforms = [];
            
            // Detect platforms
            const detected = detectPlatforms();
            console.log(`Detected ${detected.length} platforms total`);
            
            if (detected.length < 7) {
                console.log('Not enough platforms detected, using fallback');
                return generateFallbackLayout();
            }
            
            // Safe zone filtering - only check X bounds, platforms already scanned at bottom
            const marginX = 160; // 300px sprite / 2 + 10px buffer
            
            const safe = detected.filter(p => {
                const centerX = p.x + p.w / 2;
                return centerX > marginX && centerX < canvas.width - marginX;
            });
            
            console.log(`${safe.length} platforms in safe zone`);
            
            if (safe.length < 7) {
                console.log('Not enough safe platforms, using fallback');
                return generateFallbackLayout();
            }
            
            // Shuffle safe platforms for variety each battle
            const shuffled = [...safe].sort(() => Math.random() - 0.5);
            
            // Pick platforms ensuring spatial separation (300px sprites need 200px+ spacing)
            const minDistance = 200;
            const selected = [];
            
            for (let i = 0; i < shuffled.length && selected.length < 7; i++) {
                const candidate = shuffled[i];
                const candidateX = candidate.x + candidate.w / 2;
                const candidateY = candidate.y;
                
                // Check if candidate overlaps with already selected platforms
                let overlaps = false;
                for (const existing of selected) {
                    const existingX = existing.x + existing.w / 2;
                    const existingY = existing.y;
                    
                    const dx = candidateX - existingX;
                    const dy = candidateY - existingY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < minDistance) {
                        overlaps = true;
                        break;
                    }
                }
                
                if (!overlaps) {
                    selected.push(candidate);
                }
            }
            
            console.log(`Selected ${selected.length} non-overlapping platforms`);
            
            // Need at least 7 non-overlapping platforms (4 heroes + 3 enemies)
            if (selected.length < 7) {
                console.log('Could not find 7 non-overlapping platforms, using fallback');
                return generateFallbackLayout();
            }
            
            // Position heroes
            for (let i = 0; i < 4; i++) {
                const p = selected[i];
                battleState.platforms.push(p);
                
                // Center of detection box
                const centerX = p.x + p.w / 2;
                const centerY = p.y + p.h / 2;
                
                // We need to solve: floor contact point (heroY + scaledBoxSize/2) = centerY
                // scaledBoxSize = 300 * (0.6 + heroY / canvas.height * 0.4)
                // This is circular, so we iterate to solve
                let heroY = centerY - 150; // Initial guess
                for (let iter = 0; iter < 5; iter++) {
                    const depthScale = 0.6 + (heroY / canvas.height) * 0.4;
                    const scaledBoxSize = 300 * depthScale;
                    heroY = centerY - scaledBoxSize / 2;
                }
                
                battleState.heroes[i].platform = p;
                battleState.heroes[i].x = centerX;
                battleState.heroes[i].y = heroY;
                battleState.heroes[i].facing = 'center';
            }
            
            // Position enemies
            for (let i = 0; i < battleState.enemies.length; i++) {
                const ep = selected[4 + i];
                battleState.platforms.push(ep);
                
                // Center of detection box
                const centerX = ep.x + ep.w / 2;
                const centerY = ep.y + ep.h / 2;
                
                const enemy = battleState.enemies[i];
                
                if (enemy.isMob) {
                    // For mobs: enemy.y is at FEET (bottom of sprite)
                    // Sprite bottom should be at centerY
                    enemy.x = centerX;
                    enemy.y = centerY;
                } else {
                    // For bosses: solve for Y position where floor contact point = centerY
                    let enemyY = centerY - 150; // Initial guess
                    for (let iter = 0; iter < 5; iter++) {
                        const depthScale = 0.6 + (enemyY / canvas.height) * 0.4;
                        const scaledBoxSize = 300 * depthScale;
                        enemyY = centerY - scaledBoxSize / 2;
                    }
                    enemy.x = centerX;
                    enemy.y = enemyY;
                }
                
                enemy.platform = ep;
                enemy.facing = 'center';
            }
            
            battleState.detectedPlatforms = detected;
            console.log('Platform layout generated successfully');
        }
        
        // Fallback positioning
        function generateFallbackLayout() {
            const canvas = battleState.canvas;
            const safePositions = {
                heroes: [
                    { x: 0.20, y: 0.40 },
                    { x: 0.25, y: 0.55 },
                    { x: 0.15, y: 0.65 },
                    { x: 0.30, y: 0.75 }
                ],
                enemies: [
                    { x: 0.75, y: 0.60 },
                    { x: 0.70, y: 0.45 },
                    { x: 0.80, y: 0.70 }
                ]
            };
            
            for (let i = 0; i < 4; i++) {
                const pos = safePositions.heroes[i];
                const heroX = canvas.width * pos.x;
                const heroY = canvas.height * pos.y;
                
                const platform = {
                    x: heroX - 50, y: heroY + 140, w: 100, h: 10,
                    type: 'fallback', color: '#6B4FA0'
                };
                
                battleState.platforms.push(platform);
                battleState.heroes[i].platform = platform;
                battleState.heroes[i].x = heroX;
                battleState.heroes[i].y = heroY;
                battleState.heroes[i].facing = 'center';
            }
            
            for (let i = 0; i < battleState.enemies.length; i++) {
                const pos = safePositions.enemies[i];
                const enemyX = canvas.width * pos.x;
                const enemyY = canvas.height * pos.y;
                
                const enemyPlatform = {
                    x: enemyX - 75, y: enemyY + 140, w: 150, h: 10,
                    type: 'fallback', color: '#4A2A6B'
                };
                
                battleState.platforms.push(enemyPlatform);
                battleState.enemies[i].platform = enemyPlatform;
                battleState.enemies[i].x = enemyX;
                battleState.enemies[i].y = enemyY;
                battleState.enemies[i].facing = 'center';
            }
        }
        

        // Render battle scene
        function renderBattle() {
            const ctx = battleState.ctx;
            const canvas = battleState.canvas;
            
            // Draw background image if loaded, otherwise fallback to gradient
            if (battleState.backgroundImage && battleState.backgroundImage.complete && battleState.backgroundImage.naturalHeight !== 0) {
                ctx.drawImage(battleState.backgroundImage, 0, 0, canvas.width, canvas.height);
            } else {
                // Fallback: Clear canvas with gradient
                ctx.fillStyle = '#1a0f2e';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw starry background
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                for (let i = 0; i < 100; i++) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    const r = Math.random() * 2;
                    ctx.beginPath();
                    ctx.arc(x, y, r, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Draw detected platform spawn areas if hitboxes enabled
            if (settings.showHitboxes && battleState.detectedPlatforms) {
                battleState.detectedPlatforms.forEach(platform => {
                    // Different colors for different detection methods
                    let fillColor, strokeColor;
                    
                    if (platform.type === 'detected') {
                        // Edge detection = GREEN
                        fillColor = 'rgba(0, 255, 0, 0.2)';
                        strokeColor = 'rgba(0, 255, 0, 0.8)';
                    } else if (platform.type === 'sampled') {
                        // Grid sampling = MAGENTA
                        fillColor = 'rgba(255, 0, 255, 0.2)';
                        strokeColor = 'rgba(255, 0, 255, 0.8)';
                    } else if (platform.type === 'gradient') {
                        // Gradient/flat area = CYAN
                        fillColor = 'rgba(0, 255, 255, 0.2)';
                        strokeColor = 'rgba(0, 255, 255, 0.8)';
                    } else {
                        // Unknown = WHITE
                        fillColor = 'rgba(255, 255, 255, 0.2)';
                        strokeColor = 'rgba(255, 255, 255, 0.8)';
                    }
                    
                    ctx.fillStyle = fillColor;
                    ctx.fillRect(platform.x, platform.y, platform.w, platform.h);
                    
                    ctx.strokeStyle = strokeColor;
                    ctx.lineWidth = 1;
                    ctx.strokeRect(platform.x, platform.y, platform.w, platform.h);
                });
            }
            
            // Draw platforms
            battleState.platforms.forEach(platform => {
                // Don't draw platforms, keep them invisible for collision only
                // ctx.fillStyle = platform.color;
                // ctx.fillRect(platform.x, platform.y, platform.w, platform.h);
                
                // Platform edge highlight
                // ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                // ctx.lineWidth = 2;
                // ctx.strokeRect(platform.x, platform.y, platform.w, platform.h);
            });
            
            // Draw heroes
            battleState.heroes.forEach(hero => {
                // Calculate depth-based scale (higher Y = farther back = smaller)
                // Y range: 0 (top) to canvas.height (bottom)
                // Scale range: 0.6 (top/far) to 1.0 (bottom/near)
                const depthScale = 0.6 + (hero.y / canvas.height) * 0.4;
                
                // Draw hero sprite
                if (hero.sprite && hero.sprite.complete && hero.sprite.naturalHeight !== 0) {
                    const spriteWidth = 300 * depthScale;
                    const spriteHeight = 300 * depthScale;
                    const spriteX = hero.x - spriteWidth / 2;
                    // Per-hero offset adjustments
                    let offsetY = 10; // Default (Zooko, Nate)
                    if (hero.name === 'Zancas') {
                        offsetY = 20; // Zancas down 10px more
                    } else if (hero.name === 'CyberAxe') {
                        offsetY = 13; // CyberAxe down 3px more
                    }
                    const spriteY = hero.y - spriteHeight / 2 + offsetY;
                    
                    ctx.save();
                    if (hero.facing === 'left') {
                        ctx.translate(hero.x, hero.y);
                        ctx.scale(-1, 1);
                        ctx.translate(-hero.x, -hero.y);
                    }
                    ctx.drawImage(hero.sprite, spriteX, spriteY, spriteWidth, spriteHeight);
                    ctx.restore();
                } else {
                    // Fallback to colored circle if sprite not loaded
                    ctx.fillStyle = hero.color;
                    ctx.beginPath();
                    ctx.arc(hero.x, hero.y, 90 * depthScale, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                
                // Hero name
                ctx.fillStyle = '#FFFFFF';
                ctx.font = `bold ${Math.floor(12 * depthScale)}px Inter`;
                ctx.textAlign = 'center';
                ctx.fillText(hero.name.toUpperCase(), hero.x, hero.y - 195 * depthScale);
                
                // HP bar (positioned above sprite, below name)
                const barWidth = 80 * depthScale;
                const barHeight = 10 * depthScale;
                const barX = hero.x - barWidth / 2;
                const barY = hero.y - 180 * depthScale;
                
                // HP text (centered on top of bar)
                ctx.fillStyle = '#FFFFFF';
                ctx.font = `bold ${Math.floor(10 * depthScale)}px JetBrains Mono`;
                ctx.textAlign = 'center';
                ctx.fillText(`${hero.hp}/${hero.maxHp}`, hero.x, barY - 3);
                
                // Background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(barX, barY, barWidth, barHeight);
                
                // HP fill
                const hpPercent = hero.hp / hero.maxHp;
                ctx.fillStyle = hpPercent > 0.5 ? '#27AE60' : hpPercent > 0.25 ? '#F39C12' : '#E74C3C';
                ctx.fillRect(barX, barY, barWidth * hpPercent, barHeight);
            });
            
            // Draw enemies
            battleState.enemies.forEach(enemy => {
                // Calculate depth-based scale (higher Y = farther back = smaller)
                const depthScale = 0.6 + (enemy.y / canvas.height) * 0.4;
                
                // Draw enemy sprite
                if (enemy.sprite && enemy.sprite.complete && enemy.sprite.naturalHeight !== 0) {
                    let spriteWidth, spriteHeight, spriteX, spriteY;
                    
                    if (enemy.isMob) {
                        // Mobs are 1344x768, render 4x smaller with correct aspect ratio
                        const mobAspectRatio = 1344 / 768; // 1.75
                        const baseHeight = 75; // 768 / 4 / 2.56 ‚âà 75px base height
                        spriteHeight = baseHeight * depthScale;
                        spriteWidth = spriteHeight * mobAspectRatio;
                        spriteX = enemy.x - spriteWidth / 2;
                        // Position so BOTTOM of sprite is at enemy.y (feet on ground)
                        spriteY = enemy.y - spriteHeight;
                    } else {
                        // Bosses are 300x300, centered
                        spriteWidth = 300 * depthScale;
                        spriteHeight = 300 * depthScale;
                        spriteX = enemy.x - spriteWidth / 2;
                        spriteY = enemy.y - spriteHeight / 2 + 10; // Offset down by 10px
                    }
                    
                    ctx.save();
                    if (enemy.facing === 'left') {
                        ctx.translate(enemy.x, enemy.y);
                        ctx.scale(-1, 1);
                        ctx.translate(-enemy.x, -enemy.y);
                    }
                    ctx.drawImage(enemy.sprite, spriteX, spriteY, spriteWidth, spriteHeight);
                    ctx.restore();
                } else {
                    // Fallback to colored circle if sprite not loaded
                    ctx.fillStyle = enemy.color;
                    ctx.beginPath();
                    ctx.arc(enemy.x, enemy.y, 50 * depthScale, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
                
                // Enemy name (RED for enemies)
                ctx.fillStyle = '#FF4444';
                ctx.font = `bold ${Math.floor(14 * depthScale)}px Inter`;
                ctx.textAlign = 'center';
                
                let nameOffsetY, barOffsetY;
                if (enemy.isMob) {
                    // For mobs, position above the sprite (which starts at enemy.y - spriteHeight)
                    const mobAspectRatio = 1344 / 768;
                    const baseHeight = 75;
                    const spriteHeight = baseHeight * depthScale;
                    nameOffsetY = enemy.y - spriteHeight - 10;
                    barOffsetY = enemy.y - spriteHeight - 30;
                } else {
                    // For bosses, position above centered sprite
                    nameOffsetY = enemy.y - 195 * depthScale;
                    barOffsetY = enemy.y - 180 * depthScale;
                }
                
                ctx.fillText(enemy.name.toUpperCase(), enemy.x, nameOffsetY);
                
                // HP bar
                const barWidth = 100 * depthScale;
                const barHeight = 10 * depthScale;
                const barX = enemy.x - barWidth / 2;
                const barY = barOffsetY;
                
                // HP text (centered on top of bar)
                ctx.fillStyle = '#FFFFFF';
                ctx.font = `bold ${Math.floor(10 * depthScale)}px JetBrains Mono`;
                ctx.textAlign = 'center';
                ctx.fillText(`${enemy.hp}/${enemy.maxHp}`, enemy.x, barY - 3);
                
                // Background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(barX, barY, barWidth, barHeight);
                
                // HP fill (RED for enemies)
                const hpPercent = enemy.hp / enemy.maxHp;
                ctx.fillStyle = hpPercent > 0.5 ? '#E74C3C' : hpPercent > 0.25 ? '#C0392B' : '#A93226';
                ctx.fillRect(barX, barY, barWidth * hpPercent, barHeight);
            });
            
            // Draw hitboxes if enabled
            if (settings.showHitboxes) {
                // Draw hero spawn area boxes (scaled with depth)
                battleState.heroes.forEach(hero => {
                    const depthScale = 0.6 + (hero.y / canvas.height) * 0.4;
                    const boxSize = 300 * depthScale;
                    ctx.strokeStyle = '#00FF00';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(hero.x - boxSize / 2, hero.y - boxSize / 2, boxSize, boxSize);
                    
                    // Draw center point (hero.x, hero.y)
                    ctx.fillStyle = '#00FF00';
                    ctx.beginPath();
                    ctx.arc(hero.x, hero.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw FLOOR CONTACT POINT - bottom center of hitbox where feet should touch
                    const floorY = hero.y + boxSize / 2;
                    ctx.fillStyle = '#FF00FF';
                    ctx.beginPath();
                    ctx.arc(hero.x, floorY, 8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });
                
                // Draw enemy spawn area boxes (scaled with depth)
                battleState.enemies.forEach(enemy => {
                    const depthScale = 0.6 + (enemy.y / canvas.height) * 0.4;
                    
                    let boxSize, boxY;
                    if (enemy.isMob) {
                        // Mobs: hitbox matches sprite size (aspect ratio 1.75:1)
                        const mobAspectRatio = 1344 / 768;
                        const baseHeight = 75;
                        const spriteHeight = baseHeight * depthScale;
                        const spriteWidth = spriteHeight * mobAspectRatio;
                        // Hitbox from feet (enemy.y) upward
                        ctx.strokeStyle = '#FF0000';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(enemy.x - spriteWidth / 2, enemy.y - spriteHeight, spriteWidth, spriteHeight);
                        
                        // Draw floor contact point at enemy.y (feet)
                        ctx.fillStyle = '#FF00FF';
                        ctx.beginPath();
                        ctx.arc(enemy.x, enemy.y, 8, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#FFFFFF';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    } else {
                        // Bosses: 300x300 scaled box centered
                        const boxSize = 300 * depthScale;
                        ctx.strokeStyle = '#FF0000';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(enemy.x - boxSize / 2, enemy.y - boxSize / 2, boxSize, boxSize);
                        
                        // Draw center point
                        ctx.fillStyle = '#FF0000';
                        ctx.beginPath();
                        ctx.arc(enemy.x, enemy.y, 5, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Draw floor contact point
                        const floorY = enemy.y + boxSize / 2;
                        ctx.fillStyle = '#FF00FF';
                        ctx.beginPath();
                        ctx.arc(enemy.x, floorY, 8, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#FFFFFF';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                });
                
                // Draw platform hitboxes
                battleState.platforms.forEach(platform => {
                    ctx.strokeStyle = '#FFFF00';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(platform.x, platform.y, platform.w, platform.h);
                });
            }
        }
        
        // Update turn info display
        function updateBattleTurnInfo() {
            const currentHero = battleState.turnOrder[battleState.currentTurn];
            const turnInfo = document.getElementById('battleTurnInfo');
            if (turnInfo && currentHero) {
                turnInfo.textContent = `${currentHero.name.toUpperCase()}'S TURN`;
            }
            
            // Update active hero card highlighting
            document.querySelectorAll('.battleHeroCard').forEach(card => card.classList.remove('active'));
            const activeCard = document.getElementById(`battleCard${currentHero.name}`);
            if (activeCard) activeCard.classList.add('active');
        }
        
        // Update battle hero card stats
        function updateBattleHeroCards() {
            battleState.heroes.forEach(hero => {
                const heroName = hero.name.toLowerCase();
                const hpEl = document.getElementById(`b${heroName}-hp`);
                const maxHpEl = document.getElementById(`b${heroName}-maxhp`);
                const acEl = document.getElementById(`b${heroName}-ac`);
                
                if (hpEl) hpEl.textContent = hero.hp;
                if (maxHpEl) maxHpEl.textContent = hero.maxHp;
                if (acEl) acEl.textContent = hero.stats.ac || 10;
            });
        }
        
        // Handle battle actions
        function battleAction(action) {
            // Placeholder - just advance turn for now
            if (action === 'retreat') {
                endBattle();
                return;
            }
            
            // Next turn
            battleState.currentTurn = (battleState.currentTurn + 1) % battleState.turnOrder.length;
            updateBattleTurnInfo();
        }
        
        // End battle and return to dungeon menu
        function endBattle() {
            battleState.active = false;
            currentScreen = 'dungeonMenu';
            document.getElementById('battleScreen').style.display = 'none';
            document.getElementById('dungeonMenuScreen').style.display = 'block';
        }
        
        // ===== END BATTLE SYSTEM =====
        
        // Exit portal and return to arcade game
        function exitPortal() {
            try {
                // Load shared save
                const sharedSave = loadSharedSave();
                if (!sharedSave) {
                    alert('No shared save found! Cannot return to arcade.');
                    return;
                }
                
                // Update dungeon state (currently minimal since no gameplay yet)
                sharedSave.dungeonState = {
                    currentLevel: 1,
                    inventory: [],
                    gold: 0,
                    questProgress: {
                        hasScepter: false,
                        hasReturned: false,
                        bossesDefeated: []
                    }
                };
                sharedSave.lastPlayed = Date.now();
                
                // Save updated shared state
                saveSharedSave(sharedSave);
                
                // Navigate back to arcade
                window.location.href = 'zlock_consensus.html';
            } catch (e) {
                console.error('Failed to exit portal:', e);
                alert('Portal exit failed! ' + e.message);
            }
        }
        
        // Update hero stat display (both title and dungeon screens)
        function updateHeroDisplay(heroName, stats) {
            const prefix = heroName.toLowerCase();
            
            // Title screen hero stats
            const levelEl = document.getElementById(`${prefix}-level`);
            const hpEl = document.getElementById(`${prefix}-hp`);
            const maxhpEl = document.getElementById(`${prefix}-maxhp`);
            const strEl = document.getElementById(`${prefix}-str`);
            const dexEl = document.getElementById(`${prefix}-dex`);
            const conEl = document.getElementById(`${prefix}-con`);
            const intEl = document.getElementById(`${prefix}-int`);
            const wisEl = document.getElementById(`${prefix}-wis`);
            const chaEl = document.getElementById(`${prefix}-cha`);
            
            // Dungeon screen hero stats (prefixed with 'd')
            const dhpEl = document.getElementById(`d${prefix}-hp`);
            const dmaxhpEl = document.getElementById(`d${prefix}-maxhp`);
            const dstrEl = document.getElementById(`d${prefix}-str`);
            const ddexEl = document.getElementById(`d${prefix}-dex`);
            const dconEl = document.getElementById(`d${prefix}-con`);
            const dintEl = document.getElementById(`d${prefix}-int`);
            const dwisEl = document.getElementById(`d${prefix}-wis`);
            const dchaEl = document.getElementById(`d${prefix}-cha`);
            
            // Update title screen
            if (levelEl) levelEl.textContent = stats.level || 1;
            if (hpEl) hpEl.textContent = stats.hp || 0;
            if (maxhpEl) maxhpEl.textContent = stats.maxHp || 0;
            if (strEl) strEl.textContent = stats.str || 0;
            if (dexEl) dexEl.textContent = stats.dex || 0;
            if (conEl) conEl.textContent = stats.con || 0;
            if (intEl) intEl.textContent = stats.int || 0;
            if (wisEl) wisEl.textContent = stats.wis || 0;
            if (chaEl) chaEl.textContent = stats.cha || 0;
            
            // Update dungeon screen
            if (dhpEl) dhpEl.textContent = stats.hp || 0;
            if (dmaxhpEl) dmaxhpEl.textContent = stats.maxHp || 0;
            if (dstrEl) dstrEl.textContent = stats.str || 0;
            if (ddexEl) ddexEl.textContent = stats.dex || 0;
            if (dconEl) dconEl.textContent = stats.con || 0;
            if (dintEl) dintEl.textContent = stats.int || 0;
            if (dwisEl) dwisEl.textContent = stats.wis || 0;
            if (dchaEl) dchaEl.textContent = stats.cha || 0;
        }
        
        // Start adventure - switch from title to dungeon menu
        function startAdventure() {
            const titleScreen = document.getElementById('titleScreen');
            const dungeonMenuScreen = document.getElementById('dungeonMenuScreen');
            
            if (titleScreen) titleScreen.style.display = 'none';
            if (dungeonMenuScreen) dungeonMenuScreen.style.display = 'block';
            
            currentScreen = 'dungeonMenu';
            
            // Sync dungeon level display
            const sharedSave = loadSharedSave();
            if (sharedSave && sharedSave.arcadeState && sharedSave.arcadeState.level) {
                const dungeonMenuLevel = document.getElementById('dungeonMenuLevel');
                if (dungeonMenuLevel) {
                    dungeonMenuLevel.textContent = sharedSave.arcadeState.level;
                }
            }
        }
        
        // Pause game
        function pauseGame() {
            if (currentScreen === 'title') return; // Can't pause on title screen
            
            isPaused = true;
            const pauseScreen = document.getElementById('pauseScreen');
            if (pauseScreen) pauseScreen.style.display = 'flex';
        }
        
        // Resume game
        function resumeGame() {
            isPaused = false;
            const pauseScreen = document.getElementById('pauseScreen');
            if (pauseScreen) pauseScreen.style.display = 'none';
        }
        
        // Save game from pause menu
        function saveGameFromPause() {
            try {
                const sharedSave = loadSharedSave();
                if (!sharedSave) {
                    alert('No save data found!');
                    return;
                }
                
                // Update last played timestamp
                sharedSave.lastPlayed = Date.now();
                
                // Save to localStorage
                if (saveSharedSave(sharedSave)) {
                    alert('Game saved successfully!');
                } else {
                    alert('Failed to save game!');
                }
            } catch (e) {
                console.error('Save error:', e);
                alert('Error saving game: ' + e.message);
            }
        }
        
        // Download save file
        function downloadSaveFile() {
            try {
                const sharedSave = loadSharedSave();
                if (!sharedSave) {
                    alert('No save data to download!');
                    return;
                }
                
                // Update timestamp
                sharedSave.lastPlayed = Date.now();
                saveSharedSave(sharedSave);
                
                // Create filename with date/time
                const now = new Date();
                const dateStr = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
                const hours = now.getHours();
                const minutes = String(now.getMinutes()).padStart(2, '0');
                const ampm = hours >= 12 ? 'pm' : 'am';
                const hour12 = hours % 12 || 12;
                const timeStr = `${hour12}_${minutes}_${ampm}`;
                
                const level = sharedSave.arcadeState ? sharedSave.arcadeState.level : 1;
                const filename = `tunnels-save-level${level}-${dateStr}-${timeStr}.json`;
                
                // Download JSON
                const jsonString = JSON.stringify(sharedSave, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                alert(`Save file downloaded: ${filename}`);
            } catch (e) {
                console.error('Download error:', e);
                alert('Error downloading save file: ' + e.message);
            }
        }
        
        // Show settings from pause
        function showSettingsFromPause() {
            showSettings();
        }
        
        // Quit to menu
        function quitToMenu() {
            isPaused = false;
            currentScreen = 'title';
            
            const pauseScreen = document.getElementById('pauseScreen');
            const dungeonMenuScreen = document.getElementById('dungeonMenuScreen');
            const titleScreen = document.getElementById('titleScreen');
            
            if (pauseScreen) pauseScreen.style.display = 'none';
            if (dungeonMenuScreen) dungeonMenuScreen.style.display = 'none';
            if (titleScreen) titleScreen.style.display = 'block';
        }
        
        // ESC key listener
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                e.preventDefault();
                
                // Close all panels first
                const overlay = document.getElementById('overlay');
                const settingsPanel = document.getElementById('settingsPanel');
                const loadSavePanel = document.getElementById('loadSavePanel');
                
                if (overlay && overlay.style.display === 'block') {
                    closeAllPanels();
                    return;
                }
                
                // Toggle pause
                if (isPaused) {
                    resumeGame();
                } else {
                    pauseGame();
                }
            }
        });
        
        // ===== GAMEPAD FUNCTIONS =====
        function onGamepadConnected(e) {
            gamepadConnected = true;
            gamepadIndex = e.gamepad.index;
            console.log(`üéÆ Controller Connected: ${e.gamepad.id}`);
        }
        
        function onGamepadDisconnected(e) {
            if (e.gamepad.index === gamepadIndex) {
                gamepadConnected = false;
                gamepadIndex = null;
                gamepadButtonStates = {};
                console.log('üéÆ Controller Disconnected');
            }
        }
        
        function updateGamepad() {
            if (!gamepadConnected || gamepadIndex === null) return;
            
            // Don't process gamepad input while loading modal is visible
            const loadingModal = document.getElementById('loadingModal');
            if (loadingModal && loadingModal.style.display !== 'none') return;
            
            const now = Date.now();
            if (now - lastGamepadUpdate < gamepadUpdateInterval) return;
            lastGamepadUpdate = now;
            
            const gamepads = navigator.getGamepads();
            const gamepad = gamepads[gamepadIndex];
            
            if (!gamepad) return;
            
            // Process buttons
            gamepad.buttons.forEach((button, index) => {
                const wasPressed = gamepadButtonStates[index] || false;
                const isPressed = button.pressed;
                
                // Button just pressed (rising edge)
                if (isPressed && !wasPressed) {
                    handleGamepadButtonPress(index);
                }
                
                gamepadButtonStates[index] = isPressed;
            });
        }
        
        function handleGamepadButtonPress(buttonIndex) {
            // ===== SETTINGS PANEL NAVIGATION =====
            const settingsPanel = document.getElementById('settingsPanel');
            if (settingsPanel && settingsPanel.style.display === 'block') {
                // B button - Close
                if (buttonIndex === GamepadButtons.B) {
                    closeAllPanels();
                    return;
                }
                return; // Block all other inputs when settings is open
            }
            // ===== END SETTINGS PANEL NAVIGATION =====
            
            // ===== LOAD SAVE PANEL NAVIGATION =====
            const loadSavePanel = document.getElementById('loadSavePanel');
            if (loadSavePanel && loadSavePanel.style.display === 'block') {
                // B button - Close
                if (buttonIndex === GamepadButtons.B) {
                    closeAllPanels();
                    return;
                }
                return; // Block all other inputs when load save panel is open
            }
            // ===== END LOAD SAVE PANEL NAVIGATION =====
            
            // ===== TITLE SCREEN NAVIGATION =====
            if (currentScreen === 'title') {
                // A button - Start Adventure
                if (buttonIndex === GamepadButtons.A) {
                    startAdventure();
                    return;
                }
                // Y button - Settings
                else if (buttonIndex === GamepadButtons.Y) {
                    showSettings();
                    return;
                }
                // B button - Load Save File
                else if (buttonIndex === GamepadButtons.B) {
                    showLoadSave();
                    return;
                }
                // BACK button (SELECT) - Exit Portal
                else if (buttonIndex === GamepadButtons.SELECT) {
                    exitPortal();
                    return;
                }
            }
            // ===== END TITLE SCREEN NAVIGATION =====
            
            // ===== PAUSE MENU NAVIGATION =====
            if (isPaused) {
                // A button - Resume
                if (buttonIndex === GamepadButtons.A) {
                    resumeGame();
                    return;
                }
                // B button - Resume (also works)
                else if (buttonIndex === GamepadButtons.B) {
                    resumeGame();
                    return;
                }
                // Y button - Settings
                else if (buttonIndex === GamepadButtons.Y) {
                    showSettingsFromPause();
                    return;
                }
                // SELECT button - Quit to Menu
                else if (buttonIndex === GamepadButtons.SELECT) {
                    quitToMenu();
                    return;
                }
            }
            // ===== END PAUSE MENU NAVIGATION =====
            
            // START button - Pause/Resume
            if (buttonIndex === GamepadButtons.START) {
                if (currentScreen === 'title') return; // Can't pause on title screen
                
                if (isPaused) {
                    resumeGame();
                } else {
                    pauseGame();
                }
                return;
            }
        }
        
        // Poll gamepad in animation loop
        function gamepadLoop() {
            updateGamepad();
            requestAnimationFrame(gamepadLoop);
        }
        
        // Gamepad polling for Click to Enter
        function pollGamepadForClickToPlay() {
            const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
            for (let i = 0; i < gamepads.length; i++) {
                const gp = gamepads[i];
                if (gp && gp.buttons[0] && gp.buttons[0].pressed) { // A button
                    const clickToPlayPrompt = document.getElementById('clickToPlayPrompt');
                    if (clickToPlayPrompt && clickToPlayPrompt.style.display !== 'none') {
                        clickToPlayPrompt.click();
                        return;
                    }
                }
            }
            
            // Continue polling if loading modal is visible
            const loadingModal = document.getElementById('loadingModal');
            if (loadingModal && loadingModal.style.display !== 'none') {
                requestAnimationFrame(pollGamepadForClickToPlay);
            }
        }
        // ===== END GAMEPAD FUNCTIONS =====
        
        // Initialize on page load
        // Preload images and audio into browser cache
        function preloadAssets() {
            const imageList = [
                // Story intro background
                'story/intro/intro_a.png',
                // Character head icons
                'people/zooko_a_head_compressed.png',
                'people/Nate_a_head_compressed.png',
                'people/Zancas_a_head_compressed.png',
                'people/cyberaxe_a_head_compressed.png'
            ];
            
            artTotal = imageList.length;
            assetsToLoad += imageList.length;
            
            // Preload images
            imageList.forEach(imagePath => {
                const img = new Image();
                img.src = imagePath;
                img.addEventListener('load', () => {
                    console.log(`Preloaded: ${imagePath}`);
                    artLoaded++;
                    assetsLoaded++;
                    updateLoadingProgress();
                }, { once: true });
                img.addEventListener('error', (e) => {
                    console.error(`Failed to preload: ${imagePath}`, e);
                    artLoaded++;
                    assetsLoaded++;
                    updateLoadingProgress();
                }, { once: true });
            });
            
            // Preload music if enabled
            if (musicEnabled && musicVolume > 0) {
                audioTotal = 1;
                assetsToLoad += 1;
                
                const musicPlayer = document.getElementById('musicPlayer');
                if (musicPlayer) {
                    musicPlayer.volume = Math.min(1.0, musicVolume / 100);
                    musicPlayer.preload = 'metadata'; // Changed from 'auto' to avoid hanging
                    
                    // Set a timeout in case music doesn't load
                    const musicTimeout = setTimeout(() => {
                        console.log('Music preload timeout - continuing anyway');
                        audioLoaded++;
                        assetsLoaded++;
                        updateLoadingProgress();
                    }, 3000); // 3 second timeout
                    
                    musicPlayer.addEventListener('loadedmetadata', () => {
                        console.log('Music metadata loaded');
                        clearTimeout(musicTimeout);
                        audioLoaded++;
                        assetsLoaded++;
                        updateLoadingProgress();
                    }, { once: true });
                    
                    musicPlayer.addEventListener('error', (e) => {
                        console.error('Failed to preload music', e);
                        clearTimeout(musicTimeout);
                        audioLoaded++;
                        assetsLoaded++;
                        updateLoadingProgress();
                    }, { once: true });
                    
                    musicPlayer.load();
                } else {
                    // Music player doesn't exist, skip it
                    audioLoaded++;
                    assetsLoaded++;
                    updateLoadingProgress();
                }
            }
            
            updateLoadingProgress();
        }
        
        // Update loading progress indicator
        function updateLoadingProgress() {
            const loadingIndicator = document.getElementById('loadingIndicator');
            const loadingBar = document.getElementById('loadingBar');
            const loadingArt = document.getElementById('loadingArt');
            const loadingSound = document.getElementById('loadingSound');
            
            if (loadingIndicator && assetsToLoad > 0) {
                const percent = Math.floor((assetsLoaded / assetsToLoad) * 100);
                loadingIndicator.textContent = `${percent}%`;
                
                if (loadingBar) {
                    loadingBar.style.width = `${percent}%`;
                    loadingBar.textContent = `${percent}%`;
                }
                
                // Update category counts
                if (loadingArt) {
                    loadingArt.innerHTML = `üé® Art: <span style="color: #8B45FF; font-weight: bold;">${artLoaded}/${artTotal}</span>`;
                }
                if (loadingSound) {
                    loadingSound.innerHTML = `üîä Sound: <span style="color: #8B45FF; font-weight: bold;">${audioLoaded}/${audioTotal}</span>`;
                }
            }
            
            checkAllAssetsReady();
        }
        
        function checkAllAssetsReady() {
            if (assetsToLoad > 0 && assetsLoaded >= assetsToLoad && !allAssetsReady) {
                allAssetsReady = true;
                
                const loadingIndicator = document.getElementById('loadingIndicator');
                const loadingBar = document.getElementById('loadingBar');
                const loadingModal = document.getElementById('loadingModal');
                const loadingNote = document.getElementById('loadingNote');
                const clickToPlayPrompt = document.getElementById('clickToPlayPrompt');
                
                if (loadingIndicator) {
                    loadingIndicator.textContent = '‚úì All Assets Ready!';
                    loadingIndicator.style.color = '#2ECC71';
                }
                
                if (loadingBar) {
                    loadingBar.style.width = '100%';
                    loadingBar.textContent = '100%';
                    loadingBar.style.background = 'linear-gradient(90deg, #2ECC71, #27AE60)';
                }
                
                if (loadingNote) {
                    loadingNote.style.display = 'none';
                }
                
                if (clickToPlayPrompt) {
                    clickToPlayPrompt.style.display = 'block';
                    
                    // Start gamepad polling for A button
                    pollGamepadForClickToPlay();
                    
                    const handleClick = () => {
                        // Start music when user clicks
                        if (musicEnabled && musicVolume > 0 && !musicStarted) {
                            const randomTrack = themeTracks[Math.floor(Math.random() * themeTracks.length)];
                            loadMusic(randomTrack);
                        }
                        
                        // Fade out and remove loading modal
                        if (loadingModal) {
                            loadingModal.style.opacity = '0';
                            loadingModal.style.transition = 'opacity 0.5s ease';
                            setTimeout(() => {
                                loadingModal.style.display = 'none';
                            }, 500);
                        }
                        
                        // Remove click handler
                        clickToPlayPrompt.removeEventListener('click', handleClick);
                        document.removeEventListener('keydown', handleKeyDown);
                    };
                    
                    const handleKeyDown = (e) => {
                        if (e.key === 'a' || e.key === 'A' || e.key === 'Enter') {
                            handleClick();
                        }
                    };
                    
                    clickToPlayPrompt.addEventListener('click', handleClick);
                    document.addEventListener('keydown', handleKeyDown);
                }
            }
        }
        
        function init() {
            console.log('Tunnels of Privacy - Initializing...');
            
            // Load settings
            loadSettings();
            console.log('Settings loaded:', settings);
            
            // ===== GAMEPAD SUPPORT =====
            // Handle gamepad connections
            window.addEventListener('gamepadconnected', onGamepadConnected);
            window.addEventListener('gamepaddisconnected', onGamepadDisconnected);
            // Start gamepad polling loop
            gamepadLoop();
            // ===== END GAMEPAD SUPPORT =====
            
            // Preload assets
            preloadAssets();
            
            // Start background animation
            startStoryIntroAnimation();
            
            // Load shared save and display hero stats
            const sharedSave = loadSharedSave();
            if (sharedSave && sharedSave.heroes) {
                console.log('Loaded shared save with heroes:', sharedSave.heroes);
                
                // Update each hero's display
                updateHeroDisplay('zooko', sharedSave.heroes.zooko);
                updateHeroDisplay('nate', sharedSave.heroes.nate);
                updateHeroDisplay('zancas', sharedSave.heroes.zancas);
                updateHeroDisplay('cyberaxe', sharedSave.heroes.cyberaxe);
                
                // Update dungeon level from arcade level
                if (sharedSave.arcadeState && sharedSave.arcadeState.level) {
                    const arcadeLevel = sharedSave.arcadeState.level;
                    document.getElementById('dungeonLevel').textContent = arcadeLevel;
                    console.log('Dungeon depth set to arcade level:', arcadeLevel);
                } else {
                    console.log('No arcade level found - defaulting to level 1');
                }
            } else {
                console.log('No shared save found - using default hero stats');
            }
            
            // Update title screen button states
            updateTitleScreenButtons();
            
            console.log('Initialization complete. Portal system ready.');
        }
        
        // Run init when page loads
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
